/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/client/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/classnames/index.js":
/*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ "./node_modules/cytoscape/dist/cytoscape.cjs.js":
/*!******************************************************!*\
  !*** ./node_modules/cytoscape/dist/cytoscape.cjs.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/**
 * Copyright (c) 2016-2019, The Cytoscape Consortium.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */



function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var util = _interopDefault(__webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js"));
var Heap = _interopDefault(__webpack_require__(/*! heap */ "./node_modules/heap/index.js"));

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var window$1 = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef

var navigator = window$1 ? window$1.navigator : null;
var document$1 = window$1 ? window$1.document : null;

var typeofstr = _typeof('');

var typeofobj = _typeof({});

var typeoffn = _typeof(function () {});

var typeofhtmlele = typeof HTMLElement === "undefined" ? "undefined" : _typeof(HTMLElement);

var instanceStr = function instanceStr(obj) {
  return obj && obj.instanceString && fn(obj.instanceString) ? obj.instanceString() : null;
};

var string = function string(obj) {
  return obj != null && _typeof(obj) == typeofstr;
};
var fn = function fn(obj) {
  return obj != null && _typeof(obj) === typeoffn;
};
var array = function array(obj) {
  return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
};
var plainObject = function plainObject(obj) {
  return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;
};
var object = function object(obj) {
  return obj != null && _typeof(obj) === typeofobj;
};
var number = function number(obj) {
  return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);
};
var integer = function integer(obj) {
  return number(obj) && Math.floor(obj) === obj;
};
var htmlElement = function htmlElement(obj) {
  if ('undefined' === typeofhtmlele) {
    return undefined;
  } else {
    return null != obj && obj instanceof HTMLElement;
  }
};
var elementOrCollection = function elementOrCollection(obj) {
  return element(obj) || collection(obj);
};
var element = function element(obj) {
  return instanceStr(obj) === 'collection' && obj._private.single;
};
var collection = function collection(obj) {
  return instanceStr(obj) === 'collection' && !obj._private.single;
};
var core = function core(obj) {
  return instanceStr(obj) === 'core';
};
var stylesheet = function stylesheet(obj) {
  return instanceStr(obj) === 'stylesheet';
};
var event = function event(obj) {
  return instanceStr(obj) === 'event';
};
var emptyString = function emptyString(obj) {
  if (obj === undefined || obj === null) {
    // null is empty
    return true;
  } else if (obj === '' || obj.match(/^\s+$/)) {
    return true; // empty string is empty
  }

  return false; // otherwise, we don't know what we've got
};
var domElement = function domElement(obj) {
  if (typeof HTMLElement === 'undefined') {
    return false; // we're not in a browser so it doesn't matter
  } else {
    return obj instanceof HTMLElement;
  }
};
var boundingBox = function boundingBox(obj) {
  return plainObject(obj) && number(obj.x1) && number(obj.x2) && number(obj.y1) && number(obj.y2);
};
var promise = function promise(obj) {
  return object(obj) && fn(obj.then);
};
var ms = function ms() {
  return navigator && navigator.userAgent.match(/msie|trident|edge/i);
}; // probably a better way to detect this...

var memoize = function memoize(fn, keyFn) {
  if (!keyFn) {
    keyFn = function keyFn() {
      if (arguments.length === 1) {
        return arguments[0];
      } else if (arguments.length === 0) {
        return 'undefined';
      }

      var args = [];

      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }

      return args.join('$');
    };
  }

  var memoizedFn = function memoizedFn() {
    var self = this;
    var args = arguments;
    var ret;
    var k = keyFn.apply(self, args);
    var cache = memoizedFn.cache;

    if (!(ret = cache[k])) {
      ret = cache[k] = fn.apply(self, args);
    }

    return ret;
  };

  memoizedFn.cache = {};
  return memoizedFn;
};

var camel2dash = memoize(function (str) {
  return str.replace(/([A-Z])/g, function (v) {
    return '-' + v.toLowerCase();
  });
});
var dash2camel = memoize(function (str) {
  return str.replace(/(-\w)/g, function (v) {
    return v[1].toUpperCase();
  });
});
var prependCamel = memoize(function (prefix, str) {
  return prefix + str[0].toUpperCase() + str.substring(1);
}, function (prefix, str) {
  return prefix + '$' + str;
});
var capitalize = function capitalize(str) {
  if (emptyString(str)) {
    return str;
  }

  return str.charAt(0).toUpperCase() + str.substring(1);
};

var number$1 = '(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))';
var rgba = 'rgb[a]?\\((' + number$1 + '[%]?)\\s*,\\s*(' + number$1 + '[%]?)\\s*,\\s*(' + number$1 + '[%]?)(?:\\s*,\\s*(' + number$1 + '))?\\)';
var rgbaNoBackRefs = 'rgb[a]?\\((?:' + number$1 + '[%]?)\\s*,\\s*(?:' + number$1 + '[%]?)\\s*,\\s*(?:' + number$1 + '[%]?)(?:\\s*,\\s*(?:' + number$1 + '))?\\)';
var hsla = 'hsl[a]?\\((' + number$1 + ')\\s*,\\s*(' + number$1 + '[%])\\s*,\\s*(' + number$1 + '[%])(?:\\s*,\\s*(' + number$1 + '))?\\)';
var hslaNoBackRefs = 'hsl[a]?\\((?:' + number$1 + ')\\s*,\\s*(?:' + number$1 + '[%])\\s*,\\s*(?:' + number$1 + '[%])(?:\\s*,\\s*(?:' + number$1 + '))?\\)';
var hex3 = '\\#[0-9a-fA-F]{3}';
var hex6 = '\\#[0-9a-fA-F]{6}';

var ascending = function ascending(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
};
var descending = function descending(a, b) {
  return -1 * ascending(a, b);
};

var extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {
  var args = arguments;

  for (var i = 1; i < args.length; i++) {
    var obj = args[i];

    if (obj == null) {
      continue;
    }

    var keys = Object.keys(obj);

    for (var j = 0; j < keys.length; j++) {
      var k = keys[j];
      tgt[k] = obj[k];
    }
  }

  return tgt;
};

var hex2tuple = function hex2tuple(hex) {
  if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {
    return;
  }

  var shortHex = hex.length === 4;
  var r, g, b;
  var base = 16;

  if (shortHex) {
    r = parseInt(hex[1] + hex[1], base);
    g = parseInt(hex[2] + hex[2], base);
    b = parseInt(hex[3] + hex[3], base);
  } else {
    r = parseInt(hex[1] + hex[2], base);
    g = parseInt(hex[3] + hex[4], base);
    b = parseInt(hex[5] + hex[6], base);
  }

  return [r, g, b];
}; // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)

var hsl2tuple = function hsl2tuple(hsl) {
  var ret;
  var h, s, l, a, r, g, b;

  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }

  var m = new RegExp('^' + hsla + '$').exec(hsl);

  if (m) {
    // get hue
    h = parseInt(m[1]);

    if (h < 0) {
      h = (360 - -1 * h % 360) % 360;
    } else if (h > 360) {
      h = h % 360;
    }

    h /= 360; // normalise on [0, 1]

    s = parseFloat(m[2]);

    if (s < 0 || s > 100) {
      return;
    } // saturation is [0, 100]


    s = s / 100; // normalise on [0, 1]

    l = parseFloat(m[3]);

    if (l < 0 || l > 100) {
      return;
    } // lightness is [0, 100]


    l = l / 100; // normalise on [0, 1]

    a = m[4];

    if (a !== undefined) {
      a = parseFloat(a);

      if (a < 0 || a > 1) {
        return;
      } // alpha is [0, 1]

    } // now, convert to rgb
    // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript


    if (s === 0) {
      r = g = b = Math.round(l * 255); // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));
      g = Math.round(255 * hue2rgb(p, q, h));
      b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));
    }

    ret = [r, g, b, a];
  }

  return ret;
}; // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)

var rgb2tuple = function rgb2tuple(rgb) {
  var ret;
  var m = new RegExp('^' + rgba + '$').exec(rgb);

  if (m) {
    ret = [];
    var isPct = [];

    for (var i = 1; i <= 3; i++) {
      var channel = m[i];

      if (channel[channel.length - 1] === '%') {
        isPct[i] = true;
      }

      channel = parseFloat(channel);

      if (isPct[i]) {
        channel = channel / 100 * 255; // normalise to [0, 255]
      }

      if (channel < 0 || channel > 255) {
        return;
      } // invalid channel value


      ret.push(Math.floor(channel));
    }

    var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
    var allArePct = isPct[1] && isPct[2] && isPct[3];

    if (atLeastOneIsPct && !allArePct) {
      return;
    } // must all be percent values if one is


    var alpha = m[4];

    if (alpha !== undefined) {
      alpha = parseFloat(alpha);

      if (alpha < 0 || alpha > 1) {
        return;
      } // invalid alpha value


      ret.push(alpha);
    }
  }

  return ret;
};
var colorname2tuple = function colorname2tuple(color) {
  return colors[color.toLowerCase()];
};
var color2tuple = function color2tuple(color) {
  return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);
};
var colors = {
  // special colour names
  transparent: [0, 0, 0, 0],
  // NB alpha === 0
  // regular colours
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};

var setMap = function setMap(options) {
  var obj = options.map;
  var keys = options.keys;
  var l = keys.length;

  for (var i = 0; i < l; i++) {
    var key = keys[i];

    if (plainObject(key)) {
      throw Error('Tried to set map with object key');
    }

    if (i < keys.length - 1) {
      // extend the map if necessary
      if (obj[key] == null) {
        obj[key] = {};
      }

      obj = obj[key];
    } else {
      // set the value
      obj[key] = options.value;
    }
  }
}; // gets the value in a map even if it's not built in places

var getMap = function getMap(options) {
  var obj = options.map;
  var keys = options.keys;
  var l = keys.length;

  for (var i = 0; i < l; i++) {
    var key = keys[i];

    if (plainObject(key)) {
      throw Error('Tried to get map with object key');
    }

    obj = obj[key];

    if (obj == null) {
      return obj;
    }
  }

  return obj;
}; // deletes the entry in the map

var performance = window$1 ? window$1.performance : null;
var pnow = performance && performance.now ? function () {
  return performance.now();
} : function () {
  return Date.now();
};

var raf = function () {
  if (window$1) {
    if (window$1.requestAnimationFrame) {
      return function (fn) {
        window$1.requestAnimationFrame(fn);
      };
    } else if (window$1.mozRequestAnimationFrame) {
      return function (fn) {
        window$1.mozRequestAnimationFrame(fn);
      };
    } else if (window$1.webkitRequestAnimationFrame) {
      return function (fn) {
        window$1.webkitRequestAnimationFrame(fn);
      };
    } else if (window$1.msRequestAnimationFrame) {
      return function (fn) {
        window$1.msRequestAnimationFrame(fn);
      };
    }
  }

  return function (fn) {
    if (fn) {
      setTimeout(function () {
        fn(pnow());
      }, 1000 / 60);
    }
  };
}();

var requestAnimationFrame = function requestAnimationFrame(fn) {
  return raf(fn);
};
var performanceNow = pnow;

var DEFAULT_SEED = 5381;
var hashIterableInts = function hashIterableInts(iterator) {
  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_SEED;
  // djb2/string-hash
  var hash = seed;
  var entry;

  for (;;) {
    entry = iterator.next();

    if (entry.done) {
      break;
    }

    hash = (hash << 5) + hash + entry.value | 0;
  }

  return hash;
};
var hashInt = function hashInt(num) {
  var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_SEED;
  // djb2/string-hash
  return (seed << 5) + seed + num | 0;
};
var hashIntsArray = function hashIntsArray(ints, seed) {
  var entry = {
    value: 0,
    done: false
  };
  var i = 0;
  var length = ints.length;
  var iterator = {
    next: function next() {
      if (i < length) {
        entry.value = ints[i++];
      } else {
        entry.done = true;
      }

      return entry;
    }
  };
  return hashIterableInts(iterator, seed);
};
var hashString = function hashString(str, seed) {
  var entry = {
    value: 0,
    done: false
  };
  var i = 0;
  var length = str.length;
  var iterator = {
    next: function next() {
      if (i < length) {
        entry.value = str.charCodeAt(i++);
      } else {
        entry.done = true;
      }

      return entry;
    }
  };
  return hashIterableInts(iterator, seed);
};
var hashStrings = function hashStrings() {
  return hashStringsArray(arguments);
};
var hashStringsArray = function hashStringsArray(strs) {
  var hash;

  for (var i = 0; i < strs.length; i++) {
    var str = strs[i];

    if (i === 0) {
      hash = hashString(str);
    } else {
      hash = hashString(str, hash);
    }
  }

  return hash;
};

/*global console */
var warningsEnabled = true;
var warnSupported = console.warn != null; // eslint-disable-line no-console

var traceSupported = console.trace != null; // eslint-disable-line no-console

var MAX_INT = Number.MAX_SAFE_INTEGER || 9007199254740991;
var trueify = function trueify() {
  return true;
};
var falsify = function falsify() {
  return false;
};
var zeroify = function zeroify() {
  return 0;
};
var noop = function noop() {};
var error = function error(msg) {
  throw new Error(msg);
};
var warnings = function warnings(enabled) {
  if (enabled !== undefined) {
    warningsEnabled = !!enabled;
  } else {
    return warningsEnabled;
  }
};
var warn = function warn(msg) {
  /* eslint-disable no-console */
  if (!warnings()) {
    return;
  }

  if (warnSupported) {
    console.warn(msg);
  } else {
    console.log(msg);

    if (traceSupported) {
      console.trace();
    }
  }
};
/* eslint-enable */

var clone = function clone(obj) {
  return extend({}, obj);
}; // gets a shallow copy of the argument

var copy = function copy(obj) {
  if (obj == null) {
    return obj;
  }

  if (array(obj)) {
    return obj.slice();
  } else if (plainObject(obj)) {
    return clone(obj);
  } else {
    return obj;
  }
};
var copyArray = function copyArray(arr) {
  return arr.slice();
};
var uuid = function uuid(a, b
/* placeholders */
) {
  for ( // loop :)
  b = a = ''; // b - result , a - numeric letiable
  a++ < 36; //
  b += a * 51 & 52 // if "a" is not 9 or 14 or 19 or 24
  ? //  return a random number or 4
  (a ^ 15 // if "a" is not 15
  ? // genetate a random number from 0 to 15
  8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless "a" is 20, in which case a random number from 8 to 11
  : 4 //  otherwise 4
  ).toString(16) : '-' //  in other cases (if "a" is 9,14,19,24) insert "-"
  ) {
  }

  return b;
};
var _staticEmptyObject = {};
var staticEmptyObject = function staticEmptyObject() {
  return _staticEmptyObject;
};
var defaults = function defaults(_defaults) {
  var keys = Object.keys(_defaults);
  return function (opts) {
    var filledOpts = {};

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var optVal = opts == null ? undefined : opts[key];
      filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;
    }

    return filledOpts;
  };
};
var removeFromArray = function removeFromArray(arr, ele, manyCopies) {
  for (var i = arr.length; i >= 0; i--) {
    if (arr[i] === ele) {
      arr.splice(i, 1);

      if (!manyCopies) {
        break;
      }
    }
  }
};
var clearArray = function clearArray(arr) {
  arr.splice(0, arr.length);
};
var push = function push(arr, otherArr) {
  for (var i = 0; i < otherArr.length; i++) {
    var el = otherArr[i];
    arr.push(el);
  }
};
var getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {
  if (prefix) {
    propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  return obj[propName];
};
var setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {
  if (prefix) {
    propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth
  }

  obj[propName] = value;
};

/* global Map */
var ObjectMap =
/*#__PURE__*/
function () {
  function ObjectMap() {
    _classCallCheck(this, ObjectMap);

    this._obj = {};
  }

  _createClass(ObjectMap, [{
    key: "set",
    value: function set(key, val) {
      this._obj[key] = val;
      return this;
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      this._obj[key] = undefined;
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      this._obj = {};
    }
  }, {
    key: "has",
    value: function has(key) {
      return this._obj[key] !== undefined;
    }
  }, {
    key: "get",
    value: function get(key) {
      return this._obj[key];
    }
  }]);

  return ObjectMap;
}();

var Map$1 = typeof Map !== 'undefined' ? Map : ObjectMap;

/* global Set */
var undef =  "undefined" ;

var ObjectSet =
/*#__PURE__*/
function () {
  function ObjectSet(arrayOrObjectSet) {
    _classCallCheck(this, ObjectSet);

    this._obj = Object.create(null);
    this.size = 0;

    if (arrayOrObjectSet != null) {
      var arr;

      if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {
        arr = arrayOrObjectSet.toArray();
      } else {
        arr = arrayOrObjectSet;
      }

      for (var i = 0; i < arr.length; i++) {
        this.add(arr[i]);
      }
    }
  }

  _createClass(ObjectSet, [{
    key: "instanceString",
    value: function instanceString() {
      return 'set';
    }
  }, {
    key: "add",
    value: function add(val) {
      var o = this._obj;

      if (o[val] !== 1) {
        o[val] = 1;
        this.size++;
      }
    }
  }, {
    key: "delete",
    value: function _delete(val) {
      var o = this._obj;

      if (o[val] === 1) {
        o[val] = 0;
        this.size--;
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this._obj = Object.create(null);
    }
  }, {
    key: "has",
    value: function has(val) {
      return this._obj[val] === 1;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var _this = this;

      return Object.keys(this._obj).filter(function (key) {
        return _this.has(key);
      });
    }
  }, {
    key: "forEach",
    value: function forEach(callback, thisArg) {
      return this.toArray().forEach(callback, thisArg);
    }
  }]);

  return ObjectSet;
}();

var Set$1 = (typeof Set === "undefined" ? "undefined" : _typeof(Set)) !== undef ? Set : ObjectSet;

var Element = function Element(cy, params, restore) {
  restore = restore === undefined || restore ? true : false;

  if (cy === undefined || params === undefined || !core(cy)) {
    error('An element must have a core reference and parameters set');
    return;
  }

  var group = params.group; // try to automatically infer the group if unspecified

  if (group == null) {
    if (params.data && params.data.source != null && params.data.target != null) {
      group = 'edges';
    } else {
      group = 'nodes';
    }
  } // validate group


  if (group !== 'nodes' && group !== 'edges') {
    error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');
    return;
  } // make the element array-like, just like a collection


  this.length = 1;
  this[0] = this; // NOTE: when something is added here, add also to ele.json()

  var _p = this._private = {
    cy: cy,
    single: true,
    // indicates this is an element
    data: params.data || {},
    // data object
    position: params.position || {
      x: 0,
      y: 0
    },
    // (x, y) position pair
    autoWidth: undefined,
    // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: undefined,
    autoPadding: undefined,
    compoundBoundsClean: false,
    // whether the compound dimensions need to be recalculated the next time dimensions are read
    listeners: [],
    // array of bound listeners
    group: group,
    // string; 'nodes' or 'edges'
    style: {},
    // properties as set by the style
    rstyle: {},
    // properties for style sent from the renderer to the core
    styleCxts: [],
    // applied style contexts from the styler
    styleKeys: {},
    // per-group keys of style property values
    removed: true,
    // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: params.selected ? true : false,
    // whether it's selected
    selectable: params.selectable === undefined ? true : params.selectable ? true : false,
    // whether it's selectable
    locked: params.locked ? true : false,
    // whether the element is locked (cannot be moved)
    grabbed: false,
    // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,
    // whether the element can be grabbed
    pannable: params.pannable === undefined ? group === 'edges' ? true : false : params.pannable ? true : false,
    // whether the element has passthrough panning enabled
    active: false,
    // whether the element is active from user interaction
    classes: new Set$1(),
    // map ( className => true )
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {},
    // object in which the renderer can store information
    scratch: params.scratch || {},
    // scratch objects
    edges: [],
    // array of connected edges
    children: [],
    // array of children
    parent: null,
    // parent ref
    traversalCache: {},
    // cache of output of traversal functions
    backgrounding: false,
    // whether background images are loading
    bbCache: null,
    // cache of the current bounding box
    bbCacheShift: {
      x: 0,
      y: 0
    },
    // shift applied to cached bb to be applied on next get
    bodyBounds: null,
    // bounds cache of element body, w/o overlay
    overlayBounds: null,
    // bounds cache of element body, including overlay
    labelBounds: {
      // bounds cache of labels
      all: null,
      source: null,
      target: null,
      main: null
    },
    arrowBounds: {
      // bounds cache of edge arrows
      source: null,
      target: null,
      'mid-source': null,
      'mid-target': null
    }
  };

  if (_p.position.x == null) {
    _p.position.x = 0;
  }

  if (_p.position.y == null) {
    _p.position.y = 0;
  } // renderedPosition overrides if specified


  if (params.renderedPosition) {
    var rpos = params.renderedPosition;
    var pan = cy.pan();
    var zoom = cy.zoom();
    _p.position = {
      x: (rpos.x - pan.x) / zoom,
      y: (rpos.y - pan.y) / zoom
    };
  }

  var classes = [];

  if (array(params.classes)) {
    classes = params.classes;
  } else if (string(params.classes)) {
    classes = params.classes.split(/\s+/);
  }

  for (var i = 0, l = classes.length; i < l; i++) {
    var cls = classes[i];

    if (!cls || cls === '') {
      continue;
    }

    _p.classes.add(cls);
  }

  this.createEmitter();
  var bypass = params.style || params.css;

  if (bypass) {
    warn('Setting a `style` bypass at element creation is deprecated');
    this.style(bypass);
  }

  if (restore === undefined || restore) {
    this.restore();
  }
};

var defineSearch = function defineSearch(params) {
  params = {
    bfs: params.bfs || !params.dfs,
    dfs: params.dfs || !params.bfs
  }; // from pseudocode on wikipedia

  return function searchFn(roots, fn$1, directed) {
    var options;

    if (plainObject(roots) && !elementOrCollection(roots)) {
      options = roots;
      roots = options.roots || options.root;
      fn$1 = options.visit;
      directed = options.directed;
    }

    directed = arguments.length === 2 && !fn(fn$1) ? fn$1 : directed;
    fn$1 = fn(fn$1) ? fn$1 : function () {};
    var cy = this._private.cy;
    var v = roots = string(roots) ? this.filter(roots) : roots;
    var Q = [];
    var connectedNodes = [];
    var connectedBy = {};
    var id2depth = {};
    var V = {};
    var j = 0;
    var found;

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges; // enqueue v


    for (var i = 0; i < v.length; i++) {
      var vi = v[i];
      var viId = vi.id();

      if (vi.isNode()) {
        Q.unshift(vi);

        if (params.bfs) {
          V[viId] = true;
          connectedNodes.push(vi);
        }

        id2depth[viId] = 0;
      }
    }

    var _loop2 = function _loop2() {
      var v = params.bfs ? Q.shift() : Q.pop();
      var vId = v.id();

      if (params.dfs) {
        if (V[vId]) {
          return "continue";
        }

        V[vId] = true;
        connectedNodes.push(v);
      }

      var depth = id2depth[vId];
      var prevEdge = connectedBy[vId];
      var src = prevEdge != null ? prevEdge.source() : null;
      var tgt = prevEdge != null ? prevEdge.target() : null;
      var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];
      var ret = void 0;
      ret = fn$1(v, prevEdge, prevNode, j++, depth);

      if (ret === true) {
        found = v;
        return "break";
      }

      if (ret === false) {
        return "break";
      }

      var vwEdges = v.connectedEdges().filter(function (e) {
        return (!directed || e.source().same(v)) && edges.has(e);
      });

      for (var _i2 = 0; _i2 < vwEdges.length; _i2++) {
        var e = vwEdges[_i2];
        var w = e.connectedNodes().filter(function (n) {
          return !n.same(v) && nodes.has(n);
        });
        var wId = w.id();

        if (w.length !== 0 && !V[wId]) {
          w = w[0];
          Q.push(w);

          if (params.bfs) {
            V[wId] = true;
            connectedNodes.push(w);
          }

          connectedBy[wId] = e;
          id2depth[wId] = id2depth[vId] + 1;
        }
      }
    };

    _loop: while (Q.length !== 0) {
      var _ret = _loop2();

      switch (_ret) {
        case "continue":
          continue;

        case "break":
          break _loop;
      }
    }

    var connectedEles = cy.collection();

    for (var _i = 0; _i < connectedNodes.length; _i++) {
      var node = connectedNodes[_i];
      var edge = connectedBy[node.id()];

      if (edge != null) {
        connectedEles.merge(edge);
      }

      connectedEles.merge(node);
    }

    return {
      path: cy.collection(connectedEles),
      found: cy.collection(found)
    };
  };
}; // search, spanning trees, etc


var elesfn = {
  breadthFirstSearch: defineSearch({
    bfs: true
  }),
  depthFirstSearch: defineSearch({
    dfs: true
  })
}; // nice, short mathemathical alias

elesfn.bfs = elesfn.breadthFirstSearch;
elesfn.dfs = elesfn.depthFirstSearch;

var dijkstraDefaults = defaults({
  root: null,
  weight: function weight(edge) {
    return 1;
  },
  directed: false
});
var elesfn$1 = {
  dijkstra: function dijkstra(options) {
    if (!plainObject(options)) {
      var args = arguments;
      options = {
        root: args[0],
        weight: args[1],
        directed: args[2]
      };
    }

    var _dijkstraDefaults = dijkstraDefaults(options),
        root = _dijkstraDefaults.root,
        weight = _dijkstraDefaults.weight,
        directed = _dijkstraDefaults.directed;

    var eles = this;
    var weightFn = weight;
    var source = string(root) ? this.filter(root)[0] : root[0];
    var dist = {};
    var prev = {};
    var knownDist = {};

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    edges.unmergeBy(function (ele) {
      return ele.isLoop();
    });

    var getDist = function getDist(node) {
      return dist[node.id()];
    };

    var setDist = function setDist(node, d) {
      dist[node.id()] = d;
      Q.updateItem(node);
    };

    var Q = new Heap(function (a, b) {
      return getDist(a) - getDist(b);
    });

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      dist[node.id()] = node.same(source) ? 0 : Infinity;
      Q.push(node);
    }

    var distBetween = function distBetween(u, v) {
      var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);
      var smallestDistance = Infinity;
      var smallestEdge;

      for (var _i = 0; _i < uvs.length; _i++) {
        var edge = uvs[_i];

        var _weight = weightFn(edge);

        if (_weight < smallestDistance || !smallestEdge) {
          smallestDistance = _weight;
          smallestEdge = edge;
        }
      }

      return {
        edge: smallestEdge,
        dist: smallestDistance
      };
    };

    while (Q.size() > 0) {
      var u = Q.pop();
      var smalletsDist = getDist(u);
      var uid = u.id();
      knownDist[uid] = smalletsDist;

      if (smalletsDist === Infinity) {
        continue;
      }

      var neighbors = u.neighborhood().intersect(nodes);

      for (var _i2 = 0; _i2 < neighbors.length; _i2++) {
        var v = neighbors[_i2];
        var vid = v.id();
        var vDist = distBetween(u, v);
        var alt = smalletsDist + vDist.dist;

        if (alt < getDist(v)) {
          setDist(v, alt);
          prev[vid] = {
            node: u,
            edge: vDist.edge
          };
        }
      } // for

    } // while


    return {
      distanceTo: function distanceTo(node) {
        var target = string(node) ? nodes.filter(node)[0] : node[0];
        return knownDist[target.id()];
      },
      pathTo: function pathTo(node) {
        var target = string(node) ? nodes.filter(node)[0] : node[0];
        var S = [];
        var u = target;
        var uid = u.id();

        if (target.length > 0) {
          S.unshift(target);

          while (prev[uid]) {
            var p = prev[uid];
            S.unshift(p.edge);
            S.unshift(p.node);
            u = p.node;
            uid = u.id();
          }
        }

        return eles.spawn(S);
      }
    };
  }
};

var elesfn$2 = {
  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function kruskal(weightFn) {
    weightFn = weightFn || function (edge) {
      return 1;
    };

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    var numNodes = nodes.length;
    var forest = new Array(numNodes);
    var A = nodes; // assumes byGroup() creates new collections that can be safely mutated

    var findSetIndex = function findSetIndex(ele) {
      for (var i = 0; i < forest.length; i++) {
        var eles = forest[i];

        if (eles.has(ele)) {
          return i;
        }
      }
    }; // start with one forest per node


    for (var i = 0; i < numNodes; i++) {
      forest[i] = this.spawn(nodes[i]);
    }

    var S = edges.sort(function (a, b) {
      return weightFn(a) - weightFn(b);
    });

    for (var _i = 0; _i < S.length; _i++) {
      var edge = S[_i];
      var u = edge.source()[0];
      var v = edge.target()[0];
      var setUIndex = findSetIndex(u);
      var setVIndex = findSetIndex(v);
      var setU = forest[setUIndex];
      var setV = forest[setVIndex];

      if (setUIndex !== setVIndex) {
        A.merge(edge); // combine forests for u and v

        setU.merge(setV);
        forest.splice(setVIndex, 1);
      }
    }

    return A;
  }
};

var aStarDefaults = defaults({
  root: null,
  goal: null,
  weight: function weight(edge) {
    return 1;
  },
  heuristic: function heuristic(edge) {
    return 0;
  },
  directed: false
});
var elesfn$3 = {
  // Implemented from pseudocode from wikipedia
  aStar: function aStar(options) {
    var cy = this.cy();

    var _aStarDefaults = aStarDefaults(options),
        root = _aStarDefaults.root,
        goal = _aStarDefaults.goal,
        heuristic = _aStarDefaults.heuristic,
        directed = _aStarDefaults.directed,
        weight = _aStarDefaults.weight;

    root = cy.collection(root)[0];
    goal = cy.collection(goal)[0];
    var sid = root.id();
    var tid = goal.id();
    var gScore = {};
    var fScore = {};
    var closedSetIds = {};
    var openSet = new Heap(function (a, b) {
      return fScore[a.id()] - fScore[b.id()];
    });
    var openSetIds = new Set$1();
    var cameFrom = {};
    var cameFromEdge = {};

    var addToOpenSet = function addToOpenSet(ele, id) {
      openSet.push(ele);
      openSetIds.add(id);
    };

    var cMin, cMinId;

    var popFromOpenSet = function popFromOpenSet() {
      cMin = openSet.pop();
      cMinId = cMin.id();
      openSetIds["delete"](cMinId);
    };

    var isInOpenSet = function isInOpenSet(id) {
      return openSetIds.has(id);
    };

    addToOpenSet(root, sid);
    gScore[sid] = 0;
    fScore[sid] = heuristic(root); // Counter

    var steps = 0; // Main loop

    while (openSet.size() > 0) {
      popFromOpenSet();
      steps++; // If we've found our goal, then we are done

      if (cMinId === tid) {
        var path = [];
        var pathNode = goal;
        var pathNodeId = tid;
        var pathEdge = cameFromEdge[pathNodeId];

        for (;;) {
          path.unshift(pathNode);

          if (pathEdge != null) {
            path.unshift(pathEdge);
          }

          pathNode = cameFrom[pathNodeId];

          if (pathNode == null) {
            break;
          }

          pathNodeId = pathNode.id();
          pathEdge = cameFromEdge[pathNodeId];
        }

        return {
          found: true,
          distance: gScore[cMinId],
          path: this.spawn(path),
          steps: steps
        };
      } // Add cMin to processed nodes


      closedSetIds[cMinId] = true; // Update scores for neighbors of cMin
      // Take into account if graph is directed or not

      var vwEdges = cMin._private.edges;

      for (var i = 0; i < vwEdges.length; i++) {
        var e = vwEdges[i]; // edge must be in set of calling eles

        if (!this.hasElementWithId(e.id())) {
          continue;
        } // cMin must be the source of edge if directed


        if (directed && e.data('source') !== cMinId) {
          continue;
        }

        var wSrc = e.source();
        var wTgt = e.target();
        var w = wSrc.id() !== cMinId ? wSrc : wTgt;
        var wid = w.id(); // node must be in set of calling eles

        if (!this.hasElementWithId(wid)) {
          continue;
        } // if node is in closedSet, ignore it


        if (closedSetIds[wid]) {
          continue;
        } // New tentative score for node w


        var tempScore = gScore[cMinId] + weight(e); // Update gScore for node w if:
        //   w not present in openSet
        // OR
        //   tentative gScore is less than previous value
        // w not in openSet

        if (!isInOpenSet(wid)) {
          gScore[wid] = tempScore;
          fScore[wid] = tempScore + heuristic(w);
          addToOpenSet(w, wid);
          cameFrom[wid] = cMin;
          cameFromEdge[wid] = e;
          continue;
        } // w already in openSet, but with greater gScore


        if (tempScore < gScore[wid]) {
          gScore[wid] = tempScore;
          fScore[wid] = tempScore + heuristic(w);
          cameFrom[wid] = cMin;
        }
      } // End of neighbors update

    } // End of main loop
    // If we've reached here, then we've not reached our goal


    return {
      found: false,
      distance: undefined,
      path: undefined,
      steps: steps
    };
  }
}; // elesfn

var floydWarshallDefaults = defaults({
  weight: function weight(edge) {
    return 1;
  },
  directed: false
});
var elesfn$4 = {
  // Implemented from pseudocode from wikipedia
  floydWarshall: function floydWarshall(options) {
    var cy = this.cy();

    var _floydWarshallDefault = floydWarshallDefaults(options),
        weight = _floydWarshallDefault.weight,
        directed = _floydWarshallDefault.directed;

    var weightFn = weight;

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    var N = nodes.length;
    var Nsq = N * N;

    var indexOf = function indexOf(node) {
      return nodes.indexOf(node);
    };

    var atIndex = function atIndex(i) {
      return nodes[i];
    }; // Initialize distance matrix


    var dist = new Array(Nsq);

    for (var n = 0; n < Nsq; n++) {
      var j = n % N;
      var i = (n - j) / N;

      if (i === j) {
        dist[n] = 0;
      } else {
        dist[n] = Infinity;
      }
    } // Initialize matrix used for path reconstruction
    // Initialize distance matrix


    var next = new Array(Nsq);
    var edgeNext = new Array(Nsq); // Process edges

    for (var _i = 0; _i < edges.length; _i++) {
      var edge = edges[_i];
      var src = edge.source()[0];
      var tgt = edge.target()[0];

      if (src === tgt) {
        continue;
      } // exclude loops


      var s = indexOf(src);
      var t = indexOf(tgt);
      var st = s * N + t; // source to target index

      var _weight = weightFn(edge); // Check if already process another edge between same 2 nodes


      if (dist[st] > _weight) {
        dist[st] = _weight;
        next[st] = t;
        edgeNext[st] = edge;
      } // If undirected graph, process 'reversed' edge


      if (!directed) {
        var ts = t * N + s; // target to source index

        if (!directed && dist[ts] > _weight) {
          dist[ts] = _weight;
          next[ts] = s;
          edgeNext[ts] = edge;
        }
      }
    } // Main loop


    for (var k = 0; k < N; k++) {
      for (var _i2 = 0; _i2 < N; _i2++) {
        var ik = _i2 * N + k;

        for (var _j = 0; _j < N; _j++) {
          var ij = _i2 * N + _j;
          var kj = k * N + _j;

          if (dist[ik] + dist[kj] < dist[ij]) {
            dist[ij] = dist[ik] + dist[kj];
            next[ij] = next[ik];
          }
        }
      }
    }

    var getArgEle = function getArgEle(ele) {
      return (string(ele) ? cy.filter(ele) : ele)[0];
    };

    var indexOfArgEle = function indexOfArgEle(ele) {
      return indexOf(getArgEle(ele));
    };

    var res = {
      distance: function distance(from, to) {
        var i = indexOfArgEle(from);
        var j = indexOfArgEle(to);
        return dist[i * N + j];
      },
      path: function path(from, to) {
        var i = indexOfArgEle(from);
        var j = indexOfArgEle(to);
        var fromNode = atIndex(i);

        if (i === j) {
          return fromNode.collection();
        }

        if (next[i * N + j] == null) {
          return cy.collection();
        }

        var path = cy.collection();
        var prev = i;
        var edge;
        path.merge(fromNode);

        while (i !== j) {
          prev = i;
          i = next[i * N + j];
          edge = edgeNext[prev * N + i];
          path.merge(edge);
          path.merge(atIndex(i));
        }

        return path;
      }
    };
    return res;
  } // floydWarshall

}; // elesfn

var bellmanFordDefaults = defaults({
  weight: function weight(edge) {
    return 1;
  },
  directed: false,
  root: null
});
var elesfn$5 = {
  // Implemented from pseudocode from wikipedia
  bellmanFord: function bellmanFord(options) {
    var _this = this;

    var _bellmanFordDefaults = bellmanFordDefaults(options),
        weight = _bellmanFordDefaults.weight,
        directed = _bellmanFordDefaults.directed,
        root = _bellmanFordDefaults.root;

    var weightFn = weight;
    var eles = this;
    var cy = this.cy();

    var _this$byGroup = this.byGroup(),
        edges = _this$byGroup.edges,
        nodes = _this$byGroup.nodes;

    var numNodes = nodes.length;
    var infoMap = new Map$1();
    var hasNegativeWeightCycle = false;
    var negativeWeightCycles = [];
    root = cy.collection(root)[0]; // in case selector passed

    edges.unmergeBy(function (edge) {
      return edge.isLoop();
    });
    var numEdges = edges.length;

    var getInfo = function getInfo(node) {
      var obj = infoMap.get(node.id());

      if (!obj) {
        obj = {};
        infoMap.set(node.id(), obj);
      }

      return obj;
    };

    var getNodeFromTo = function getNodeFromTo(to) {
      return (string(to) ? cy.$(to) : to)[0];
    };

    var distanceTo = function distanceTo(to) {
      return getInfo(getNodeFromTo(to)).dist;
    };

    var pathTo = function pathTo(to) {
      var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;
      var end = getNodeFromTo(to);
      var path = [];
      var node = end;

      for (;;) {
        if (node == null) {
          return _this.spawn();
        }

        var _getInfo = getInfo(node),
            edge = _getInfo.edge,
            pred = _getInfo.pred;

        path.unshift(node[0]);

        if (node.same(thisStart) && path.length > 0) {
          break;
        }

        if (edge != null) {
          path.unshift(edge);
        }

        node = pred;
      }

      return eles.spawn(path);
    }; // Initializations { dist, pred, edge }


    for (var i = 0; i < numNodes; i++) {
      var node = nodes[i];
      var info = getInfo(node);

      if (node.same(root)) {
        info.dist = 0;
      } else {
        info.dist = Infinity;
      }

      info.pred = null;
      info.edge = null;
    } // Edges relaxation


    var replacedEdge = false;

    var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {
      var dist = info1.dist + weight;

      if (dist < info2.dist && !edge.same(info1.edge)) {
        info2.dist = dist;
        info2.pred = node1;
        info2.edge = edge;
        replacedEdge = true;
      }
    };

    for (var _i = 1; _i < numNodes; _i++) {
      replacedEdge = false;

      for (var e = 0; e < numEdges; e++) {
        var edge = edges[e];
        var src = edge.source();
        var tgt = edge.target();

        var _weight = weightFn(edge);

        var srcInfo = getInfo(src);
        var tgtInfo = getInfo(tgt);
        checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight); // If undirected graph, we need to take into account the 'reverse' edge

        if (!directed) {
          checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);
        }
      }

      if (!replacedEdge) {
        break;
      }
    }

    if (replacedEdge) {
      // Check for negative weight cycles
      for (var _e = 0; _e < numEdges; _e++) {
        var _edge = edges[_e];

        var _src = _edge.source();

        var _tgt = _edge.target();

        var _weight2 = weightFn(_edge);

        var srcDist = getInfo(_src).dist;
        var tgtDist = getInfo(_tgt).dist;

        if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {
          warn('Graph contains a negative weight cycle for Bellman-Ford');
          hasNegativeWeightCycle = true;
          break;
        }
      }
    }

    return {
      distanceTo: distanceTo,
      pathTo: pathTo,
      hasNegativeWeightCycle: hasNegativeWeightCycle,
      negativeWeightCycles: negativeWeightCycles
    };
  } // bellmanFord

}; // elesfn

var sqrt2 = Math.sqrt(2); // Function which colapses 2 (meta) nodes into one
// Updates the remaining edge lists
// Receives as a paramater the edge which causes the collapse

var collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {
  if (remainingEdges.length === 0) {
    error("Karger-Stein must be run on a connected (sub)graph");
  }

  var edgeInfo = remainingEdges[edgeIndex];
  var sourceIn = edgeInfo[1];
  var targetIn = edgeInfo[2];
  var partition1 = nodeMap[sourceIn];
  var partition2 = nodeMap[targetIn];
  var newEdges = remainingEdges; // re-use array
  // Delete all edges between partition1 and partition2

  for (var i = newEdges.length - 1; i >= 0; i--) {
    var edge = newEdges[i];
    var src = edge[1];
    var tgt = edge[2];

    if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {
      newEdges.splice(i, 1);
    }
  } // All edges pointing to partition2 should now point to partition1


  for (var _i = 0; _i < newEdges.length; _i++) {
    var _edge = newEdges[_i];

    if (_edge[1] === partition2) {
      // Check source
      newEdges[_i] = _edge.slice(); // copy

      newEdges[_i][1] = partition1;
    } else if (_edge[2] === partition2) {
      // Check target
      newEdges[_i] = _edge.slice(); // copy

      newEdges[_i][2] = partition1;
    }
  } // Move all nodes from partition2 to partition1


  for (var _i2 = 0; _i2 < nodeMap.length; _i2++) {
    if (nodeMap[_i2] === partition2) {
      nodeMap[_i2] = partition1;
    }
  }

  return newEdges;
}; // Contracts a graph until we reach a certain number of meta nodes


var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {
  while (size > sizeLimit) {
    // Choose an edge randomly
    var edgeIndex = Math.floor(Math.random() * remainingEdges.length); // Collapse graph based on edge

    remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);
    size--;
  }

  return remainingEdges;
};

var elesfn$6 = {
  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function kargerStein() {
    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    edges.unmergeBy(function (edge) {
      return edge.isLoop();
    });
    var numNodes = nodes.length;
    var numEdges = edges.length;
    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
    var stopSize = Math.floor(numNodes / sqrt2);

    if (numNodes < 2) {
      error('At least 2 nodes are required for Karger-Stein algorithm');
      return undefined;
    } // Now store edge destination as indexes
    // Format for each edge (edge index, source node index, target node index)


    var edgeIndexes = [];

    for (var i = 0; i < numEdges; i++) {
      var e = edges[i];
      edgeIndexes.push([i, nodes.indexOf(e.source()), nodes.indexOf(e.target())]);
    } // We will store the best cut found here


    var minCutSize = Infinity;
    var minCutEdgeIndexes = [];
    var minCutNodeMap = new Array(numNodes); // Initial meta node partition

    var metaNodeMap = new Array(numNodes);
    var metaNodeMap2 = new Array(numNodes);

    var copyNodesMap = function copyNodesMap(from, to) {
      for (var _i3 = 0; _i3 < numNodes; _i3++) {
        to[_i3] = from[_i3];
      }
    }; // Main loop


    for (var iter = 0; iter <= numIter; iter++) {
      // Reset meta node partition
      for (var _i4 = 0; _i4 < numNodes; _i4++) {
        metaNodeMap[_i4] = _i4;
      } // Contract until stop point (stopSize nodes)


      var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);
      var edgesState2 = edgesState.slice(); // copy
      // Create a copy of the colapsed nodes state

      copyNodesMap(metaNodeMap, metaNodeMap2); // Run 2 iterations starting in the stop state

      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
      var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2); // Is any of the 2 results the best cut so far?

      if (res1.length <= res2.length && res1.length < minCutSize) {
        minCutSize = res1.length;
        minCutEdgeIndexes = res1;
        copyNodesMap(metaNodeMap, minCutNodeMap);
      } else if (res2.length <= res1.length && res2.length < minCutSize) {
        minCutSize = res2.length;
        minCutEdgeIndexes = res2;
        copyNodesMap(metaNodeMap2, minCutNodeMap);
      }
    } // end of main loop
    // Construct result


    var cut = this.spawn(minCutEdgeIndexes.map(function (e) {
      return edges[e[0]];
    }));
    var partition1 = this.spawn();
    var partition2 = this.spawn(); // traverse metaNodeMap for best cut

    var witnessNodePartition = minCutNodeMap[0];

    for (var _i5 = 0; _i5 < minCutNodeMap.length; _i5++) {
      var partitionId = minCutNodeMap[_i5];
      var node = nodes[_i5];

      if (partitionId === witnessNodePartition) {
        partition1.merge(node);
      } else {
        partition2.merge(node);
      }
    }

    var ret = {
      cut: cut,
      partition1: partition1,
      partition2: partition2
    };
    return ret;
  }
}; // elesfn

var copyPosition = function copyPosition(p) {
  return {
    x: p.x,
    y: p.y
  };
};
var modelToRenderedPosition = function modelToRenderedPosition(p, zoom, pan) {
  return {
    x: p.x * zoom + pan.x,
    y: p.y * zoom + pan.y
  };
};
var renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {
  return {
    x: (p.x - pan.x) / zoom,
    y: (p.y - pan.y) / zoom
  };
};
var array2point = function array2point(arr) {
  return {
    x: arr[0],
    y: arr[1]
  };
};
var min = function min(arr) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
  var min = Infinity;

  for (var i = begin; i < end; i++) {
    var val = arr[i];

    if (isFinite(val)) {
      min = Math.min(val, min);
    }
  }

  return min;
};
var max = function max(arr) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
  var max = -Infinity;

  for (var i = begin; i < end; i++) {
    var val = arr[i];

    if (isFinite(val)) {
      max = Math.max(val, max);
    }
  }

  return max;
};
var mean = function mean(arr) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
  var total = 0;
  var n = 0;

  for (var i = begin; i < end; i++) {
    var val = arr[i];

    if (isFinite(val)) {
      total += val;
      n++;
    }
  }

  return total / n;
};
var median = function median(arr) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;
  var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

  if (copy) {
    arr = arr.slice(begin, end);
  } else {
    if (end < arr.length) {
      arr.splice(end, arr.length - end);
    }

    if (begin > 0) {
      arr.splice(0, begin);
    }
  } // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start


  var off = 0; // offset from non-finite values

  for (var i = arr.length - 1; i >= 0; i--) {
    var v = arr[i];

    if (includeHoles) {
      if (!isFinite(v)) {
        arr[i] = -Infinity;
        off++;
      }
    } else {
      // just remove it if we don't want to consider holes
      arr.splice(i, 1);
    }
  }

  if (sort) {
    arr.sort(function (a, b) {
      return a - b;
    }); // requires copy = true if you don't want to change the orig
  }

  var len = arr.length;
  var mid = Math.floor(len / 2);

  if (len % 2 !== 0) {
    return arr[mid + 1 + off];
  } else {
    return (arr[mid - 1 + off] + arr[mid + off]) / 2;
  }
};
var deg2rad = function deg2rad(deg) {
  return Math.PI * deg / 180;
};
var getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {
  return Math.atan2(dispY, dispX) - Math.PI / 2;
};
var log2 = Math.log2 || function (n) {
  return Math.log(n) / Math.log(2);
};
var signum = function signum(x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};
var dist = function dist(p1, p2) {
  return Math.sqrt(sqdist(p1, p2));
};
var sqdist = function sqdist(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return dx * dx + dy * dy;
};
var inPlaceSumNormalize = function inPlaceSumNormalize(v) {
  var length = v.length; // First, get sum of all elements

  var total = 0;

  for (var i = 0; i < length; i++) {
    total += v[i];
  } // Now, divide each by the sum of all elements


  for (var _i = 0; _i < length; _i++) {
    v[_i] = v[_i] / total;
  }

  return v;
};

var qbezierAt = function qbezierAt(p0, p1, p2, t) {
  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
};
var qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {
  return {
    x: qbezierAt(p0.x, p1.x, p2.x, t),
    y: qbezierAt(p0.y, p1.y, p2.y, t)
  };
};
var lineAt = function lineAt(p0, p1, t, d) {
  var vec = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var vecDist = dist(p0, p1);
  var normVec = {
    x: vec.x / vecDist,
    y: vec.y / vecDist
  };
  t = t == null ? 0 : t;
  d = d != null ? d : t * vecDist;
  return {
    x: p0.x + normVec.x * d,
    y: p0.y + normVec.y * d
  };
};
var bound = function bound(min, val, max) {
  return Math.max(min, Math.min(max, val));
}; // makes a full bb (x1, y1, x2, y2, w, h) from implicit params

var makeBoundingBox = function makeBoundingBox(bb) {
  if (bb == null) {
    return {
      x1: Infinity,
      y1: Infinity,
      x2: -Infinity,
      y2: -Infinity,
      w: 0,
      h: 0
    };
  } else if (bb.x1 != null && bb.y1 != null) {
    if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x2,
        y2: bb.y2,
        w: bb.x2 - bb.x1,
        h: bb.y2 - bb.y1
      };
    } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x1 + bb.w,
        y2: bb.y1 + bb.h,
        w: bb.w,
        h: bb.h
      };
    }
  }
};
var copyBoundingBox = function copyBoundingBox(bb) {
  return {
    x1: bb.x1,
    x2: bb.x2,
    w: bb.w,
    y1: bb.y1,
    y2: bb.y2,
    h: bb.h
  };
};
var clearBoundingBox = function clearBoundingBox(bb) {
  bb.x1 = Infinity;
  bb.y1 = Infinity;
  bb.x2 = -Infinity;
  bb.y2 = -Infinity;
  bb.w = 0;
  bb.h = 0;
};
var updateBoundingBox = function updateBoundingBox(bb1, bb2) {
  // update bb1 with bb2 bounds
  bb1.x1 = Math.min(bb1.x1, bb2.x1);
  bb1.x2 = Math.max(bb1.x2, bb2.x2);
  bb1.w = bb1.x2 - bb1.x1;
  bb1.y1 = Math.min(bb1.y1, bb2.y1);
  bb1.y2 = Math.max(bb1.y2, bb2.y2);
  bb1.h = bb1.y2 - bb1.y1;
};
var expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {
  bb.x1 = Math.min(bb.x1, x);
  bb.x2 = Math.max(bb.x2, x);
  bb.w = bb.x2 - bb.x1;
  bb.y1 = Math.min(bb.y1, y);
  bb.y2 = Math.max(bb.y2, y);
  bb.h = bb.y2 - bb.y1;
};
var expandBoundingBox = function expandBoundingBox(bb) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  bb.x1 -= padding;
  bb.x2 += padding;
  bb.y1 -= padding;
  bb.y2 += padding;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;
  return bb;
};
var expandBoundingBoxSides = function expandBoundingBoxSides(bb) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0];
  var top, right, bottom, left;

  if (padding.length === 1) {
    top = right = bottom = left = padding[0];
  } else if (padding.length === 2) {
    top = bottom = padding[0];
    left = right = padding[1];
  } else if (padding.length === 4) {
    var _padding = _slicedToArray(padding, 4);

    top = _padding[0];
    right = _padding[1];
    bottom = _padding[2];
    left = _padding[3];
  }

  bb.x1 -= left;
  bb.x2 += right;
  bb.y1 -= top;
  bb.y2 += bottom;
  bb.w = bb.x2 - bb.x1;
  bb.h = bb.y2 - bb.y1;
  return bb;
};

var assignBoundingBox = function assignBoundingBox(bb1, bb2) {
  bb1.x1 = bb2.x1;
  bb1.y1 = bb2.y1;
  bb1.x2 = bb2.x2;
  bb1.y2 = bb2.y2;
  bb1.w = bb1.x2 - bb1.x1;
  bb1.h = bb1.y2 - bb1.y1;
};
var assignShiftToBoundingBox = function assignShiftToBoundingBox(bb, delta) {
  bb.x1 += delta.x;
  bb.x2 += delta.x;
  bb.y1 += delta.y;
  bb.y2 += delta.y;
};
var boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {
  // case: one bb to right of other
  if (bb1.x1 > bb2.x2) {
    return false;
  }

  if (bb2.x1 > bb1.x2) {
    return false;
  } // case: one bb to left of other


  if (bb1.x2 < bb2.x1) {
    return false;
  }

  if (bb2.x2 < bb1.x1) {
    return false;
  } // case: one bb above other


  if (bb1.y2 < bb2.y1) {
    return false;
  }

  if (bb2.y2 < bb1.y1) {
    return false;
  } // case: one bb below other


  if (bb1.y1 > bb2.y2) {
    return false;
  }

  if (bb2.y1 > bb1.y2) {
    return false;
  } // otherwise, must have some overlap


  return true;
};
var inBoundingBox = function inBoundingBox(bb, x, y) {
  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
};
var pointInBoundingBox = function pointInBoundingBox(bb, pt) {
  return inBoundingBox(bb, pt.x, pt.y);
};
var boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {
  return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);
};
var roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {
  var cornerRadius = getRoundRectangleRadius(width, height);
  var halfWidth = width / 2;
  var halfHeight = height / 2; // Check intersections with straight line segments

  var straightLineIntersections; // Top segment, left to right

  {
    var topStartX = nodeX - halfWidth + cornerRadius - padding;
    var topStartY = nodeY - halfHeight - padding;
    var topEndX = nodeX + halfWidth - cornerRadius + padding;
    var topEndY = topStartY;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  } // Right segment, top to bottom

  {
    var rightStartX = nodeX + halfWidth + padding;
    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
    var rightEndX = rightStartX;
    var rightEndY = nodeY + halfHeight - cornerRadius + padding;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  } // Bottom segment, left to right

  {
    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
    var bottomStartY = nodeY + halfHeight + padding;
    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
    var bottomEndY = bottomStartY;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  } // Left segment, top to bottom

  {
    var leftStartX = nodeX - halfWidth - padding;
    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
    var leftEndX = leftStartX;
    var leftEndY = nodeY + halfHeight - cornerRadius + padding;
    straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  } // Check intersections with arc segments

  var arcIntersections; // Top Left

  {
    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

    if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  } // Top Right

  {
    var topRightCenterX = nodeX + halfWidth - cornerRadius;
    var topRightCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

    if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  } // Bottom Right

  {
    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

    if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  } // Bottom Left

  {
    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle

    if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }
  return []; // if nothing
};
var inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {
  var t = tolerance;
  var x1 = Math.min(lx1, lx2);
  var x2 = Math.max(lx1, lx2);
  var y1 = Math.min(ly1, ly2);
  var y2 = Math.max(ly1, ly2);
  return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;
};
var inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {
  var bb = {
    x1: Math.min(x1, x3, x2) - tolerance,
    x2: Math.max(x1, x3, x2) + tolerance,
    y1: Math.min(y1, y3, y2) - tolerance,
    y2: Math.max(y1, y3, y2) + tolerance
  }; // if outside the rough bounding box for the bezier, then it can't be a hit

  if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {
    // console.log('bezier out of rough bb')
    return false;
  } else {
    // console.log('do more expensive check');
    return true;
  }
};
var solveQuadratic = function solveQuadratic(a, b, c, val) {
  c -= val;
  var r = b * b - 4 * a * c;

  if (r < 0) {
    return [];
  }

  var sqrtR = Math.sqrt(r);
  var denom = 2 * a;
  var root1 = (-b + sqrtR) / denom;
  var root2 = (-b - sqrtR) / denom;
  return [root1, root2];
};
var solveCubic = function solveCubic(a, b, c, d, result) {
  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
  // r is the real component, i is the imaginary component
  // An implementation of the Cardano method from the year 1545
  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots
  var epsilon = 0.00001; // avoid division by zero while keeping the overall expression close in value

  if (a === 0) {
    a = epsilon;
  }

  b /= a;
  c /= a;
  d /= a;
  var discriminant, q, r, dum1, s, t, term1, r13;
  q = (3.0 * c - b * b) / 9.0;
  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
  r /= 54.0;
  discriminant = q * q * q + r * r;
  result[1] = 0;
  term1 = b / 3.0;

  if (discriminant > 0) {
    s = r + Math.sqrt(discriminant);
    s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);
    t = r - Math.sqrt(discriminant);
    t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);
    result[0] = -term1 + s + t;
    term1 += (s + t) / 2.0;
    result[4] = result[2] = -term1;
    term1 = Math.sqrt(3.0) * (-t + s) / 2;
    result[3] = term1;
    result[5] = -term1;
    return;
  }

  result[5] = result[3] = 0;

  if (discriminant === 0) {
    r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);
    result[0] = -term1 + 2.0 * r13;
    result[4] = result[2] = -(r13 + term1);
    return;
  }

  q = -q;
  dum1 = q * q * q;
  dum1 = Math.acos(r / Math.sqrt(dum1));
  r13 = 2.0 * Math.sqrt(q);
  result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
  result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
  result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);
  return;
};
var sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {
  // Find minimum distance by using the minimum of the distance
  // function between the given point and the curve
  // This gives the coefficients of the resulting cubic equation
  // whose roots tell us where a possible minimum is
  // (Coefficients are divided by 4)
  var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;
  var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;
  var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;
  var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y; // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

  var roots = []; // Use the cubic solving algorithm

  solveCubic(a, b, c, d, roots);
  var zeroThreshold = 0.0000001;
  var params = [];

  for (var index = 0; index < 6; index += 2) {
    if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {
      params.push(roots[index]);
    }
  }

  params.push(1.0);
  params.push(0.0);
  var minDistanceSquared = -1;
  var curX, curY, distSquared;

  for (var i = 0; i < params.length; i++) {
    curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;
    curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;
    distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2); // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));

    if (minDistanceSquared >= 0) {
      if (distSquared < minDistanceSquared) {
        minDistanceSquared = distSquared;
      }
    } else {
      minDistanceSquared = distSquared;
    }
  }

  return minDistanceSquared;
};
var sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {
  var offset = [x - x1, y - y1];
  var line = [x2 - x1, y2 - y1];
  var lineSq = line[0] * line[0] + line[1] * line[1];
  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
  var dotProduct = offset[0] * line[0] + offset[1] * line[1];
  var adjSq = dotProduct * dotProduct / lineSq;

  if (dotProduct < 0) {
    return hypSq;
  }

  if (adjSq > lineSq) {
    return (x - x2) * (x - x2) + (y - y2) * (y - y2);
  }

  return hypSq - adjSq;
};
var pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {
  var x1, y1, x2, y2;
  var y3; // Intersect with vertical line through (x, y)

  var up = 0; // let down = 0;

  for (var i = 0; i < points.length / 2; i++) {
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];

    if (i + 1 < points.length / 2) {
      x2 = points[(i + 1) * 2];
      y2 = points[(i + 1) * 2 + 1];
    } else {
      x2 = points[(i + 1 - points.length / 2) * 2];
      y2 = points[(i + 1 - points.length / 2) * 2 + 1];
    }

    if (x1 == x && x2 == x) ; else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {
      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

      if (y3 > y) {
        up++;
      } // if( y3 < y ){
      // down++;
      // }

    } else {
      continue;
    }
  }

  if (up % 2 === 0) {
    return false;
  } else {
    return true;
  }
};
var pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {
  var transformedPoints = new Array(basePoints.length); // Gives negative angle

  var angle;

  if (direction[0] != null) {
    angle = Math.atan(direction[1] / direction[0]);

    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
  } else {
    angle = direction;
  }

  var cos = Math.cos(-angle);
  var sin = Math.sin(-angle); //    console.log("base: " + basePoints);

  for (var i = 0; i < transformedPoints.length / 2; i++) {
    transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);
    transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);
    transformedPoints[i * 2] += centerX;
    transformedPoints[i * 2 + 1] += centerY;
  }

  var points;

  if (padding > 0) {
    var expandedLineSet = expandPolygon(transformedPoints, -padding);
    points = joinLines(expandedLineSet);
  } else {
    points = transformedPoints;
  }

  return pointInsidePolygonPoints(x, y, points);
};
var pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height) {
  var cutPolygonPoints = new Array(basePoints.length);
  var halfW = width / 2;
  var halfH = height / 2;
  var cornerRadius = getRoundPolygonRadius(width, height);
  var squaredCornerRadius = cornerRadius * cornerRadius;

  for (var i = 0; i < basePoints.length / 4; i++) {
    var sourceUv = void 0,
        destUv = void 0;

    if (i === 0) {
      sourceUv = basePoints.length - 2;
    } else {
      sourceUv = i * 4 - 2;
    }

    destUv = i * 4 + 2;
    var px = centerX + halfW * basePoints[i * 4];
    var py = centerY + halfH * basePoints[i * 4 + 1];
    var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
    var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
    var cp0x = px - offset * basePoints[sourceUv];
    var cp0y = py - offset * basePoints[sourceUv + 1];
    var cp1x = px + offset * basePoints[destUv];
    var cp1y = py + offset * basePoints[destUv + 1];
    cutPolygonPoints[i * 4] = cp0x;
    cutPolygonPoints[i * 4 + 1] = cp0y;
    cutPolygonPoints[i * 4 + 2] = cp1x;
    cutPolygonPoints[i * 4 + 3] = cp1y;
    var orthx = basePoints[sourceUv + 1];
    var orthy = -basePoints[sourceUv];
    var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];

    if (cosAlpha < 0) {
      orthx *= -1;
      orthy *= -1;
    }

    var cx = cp0x + orthx * cornerRadius;
    var cy = cp0y + orthy * cornerRadius;
    var squaredDistance = Math.pow(cx - x, 2) + Math.pow(cy - y, 2);

    if (squaredDistance <= squaredCornerRadius) {
      return true;
    }
  }

  return pointInsidePolygonPoints(x, y, cutPolygonPoints);
};
var joinLines = function joinLines(lineSet) {
  var vertices = new Array(lineSet.length / 2);
  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;

  for (var i = 0; i < lineSet.length / 4; i++) {
    currentLineStartX = lineSet[i * 4];
    currentLineStartY = lineSet[i * 4 + 1];
    currentLineEndX = lineSet[i * 4 + 2];
    currentLineEndY = lineSet[i * 4 + 3];

    if (i < lineSet.length / 4 - 1) {
      nextLineStartX = lineSet[(i + 1) * 4];
      nextLineStartY = lineSet[(i + 1) * 4 + 1];
      nextLineEndX = lineSet[(i + 1) * 4 + 2];
      nextLineEndY = lineSet[(i + 1) * 4 + 3];
    } else {
      nextLineStartX = lineSet[0];
      nextLineStartY = lineSet[1];
      nextLineEndX = lineSet[2];
      nextLineEndY = lineSet[3];
    }

    var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);
    vertices[i * 2] = intersection[0];
    vertices[i * 2 + 1] = intersection[1];
  }

  return vertices;
};
var expandPolygon = function expandPolygon(points, pad) {
  var expandedLineSet = new Array(points.length * 2);
  var currentPointX, currentPointY, nextPointX, nextPointY;

  for (var i = 0; i < points.length / 2; i++) {
    currentPointX = points[i * 2];
    currentPointY = points[i * 2 + 1];

    if (i < points.length / 2 - 1) {
      nextPointX = points[(i + 1) * 2];
      nextPointY = points[(i + 1) * 2 + 1];
    } else {
      nextPointX = points[0];
      nextPointY = points[1];
    } // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
    // Assume CCW polygon winding


    var offsetX = nextPointY - currentPointY;
    var offsetY = -(nextPointX - currentPointX); // Normalize

    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
    var normalizedOffsetX = offsetX / offsetLength;
    var normalizedOffsetY = offsetY / offsetLength;
    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
  }

  return expandedLineSet;
};
var intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
  var dispX = centerX - x;
  var dispY = centerY - y;
  dispX /= ellipseWradius;
  dispY /= ellipseHradius;
  var len = Math.sqrt(dispX * dispX + dispY * dispY);
  var newLength = len - 1;

  if (newLength < 0) {
    return [];
  }

  var lenProportion = newLength / len;
  return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
};
var checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {
  x -= centerX;
  y -= centerY;
  x /= width / 2 + padding;
  y /= height / 2 + padding;
  return x * x + y * y <= 1;
}; // Returns intersections of increasing distance from line's start point

var intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {
  // Calculate d, direction vector of line
  var d = [x2 - x1, y2 - y1]; // Direction vector of line

  var f = [x1 - centerX, y1 - centerY];
  var a = d[0] * d[0] + d[1] * d[1];
  var b = 2 * (f[0] * d[0] + f[1] * d[1]);
  var c = f[0] * f[0] + f[1] * f[1] - radius * radius;
  var discriminant = b * b - 4 * a * c;

  if (discriminant < 0) {
    return [];
  }

  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
  var tMin = Math.min(t1, t2);
  var tMax = Math.max(t1, t2);
  var inRangeParams = [];

  if (tMin >= 0 && tMin <= 1) {
    inRangeParams.push(tMin);
  }

  if (tMax >= 0 && tMax <= 1) {
    inRangeParams.push(tMax);
  }

  if (inRangeParams.length === 0) {
    return [];
  }

  var nearIntersectionX = inRangeParams[0] * d[0] + x1;
  var nearIntersectionY = inRangeParams[0] * d[1] + y1;

  if (inRangeParams.length > 1) {
    if (inRangeParams[0] == inRangeParams[1]) {
      return [nearIntersectionX, nearIntersectionY];
    } else {
      var farIntersectionX = inRangeParams[1] * d[0] + x1;
      var farIntersectionY = inRangeParams[1] * d[1] + y1;
      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
    }
  } else {
    return [nearIntersectionX, nearIntersectionY];
  }
};
var midOfThree = function midOfThree(a, b, c) {
  if (b <= a && a <= c || c <= a && a <= b) {
    return a;
  } else if (a <= b && b <= c || c <= b && b <= a) {
    return b;
  } else {
    return c;
  }
}; // (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)

var finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
  var dx13 = x1 - x3;
  var dx21 = x2 - x1;
  var dx43 = x4 - x3;
  var dy13 = y1 - y3;
  var dy21 = y2 - y1;
  var dy43 = y4 - y3;
  var ua_t = dx43 * dy13 - dy43 * dx13;
  var ub_t = dx21 * dy13 - dy21 * dx13;
  var u_b = dy43 * dx21 - dx43 * dy21;

  if (u_b !== 0) {
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;
    var flptThreshold = 0.001;

    var _min = 0 - flptThreshold;

    var _max = 1 + flptThreshold;

    if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {
      return [x1 + ua * dx21, y1 + ua * dy21];
    } else {
      if (!infiniteLines) {
        return [];
      } else {
        return [x1 + ua * dx21, y1 + ua * dy21];
      }
    }
  } else {
    if (ua_t === 0 || ub_t === 0) {
      // Parallel, coincident lines. Check if overlap
      // Check endpoint of second line
      if (midOfThree(x1, x2, x4) === x4) {
        return [x4, y4];
      } // Check start point of second line


      if (midOfThree(x1, x2, x3) === x3) {
        return [x3, y3];
      } // Endpoint of first line


      if (midOfThree(x3, x4, x2) === x2) {
        return [x2, y2];
      }

      return [];
    } else {
      // Parallel, non-coincident
      return [];
    }
  }
}; // math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )
// intersect a node polygon (pts transformed)
//
// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )
// intersect the points (no transform)

var polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {
  var intersections = [];
  var intersection;
  var transformedPoints = new Array(basePoints.length);
  var doTransform = true;

  if (width == null) {
    doTransform = false;
  }

  var points;

  if (doTransform) {
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
    }

    if (padding > 0) {
      var expandedLineSet = expandPolygon(transformedPoints, -padding);
      points = joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
  } else {
    points = basePoints;
  }

  var currentX, currentY, nextX, nextY;

  for (var _i2 = 0; _i2 < points.length / 2; _i2++) {
    currentX = points[_i2 * 2];
    currentY = points[_i2 * 2 + 1];

    if (_i2 < points.length / 2 - 1) {
      nextX = points[(_i2 + 1) * 2];
      nextY = points[(_i2 + 1) * 2 + 1];
    } else {
      nextX = points[0];
      nextY = points[1];
    }

    intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  return intersections;
};
var roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {
  var intersections = [];
  var intersection;
  var lines = new Array(basePoints.length);
  var halfW = width / 2;
  var halfH = height / 2;
  var cornerRadius = getRoundPolygonRadius(width, height);

  for (var i = 0; i < basePoints.length / 4; i++) {
    var sourceUv = void 0,
        destUv = void 0;

    if (i === 0) {
      sourceUv = basePoints.length - 2;
    } else {
      sourceUv = i * 4 - 2;
    }

    destUv = i * 4 + 2;
    var px = centerX + halfW * basePoints[i * 4];
    var py = centerY + halfH * basePoints[i * 4 + 1];
    var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];
    var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
    var cp0x = px - offset * basePoints[sourceUv];
    var cp0y = py - offset * basePoints[sourceUv + 1];
    var cp1x = px + offset * basePoints[destUv];
    var cp1y = py + offset * basePoints[destUv + 1];

    if (i === 0) {
      lines[basePoints.length - 2] = cp0x;
      lines[basePoints.length - 1] = cp0y;
    } else {
      lines[i * 4 - 2] = cp0x;
      lines[i * 4 - 1] = cp0y;
    }

    lines[i * 4] = cp1x;
    lines[i * 4 + 1] = cp1y;
    var orthx = basePoints[sourceUv + 1];
    var orthy = -basePoints[sourceUv];
    var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];

    if (cosAlpha < 0) {
      orthx *= -1;
      orthy *= -1;
    }

    var cx = cp0x + orthx * cornerRadius;
    var cy = cp0y + orthy * cornerRadius;
    intersection = intersectLineCircle(x, y, centerX, centerY, cx, cy, cornerRadius);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  for (var _i3 = 0; _i3 < lines.length / 4; _i3++) {
    intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[_i3 * 4], lines[_i3 * 4 + 1], lines[_i3 * 4 + 2], lines[_i3 * 4 + 3], false);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  if (intersections.length > 2) {
    var lowestIntersection = [intersections[0], intersections[1]];
    var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);

    for (var _i4 = 1; _i4 < intersections.length / 2; _i4++) {
      var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);

      if (squaredDistance <= lowestSquaredDistance) {
        lowestIntersection[0] = intersections[_i4 * 2];
        lowestIntersection[1] = intersections[_i4 * 2 + 1];
        lowestSquaredDistance = squaredDistance;
      }
    }

    return lowestIntersection;
  }

  return intersections;
};
var shortenIntersection = function shortenIntersection(intersection, offset, amount) {
  var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];
  var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
  var lenRatio = (length - amount) / length;

  if (lenRatio < 0) {
    lenRatio = 0.00001;
  }

  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
};
var generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {
  var points = generateUnitNgonPoints(sides, rotationRadians);
  points = fitPolygonToSquare(points);
  return points;
};
var fitPolygonToSquare = function fitPolygonToSquare(points) {
  var x, y;
  var sides = points.length / 2;
  var minX = Infinity,
      minY = Infinity,
      maxX = -Infinity,
      maxY = -Infinity;

  for (var i = 0; i < sides; i++) {
    x = points[2 * i];
    y = points[2 * i + 1];
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  } // stretch factors


  var sx = 2 / (maxX - minX);
  var sy = 2 / (maxY - minY);

  for (var _i5 = 0; _i5 < sides; _i5++) {
    x = points[2 * _i5] = points[2 * _i5] * sx;
    y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  }

  if (minY < -1) {
    for (var _i6 = 0; _i6 < sides; _i6++) {
      y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);
    }
  }

  return points;
};
var generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {
  var increment = 1.0 / sides * 2 * Math.PI;
  var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
  startAngle += rotationRadians;
  var points = new Array(sides * 2);
  var currentAngle;

  for (var i = 0; i < sides; i++) {
    currentAngle = i * increment + startAngle;
    points[2 * i] = Math.cos(currentAngle); // x

    points[2 * i + 1] = Math.sin(-currentAngle); // y
  }

  return points;
}; // Set the default radius, unless half of width or height is smaller than default

var getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {
  return Math.min(width / 4, height / 4, 8);
}; // Set the default radius

var getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {
  return Math.min(width / 10, height / 10, 8);
};
var getCutRectangleCornerLength = function getCutRectangleCornerLength() {
  return 8;
};
var bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {
  return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];
}; // get curve width, height, and control point position offsets as a percentage of node height / width

var getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {
  return {
    heightOffset: Math.min(15, 0.05 * height),
    widthOffset: Math.min(100, 0.25 * width),
    ctrlPtOffsetPct: 0.05
  };
};

var pageRankDefaults = defaults({
  dampingFactor: 0.8,
  precision: 0.000001,
  iterations: 200,
  weight: function weight(edge) {
    return 1;
  }
});
var elesfn$7 = {
  pageRank: function pageRank(options) {
    var _pageRankDefaults = pageRankDefaults(options),
        dampingFactor = _pageRankDefaults.dampingFactor,
        precision = _pageRankDefaults.precision,
        iterations = _pageRankDefaults.iterations,
        weight = _pageRankDefaults.weight;

    var cy = this._private.cy;

    var _this$byGroup = this.byGroup(),
        nodes = _this$byGroup.nodes,
        edges = _this$byGroup.edges;

    var numNodes = nodes.length;
    var numNodesSqd = numNodes * numNodes;
    var numEdges = edges.length; // Construct transposed adjacency matrix
    // First lets have a zeroed matrix of the right size
    // We'll also keep track of the sum of each column

    var matrix = new Array(numNodesSqd);
    var columnSum = new Array(numNodes);
    var additionalProb = (1 - dampingFactor) / numNodes; // Create null matrix

    for (var i = 0; i < numNodes; i++) {
      for (var j = 0; j < numNodes; j++) {
        var n = i * numNodes + j;
        matrix[n] = 0;
      }

      columnSum[i] = 0;
    } // Now, process edges


    for (var _i = 0; _i < numEdges; _i++) {
      var edge = edges[_i];
      var srcId = edge.data('source');
      var tgtId = edge.data('target'); // Don't include loops in the matrix

      if (srcId === tgtId) {
        continue;
      }

      var s = nodes.indexOfId(srcId);
      var t = nodes.indexOfId(tgtId);
      var w = weight(edge);

      var _n = t * numNodes + s; // Update matrix


      matrix[_n] += w; // Update column sum

      columnSum[s] += w;
    } // Add additional probability based on damping factor
    // Also, take into account columns that have sum = 0


    var p = 1.0 / numNodes + additionalProb; // Shorthand
    // Traverse matrix, column by column

    for (var _j = 0; _j < numNodes; _j++) {
      if (columnSum[_j] === 0) {
        // No 'links' out from node jth, assume equal probability for each possible node
        for (var _i2 = 0; _i2 < numNodes; _i2++) {
          var _n2 = _i2 * numNodes + _j;

          matrix[_n2] = p;
        }
      } else {
        // Node jth has outgoing link, compute normalized probabilities
        for (var _i3 = 0; _i3 < numNodes; _i3++) {
          var _n3 = _i3 * numNodes + _j;

          matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;
        }
      }
    } // Compute dominant eigenvector using power method


    var eigenvector = new Array(numNodes);
    var temp = new Array(numNodes);
    var previous; // Start with a vector of all 1's
    // Also, initialize a null vector which will be used as shorthand

    for (var _i4 = 0; _i4 < numNodes; _i4++) {
      eigenvector[_i4] = 1;
    }

    for (var iter = 0; iter < iterations; iter++) {
      // Temp array with all 0's
      for (var _i5 = 0; _i5 < numNodes; _i5++) {
        temp[_i5] = 0;
      } // Multiply matrix with previous result


      for (var _i6 = 0; _i6 < numNodes; _i6++) {
        for (var _j2 = 0; _j2 < numNodes; _j2++) {
          var _n4 = _i6 * numNodes + _j2;

          temp[_i6] += matrix[_n4] * eigenvector[_j2];
        }
      }

      inPlaceSumNormalize(temp);
      previous = eigenvector;
      eigenvector = temp;
      temp = previous;
      var diff = 0; // Compute difference (squared module) of both vectors

      for (var _i7 = 0; _i7 < numNodes; _i7++) {
        var delta = previous[_i7] - eigenvector[_i7];
        diff += delta * delta;
      } // If difference is less than the desired threshold, stop iterating


      if (diff < precision) {
        break;
      }
    } // Construct result


    var res = {
      rank: function rank(node) {
        node = cy.collection(node)[0];
        return eigenvector[nodes.indexOf(node)];
      }
    };
    return res;
  } // pageRank

}; // elesfn

var defaults$1 = defaults({
  root: null,
  weight: function weight(edge) {
    return 1;
  },
  directed: false,
  alpha: 0
});
var elesfn$8 = {
  degreeCentralityNormalized: function degreeCentralityNormalized(options) {
    options = defaults$1(options);
    var cy = this.cy();
    var nodes = this.nodes();
    var numNodes = nodes.length;

    if (!options.directed) {
      var degrees = {};
      var maxDegree = 0;

      for (var i = 0; i < numNodes; i++) {
        var node = nodes[i]; // add current node to the current options object and call degreeCentrality

        options.root = node;
        var currDegree = this.degreeCentrality(options);

        if (maxDegree < currDegree.degree) {
          maxDegree = currDegree.degree;
        }

        degrees[node.id()] = currDegree.degree;
      }

      return {
        degree: function degree(node) {
          if (maxDegree === 0) {
            return 0;
          }

          if (string(node)) {
            // from is a selector string
            node = cy.filter(node);
          }

          return degrees[node.id()] / maxDegree;
        }
      };
    } else {
      var indegrees = {};
      var outdegrees = {};
      var maxIndegree = 0;
      var maxOutdegree = 0;

      for (var _i = 0; _i < numNodes; _i++) {
        var _node = nodes[_i];

        var id = _node.id(); // add current node to the current options object and call degreeCentrality


        options.root = _node;

        var _currDegree = this.degreeCentrality(options);

        if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;
        if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;
        indegrees[id] = _currDegree.indegree;
        outdegrees[id] = _currDegree.outdegree;
      }

      return {
        indegree: function indegree(node) {
          if (maxIndegree == 0) {
            return 0;
          }

          if (string(node)) {
            // from is a selector string
            node = cy.filter(node);
          }

          return indegrees[node.id()] / maxIndegree;
        },
        outdegree: function outdegree(node) {
          if (maxOutdegree === 0) {
            return 0;
          }

          if (string(node)) {
            // from is a selector string
            node = cy.filter(node);
          }

          return outdegrees[node.id()] / maxOutdegree;
        }
      };
    }
  },
  // degreeCentralityNormalized
  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function degreeCentrality(options) {
    options = defaults$1(options);
    var cy = this.cy();
    var callingEles = this;
    var _options = options,
        root = _options.root,
        weight = _options.weight,
        directed = _options.directed,
        alpha = _options.alpha;
    root = cy.collection(root)[0];

    if (!directed) {
      var connEdges = root.connectedEdges().intersection(callingEles);
      var k = connEdges.length;
      var s = 0; // Now, sum edge weights

      for (var i = 0; i < connEdges.length; i++) {
        s += weight(connEdges[i]);
      }

      return {
        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
      };
    } else {
      var edges = root.connectedEdges();
      var incoming = edges.filter(function (edge) {
        return edge.target().same(root) && callingEles.has(edge);
      });
      var outgoing = edges.filter(function (edge) {
        return edge.source().same(root) && callingEles.has(edge);
      });
      var k_in = incoming.length;
      var k_out = outgoing.length;
      var s_in = 0;
      var s_out = 0; // Now, sum incoming edge weights

      for (var _i2 = 0; _i2 < incoming.length; _i2++) {
        s_in += weight(incoming[_i2]);
      } // Now, sum outgoing edge weights


      for (var _i3 = 0; _i3 < outgoing.length; _i3++) {
        s_out += weight(outgoing[_i3]);
      }

      return {
        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
      };
    }
  } // degreeCentrality

}; // elesfn
// nice, short mathemathical alias

elesfn$8.dc = elesfn$8.degreeCentrality;
elesfn$8.dcn = elesfn$8.degreeCentralityNormalised = elesfn$8.degreeCentralityNormalized;

var defaults$2 = defaults({
  harmonic: true,
  weight: function weight() {
    return 1;
  },
  directed: false,
  root: null
});
var elesfn$9 = {
  closenessCentralityNormalized: function closenessCentralityNormalized(options) {
    var _defaults = defaults$2(options),
        harmonic = _defaults.harmonic,
        weight = _defaults.weight,
        directed = _defaults.directed;

    var cy = this.cy();
    var closenesses = {};
    var maxCloseness = 0;
    var nodes = this.nodes();
    var fw = this.floydWarshall({
      weight: weight,
      directed: directed
    }); // Compute closeness for every node and find the maximum closeness

    for (var i = 0; i < nodes.length; i++) {
      var currCloseness = 0;
      var node_i = nodes[i];

      for (var j = 0; j < nodes.length; j++) {
        if (i !== j) {
          var d = fw.distance(node_i, nodes[j]);

          if (harmonic) {
            currCloseness += 1 / d;
          } else {
            currCloseness += d;
          }
        }
      }

      if (!harmonic) {
        currCloseness = 1 / currCloseness;
      }

      if (maxCloseness < currCloseness) {
        maxCloseness = currCloseness;
      }

      closenesses[node_i.id()] = currCloseness;
    }

    return {
      closeness: function closeness(node) {
        if (maxCloseness == 0) {
          return 0;
        }

        if (string(node)) {
          // from is a selector string
          node = cy.filter(node)[0].id();
        } else {
          // from is a node
          node = node.id();
        }

        return closenesses[node] / maxCloseness;
      }
    };
  },
  // Implemented from pseudocode from wikipedia
  closenessCentrality: function closenessCentrality(options) {
    var _defaults2 = defaults$2(options),
        root = _defaults2.root,
        weight = _defaults2.weight,
        directed = _defaults2.directed,
        harmonic = _defaults2.harmonic;

    root = this.filter(root)[0]; // we need distance from this node to every other node

    var dijkstra = this.dijkstra({
      root: root,
      weight: weight,
      directed: directed
    });
    var totalDistance = 0;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      var n = nodes[i];

      if (!n.same(root)) {
        var d = dijkstra.distanceTo(n);

        if (harmonic) {
          totalDistance += 1 / d;
        } else {
          totalDistance += d;
        }
      }
    }

    return harmonic ? totalDistance : 1 / totalDistance;
  } // closenessCentrality

}; // elesfn
// nice, short mathemathical alias

elesfn$9.cc = elesfn$9.closenessCentrality;
elesfn$9.ccn = elesfn$9.closenessCentralityNormalised = elesfn$9.closenessCentralityNormalized;

var defaults$3 = defaults({
  weight: null,
  directed: false
});
var elesfn$a = {
  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function betweennessCentrality(options) {
    var _defaults = defaults$3(options),
        directed = _defaults.directed,
        weight = _defaults.weight;

    var weighted = weight != null;
    var cy = this.cy(); // starting

    var V = this.nodes();
    var A = {};
    var _C = {};
    var max = 0;
    var C = {
      set: function set(key, val) {
        _C[key] = val;

        if (val > max) {
          max = val;
        }
      },
      get: function get(key) {
        return _C[key];
      }
    }; // A contains the neighborhoods of every node

    for (var i = 0; i < V.length; i++) {
      var v = V[i];
      var vid = v.id();

      if (directed) {
        A[vid] = v.outgoers().nodes(); // get outgoers of every node
      } else {
        A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node
      }

      C.set(vid, 0);
    }

    var _loop = function _loop(s) {
      var sid = V[s].id();
      var S = []; // stack

      var P = {};
      var g = {};
      var d = {};
      var Q = new Heap(function (a, b) {
        return d[a] - d[b];
      }); // queue
      // init dictionaries

      for (var _i = 0; _i < V.length; _i++) {
        var _vid = V[_i].id();

        P[_vid] = [];
        g[_vid] = 0;
        d[_vid] = Infinity;
      }

      g[sid] = 1; // sigma

      d[sid] = 0; // distance to s

      Q.push(sid);

      while (!Q.empty()) {
        var _v = Q.pop();

        S.push(_v);

        if (weighted) {
          for (var j = 0; j < A[_v].length; j++) {
            var w = A[_v][j];
            var vEle = cy.getElementById(_v);
            var edge = void 0;

            if (vEle.edgesTo(w).length > 0) {
              edge = vEle.edgesTo(w)[0];
            } else {
              edge = w.edgesTo(vEle)[0];
            }

            var edgeWeight = weight(edge);
            w = w.id();

            if (d[w] > d[_v] + edgeWeight) {
              d[w] = d[_v] + edgeWeight;

              if (Q.nodes.indexOf(w) < 0) {
                //if w is not in Q
                Q.push(w);
              } else {
                // update position if w is in Q
                Q.updateItem(w);
              }

              g[w] = 0;
              P[w] = [];
            }

            if (d[w] == d[_v] + edgeWeight) {
              g[w] = g[w] + g[_v];
              P[w].push(_v);
            }
          }
        } else {
          for (var _j = 0; _j < A[_v].length; _j++) {
            var _w = A[_v][_j].id();

            if (d[_w] == Infinity) {
              Q.push(_w);
              d[_w] = d[_v] + 1;
            }

            if (d[_w] == d[_v] + 1) {
              g[_w] = g[_w] + g[_v];

              P[_w].push(_v);
            }
          }
        }
      }

      var e = {};

      for (var _i2 = 0; _i2 < V.length; _i2++) {
        e[V[_i2].id()] = 0;
      }

      while (S.length > 0) {
        var _w2 = S.pop();

        for (var _j2 = 0; _j2 < P[_w2].length; _j2++) {
          var _v2 = P[_w2][_j2];
          e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);

          if (_w2 != V[s].id()) {
            C.set(_w2, C.get(_w2) + e[_w2]);
          }
        }
      }
    };

    for (var s = 0; s < V.length; s++) {
      _loop(s);
    }

    var ret = {
      betweenness: function betweenness(node) {
        var id = cy.collection(node).id();
        return C.get(id);
      },
      betweennessNormalized: function betweennessNormalized(node) {
        if (max == 0) {
          return 0;
        }

        var id = cy.collection(node).id();
        return C.get(id) / max;
      }
    }; // alias

    ret.betweennessNormalised = ret.betweennessNormalized;
    return ret;
  } // betweennessCentrality

}; // elesfn
// nice, short mathemathical alias

elesfn$a.bc = elesfn$a.betweennessCentrality;

// Implemented by Zoe Xi @zoexi for GSOC 2016
/* eslint-disable no-unused-vars */

var defaults$4 = defaults({
  expandFactor: 2,
  // affects time of computation and cluster granularity to some extent: M * M
  inflateFactor: 2,
  // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)
  multFactor: 1,
  // optional self loops for each node. Use a neutral value to improve cluster computations.
  maxIterations: 20,
  // maximum number of iterations of the MCL algorithm in a single run
  attributes: [// attributes/features used to group nodes, ie. similarity values between nodes
  function (edge) {
    return 1;
  }]
});
/* eslint-enable */

var setOptions = function setOptions(options) {
  return defaults$4(options);
};
/* eslint-enable */


var getSimilarity = function getSimilarity(edge, attributes) {
  var total = 0;

  for (var i = 0; i < attributes.length; i++) {
    total += attributes[i](edge);
  }

  return total;
};

var addLoops = function addLoops(M, n, val) {
  for (var i = 0; i < n; i++) {
    M[i * n + i] = val;
  }
};

var normalize = function normalize(M, n) {
  var sum;

  for (var col = 0; col < n; col++) {
    sum = 0;

    for (var row = 0; row < n; row++) {
      sum += M[row * n + col];
    }

    for (var _row = 0; _row < n; _row++) {
      M[_row * n + col] = M[_row * n + col] / sum;
    }
  }
}; // TODO: blocked matrix multiplication?


var mmult = function mmult(A, B, n) {
  var C = new Array(n * n);

  for (var i = 0; i < n; i++) {
    for (var j = 0; j < n; j++) {
      C[i * n + j] = 0;
    }

    for (var k = 0; k < n; k++) {
      for (var _j = 0; _j < n; _j++) {
        C[i * n + _j] += A[i * n + k] * B[k * n + _j];
      }
    }
  }

  return C;
};

var expand = function expand(M, n, expandFactor
/** power **/
) {
  var _M = M.slice(0);

  for (var p = 1; p < expandFactor; p++) {
    M = mmult(M, _M, n);
  }

  return M;
};

var inflate = function inflate(M, n, inflateFactor
/** r **/
) {
  var _M = new Array(n * n); // M(i,j) ^ inflatePower


  for (var i = 0; i < n * n; i++) {
    _M[i] = Math.pow(M[i], inflateFactor);
  }

  normalize(_M, n);
  return _M;
};

var hasConverged = function hasConverged(M, _M, n2, roundFactor) {
  // Check that both matrices have the same elements (i,j)
  for (var i = 0; i < n2; i++) {
    var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places

    var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);

    if (v1 !== v2) {
      return false;
    }
  }

  return true;
};

var assign = function assign(M, n, nodes, cy) {
  var clusters = [];

  for (var i = 0; i < n; i++) {
    var cluster = [];

    for (var j = 0; j < n; j++) {
      // Row-wise attractors and elements that they attract belong in same cluster
      if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {
        cluster.push(nodes[j]);
      }
    }

    if (cluster.length !== 0) {
      clusters.push(cy.collection(cluster));
    }
  }

  return clusters;
};

var isDuplicate = function isDuplicate(c1, c2) {
  for (var i = 0; i < c1.length; i++) {
    if (!c2[i] || c1[i].id() !== c2[i].id()) {
      return false;
    }
  }

  return true;
};

var removeDuplicates = function removeDuplicates(clusters) {
  for (var i = 0; i < clusters.length; i++) {
    for (var j = 0; j < clusters.length; j++) {
      if (i != j && isDuplicate(clusters[i], clusters[j])) {
        clusters.splice(j, 1);
      }
    }
  }

  return clusters;
};

var markovClustering = function markovClustering(options) {
  var nodes = this.nodes();
  var edges = this.edges();
  var cy = this.cy(); // Set parameters of algorithm:

  var opts = setOptions(options); // Map each node to its position in node array

  var id2position = {};

  for (var i = 0; i < nodes.length; i++) {
    id2position[nodes[i].id()] = i;
  } // Generate stochastic matrix M from input graph G (should be symmetric/undirected)


  var n = nodes.length,
      n2 = n * n;

  var M = new Array(n2),
      _M;

  for (var _i = 0; _i < n2; _i++) {
    M[_i] = 0;
  }

  for (var e = 0; e < edges.length; e++) {
    var edge = edges[e];
    var _i2 = id2position[edge.source().id()];
    var j = id2position[edge.target().id()];
    var sim = getSimilarity(edge, opts.attributes);
    M[_i2 * n + j] += sim; // G should be symmetric and undirected

    M[j * n + _i2] += sim;
  } // Begin Markov cluster algorithm
  // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal


  addLoops(M, n, opts.multFactor); // Step 2: M = normalize( M );

  normalize(M, n);
  var isStillMoving = true;
  var iterations = 0;

  while (isStillMoving && iterations < opts.maxIterations) {
    isStillMoving = false; // Step 3:

    _M = expand(M, n, opts.expandFactor); // Step 4:

    M = inflate(_M, n, opts.inflateFactor); // Step 5: check to see if ~steady state has been reached

    if (!hasConverged(M, _M, n2, 4)) {
      isStillMoving = true;
    }

    iterations++;
  } // Build clusters from matrix


  var clusters = assign(M, n, nodes, cy); // Remove duplicate clusters due to symmetry of graph and M matrix

  clusters = removeDuplicates(clusters);
  return clusters;
};

var markovClustering$1 = {
  markovClustering: markovClustering,
  mcl: markovClustering
};

// Common distance metrics for clustering algorithms

var identity = function identity(x) {
  return x;
};

var absDiff = function absDiff(p, q) {
  return Math.abs(q - p);
};

var addAbsDiff = function addAbsDiff(total, p, q) {
  return total + absDiff(p, q);
};

var addSquaredDiff = function addSquaredDiff(total, p, q) {
  return total + Math.pow(q - p, 2);
};

var sqrt = function sqrt(x) {
  return Math.sqrt(x);
};

var maxAbsDiff = function maxAbsDiff(currentMax, p, q) {
  return Math.max(currentMax, absDiff(p, q));
};

var getDistance = function getDistance(length, getP, getQ, init, visit) {
  var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity;
  var ret = init;
  var p, q;

  for (var dim = 0; dim < length; dim++) {
    p = getP(dim);
    q = getQ(dim);
    ret = visit(ret, p, q);
  }

  return post(ret);
};

var distances = {
  euclidean: function euclidean(length, getP, getQ) {
    if (length >= 2) {
      return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);
    } else {
      // for single attr case, more efficient to avoid sqrt
      return getDistance(length, getP, getQ, 0, addAbsDiff);
    }
  },
  squaredEuclidean: function squaredEuclidean(length, getP, getQ) {
    return getDistance(length, getP, getQ, 0, addSquaredDiff);
  },
  manhattan: function manhattan(length, getP, getQ) {
    return getDistance(length, getP, getQ, 0, addAbsDiff);
  },
  max: function max(length, getP, getQ) {
    return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);
  }
}; // in case the user accidentally doesn't use camel case

distances['squared-euclidean'] = distances['squaredEuclidean'];
distances['squaredeuclidean'] = distances['squaredEuclidean'];
function clusteringDistance (method, length, getP, getQ, nodeP, nodeQ) {
  var impl;

  if (fn(method)) {
    impl = method;
  } else {
    impl = distances[method] || distances.euclidean;
  }

  if (length === 0 && fn(method)) {
    return impl(nodeP, nodeQ);
  } else {
    return impl(length, getP, getQ, nodeP, nodeQ);
  }
}

var defaults$5 = defaults({
  k: 2,
  m: 2,
  sensitivityThreshold: 0.0001,
  distance: 'euclidean',
  maxIterations: 10,
  attributes: [],
  testMode: false,
  testCentroids: null
});

var setOptions$1 = function setOptions(options) {
  return defaults$5(options);
};
/* eslint-enable */


var getDist = function getDist(type, node, centroid, attributes, mode) {
  var noNodeP = mode !== 'kMedoids';
  var getP = noNodeP ? function (i) {
    return centroid[i];
  } : function (i) {
    return attributes[i](centroid);
  };

  var getQ = function getQ(i) {
    return attributes[i](node);
  };

  var nodeP = centroid;
  var nodeQ = node;
  return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);
};

var randomCentroids = function randomCentroids(nodes, k, attributes) {
  var ndim = attributes.length;
  var min = new Array(ndim);
  var max = new Array(ndim);
  var centroids = new Array(k);
  var centroid = null; // Find min, max values for each attribute dimension

  for (var i = 0; i < ndim; i++) {
    min[i] = nodes.min(attributes[i]).value;
    max[i] = nodes.max(attributes[i]).value;
  } // Build k centroids, each represented as an n-dim feature vector


  for (var c = 0; c < k; c++) {
    centroid = [];

    for (var _i = 0; _i < ndim; _i++) {
      centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value
    }

    centroids[c] = centroid;
  }

  return centroids;
};

var classify = function classify(node, centroids, distance, attributes, type) {
  var min = Infinity;
  var index = 0;

  for (var i = 0; i < centroids.length; i++) {
    var dist = getDist(distance, node, centroids[i], attributes, type);

    if (dist < min) {
      min = dist;
      index = i;
    }
  }

  return index;
};

var buildCluster = function buildCluster(centroid, nodes, assignment) {
  var cluster = [];
  var node = null;

  for (var n = 0; n < nodes.length; n++) {
    node = nodes[n];

    if (assignment[node.id()] === centroid) {
      //console.log("Node " + node.id() + " is associated with medoid #: " + m);
      cluster.push(node);
    }
  }

  return cluster;
};

var haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {
  return Math.abs(v2 - v1) <= sensitivityThreshold;
};

var haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {
  for (var i = 0; i < v1.length; i++) {
    for (var j = 0; j < v1[i].length; j++) {
      var diff = Math.abs(v1[i][j] - v2[i][j]);

      if (diff > sensitivityThreshold) {
        return false;
      }
    }
  }

  return true;
};

var seenBefore = function seenBefore(node, medoids, n) {
  for (var i = 0; i < n; i++) {
    if (node === medoids[i]) return true;
  }

  return false;
};

var randomMedoids = function randomMedoids(nodes, k) {
  var medoids = new Array(k); // For small data sets, the probability of medoid conflict is greater,
  // so we need to check to see if we've already seen or chose this node before.

  if (nodes.length < 50) {
    // Randomly select k medoids from the n nodes
    for (var i = 0; i < k; i++) {
      var node = nodes[Math.floor(Math.random() * nodes.length)]; // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).
      // Instead choose a different random node.

      while (seenBefore(node, medoids, i)) {
        node = nodes[Math.floor(Math.random() * nodes.length)];
      }

      medoids[i] = node;
    }
  } else {
    // Relatively large data set, so pretty safe to not check and just select random nodes
    for (var _i2 = 0; _i2 < k; _i2++) {
      medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];
    }
  }

  return medoids;
};

var findCost = function findCost(potentialNewMedoid, cluster, attributes) {
  var cost = 0;

  for (var n = 0; n < cluster.length; n++) {
    cost += getDist('manhattan', cluster[n], potentialNewMedoid, attributes, 'kMedoids');
  }

  return cost;
};

var kMeans = function kMeans(options) {
  var cy = this.cy();
  var nodes = this.nodes();
  var node = null; // Set parameters of algorithm: # of clusters, distance metric, etc.

  var opts = setOptions$1(options); // Begin k-means algorithm

  var clusters = new Array(opts.k);
  var assignment = {};
  var centroids; // Step 1: Initialize centroid positions

  if (opts.testMode) {
    if (typeof opts.testCentroids === 'number') {
      centroids = randomCentroids(nodes, opts.k, opts.attributes);
    } else if (_typeof(opts.testCentroids) === 'object') {
      centroids = opts.testCentroids;
    } else {
      centroids = randomCentroids(nodes, opts.k, opts.attributes);
    }
  } else {
    centroids = randomCentroids(nodes, opts.k, opts.attributes);
  }

  var isStillMoving = true;
  var iterations = 0;

  while (isStillMoving && iterations < opts.maxIterations) {
    // Step 2: Assign nodes to the nearest centroid
    for (var n = 0; n < nodes.length; n++) {
      node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #

      assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, 'kMeans');
    } // Step 3: For each of the k clusters, update its centroid


    isStillMoving = false;

    for (var c = 0; c < opts.k; c++) {
      // Get all nodes that belong to this cluster
      var cluster = buildCluster(c, nodes, assignment);

      if (cluster.length === 0) {
        // If cluster is empty, break out early & move to next cluster
        continue;
      } // Update centroids by calculating avg of all nodes within the cluster.


      var ndim = opts.attributes.length;
      var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]

      var newCentroid = new Array(ndim);
      var sum = new Array(ndim);

      for (var d = 0; d < ndim; d++) {
        sum[d] = 0.0;

        for (var i = 0; i < cluster.length; i++) {
          node = cluster[i];
          sum[d] += opts.attributes[d](node);
        }

        newCentroid[d] = sum[d] / cluster.length; // Check to see if algorithm has converged, i.e. when centroids no longer change

        if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {
          isStillMoving = true;
        }
      }

      centroids[c] = newCentroid;
      clusters[c] = cy.collection(cluster);
    }

    iterations++;
  }

  return clusters;
};

var kMedoids = function kMedoids(options) {
  var cy = this.cy();
  var nodes = this.nodes();
  var node = null;
  var opts = setOptions$1(options); // Begin k-medoids algorithm

  var clusters = new Array(opts.k);
  var medoids;
  var assignment = {};
  var curCost;
  var minCosts = new Array(opts.k); // minimum cost configuration for each cluster
  // Step 1: Initialize k medoids

  if (opts.testMode) {
    if (typeof opts.testCentroids === 'number') ; else if (_typeof(opts.testCentroids) === 'object') {
      medoids = opts.testCentroids;
    } else {
      medoids = randomMedoids(nodes, opts.k);
    }
  } else {
    medoids = randomMedoids(nodes, opts.k);
  }

  var isStillMoving = true;
  var iterations = 0;

  while (isStillMoving && iterations < opts.maxIterations) {
    // Step 2: Assign nodes to the nearest medoid
    for (var n = 0; n < nodes.length; n++) {
      node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #

      assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, 'kMedoids');
    }

    isStillMoving = false; // Step 3: For each medoid m, and for each node assciated with mediod m,
    // select the node with the lowest configuration cost as new medoid.

    for (var m = 0; m < medoids.length; m++) {
      // Get all nodes that belong to this medoid
      var cluster = buildCluster(m, nodes, assignment);

      if (cluster.length === 0) {
        // If cluster is empty, break out early & move to next cluster
        continue;
      }

      minCosts[m] = findCost(medoids[m], cluster, opts.attributes); // original cost
      // Select different medoid if its configuration has the lowest cost

      for (var _n = 0; _n < cluster.length; _n++) {
        curCost = findCost(cluster[_n], cluster, opts.attributes);

        if (curCost < minCosts[m]) {
          minCosts[m] = curCost;
          medoids[m] = cluster[_n];
          isStillMoving = true;
        }
      }

      clusters[m] = cy.collection(cluster);
    }

    iterations++;
  }

  return clusters;
};

var updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {
  var numerator, denominator;

  for (var n = 0; n < nodes.length; n++) {
    for (var c = 0; c < centroids.length; c++) {
      weight[n][c] = Math.pow(U[n][c], opts.m);
    }
  }

  for (var _c = 0; _c < centroids.length; _c++) {
    for (var dim = 0; dim < opts.attributes.length; dim++) {
      numerator = 0;
      denominator = 0;

      for (var _n2 = 0; _n2 < nodes.length; _n2++) {
        numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);
        denominator += weight[_n2][_c];
      }

      centroids[_c][dim] = numerator / denominator;
    }
  }
};

var updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {
  // Save previous step
  for (var i = 0; i < U.length; i++) {
    _U[i] = U[i].slice();
  }

  var sum, numerator, denominator;
  var pow = 2 / (opts.m - 1);

  for (var c = 0; c < centroids.length; c++) {
    for (var n = 0; n < nodes.length; n++) {
      sum = 0;

      for (var k = 0; k < centroids.length; k++) {
        // against all other centroids
        numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, 'cmeans');
        denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, 'cmeans');
        sum += Math.pow(numerator / denominator, pow);
      }

      U[n][c] = 1 / sum;
    }
  }
};

var assign$1 = function assign(nodes, U, opts, cy) {
  var clusters = new Array(opts.k);

  for (var c = 0; c < clusters.length; c++) {
    clusters[c] = [];
  }

  var max;
  var index;

  for (var n = 0; n < U.length; n++) {
    // for each node (U is N x C matrix)
    max = -Infinity;
    index = -1; // Determine which cluster the node is most likely to belong in

    for (var _c2 = 0; _c2 < U[0].length; _c2++) {
      if (U[n][_c2] > max) {
        max = U[n][_c2];
        index = _c2;
      }
    }

    clusters[index].push(nodes[n]);
  } // Turn every array into a collection of nodes


  for (var _c3 = 0; _c3 < clusters.length; _c3++) {
    clusters[_c3] = cy.collection(clusters[_c3]);
  }

  return clusters;
};

var fuzzyCMeans = function fuzzyCMeans(options) {
  var cy = this.cy();
  var nodes = this.nodes();
  var opts = setOptions$1(options); // Begin fuzzy c-means algorithm

  var clusters;
  var centroids;
  var U;

  var _U;

  var weight; // Step 1: Initialize letiables.

  _U = new Array(nodes.length);

  for (var i = 0; i < nodes.length; i++) {
    // N x C matrix
    _U[i] = new Array(opts.k);
  }

  U = new Array(nodes.length);

  for (var _i3 = 0; _i3 < nodes.length; _i3++) {
    // N x C matrix
    U[_i3] = new Array(opts.k);
  }

  for (var _i4 = 0; _i4 < nodes.length; _i4++) {
    var total = 0;

    for (var j = 0; j < opts.k; j++) {
      U[_i4][j] = Math.random();
      total += U[_i4][j];
    }

    for (var _j = 0; _j < opts.k; _j++) {
      U[_i4][_j] = U[_i4][_j] / total;
    }
  }

  centroids = new Array(opts.k);

  for (var _i5 = 0; _i5 < opts.k; _i5++) {
    centroids[_i5] = new Array(opts.attributes.length);
  }

  weight = new Array(nodes.length);

  for (var _i6 = 0; _i6 < nodes.length; _i6++) {
    // N x C matrix
    weight[_i6] = new Array(opts.k);
  } // end init FCM


  var isStillMoving = true;
  var iterations = 0;

  while (isStillMoving && iterations < opts.maxIterations) {
    isStillMoving = false; // Step 2: Calculate the centroids for each step.

    updateCentroids(centroids, nodes, U, weight, opts); // Step 3: Update the partition matrix U.

    updateMembership(U, _U, centroids, nodes, opts); // Step 4: Check for convergence.

    if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {
      isStillMoving = true;
    }

    iterations++;
  } // Assign nodes to clusters with highest probability.


  clusters = assign$1(nodes, U, opts, cy);
  return {
    clusters: clusters,
    degreeOfMembership: U
  };
};

var kClustering = {
  kMeans: kMeans,
  kMedoids: kMedoids,
  fuzzyCMeans: fuzzyCMeans,
  fcm: fuzzyCMeans
};

// Implemented by Zoe Xi @zoexi for GSOC 2016
var defaults$6 = defaults({
  distance: 'euclidean',
  // distance metric to compare nodes
  linkage: 'min',
  // linkage criterion : how to determine the distance between clusters of nodes
  mode: 'threshold',
  // mode:'threshold' => clusters must be threshold distance apart
  threshold: Infinity,
  // the distance threshold
  // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters
  addDendrogram: false,
  // whether to add the dendrogram to the graph for viz
  dendrogramDepth: 0,
  // depth at which dendrogram branches are merged into the returned clusters
  attributes: [] // array of attr functions

});
var linkageAliases = {
  'single': 'min',
  'complete': 'max'
};

var setOptions$2 = function setOptions(options) {
  var opts = defaults$6(options);
  var preferredAlias = linkageAliases[opts.linkage];

  if (preferredAlias != null) {
    opts.linkage = preferredAlias;
  }

  return opts;
};

var mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {
  // Find two closest clusters from cached mins
  var minKey = 0;
  var min = Infinity;
  var dist;
  var attrs = opts.attributes;

  var getDist = function getDist(n1, n2) {
    return clusteringDistance(opts.distance, attrs.length, function (i) {
      return attrs[i](n1);
    }, function (i) {
      return attrs[i](n2);
    }, n1, n2);
  };

  for (var i = 0; i < clusters.length; i++) {
    var key = clusters[i].key;
    var _dist = dists[key][mins[key]];

    if (_dist < min) {
      minKey = key;
      min = _dist;
    }
  }

  if (opts.mode === 'threshold' && min >= opts.threshold || opts.mode === 'dendrogram' && clusters.length === 1) {
    return false;
  }

  var c1 = index[minKey];
  var c2 = index[mins[minKey]];
  var merged; // Merge two closest clusters

  if (opts.mode === 'dendrogram') {
    merged = {
      left: c1,
      right: c2,
      key: c1.key
    };
  } else {
    merged = {
      value: c1.value.concat(c2.value),
      key: c1.key
    };
  }

  clusters[c1.index] = merged;
  clusters.splice(c2.index, 1);
  index[c1.key] = merged; // Update distances with new merged cluster

  for (var _i = 0; _i < clusters.length; _i++) {
    var cur = clusters[_i];

    if (c1.key === cur.key) {
      dist = Infinity;
    } else if (opts.linkage === 'min') {
      dist = dists[c1.key][cur.key];

      if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {
        dist = dists[c2.key][cur.key];
      }
    } else if (opts.linkage === 'max') {
      dist = dists[c1.key][cur.key];

      if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {
        dist = dists[c2.key][cur.key];
      }
    } else if (opts.linkage === 'mean') {
      dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);
    } else {
      if (opts.mode === 'dendrogram') dist = getDist(cur.value, c1.value);else dist = getDist(cur.value[0], c1.value[0]);
    }

    dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric
  } // Update cached mins


  for (var _i2 = 0; _i2 < clusters.length; _i2++) {
    var key1 = clusters[_i2].key;

    if (mins[key1] === c1.key || mins[key1] === c2.key) {
      var _min = key1;

      for (var j = 0; j < clusters.length; j++) {
        var key2 = clusters[j].key;

        if (dists[key1][key2] < dists[key1][_min]) {
          _min = key2;
        }
      }

      mins[key1] = _min;
    }

    clusters[_i2].index = _i2;
  } // Clean up meta data used for clustering


  c1.key = c2.key = c1.index = c2.index = null;
  return true;
};

var getAllChildren = function getAllChildren(root, arr, cy) {
  if (!root) return;

  if (root.value) {
    arr.push(root.value);
  } else {
    if (root.left) getAllChildren(root.left, arr);
    if (root.right) getAllChildren(root.right, arr);
  }
};

var buildDendrogram = function buildDendrogram(root, cy) {
  if (!root) return '';

  if (root.left && root.right) {
    var leftStr = buildDendrogram(root.left, cy);
    var rightStr = buildDendrogram(root.right, cy);
    var node = cy.add({
      group: 'nodes',
      data: {
        id: leftStr + ',' + rightStr
      }
    });
    cy.add({
      group: 'edges',
      data: {
        source: leftStr,
        target: node.id()
      }
    });
    cy.add({
      group: 'edges',
      data: {
        source: rightStr,
        target: node.id()
      }
    });
    return node.id();
  } else if (root.value) {
    return root.value.id();
  }
};

var buildClustersFromTree = function buildClustersFromTree(root, k, cy) {
  if (!root) return [];
  var left = [],
      right = [],
      leaves = [];

  if (k === 0) {
    // don't cut tree, simply return all nodes as 1 single cluster
    if (root.left) getAllChildren(root.left, left);
    if (root.right) getAllChildren(root.right, right);
    leaves = left.concat(right);
    return [cy.collection(leaves)];
  } else if (k === 1) {
    // cut at root
    if (root.value) {
      // leaf node
      return [cy.collection(root.value)];
    } else {
      if (root.left) getAllChildren(root.left, left);
      if (root.right) getAllChildren(root.right, right);
      return [cy.collection(left), cy.collection(right)];
    }
  } else {
    if (root.value) {
      return [cy.collection(root.value)];
    } else {
      if (root.left) left = buildClustersFromTree(root.left, k - 1, cy);
      if (root.right) right = buildClustersFromTree(root.right, k - 1, cy);
      return left.concat(right);
    }
  }
};
/* eslint-enable */


var hierarchicalClustering = function hierarchicalClustering(options) {
  var cy = this.cy();
  var nodes = this.nodes(); // Set parameters of algorithm: linkage type, distance metric, etc.

  var opts = setOptions$2(options);
  var attrs = opts.attributes;

  var getDist = function getDist(n1, n2) {
    return clusteringDistance(opts.distance, attrs.length, function (i) {
      return attrs[i](n1);
    }, function (i) {
      return attrs[i](n2);
    }, n1, n2);
  }; // Begin hierarchical algorithm


  var clusters = [];
  var dists = []; // distances between each pair of clusters

  var mins = []; // closest cluster for each cluster

  var index = []; // hash of all clusters by key
  // In agglomerative (bottom-up) clustering, each node starts as its own cluster

  for (var n = 0; n < nodes.length; n++) {
    var cluster = {
      value: opts.mode === 'dendrogram' ? nodes[n] : [nodes[n]],
      key: n,
      index: n
    };
    clusters[n] = cluster;
    index[n] = cluster;
    dists[n] = [];
    mins[n] = 0;
  } // Calculate the distance between each pair of clusters


  for (var i = 0; i < clusters.length; i++) {
    for (var j = 0; j <= i; j++) {
      var dist = void 0;

      if (opts.mode === 'dendrogram') {
        // modes store cluster values differently
        dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);
      } else {
        dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);
      }

      dists[i][j] = dist;
      dists[j][i] = dist;

      if (dist < dists[i][mins[i]]) {
        mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j
      }
    }
  } // Find the closest pair of clusters and merge them into a single cluster.
  // Update distances between new cluster and each of the old clusters, and loop until threshold reached.


  var merged = mergeClosest(clusters, index, dists, mins, opts);

  while (merged) {
    merged = mergeClosest(clusters, index, dists, mins, opts);
  }

  var retClusters; // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges
  // in addition to returning the clusters.

  if (opts.mode === 'dendrogram') {
    retClusters = buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);
    if (opts.addDendrogram) buildDendrogram(clusters[0], cy);
  } else {
    // Regular mode simply returns the clusters
    retClusters = new Array(clusters.length);
    clusters.forEach(function (cluster, i) {
      // Clean up meta data used for clustering
      cluster.key = cluster.index = null;
      retClusters[i] = cy.collection(cluster.value);
    });
  }

  return retClusters;
};

var hierarchicalClustering$1 = {
  hierarchicalClustering: hierarchicalClustering,
  hca: hierarchicalClustering
};

// Implemented by Zoe Xi @zoexi for GSOC 2016
var defaults$7 = defaults({
  distance: 'euclidean',
  // distance metric to compare attributes between two nodes
  preference: 'median',
  // suitability of a data point to serve as an exemplar
  damping: 0.8,
  // damping factor between [0.5, 1)
  maxIterations: 1000,
  // max number of iterations to run
  minIterations: 100,
  // min number of iterations to run in order for clustering to stop
  attributes: [// functions to quantify the similarity between any two points
    // e.g. node => node.data('weight')
  ]
});

var setOptions$3 = function setOptions(options) {
  var dmp = options.damping;
  var pref = options.preference;

  if (!(0.5 <= dmp && dmp < 1)) {
    error("Damping must range on [0.5, 1).  Got: ".concat(dmp));
  }

  var validPrefs = ['median', 'mean', 'min', 'max'];

  if (!(validPrefs.some(function (v) {
    return v === pref;
  }) || number(pref))) {
    error("Preference must be one of [".concat(validPrefs.map(function (p) {
      return "'".concat(p, "'");
    }).join(', '), "] or a number.  Got: ").concat(pref));
  }

  return defaults$7(options);
};
/* eslint-enable */


var getSimilarity$1 = function getSimilarity(type, n1, n2, attributes) {
  var attr = function attr(n, i) {
    return attributes[i](n);
  }; // nb negative because similarity should have an inverse relationship to distance


  return -clusteringDistance(type, attributes.length, function (i) {
    return attr(n1, i);
  }, function (i) {
    return attr(n2, i);
  }, n1, n2);
};

var getPreference = function getPreference(S, preference) {
  // larger preference = greater # of clusters
  var p = null;

  if (preference === 'median') {
    p = median(S);
  } else if (preference === 'mean') {
    p = mean(S);
  } else if (preference === 'min') {
    p = min(S);
  } else if (preference === 'max') {
    p = max(S);
  } else {
    // Custom preference number, as set by user
    p = preference;
  }

  return p;
};

var findExemplars = function findExemplars(n, R, A) {
  var indices = [];

  for (var i = 0; i < n; i++) {
    if (R[i * n + i] + A[i * n + i] > 0) {
      indices.push(i);
    }
  }

  return indices;
};

var assignClusters = function assignClusters(n, S, exemplars) {
  var clusters = [];

  for (var i = 0; i < n; i++) {
    var index = -1;
    var max = -Infinity;

    for (var ei = 0; ei < exemplars.length; ei++) {
      var e = exemplars[ei];

      if (S[i * n + e] > max) {
        index = e;
        max = S[i * n + e];
      }
    }

    if (index > 0) {
      clusters.push(index);
    }
  }

  for (var _ei = 0; _ei < exemplars.length; _ei++) {
    clusters[exemplars[_ei]] = exemplars[_ei];
  }

  return clusters;
};

var assign$2 = function assign(n, S, exemplars) {
  var clusters = assignClusters(n, S, exemplars);

  for (var ei = 0; ei < exemplars.length; ei++) {
    var ii = [];

    for (var c = 0; c < clusters.length; c++) {
      if (clusters[c] === exemplars[ei]) {
        ii.push(c);
      }
    }

    var maxI = -1;
    var maxSum = -Infinity;

    for (var i = 0; i < ii.length; i++) {
      var sum = 0;

      for (var j = 0; j < ii.length; j++) {
        sum += S[ii[j] * n + ii[i]];
      }

      if (sum > maxSum) {
        maxI = i;
        maxSum = sum;
      }
    }

    exemplars[ei] = ii[maxI];
  }

  clusters = assignClusters(n, S, exemplars);
  return clusters;
};

var affinityPropagation = function affinityPropagation(options) {
  var cy = this.cy();
  var nodes = this.nodes();
  var opts = setOptions$3(options); // Map each node to its position in node array

  var id2position = {};

  for (var i = 0; i < nodes.length; i++) {
    id2position[nodes[i].id()] = i;
  } // Begin affinity propagation algorithm


  var n; // number of data points

  var n2; // size of matrices

  var S; // similarity matrix (1D array)

  var p; // preference/suitability of a data point to serve as an exemplar

  var R; // responsibility matrix (1D array)

  var A; // availability matrix (1D array)

  n = nodes.length;
  n2 = n * n; // Initialize and build S similarity matrix

  S = new Array(n2);

  for (var _i = 0; _i < n2; _i++) {
    S[_i] = -Infinity; // for cases where two data points shouldn't be linked together
  }

  for (var _i2 = 0; _i2 < n; _i2++) {
    for (var j = 0; j < n; j++) {
      if (_i2 !== j) {
        S[_i2 * n + j] = getSimilarity$1(opts.distance, nodes[_i2], nodes[j], opts.attributes);
      }
    }
  } // Place preferences on the diagonal of S


  p = getPreference(S, opts.preference);

  for (var _i3 = 0; _i3 < n; _i3++) {
    S[_i3 * n + _i3] = p;
  } // Initialize R responsibility matrix


  R = new Array(n2);

  for (var _i4 = 0; _i4 < n2; _i4++) {
    R[_i4] = 0.0;
  } // Initialize A availability matrix


  A = new Array(n2);

  for (var _i5 = 0; _i5 < n2; _i5++) {
    A[_i5] = 0.0;
  }

  var old = new Array(n);
  var Rp = new Array(n);
  var se = new Array(n);

  for (var _i6 = 0; _i6 < n; _i6++) {
    old[_i6] = 0.0;
    Rp[_i6] = 0.0;
    se[_i6] = 0;
  }

  var e = new Array(n * opts.minIterations);

  for (var _i7 = 0; _i7 < e.length; _i7++) {
    e[_i7] = 0;
  }

  var iter;

  for (iter = 0; iter < opts.maxIterations; iter++) {
    // main algorithmic loop
    // Update R responsibility matrix
    for (var _i8 = 0; _i8 < n; _i8++) {
      var max = -Infinity,
          max2 = -Infinity,
          maxI = -1,
          AS = 0.0;

      for (var _j = 0; _j < n; _j++) {
        old[_j] = R[_i8 * n + _j];
        AS = A[_i8 * n + _j] + S[_i8 * n + _j];

        if (AS >= max) {
          max2 = max;
          max = AS;
          maxI = _j;
        } else if (AS > max2) {
          max2 = AS;
        }
      }

      for (var _j2 = 0; _j2 < n; _j2++) {
        R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];
      }

      R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];
    } // Update A availability matrix


    for (var _i9 = 0; _i9 < n; _i9++) {
      var sum = 0;

      for (var _j3 = 0; _j3 < n; _j3++) {
        old[_j3] = A[_j3 * n + _i9];
        Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);
        sum += Rp[_j3];
      }

      sum -= Rp[_i9];
      Rp[_i9] = R[_i9 * n + _i9];
      sum += Rp[_i9];

      for (var _j4 = 0; _j4 < n; _j4++) {
        A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];
      }

      A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];
    } // Check for convergence


    var K = 0;

    for (var _i10 = 0; _i10 < n; _i10++) {
      var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;
      e[iter % opts.minIterations * n + _i10] = E;
      K += E;
    }

    if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {
      var _sum = 0;

      for (var _i11 = 0; _i11 < n; _i11++) {
        se[_i11] = 0;

        for (var _j5 = 0; _j5 < opts.minIterations; _j5++) {
          se[_i11] += e[_j5 * n + _i11];
        }

        if (se[_i11] === 0 || se[_i11] === opts.minIterations) {
          _sum++;
        }
      }

      if (_sum === n) {
        // then we have convergence
        break;
      }
    }
  } // Identify exemplars (cluster centers)


  var exemplarsIndices = findExemplars(n, R, A); // Assign nodes to clusters

  var clusterIndices = assign$2(n, S, exemplarsIndices);
  var clusters = {};

  for (var c = 0; c < exemplarsIndices.length; c++) {
    clusters[exemplarsIndices[c]] = [];
  }

  for (var _i12 = 0; _i12 < nodes.length; _i12++) {
    var pos = id2position[nodes[_i12].id()];

    var clusterIndex = clusterIndices[pos];

    if (clusterIndex != null) {
      // the node may have not been assigned a cluster if no valid attributes were specified
      clusters[clusterIndex].push(nodes[_i12]);
    }
  }

  var retClusters = new Array(exemplarsIndices.length);

  for (var _c = 0; _c < exemplarsIndices.length; _c++) {
    retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);
  }

  return retClusters;
};

var affinityPropagation$1 = {
  affinityPropagation: affinityPropagation,
  ap: affinityPropagation
};

var hierholzerDefaults = defaults({
  root: undefined,
  directed: false
});
var elesfn$b = {
  hierholzer: function hierholzer(options) {
    if (!plainObject(options)) {
      var args = arguments;
      options = {
        root: args[0],
        directed: args[1]
      };
    }

    var _hierholzerDefaults = hierholzerDefaults(options),
        root = _hierholzerDefaults.root,
        directed = _hierholzerDefaults.directed;

    var eles = this;
    var dflag = false;
    var oddIn;
    var oddOut;
    var startVertex;
    if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();
    var nodes = {};
    var edges = {};

    if (directed) {
      eles.forEach(function (ele) {
        var id = ele.id();

        if (ele.isNode()) {
          var ind = ele.indegree(true);
          var outd = ele.outdegree(true);
          var d1 = ind - outd;
          var d2 = outd - ind;

          if (d1 == 1) {
            if (oddIn) dflag = true;else oddIn = id;
          } else if (d2 == 1) {
            if (oddOut) dflag = true;else oddOut = id;
          } else if (d2 > 1 || d1 > 1) {
            dflag = true;
          }

          nodes[id] = [];
          ele.outgoers().forEach(function (e) {
            if (e.isEdge()) nodes[id].push(e.id());
          });
        } else {
          edges[id] = [undefined, ele.target().id()];
        }
      });
    } else {
      eles.forEach(function (ele) {
        var id = ele.id();

        if (ele.isNode()) {
          var d = ele.degree(true);

          if (d % 2) {
            if (!oddIn) oddIn = id;else if (!oddOut) oddOut = id;else dflag = true;
          }

          nodes[id] = [];
          ele.connectedEdges().forEach(function (e) {
            return nodes[id].push(e.id());
          });
        } else {
          edges[id] = [ele.source().id(), ele.target().id()];
        }
      });
    }

    var result = {
      found: false,
      trail: undefined
    };
    if (dflag) return result;else if (oddOut && oddIn) {
      if (directed) {
        if (startVertex && oddOut != startVertex) {
          return result;
        }

        startVertex = oddOut;
      } else {
        if (startVertex && oddOut != startVertex && oddIn != startVertex) {
          return result;
        } else if (!startVertex) {
          startVertex = oddOut;
        }
      }
    } else {
      if (!startVertex) startVertex = eles[0].id();
    }

    var walk = function walk(v) {
      var currentNode = v;
      var subtour = [v];
      var adj, adjTail, adjHead;

      while (nodes[currentNode].length) {
        adj = nodes[currentNode].shift();
        adjTail = edges[adj][0];
        adjHead = edges[adj][1];

        if (currentNode != adjHead) {
          nodes[adjHead] = nodes[adjHead].filter(function (e) {
            return e != adj;
          });
          currentNode = adjHead;
        } else if (!directed && currentNode != adjTail) {
          nodes[adjTail] = nodes[adjTail].filter(function (e) {
            return e != adj;
          });
          currentNode = adjTail;
        }

        subtour.unshift(adj);
        subtour.unshift(currentNode);
      }

      return subtour;
    };

    var trail = [];
    var subtour = [];
    subtour = walk(startVertex);

    while (subtour.length != 1) {
      if (nodes[subtour[0]].length == 0) {
        trail.unshift(eles.getElementById(subtour.shift()));
        trail.unshift(eles.getElementById(subtour.shift()));
      } else {
        subtour = walk(subtour.shift()).concat(subtour);
      }
    }

    trail.unshift(eles.getElementById(subtour.shift())); // final node

    for (var d in nodes) {
      if (nodes[d].length) {
        return result;
      }
    }

    result.found = true;
    result.trail = this.spawn(trail);
    return result;
  }
};

var elesfn$c = {};
[elesfn, elesfn$1, elesfn$2, elesfn$3, elesfn$4, elesfn$5, elesfn$6, elesfn$7, elesfn$8, elesfn$9, elesfn$a, markovClustering$1, kClustering, hierarchicalClustering$1, affinityPropagation$1, elesfn$b].forEach(function (props) {
  extend(elesfn$c, props);
});

/*!
Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)
Licensed under The MIT License (http://opensource.org/licenses/MIT)
*/

/*  promise states [Promises/A+ 2.1]  */
var STATE_PENDING = 0;
/*  [Promises/A+ 2.1.1]  */

var STATE_FULFILLED = 1;
/*  [Promises/A+ 2.1.2]  */

var STATE_REJECTED = 2;
/*  [Promises/A+ 2.1.3]  */

/*  promise object constructor  */

var api = function api(executor) {
  /*  optionally support non-constructor/plain-function call  */
  if (!(this instanceof api)) return new api(executor);
  /*  initialize object  */

  this.id = 'Thenable/1.0.7';
  this.state = STATE_PENDING;
  /*  initial state  */

  this.fulfillValue = undefined;
  /*  initial value  */

  /*  [Promises/A+ 1.3, 2.1.2.2]  */

  this.rejectReason = undefined;
  /*  initial reason */

  /*  [Promises/A+ 1.5, 2.1.3.2]  */

  this.onFulfilled = [];
  /*  initial handlers  */

  this.onRejected = [];
  /*  initial handlers  */

  /*  provide optional information-hiding proxy  */

  this.proxy = {
    then: this.then.bind(this)
  };
  /*  support optional executor function  */

  if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
};
/*  promise API methods  */


api.prototype = {
  /*  promise resolving methods  */
  fulfill: function fulfill(value) {
    return deliver(this, STATE_FULFILLED, 'fulfillValue', value);
  },
  reject: function reject(value) {
    return deliver(this, STATE_REJECTED, 'rejectReason', value);
  },

  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function then(onFulfilled, onRejected) {
    var curr = this;
    var next = new api();
    /*  [Promises/A+ 2.2.7]  */

    curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill'));
    /*  [Promises/A+ 2.2.2/2.2.6]  */

    curr.onRejected.push(resolver(onRejected, next, 'reject'));
    /*  [Promises/A+ 2.2.3/2.2.6]  */

    execute(curr);
    return next.proxy;
    /*  [Promises/A+ 2.2.7, 3.3]  */
  }
};
/*  deliver an action  */

var deliver = function deliver(curr, state, name, value) {
  if (curr.state === STATE_PENDING) {
    curr.state = state;
    /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */

    curr[name] = value;
    /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */

    execute(curr);
  }

  return curr;
};
/*  execute all handlers  */


var execute = function execute(curr) {
  if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);
};
/*  execute particular set of handlers  */


var execute_handlers = function execute_handlers(curr, name, value) {
  /* global setImmediate: true */

  /* global setTimeout: true */

  /*  short-circuit processing  */
  if (curr[name].length === 0) return;
  /*  iterate over all handlers, exactly once  */

  var handlers = curr[name];
  curr[name] = [];
  /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */

  var func = function func() {
    for (var i = 0; i < handlers.length; i++) {
      handlers[i](value);
    }
    /*  [Promises/A+ 2.2.5]  */

  };
  /*  execute procedure asynchronously  */

  /*  [Promises/A+ 2.2.4, 3.1]  */


  if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);
};
/*  generate a resolver function  */


var resolver = function resolver(cb, next, method) {
  return function (value) {
    if (typeof cb !== 'function')
      /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
      next[method].call(next, value);
      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
    else {
        var result;

        try {
          result = cb(value);
        }
        /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
        catch (e) {
          next.reject(e);
          /*  [Promises/A+ 2.2.7.2]  */

          return;
        }

        resolve(next, result);
        /*  [Promises/A+ 2.2.7.1]  */
      }
  };
};
/*  "Promise Resolution Procedure"  */

/*  [Promises/A+ 2.3]  */


var resolve = function resolve(promise, x) {
  /*  sanity check arguments  */

  /*  [Promises/A+ 2.3.1]  */
  if (promise === x || promise.proxy === x) {
    promise.reject(new TypeError('cannot resolve promise with itself'));
    return;
  }
  /*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */


  var then;

  if (_typeof(x) === 'object' && x !== null || typeof x === 'function') {
    try {
      then = x.then;
    }
    /*  [Promises/A+ 2.3.3.1, 3.5]  */
    catch (e) {
      promise.reject(e);
      /*  [Promises/A+ 2.3.3.2]  */

      return;
    }
  }
  /*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */


  if (typeof then === 'function') {
    var resolved = false;

    try {
      /*  call retrieved "then" method */

      /*  [Promises/A+ 2.3.3.3]  */
      then.call(x,
      /*  resolvePromise  */

      /*  [Promises/A+ 2.3.3.3.1]  */
      function (y) {
        if (resolved) return;
        resolved = true;
        /*  [Promises/A+ 2.3.3.3.3]  */

        if (y === x)
          /*  [Promises/A+ 3.6]  */
          promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);
      },
      /*  rejectPromise  */

      /*  [Promises/A+ 2.3.3.3.2]  */
      function (r) {
        if (resolved) return;
        resolved = true;
        /*  [Promises/A+ 2.3.3.3.3]  */

        promise.reject(r);
      });
    } catch (e) {
      if (!resolved)
        /*  [Promises/A+ 2.3.3.3.3]  */
        promise.reject(e);
      /*  [Promises/A+ 2.3.3.3.4]  */
    }

    return;
  }
  /*  handle other values  */


  promise.fulfill(x);
  /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
}; // so we always have Promise.all()


api.all = function (ps) {
  return new api(function (resolveAll, rejectAll) {
    var vals = new Array(ps.length);
    var doneCount = 0;

    var fulfill = function fulfill(i, val) {
      vals[i] = val;
      doneCount++;

      if (doneCount === ps.length) {
        resolveAll(vals);
      }
    };

    for (var i = 0; i < ps.length; i++) {
      (function (i) {
        var p = ps[i];
        var isPromise = p != null && p.then != null;

        if (isPromise) {
          p.then(function (val) {
            fulfill(i, val);
          }, function (err) {
            rejectAll(err);
          });
        } else {
          var val = p;
          fulfill(i, val);
        }
      })(i);
    }
  });
};

api.resolve = function (val) {
  return new api(function (resolve, reject) {
    resolve(val);
  });
};

api.reject = function (val) {
  return new api(function (resolve, reject) {
    reject(val);
  });
};

var Promise$1 = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef

var Animation = function Animation(target, opts, opts2) {
  var isCore = core(target);
  var isEle = !isCore;

  var _p = this._private = extend({
    duration: 1000
  }, opts, opts2);

  _p.target = target;
  _p.style = _p.style || _p.css;
  _p.started = false;
  _p.playing = false;
  _p.hooked = false;
  _p.applying = false;
  _p.progress = 0;
  _p.completes = [];
  _p.frames = [];

  if (_p.complete && fn(_p.complete)) {
    _p.completes.push(_p.complete);
  }

  if (isEle) {
    var pos = target.position();
    _p.startPosition = _p.startPosition || {
      x: pos.x,
      y: pos.y
    };
    _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);
  }

  if (isCore) {
    var pan = target.pan();
    _p.startPan = {
      x: pan.x,
      y: pan.y
    };
    _p.startZoom = target.zoom();
  } // for future timeline/animations impl


  this.length = 1;
  this[0] = this;
};

var anifn = Animation.prototype;
extend(anifn, {
  instanceString: function instanceString() {
    return 'animation';
  },
  hook: function hook() {
    var _p = this._private;

    if (!_p.hooked) {
      // add to target's animation queue
      var q;
      var tAni = _p.target._private.animation;

      if (_p.queue) {
        q = tAni.queue;
      } else {
        q = tAni.current;
      }

      q.push(this); // add to the animation loop pool

      if (elementOrCollection(_p.target)) {
        _p.target.cy().addToAnimationPool(_p.target);
      }

      _p.hooked = true;
    }

    return this;
  },
  play: function play() {
    var _p = this._private; // autorewind

    if (_p.progress === 1) {
      _p.progress = 0;
    }

    _p.playing = true;
    _p.started = false; // needs to be started by animation loop

    _p.stopped = false;
    this.hook(); // the animation loop will start the animation...

    return this;
  },
  playing: function playing() {
    return this._private.playing;
  },
  apply: function apply() {
    var _p = this._private;
    _p.applying = true;
    _p.started = false; // needs to be started by animation loop

    _p.stopped = false;
    this.hook(); // the animation loop will apply the animation at this progress

    return this;
  },
  applying: function applying() {
    return this._private.applying;
  },
  pause: function pause() {
    var _p = this._private;
    _p.playing = false;
    _p.started = false;
    return this;
  },
  stop: function stop() {
    var _p = this._private;
    _p.playing = false;
    _p.started = false;
    _p.stopped = true; // to be removed from animation queues

    return this;
  },
  rewind: function rewind() {
    return this.progress(0);
  },
  fastforward: function fastforward() {
    return this.progress(1);
  },
  time: function time(t) {
    var _p = this._private;

    if (t === undefined) {
      return _p.progress * _p.duration;
    } else {
      return this.progress(t / _p.duration);
    }
  },
  progress: function progress(p) {
    var _p = this._private;
    var wasPlaying = _p.playing;

    if (p === undefined) {
      return _p.progress;
    } else {
      if (wasPlaying) {
        this.pause();
      }

      _p.progress = p;
      _p.started = false;

      if (wasPlaying) {
        this.play();
      }
    }

    return this;
  },
  completed: function completed() {
    return this._private.progress === 1;
  },
  reverse: function reverse() {
    var _p = this._private;
    var wasPlaying = _p.playing;

    if (wasPlaying) {
      this.pause();
    }

    _p.progress = 1 - _p.progress;
    _p.started = false;

    var swap = function swap(a, b) {
      var _pa = _p[a];

      if (_pa == null) {
        return;
      }

      _p[a] = _p[b];
      _p[b] = _pa;
    };

    swap('zoom', 'startZoom');
    swap('pan', 'startPan');
    swap('position', 'startPosition'); // swap styles

    if (_p.style) {
      for (var i = 0; i < _p.style.length; i++) {
        var prop = _p.style[i];
        var name = prop.name;
        var startStyleProp = _p.startStyle[name];
        _p.startStyle[name] = prop;
        _p.style[i] = startStyleProp;
      }
    }

    if (wasPlaying) {
      this.play();
    }

    return this;
  },
  promise: function promise(type) {
    var _p = this._private;
    var arr;

    switch (type) {
      case 'frame':
        arr = _p.frames;
        break;

      default:
      case 'complete':
      case 'completed':
        arr = _p.completes;
    }

    return new Promise$1(function (resolve, reject) {
      arr.push(function () {
        resolve();
      });
    });
  }
});
anifn.complete = anifn.completed;
anifn.run = anifn.play;
anifn.running = anifn.playing;

var define = {
  animated: function animated() {
    return function animatedImpl() {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return false;
      }

      var ele = all[0];

      if (ele) {
        return ele._private.animation.current.length > 0;
      }
    };
  },
  // animated
  clearQueue: function clearQueue() {
    return function clearQueueImpl() {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        ele._private.animation.queue = [];
      }

      return this;
    };
  },
  // clearQueue
  delay: function delay() {
    return function delayImpl(time, complete) {
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      return this.animate({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  },
  // delay
  delayAnimation: function delayAnimation() {
    return function delayAnimationImpl(time, complete) {
      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      return this.animation({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  },
  // delay
  animation: function animation() {
    return function animationImpl(properties, params) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;
      var isCore = !selfIsArrayLike;
      var isEles = !isCore;

      if (!cy.styleEnabled()) {
        return this;
      }

      var style = cy.style();
      properties = extend({}, properties, params);
      var propertiesEmpty = Object.keys(properties).length === 0;

      if (propertiesEmpty) {
        return new Animation(all[0], properties); // nothing to animate
      }

      if (properties.duration === undefined) {
        properties.duration = 400;
      }

      switch (properties.duration) {
        case 'slow':
          properties.duration = 600;
          break;

        case 'fast':
          properties.duration = 200;
          break;
      }

      if (isEles) {
        properties.style = style.getPropsList(properties.style || properties.css);
        properties.css = undefined;
      }

      if (isEles && properties.renderedPosition != null) {
        var rpos = properties.renderedPosition;
        var pan = cy.pan();
        var zoom = cy.zoom();
        properties.position = renderedToModelPosition(rpos, zoom, pan);
      } // override pan w/ panBy if set


      if (isCore && properties.panBy != null) {
        var panBy = properties.panBy;
        var cyPan = cy.pan();
        properties.pan = {
          x: cyPan.x + panBy.x,
          y: cyPan.y + panBy.y
        };
      } // override pan w/ center if set


      var center = properties.center || properties.centre;

      if (isCore && center != null) {
        var centerPan = cy.getCenterPan(center.eles, properties.zoom);

        if (centerPan != null) {
          properties.pan = centerPan;
        }
      } // override pan & zoom w/ fit if set


      if (isCore && properties.fit != null) {
        var fit = properties.fit;
        var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);

        if (fitVp != null) {
          properties.pan = fitVp.pan;
          properties.zoom = fitVp.zoom;
        }
      } // override zoom (& potentially pan) w/ zoom obj if set


      if (isCore && plainObject(properties.zoom)) {
        var vp = cy.getZoomedViewport(properties.zoom);

        if (vp != null) {
          if (vp.zoomed) {
            properties.zoom = vp.zoom;
          }

          if (vp.panned) {
            properties.pan = vp.pan;
          }
        }
      }

      return new Animation(all[0], properties);
    };
  },
  // animate
  animate: function animate() {
    return function animateImpl(properties, params) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      if (params) {
        properties = extend({}, properties, params);
      } // manually hook and run the animation


      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        var queue = ele.animated() && (properties.queue === undefined || properties.queue);
        var ani = ele.animation(properties, queue ? {
          queue: true
        } : undefined);
        ani.play();
      }

      return this; // chaining
    };
  },
  // animate
  stop: function stop() {
    return function stopImpl(clearQueue, jumpToEnd) {
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var cy = this._private.cy || this;

      if (!cy.styleEnabled()) {
        return this;
      }

      for (var i = 0; i < all.length; i++) {
        var ele = all[i];
        var _p = ele._private;
        var anis = _p.animation.current;

        for (var j = 0; j < anis.length; j++) {
          var ani = anis[j];
          var ani_p = ani._private;

          if (jumpToEnd) {
            // next iteration of the animation loop, the animation
            // will go straight to the end and be removed
            ani_p.duration = 0;
          }
        } // clear the queue of future animations


        if (clearQueue) {
          _p.animation.queue = [];
        }

        if (!jumpToEnd) {
          _p.animation.current = [];
        }
      } // we have to notify (the animation loop doesn't do it for us on `stop`)


      cy.notify('draw');
      return this;
    };
  } // stop

}; // define

var define$1 = {
  // access data field
  data: function data(params) {
    var defaults = {
      field: 'data',
      bindingEvent: 'data',
      allowBinding: false,
      allowSetting: false,
      allowGetting: false,
      settingEvent: 'data',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      immutableKeys: {},
      // key => true if immutable
      updateStyle: false,
      beforeGet: function beforeGet(self) {},
      beforeSet: function beforeSet(self, obj) {},
      onSet: function onSet(self) {},
      canSet: function canSet(self) {
        return true;
      }
    };
    params = extend({}, defaults, params);
    return function dataImpl(name, value) {
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      var single = selfIsArrayLike ? self[0] : self; // .data('foo', ...)

      if (string(name)) {
        // set or get property
        // .data('foo')
        if (p.allowGetting && value === undefined) {
          // get
          var ret;

          if (single) {
            p.beforeGet(single);
            ret = single._private[p.field][name];
          }

          return ret; // .data('foo', 'bar')
        } else if (p.allowSetting && value !== undefined) {
          // set
          var valid = !p.immutableKeys[name];

          if (valid) {
            var change = _defineProperty({}, name, value);

            p.beforeSet(self, change);

            for (var i = 0, l = all.length; i < l; i++) {
              var ele = all[i];

              if (p.canSet(ele)) {
                ele._private[p.field][name] = value;
              }
            } // update mappers if asked


            if (p.updateStyle) {
              self.updateStyle();
            } // call onSet callback


            p.onSet(self);

            if (p.settingTriggersEvent) {
              self[p.triggerFnName](p.settingEvent);
            }
          }
        } // .data({ 'foo': 'bar' })

      } else if (p.allowSetting && plainObject(name)) {
        // extend
        var obj = name;
        var k, v;
        var keys = Object.keys(obj);
        p.beforeSet(self, obj);

        for (var _i = 0; _i < keys.length; _i++) {
          k = keys[_i];
          v = obj[k];

          var _valid = !p.immutableKeys[k];

          if (_valid) {
            for (var j = 0; j < all.length; j++) {
              var _ele = all[j];

              if (p.canSet(_ele)) {
                _ele._private[p.field][k] = v;
              }
            }
          }
        } // update mappers if asked


        if (p.updateStyle) {
          self.updateStyle();
        } // call onSet callback


        p.onSet(self);

        if (p.settingTriggersEvent) {
          self[p.triggerFnName](p.settingEvent);
        } // .data(function(){ ... })

      } else if (p.allowBinding && fn(name)) {
        // bind to event
        var fn$1 = name;
        self.on(p.bindingEvent, fn$1); // .data()
      } else if (p.allowGetting && name === undefined) {
        // get whole object
        var _ret;

        if (single) {
          p.beforeGet(single);
          _ret = single._private[p.field];
        }

        return _ret;
      }

      return self; // maintain chainability
    }; // function
  },
  // data
  // remove data field
  removeData: function removeData(params) {
    var defaults = {
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: false,
      immutableKeys: {} // key => true if immutable

    };
    params = extend({}, defaults, params);
    return function removeDataImpl(names) {
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      // .removeData('foo bar')

      if (string(names)) {
        // then get the list of keys, and delete them
        var keys = names.split(/\s+/);
        var l = keys.length;

        for (var i = 0; i < l; i++) {
          // delete each non-empty key
          var key = keys[i];

          if (emptyString(key)) {
            continue;
          }

          var valid = !p.immutableKeys[key]; // not valid if immutable

          if (valid) {
            for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {
              all[i_a]._private[p.field][key] = undefined;
            }
          }
        }

        if (p.triggerEvent) {
          self[p.triggerFnName](p.event);
        } // .removeData()

      } else if (names === undefined) {
        // then delete all keys
        for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {
          var _privateFields = all[_i_a]._private[p.field];

          var _keys = Object.keys(_privateFields);

          for (var _i2 = 0; _i2 < _keys.length; _i2++) {
            var _key = _keys[_i2];
            var validKeyToDelete = !p.immutableKeys[_key];

            if (validKeyToDelete) {
              _privateFields[_key] = undefined;
            }
          }
        }

        if (p.triggerEvent) {
          self[p.triggerFnName](p.event);
        }
      }

      return self; // maintain chaining
    }; // function
  } // removeData

}; // define

var define$2 = {
  eventAliasesOn: function eventAliasesOn(proto) {
    var p = proto;
    p.addListener = p.listen = p.bind = p.on;
    p.unlisten = p.unbind = p.off = p.removeListener;
    p.trigger = p.emit; // this is just a wrapper alias of .on()

    p.pon = p.promiseOn = function (events, selector) {
      var self = this;
      var args = Array.prototype.slice.call(arguments, 0);
      return new Promise$1(function (resolve, reject) {
        var callback = function callback(e) {
          self.off.apply(self, offArgs);
          resolve(e);
        };

        var onArgs = args.concat([callback]);
        var offArgs = onArgs.concat([]);
        self.on.apply(self, onArgs);
      });
    };
  }
}; // define

// use this module to cherry pick functions into your prototype
var define$3 = {};
[define, define$1, define$2].forEach(function (m) {
  extend(define$3, m);
});

var elesfn$d = {
  animate: define$3.animate(),
  animation: define$3.animation(),
  animated: define$3.animated(),
  clearQueue: define$3.clearQueue(),
  delay: define$3.delay(),
  delayAnimation: define$3.delayAnimation(),
  stop: define$3.stop()
};

var elesfn$e = {
  classes: function classes(_classes) {
    var self = this;

    if (_classes === undefined) {
      var ret = [];

      self[0]._private.classes.forEach(function (cls) {
        return ret.push(cls);
      });

      return ret;
    } else if (!array(_classes)) {
      // extract classes from string
      _classes = (_classes || '').match(/\S+/g) || [];
    }

    var changed = [];
    var classesSet = new Set$1(_classes); // check and update each ele

    for (var j = 0; j < self.length; j++) {
      var ele = self[j];
      var _p = ele._private;
      var eleClasses = _p.classes;
      var changedEle = false; // check if ele has all of the passed classes

      for (var i = 0; i < _classes.length; i++) {
        var cls = _classes[i];
        var eleHasClass = eleClasses.has(cls);

        if (!eleHasClass) {
          changedEle = true;
          break;
        }
      } // check if ele has classes outside of those passed


      if (!changedEle) {
        changedEle = eleClasses.size !== _classes.length;
      }

      if (changedEle) {
        _p.classes = classesSet;
        changed.push(ele);
      }
    } // trigger update style on those eles that had class changes


    if (changed.length > 0) {
      this.spawn(changed).updateStyle().emit('class');
    }

    return self;
  },
  addClass: function addClass(classes) {
    return this.toggleClass(classes, true);
  },
  hasClass: function hasClass(className) {
    var ele = this[0];
    return ele != null && ele._private.classes.has(className);
  },
  toggleClass: function toggleClass(classes, toggle) {
    if (!array(classes)) {
      // extract classes from string
      classes = classes.match(/\S+/g) || [];
    }

    var self = this;
    var toggleUndefd = toggle === undefined;
    var changed = []; // eles who had classes changed

    for (var i = 0, il = self.length; i < il; i++) {
      var ele = self[i];
      var eleClasses = ele._private.classes;
      var changedEle = false;

      for (var j = 0; j < classes.length; j++) {
        var cls = classes[j];
        var hasClass = eleClasses.has(cls);
        var changedNow = false;

        if (toggle || toggleUndefd && !hasClass) {
          eleClasses.add(cls);
          changedNow = true;
        } else if (!toggle || toggleUndefd && hasClass) {
          eleClasses["delete"](cls);
          changedNow = true;
        }

        if (!changedEle && changedNow) {
          changed.push(ele);
          changedEle = true;
        }
      } // for j classes

    } // for i eles
    // trigger update style on those eles that had class changes


    if (changed.length > 0) {
      this.spawn(changed).updateStyle().emit('class');
    }

    return self;
  },
  removeClass: function removeClass(classes) {
    return this.toggleClass(classes, false);
  },
  flashClass: function flashClass(classes, duration) {
    var self = this;

    if (duration == null) {
      duration = 250;
    } else if (duration === 0) {
      return self; // nothing to do really
    }

    self.addClass(classes);
    setTimeout(function () {
      self.removeClass(classes);
    }, duration);
    return self;
  }
};
elesfn$e.className = elesfn$e.classNames = elesfn$e.classes;

var tokens = {
  metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]',
  // chars we need to escape in let names, etc
  comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=',
  // binary comparison op (used in data selectors)
  boolOp: '\\?|\\!|\\^',
  // boolean (unary) operators (used in data selectors)
  string: '"(?:\\\\"|[^"])*"' + '|' + "'(?:\\\\'|[^'])*'",
  // string literals (used in data selectors) -- doublequotes | singlequotes
  number: number$1,
  // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
  meta: 'degree|indegree|outdegree',
  // allowed metadata fields (i.e. allowed functions to use from Collection)
  separator: '\\s*,\\s*',
  // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
  descendant: '\\s+',
  child: '\\s+>\\s+',
  subject: '\\$',
  group: 'node|edge|\\*',
  directedEdge: '\\s+->\\s+',
  undirectedEdge: '\\s+<->\\s+'
};
tokens.variable = '(?:[\\w-]|(?:\\\\' + tokens.metaChar + '))+'; // a variable name

tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number

tokens.className = tokens.variable; // a class name (follows variable conventions)

tokens.id = tokens.variable; // an element id (follows variable conventions)

(function () {
  var ops, op, i; // add @ variants to comparatorOp

  ops = tokens.comparatorOp.split('|');

  for (i = 0; i < ops.length; i++) {
    op = ops[i];
    tokens.comparatorOp += '|@' + op;
  } // add ! variants to comparatorOp


  ops = tokens.comparatorOp.split('|');

  for (i = 0; i < ops.length; i++) {
    op = ops[i];

    if (op.indexOf('!') >= 0) {
      continue;
    } // skip ops that explicitly contain !


    if (op === '=') {
      continue;
    } // skip = b/c != is explicitly defined


    tokens.comparatorOp += '|\\!' + op;
  }
})();

/**
 * Make a new query object
 *
 * @prop type {Type} The type enum (int) of the query
 * @prop checks List of checks to make against an ele to test for a match
 */
var newQuery = function newQuery() {
  return {
    checks: []
  };
};

/**
 * A check type enum-like object.  Uses integer values for fast match() lookup.
 * The ordering does not matter as long as the ints are unique.
 */
var Type = {
  /** E.g. node */
  GROUP: 0,

  /** A collection of elements */
  COLLECTION: 1,

  /** A filter(ele) function */
  FILTER: 2,

  /** E.g. [foo > 1] */
  DATA_COMPARE: 3,

  /** E.g. [foo] */
  DATA_EXIST: 4,

  /** E.g. [?foo] */
  DATA_BOOL: 5,

  /** E.g. [[degree > 2]] */
  META_COMPARE: 6,

  /** E.g. :selected */
  STATE: 7,

  /** E.g. #foo */
  ID: 8,

  /** E.g. .foo */
  CLASS: 9,

  /** E.g. #foo <-> #bar */
  UNDIRECTED_EDGE: 10,

  /** E.g. #foo -> #bar */
  DIRECTED_EDGE: 11,

  /** E.g. $#foo -> #bar */
  NODE_SOURCE: 12,

  /** E.g. #foo -> $#bar */
  NODE_TARGET: 13,

  /** E.g. $#foo <-> #bar */
  NODE_NEIGHBOR: 14,

  /** E.g. #foo > #bar */
  CHILD: 15,

  /** E.g. #foo #bar */
  DESCENDANT: 16,

  /** E.g. $#foo > #bar */
  PARENT: 17,

  /** E.g. $#foo #bar */
  ANCESTOR: 18,

  /** E.g. #foo > $bar > #baz */
  COMPOUND_SPLIT: 19,

  /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */
  TRUE: 20
};

var stateSelectors = [{
  selector: ':selected',
  matches: function matches(ele) {
    return ele.selected();
  }
}, {
  selector: ':unselected',
  matches: function matches(ele) {
    return !ele.selected();
  }
}, {
  selector: ':selectable',
  matches: function matches(ele) {
    return ele.selectable();
  }
}, {
  selector: ':unselectable',
  matches: function matches(ele) {
    return !ele.selectable();
  }
}, {
  selector: ':locked',
  matches: function matches(ele) {
    return ele.locked();
  }
}, {
  selector: ':unlocked',
  matches: function matches(ele) {
    return !ele.locked();
  }
}, {
  selector: ':visible',
  matches: function matches(ele) {
    return ele.visible();
  }
}, {
  selector: ':hidden',
  matches: function matches(ele) {
    return !ele.visible();
  }
}, {
  selector: ':transparent',
  matches: function matches(ele) {
    return ele.transparent();
  }
}, {
  selector: ':grabbed',
  matches: function matches(ele) {
    return ele.grabbed();
  }
}, {
  selector: ':free',
  matches: function matches(ele) {
    return !ele.grabbed();
  }
}, {
  selector: ':removed',
  matches: function matches(ele) {
    return ele.removed();
  }
}, {
  selector: ':inside',
  matches: function matches(ele) {
    return !ele.removed();
  }
}, {
  selector: ':grabbable',
  matches: function matches(ele) {
    return ele.grabbable();
  }
}, {
  selector: ':ungrabbable',
  matches: function matches(ele) {
    return !ele.grabbable();
  }
}, {
  selector: ':animated',
  matches: function matches(ele) {
    return ele.animated();
  }
}, {
  selector: ':unanimated',
  matches: function matches(ele) {
    return !ele.animated();
  }
}, {
  selector: ':parent',
  matches: function matches(ele) {
    return ele.isParent();
  }
}, {
  selector: ':childless',
  matches: function matches(ele) {
    return ele.isChildless();
  }
}, {
  selector: ':child',
  matches: function matches(ele) {
    return ele.isChild();
  }
}, {
  selector: ':orphan',
  matches: function matches(ele) {
    return ele.isOrphan();
  }
}, {
  selector: ':nonorphan',
  matches: function matches(ele) {
    return ele.isChild();
  }
}, {
  selector: ':compound',
  matches: function matches(ele) {
    if (ele.isNode()) {
      return ele.isParent();
    } else {
      return ele.source().isParent() || ele.target().isParent();
    }
  }
}, {
  selector: ':loop',
  matches: function matches(ele) {
    return ele.isLoop();
  }
}, {
  selector: ':simple',
  matches: function matches(ele) {
    return ele.isSimple();
  }
}, {
  selector: ':active',
  matches: function matches(ele) {
    return ele.active();
  }
}, {
  selector: ':inactive',
  matches: function matches(ele) {
    return !ele.active();
  }
}, {
  selector: ':backgrounding',
  matches: function matches(ele) {
    return ele.backgrounding();
  }
}, {
  selector: ':nonbackgrounding',
  matches: function matches(ele) {
    return !ele.backgrounding();
  }
}].sort(function (a, b) {
  // n.b. selectors that are starting substrings of others must have the longer ones first
  return descending(a.selector, b.selector);
});

var lookup = function () {
  var selToFn = {};
  var s;

  for (var i = 0; i < stateSelectors.length; i++) {
    s = stateSelectors[i];
    selToFn[s.selector] = s.matches;
  }

  return selToFn;
}();

var stateSelectorMatches = function stateSelectorMatches(sel, ele) {
  return lookup[sel](ele);
};
var stateSelectorRegex = '(' + stateSelectors.map(function (s) {
  return s.selector;
}).join('|') + ')';

// so that values get compared properly in Selector.filter()

var cleanMetaChars = function cleanMetaChars(str) {
  return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {
    return $1;
  });
};

var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {
  selector[selector.length - 1] = replacementQuery;
}; // NOTE: add new expression syntax here to have it recognised by the parser;
// - a query contains all adjacent (i.e. no separator in between) expressions;
// - the current query is stored in selector[i]
// - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward


var exprs = [{
  name: 'group',
  // just used for identifying when debugging
  query: true,
  regex: '(' + tokens.group + ')',
  populate: function populate(selector, query, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        group = _ref2[0];

    query.checks.push({
      type: Type.GROUP,
      value: group === '*' ? group : group + 's'
    });
  }
}, {
  name: 'state',
  query: true,
  regex: stateSelectorRegex,
  populate: function populate(selector, query, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
        state = _ref4[0];

    query.checks.push({
      type: Type.STATE,
      value: state
    });
  }
}, {
  name: 'id',
  query: true,
  regex: '\\#(' + tokens.id + ')',
  populate: function populate(selector, query, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
        id = _ref6[0];

    query.checks.push({
      type: Type.ID,
      value: cleanMetaChars(id)
    });
  }
}, {
  name: 'className',
  query: true,
  regex: '\\.(' + tokens.className + ')',
  populate: function populate(selector, query, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
        className = _ref8[0];

    query.checks.push({
      type: Type.CLASS,
      value: cleanMetaChars(className)
    });
  }
}, {
  name: 'dataExists',
  query: true,
  regex: '\\[\\s*(' + tokens.variable + ')\\s*\\]',
  populate: function populate(selector, query, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 1),
        variable = _ref10[0];

    query.checks.push({
      type: Type.DATA_EXIST,
      field: cleanMetaChars(variable)
    });
  }
}, {
  name: 'dataCompare',
  query: true,
  regex: '\\[\\s*(' + tokens.variable + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.value + ')\\s*\\]',
  populate: function populate(selector, query, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 3),
        variable = _ref12[0],
        comparatorOp = _ref12[1],
        value = _ref12[2];

    var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

    if (valueIsString) {
      value = value.substring(1, value.length - 1);
    } else {
      value = parseFloat(value);
    }

    query.checks.push({
      type: Type.DATA_COMPARE,
      field: cleanMetaChars(variable),
      operator: comparatorOp,
      value: value
    });
  }
}, {
  name: 'dataBool',
  query: true,
  regex: '\\[\\s*(' + tokens.boolOp + ')\\s*(' + tokens.variable + ')\\s*\\]',
  populate: function populate(selector, query, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 2),
        boolOp = _ref14[0],
        variable = _ref14[1];

    query.checks.push({
      type: Type.DATA_BOOL,
      field: cleanMetaChars(variable),
      operator: boolOp
    });
  }
}, {
  name: 'metaCompare',
  query: true,
  regex: '\\[\\[\\s*(' + tokens.meta + ')\\s*(' + tokens.comparatorOp + ')\\s*(' + tokens.number + ')\\s*\\]\\]',
  populate: function populate(selector, query, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 3),
        meta = _ref16[0],
        comparatorOp = _ref16[1],
        number = _ref16[2];

    query.checks.push({
      type: Type.META_COMPARE,
      field: cleanMetaChars(meta),
      operator: comparatorOp,
      value: parseFloat(number)
    });
  }
}, {
  name: 'nextQuery',
  separator: true,
  regex: tokens.separator,
  populate: function populate(selector, query) {
    var currentSubject = selector.currentSubject;
    var edgeCount = selector.edgeCount;
    var compoundCount = selector.compoundCount;
    var lastQ = selector[selector.length - 1];

    if (currentSubject != null) {
      lastQ.subject = currentSubject;
      selector.currentSubject = null;
    }

    lastQ.edgeCount = edgeCount;
    lastQ.compoundCount = compoundCount;
    selector.edgeCount = 0;
    selector.compoundCount = 0; // go on to next query

    var nextQuery = selector[selector.length++] = newQuery();
    return nextQuery; // this is the new query to be filled by the following exprs
  }
}, {
  name: 'directedEdge',
  separator: true,
  regex: tokens.directedEdge,
  populate: function populate(selector, query) {
    if (selector.currentSubject == null) {
      // undirected edge
      var edgeQuery = newQuery();
      var source = query;
      var target = newQuery();
      edgeQuery.checks.push({
        type: Type.DIRECTED_EDGE,
        source: source,
        target: target
      }); // the query in the selector should be the edge rather than the source

      replaceLastQuery(selector, query, edgeQuery);
      selector.edgeCount++; // we're now populating the target query with expressions that follow

      return target;
    } else {
      // source/target
      var srcTgtQ = newQuery();
      var _source = query;

      var _target = newQuery();

      srcTgtQ.checks.push({
        type: Type.NODE_SOURCE,
        source: _source,
        target: _target
      }); // the query in the selector should be the neighbourhood rather than the node

      replaceLastQuery(selector, query, srcTgtQ);
      selector.edgeCount++;
      return _target; // now populating the target with the following expressions
    }
  }
}, {
  name: 'undirectedEdge',
  separator: true,
  regex: tokens.undirectedEdge,
  populate: function populate(selector, query) {
    if (selector.currentSubject == null) {
      // undirected edge
      var edgeQuery = newQuery();
      var source = query;
      var target = newQuery();
      edgeQuery.checks.push({
        type: Type.UNDIRECTED_EDGE,
        nodes: [source, target]
      }); // the query in the selector should be the edge rather than the source

      replaceLastQuery(selector, query, edgeQuery);
      selector.edgeCount++; // we're now populating the target query with expressions that follow

      return target;
    } else {
      // neighbourhood
      var nhoodQ = newQuery();
      var node = query;
      var neighbor = newQuery();
      nhoodQ.checks.push({
        type: Type.NODE_NEIGHBOR,
        node: node,
        neighbor: neighbor
      }); // the query in the selector should be the neighbourhood rather than the node

      replaceLastQuery(selector, query, nhoodQ);
      return neighbor; // now populating the neighbor with following expressions
    }
  }
}, {
  name: 'child',
  separator: true,
  regex: tokens.child,
  populate: function populate(selector, query) {
    if (selector.currentSubject == null) {
      // default: child query
      var parentChildQuery = newQuery();
      var child = newQuery();
      var parent = selector[selector.length - 1];
      parentChildQuery.checks.push({
        type: Type.CHILD,
        parent: parent,
        child: child
      }); // the query in the selector should be the '>' itself

      replaceLastQuery(selector, query, parentChildQuery);
      selector.compoundCount++; // we're now populating the child query with expressions that follow

      return child;
    } else if (selector.currentSubject === query) {
      // compound split query
      var compound = newQuery();
      var left = selector[selector.length - 1];
      var right = newQuery();
      var subject = newQuery();

      var _child = newQuery();

      var _parent = newQuery(); // set up the root compound q


      compound.checks.push({
        type: Type.COMPOUND_SPLIT,
        left: left,
        right: right,
        subject: subject
      }); // populate the subject and replace the q at the old spot (within left) with TRUE

      subject.checks = query.checks; // take the checks from the left

      query.checks = [{
        type: Type.TRUE
      }]; // checks under left refs the subject implicitly
      // set up the right q

      _parent.checks.push({
        type: Type.TRUE
      }); // parent implicitly refs the subject


      right.checks.push({
        type: Type.PARENT,
        // type is swapped on right side queries
        parent: _parent,
        child: _child // empty for now

      });
      replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`

      selector.currentSubject = subject;
      selector.compoundCount++;
      return _child; // now populating the right side's child
    } else {
      // parent query
      // info for parent query
      var _parent2 = newQuery();

      var _child2 = newQuery();

      var pcQChecks = [{
        type: Type.PARENT,
        parent: _parent2,
        child: _child2
      }]; // the parent-child query takes the place of the query previously being populated

      _parent2.checks = query.checks; // the previous query contains the checks for the parent

      query.checks = pcQChecks; // pc query takes over

      selector.compoundCount++;
      return _child2; // we're now populating the child
    }
  }
}, {
  name: 'descendant',
  separator: true,
  regex: tokens.descendant,
  populate: function populate(selector, query) {
    if (selector.currentSubject == null) {
      // default: descendant query
      var ancChQuery = newQuery();
      var descendant = newQuery();
      var ancestor = selector[selector.length - 1];
      ancChQuery.checks.push({
        type: Type.DESCENDANT,
        ancestor: ancestor,
        descendant: descendant
      }); // the query in the selector should be the '>' itself

      replaceLastQuery(selector, query, ancChQuery);
      selector.compoundCount++; // we're now populating the descendant query with expressions that follow

      return descendant;
    } else if (selector.currentSubject === query) {
      // compound split query
      var compound = newQuery();
      var left = selector[selector.length - 1];
      var right = newQuery();
      var subject = newQuery();

      var _descendant = newQuery();

      var _ancestor = newQuery(); // set up the root compound q


      compound.checks.push({
        type: Type.COMPOUND_SPLIT,
        left: left,
        right: right,
        subject: subject
      }); // populate the subject and replace the q at the old spot (within left) with TRUE

      subject.checks = query.checks; // take the checks from the left

      query.checks = [{
        type: Type.TRUE
      }]; // checks under left refs the subject implicitly
      // set up the right q

      _ancestor.checks.push({
        type: Type.TRUE
      }); // ancestor implicitly refs the subject


      right.checks.push({
        type: Type.ANCESTOR,
        // type is swapped on right side queries
        ancestor: _ancestor,
        descendant: _descendant // empty for now

      });
      replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`

      selector.currentSubject = subject;
      selector.compoundCount++;
      return _descendant; // now populating the right side's descendant
    } else {
      // ancestor query
      // info for parent query
      var _ancestor2 = newQuery();

      var _descendant2 = newQuery();

      var adQChecks = [{
        type: Type.ANCESTOR,
        ancestor: _ancestor2,
        descendant: _descendant2
      }]; // the parent-child query takes the place of the query previously being populated

      _ancestor2.checks = query.checks; // the previous query contains the checks for the parent

      query.checks = adQChecks; // pc query takes over

      selector.compoundCount++;
      return _descendant2; // we're now populating the child
    }
  }
}, {
  name: 'subject',
  modifier: true,
  regex: tokens.subject,
  populate: function populate(selector, query) {
    if (selector.currentSubject != null && selector.currentSubject !== query) {
      warn('Redefinition of subject in selector `' + selector.toString() + '`');
      return false;
    }

    selector.currentSubject = query;
    var topQ = selector[selector.length - 1];
    var topChk = topQ.checks[0];
    var topType = topChk == null ? null : topChk.type;

    if (topType === Type.DIRECTED_EDGE) {
      // directed edge with subject on the target
      // change to target node check
      topChk.type = Type.NODE_TARGET;
    } else if (topType === Type.UNDIRECTED_EDGE) {
      // undirected edge with subject on the second node
      // change to neighbor check
      topChk.type = Type.NODE_NEIGHBOR;
      topChk.node = topChk.nodes[1]; // second node is subject

      topChk.neighbor = topChk.nodes[0]; // clean up unused fields for new type

      topChk.nodes = null;
    }
  }
}];
exprs.forEach(function (e) {
  return e.regexObj = new RegExp('^' + e.regex);
});

/**
 * Of all the expressions, find the first match in the remaining text.
 * @param {string} remaining The remaining text to parse
 * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`
 */

var consumeExpr = function consumeExpr(remaining) {
  var expr;
  var match;
  var name;

  for (var j = 0; j < exprs.length; j++) {
    var e = exprs[j];
    var n = e.name;
    var m = remaining.match(e.regexObj);

    if (m != null) {
      match = m;
      expr = e;
      name = n;
      var consumed = m[0];
      remaining = remaining.substring(consumed.length);
      break; // we've consumed one expr, so we can return now
    }
  }

  return {
    expr: expr,
    match: match,
    name: name,
    remaining: remaining
  };
};
/**
 * Consume all the leading whitespace
 * @param {string} remaining The text to consume
 * @returns The text with the leading whitespace removed
 */


var consumeWhitespace = function consumeWhitespace(remaining) {
  var match = remaining.match(/^\s+/);

  if (match) {
    var consumed = match[0];
    remaining = remaining.substring(consumed.length);
  }

  return remaining;
};
/**
 * Parse the string and store the parsed representation in the Selector.
 * @param {string} selector The selector string
 * @returns `true` if the selector was successfully parsed, `false` otherwise
 */


var parse = function parse(selector) {
  var self = this;
  var remaining = self.inputText = selector;
  var currentQuery = self[0] = newQuery();
  self.length = 1;
  remaining = consumeWhitespace(remaining); // get rid of leading whitespace

  for (;;) {
    var exprInfo = consumeExpr(remaining);

    if (exprInfo.expr == null) {
      warn('The selector `' + selector + '`is invalid');
      return false;
    } else {
      var args = exprInfo.match.slice(1); // let the token populate the selector object in currentQuery

      var ret = exprInfo.expr.populate(self, currentQuery, args);

      if (ret === false) {
        return false; // exit if population failed
      } else if (ret != null) {
        currentQuery = ret; // change the current query to be filled if the expr specifies
      }
    }

    remaining = exprInfo.remaining; // we're done when there's nothing left to parse

    if (remaining.match(/^\s*$/)) {
      break;
    }
  }

  var lastQ = self[self.length - 1];

  if (self.currentSubject != null) {
    lastQ.subject = self.currentSubject;
  }

  lastQ.edgeCount = self.edgeCount;
  lastQ.compoundCount = self.compoundCount;

  for (var i = 0; i < self.length; i++) {
    var q = self[i]; // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations

    if (q.compoundCount > 0 && q.edgeCount > 0) {
      warn('The selector `' + selector + '` is invalid because it uses both a compound selector and an edge selector');
      return false;
    }

    if (q.edgeCount > 1) {
      warn('The selector `' + selector + '` is invalid because it uses multiple edge selectors');
      return false;
    } else if (q.edgeCount === 1) {
      warn('The selector `' + selector + '` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.');
    }
  }

  return true; // success
};
/**
 * Get the selector represented as a string.  This value uses default formatting,
 * so things like spacing may differ from the input text passed to the constructor.
 * @returns {string} The selector string
 */


var toString = function toString() {
  if (this.toStringCache != null) {
    return this.toStringCache;
  }

  var clean = function clean(obj) {
    if (obj == null) {
      return '';
    } else {
      return obj;
    }
  };

  var cleanVal = function cleanVal(val) {
    if (string(val)) {
      return '"' + val + '"';
    } else {
      return clean(val);
    }
  };

  var space = function space(val) {
    return ' ' + val + ' ';
  };

  var checkToString = function checkToString(check, subject) {
    var type = check.type,
        value = check.value;

    switch (type) {
      case Type.GROUP:
        {
          var group = clean(value);
          return group.substring(0, group.length - 1);
        }

      case Type.DATA_COMPARE:
        {
          var field = check.field,
              operator = check.operator;
          return '[' + field + space(clean(operator)) + cleanVal(value) + ']';
        }

      case Type.DATA_BOOL:
        {
          var _operator = check.operator,
              _field = check.field;
          return '[' + clean(_operator) + _field + ']';
        }

      case Type.DATA_EXIST:
        {
          var _field2 = check.field;
          return '[' + _field2 + ']';
        }

      case Type.META_COMPARE:
        {
          var _operator2 = check.operator,
              _field3 = check.field;
          return '[[' + _field3 + space(clean(_operator2)) + cleanVal(value) + ']]';
        }

      case Type.STATE:
        {
          return value;
        }

      case Type.ID:
        {
          return '#' + value;
        }

      case Type.CLASS:
        {
          return '.' + value;
        }

      case Type.PARENT:
      case Type.CHILD:
        {
          return queryToString(check.parent, subject) + space('>') + queryToString(check.child, subject);
        }

      case Type.ANCESTOR:
      case Type.DESCENDANT:
        {
          return queryToString(check.ancestor, subject) + ' ' + queryToString(check.descendant, subject);
        }

      case Type.COMPOUND_SPLIT:
        {
          var lhs = queryToString(check.left, subject);
          var sub = queryToString(check.subject, subject);
          var rhs = queryToString(check.right, subject);
          return lhs + (lhs.length > 0 ? ' ' : '') + sub + rhs;
        }

      case Type.TRUE:
        {
          return '';
        }
    }
  };

  var queryToString = function queryToString(query, subject) {
    return query.checks.reduce(function (str, chk, i) {
      return str + (subject === query && i === 0 ? '$' : '') + checkToString(chk, subject);
    }, '');
  };

  var str = '';

  for (var i = 0; i < this.length; i++) {
    var query = this[i];
    str += queryToString(query, query.subject);

    if (this.length > 1 && i < this.length - 1) {
      str += ', ';
    }
  }

  this.toStringCache = str;
  return str;
};
var parse$1 = {
  parse: parse,
  toString: toString
};

var valCmp = function valCmp(fieldVal, operator, value) {
  var matches;
  var isFieldStr = string(fieldVal);
  var isFieldNum = number(fieldVal);
  var isValStr = string(value);
  var fieldStr, valStr;
  var caseInsensitive = false;
  var notExpr = false;
  var isIneqCmp = false;

  if (operator.indexOf('!') >= 0) {
    operator = operator.replace('!', '');
    notExpr = true;
  }

  if (operator.indexOf('@') >= 0) {
    operator = operator.replace('@', '');
    caseInsensitive = true;
  }

  if (isFieldStr || isValStr || caseInsensitive) {
    fieldStr = !isFieldStr && !isFieldNum ? '' : '' + fieldVal;
    valStr = '' + value;
  } // if we're doing a case insensitive comparison, then we're using a STRING comparison
  // even if we're comparing numbers


  if (caseInsensitive) {
    fieldVal = fieldStr = fieldStr.toLowerCase();
    value = valStr = valStr.toLowerCase();
  }

  switch (operator) {
    case '*=':
      matches = fieldStr.indexOf(valStr) >= 0;
      break;

    case '$=':
      matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;
      break;

    case '^=':
      matches = fieldStr.indexOf(valStr) === 0;
      break;

    case '=':
      matches = fieldVal === value;
      break;

    case '>':
      isIneqCmp = true;
      matches = fieldVal > value;
      break;

    case '>=':
      isIneqCmp = true;
      matches = fieldVal >= value;
      break;

    case '<':
      isIneqCmp = true;
      matches = fieldVal < value;
      break;

    case '<=':
      isIneqCmp = true;
      matches = fieldVal <= value;
      break;

    default:
      matches = false;
      break;
  } // apply the not op, but null vals for inequalities should always stay non-matching


  if (notExpr && (fieldVal != null || !isIneqCmp)) {
    matches = !matches;
  }

  return matches;
};
var boolCmp = function boolCmp(fieldVal, operator) {
  switch (operator) {
    case '?':
      return fieldVal ? true : false;

    case '!':
      return fieldVal ? false : true;

    case '^':
      return fieldVal === undefined;
  }
};
var existCmp = function existCmp(fieldVal) {
  return fieldVal !== undefined;
};
var data = function data(ele, field) {
  return ele.data(field);
};
var meta = function meta(ele, field) {
  return ele[field]();
};

/** A lookup of `match(check, ele)` functions by `Type` int */

var match = [];
/**
 * Returns whether the query matches for the element
 * @param query The `{ type, value, ... }` query object
 * @param ele The element to compare against
*/

var matches = function matches(query, ele) {
  return query.checks.every(function (chk) {
    return match[chk.type](chk, ele);
  });
};

match[Type.GROUP] = function (check, ele) {
  var group = check.value;
  return group === '*' || group === ele.group();
};

match[Type.STATE] = function (check, ele) {
  var stateSelector = check.value;
  return stateSelectorMatches(stateSelector, ele);
};

match[Type.ID] = function (check, ele) {
  var id = check.value;
  return ele.id() === id;
};

match[Type.CLASS] = function (check, ele) {
  var cls = check.value;
  return ele.hasClass(cls);
};

match[Type.META_COMPARE] = function (check, ele) {
  var field = check.field,
      operator = check.operator,
      value = check.value;
  return valCmp(meta(ele, field), operator, value);
};

match[Type.DATA_COMPARE] = function (check, ele) {
  var field = check.field,
      operator = check.operator,
      value = check.value;
  return valCmp(data(ele, field), operator, value);
};

match[Type.DATA_BOOL] = function (check, ele) {
  var field = check.field,
      operator = check.operator;
  return boolCmp(data(ele, field), operator);
};

match[Type.DATA_EXIST] = function (check, ele) {
  var field = check.field,
      operator = check.operator;
  return existCmp(data(ele, field));
};

match[Type.UNDIRECTED_EDGE] = function (check, ele) {
  var qA = check.nodes[0];
  var qB = check.nodes[1];
  var src = ele.source();
  var tgt = ele.target();
  return matches(qA, src) && matches(qB, tgt) || matches(qB, src) && matches(qA, tgt);
};

match[Type.NODE_NEIGHBOR] = function (check, ele) {
  return matches(check.node, ele) && ele.neighborhood().some(function (n) {
    return n.isNode() && matches(check.neighbor, n);
  });
};

match[Type.DIRECTED_EDGE] = function (check, ele) {
  return matches(check.source, ele.source()) && matches(check.target, ele.target());
};

match[Type.NODE_SOURCE] = function (check, ele) {
  return matches(check.source, ele) && ele.outgoers().some(function (n) {
    return n.isNode() && matches(check.target, n);
  });
};

match[Type.NODE_TARGET] = function (check, ele) {
  return matches(check.target, ele) && ele.incomers().some(function (n) {
    return n.isNode() && matches(check.source, n);
  });
};

match[Type.CHILD] = function (check, ele) {
  return matches(check.child, ele) && matches(check.parent, ele.parent());
};

match[Type.PARENT] = function (check, ele) {
  return matches(check.parent, ele) && ele.children().some(function (c) {
    return matches(check.child, c);
  });
};

match[Type.DESCENDANT] = function (check, ele) {
  return matches(check.descendant, ele) && ele.ancestors().some(function (a) {
    return matches(check.ancestor, a);
  });
};

match[Type.ANCESTOR] = function (check, ele) {
  return matches(check.ancestor, ele) && ele.descendants().some(function (d) {
    return matches(check.descendant, d);
  });
};

match[Type.COMPOUND_SPLIT] = function (check, ele) {
  return matches(check.subject, ele) && matches(check.left, ele) && matches(check.right, ele);
};

match[Type.TRUE] = function () {
  return true;
};

match[Type.COLLECTION] = function (check, ele) {
  var collection = check.value;
  return collection.has(ele);
};

match[Type.FILTER] = function (check, ele) {
  var filter = check.value;
  return filter(ele);
};

var filter = function filter(collection) {
  var self = this; // for 1 id #foo queries, just get the element

  if (self.length === 1 && self[0].checks.length === 1 && self[0].checks[0].type === Type.ID) {
    return collection.getElementById(self[0].checks[0].value).collection();
  }

  var selectorFunction = function selectorFunction(element) {
    for (var j = 0; j < self.length; j++) {
      var query = self[j];

      if (matches(query, element)) {
        return true;
      }
    }

    return false;
  };

  if (self.text() == null) {
    selectorFunction = function selectorFunction() {
      return true;
    };
  }

  return collection.filter(selectorFunction);
}; // filter
// does selector match a single element?


var matches$1 = function matches$1(ele) {
  var self = this;

  for (var j = 0; j < self.length; j++) {
    var query = self[j];

    if (matches(query, ele)) {
      return true;
    }
  }

  return false;
}; // matches


var matching = {
  matches: matches$1,
  filter: filter
};

var Selector = function Selector(selector) {
  this.inputText = selector;
  this.currentSubject = null;
  this.compoundCount = 0;
  this.edgeCount = 0;
  this.length = 0;

  if (selector == null || string(selector) && selector.match(/^\s*$/)) ; else if (elementOrCollection(selector)) {
    this.addQuery({
      checks: [{
        type: Type.COLLECTION,
        value: selector.collection()
      }]
    });
  } else if (fn(selector)) {
    this.addQuery({
      checks: [{
        type: Type.FILTER,
        value: selector
      }]
    });
  } else if (string(selector)) {
    if (!this.parse(selector)) {
      this.invalid = true;
    }
  } else {
    error('A selector must be created from a string; found ');
  }
};

var selfn = Selector.prototype;
[parse$1, matching].forEach(function (p) {
  return extend(selfn, p);
});

selfn.text = function () {
  return this.inputText;
};

selfn.size = function () {
  return this.length;
};

selfn.eq = function (i) {
  return this[i];
};

selfn.sameText = function (otherSel) {
  return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();
};

selfn.addQuery = function (q) {
  this[this.length++] = q;
};

selfn.selector = selfn.toString;

var elesfn$f = {
  allAre: function allAre(selector) {
    var selObj = new Selector(selector);
    return this.every(function (ele) {
      return selObj.matches(ele);
    });
  },
  is: function is(selector) {
    var selObj = new Selector(selector);
    return this.some(function (ele) {
      return selObj.matches(ele);
    });
  },
  some: function some(fn, thisArg) {
    for (var i = 0; i < this.length; i++) {
      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

      if (ret) {
        return true;
      }
    }

    return false;
  },
  every: function every(fn, thisArg) {
    for (var i = 0; i < this.length; i++) {
      var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);

      if (!ret) {
        return false;
      }
    }

    return true;
  },
  same: function same(collection) {
    // cheap collection ref check
    if (this === collection) {
      return true;
    }

    collection = this.cy().collection(collection);
    var thisLength = this.length;
    var collectionLength = collection.length; // cheap length check

    if (thisLength !== collectionLength) {
      return false;
    } // cheap element ref check


    if (thisLength === 1) {
      return this[0] === collection[0];
    }

    return this.every(function (ele) {
      return collection.hasElementWithId(ele.id());
    });
  },
  anySame: function anySame(collection) {
    collection = this.cy().collection(collection);
    return this.some(function (ele) {
      return collection.hasElementWithId(ele.id());
    });
  },
  allAreNeighbors: function allAreNeighbors(collection) {
    collection = this.cy().collection(collection);
    var nhood = this.neighborhood();
    return collection.every(function (ele) {
      return nhood.hasElementWithId(ele.id());
    });
  },
  contains: function contains(collection) {
    collection = this.cy().collection(collection);
    var self = this;
    return collection.every(function (ele) {
      return self.hasElementWithId(ele.id());
    });
  }
};
elesfn$f.allAreNeighbours = elesfn$f.allAreNeighbors;
elesfn$f.has = elesfn$f.contains;
elesfn$f.equal = elesfn$f.equals = elesfn$f.same;

var cache = function cache(fn, name) {
  return function traversalCache(arg1, arg2, arg3, arg4) {
    var selectorOrEles = arg1;
    var eles = this;
    var key;

    if (selectorOrEles == null) {
      key = '';
    } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {
      key = selectorOrEles.id();
    }

    if (eles.length === 1 && key) {
      var _p = eles[0]._private;
      var tch = _p.traversalCache = _p.traversalCache || {};
      var ch = tch[name] = tch[name] || [];
      var hash = hashString(key);
      var cacheHit = ch[hash];

      if (cacheHit) {
        return cacheHit;
      } else {
        return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);
      }
    } else {
      return fn.call(eles, arg1, arg2, arg3, arg4);
    }
  };
};

var elesfn$g = {
  parent: function parent(selector) {
    var parents = []; // optimisation for single ele call

    if (this.length === 1) {
      var parent = this[0]._private.parent;

      if (parent) {
        return parent;
      }
    }

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var _parent = ele._private.parent;

      if (_parent) {
        parents.push(_parent);
      }
    }

    return this.spawn(parents, {
      unique: true
    }).filter(selector);
  },
  parents: function parents(selector) {
    var parents = [];
    var eles = this.parent();

    while (eles.nonempty()) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        parents.push(ele);
      }

      eles = eles.parent();
    }

    return this.spawn(parents, {
      unique: true
    }).filter(selector);
  },
  commonAncestors: function commonAncestors(selector) {
    var ancestors;

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var parents = ele.parents();
      ancestors = ancestors || parents;
      ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set
    }

    return ancestors.filter(selector);
  },
  orphans: function orphans(selector) {
    return this.stdFilter(function (ele) {
      return ele.isOrphan();
    }).filter(selector);
  },
  nonorphans: function nonorphans(selector) {
    return this.stdFilter(function (ele) {
      return ele.isChild();
    }).filter(selector);
  },
  children: cache(function (selector) {
    var children = [];

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var eleChildren = ele._private.children;

      for (var j = 0; j < eleChildren.length; j++) {
        children.push(eleChildren[j]);
      }
    }

    return this.spawn(children, {
      unique: true
    }).filter(selector);
  }, 'children'),
  siblings: function siblings(selector) {
    return this.parent().children().not(this).filter(selector);
  },
  isParent: function isParent() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.children.length !== 0;
    }
  },
  isChildless: function isChildless() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.children.length === 0;
    }
  },
  isChild: function isChild() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.parent != null;
    }
  },
  isOrphan: function isOrphan() {
    var ele = this[0];

    if (ele) {
      return ele.isNode() && ele._private.parent == null;
    }
  },
  descendants: function descendants(selector) {
    var elements = [];

    function add(eles) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        elements.push(ele);

        if (ele.children().nonempty()) {
          add(ele.children());
        }
      }
    }

    add(this.children());
    return this.spawn(elements, {
      unique: true
    }).filter(selector);
  }
};

function forEachCompound(eles, fn, includeSelf, recursiveStep) {
  var q = [];
  var did = new Set$1();
  var cy = eles.cy();
  var hasCompounds = cy.hasCompoundNodes();

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (includeSelf) {
      q.push(ele);
    } else if (hasCompounds) {
      recursiveStep(q, did, ele);
    }
  }

  while (q.length > 0) {
    var _ele = q.shift();

    fn(_ele);
    did.add(_ele.id());

    if (hasCompounds) {
      recursiveStep(q, did, _ele);
    }
  }

  return eles;
}

function addChildren(q, did, ele) {
  if (ele.isParent()) {
    var children = ele._private.children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i];

      if (!did.has(child.id())) {
        q.push(child);
      }
    }
  }
} // very efficient version of eles.add( eles.descendants() ).forEach()
// for internal use


elesfn$g.forEachDown = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return forEachCompound(this, fn, includeSelf, addChildren);
};

function addParent(q, did, ele) {
  if (ele.isChild()) {
    var parent = ele._private.parent;

    if (!did.has(parent.id())) {
      q.push(parent);
    }
  }
}

elesfn$g.forEachUp = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return forEachCompound(this, fn, includeSelf, addParent);
};

function addParentAndChildren(q, did, ele) {
  addParent(q, did, ele);
  addChildren(q, did, ele);
}

elesfn$g.forEachUpAndDown = function (fn) {
  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return forEachCompound(this, fn, includeSelf, addParentAndChildren);
}; // aliases


elesfn$g.ancestors = elesfn$g.parents;

var fn$1, elesfn$h;
fn$1 = elesfn$h = {
  data: define$3.data({
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),
  removeData: define$3.removeData({
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),
  scratch: define$3.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    updateStyle: true
  }),
  removeScratch: define$3.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true,
    updateStyle: true
  }),
  rscratch: define$3.data({
    field: 'rscratch',
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: true
  }),
  removeRscratch: define$3.removeData({
    field: 'rscratch',
    triggerEvent: false
  }),
  id: function id() {
    var ele = this[0];

    if (ele) {
      return ele._private.data.id;
    }
  }
}; // aliases

fn$1.attr = fn$1.data;
fn$1.removeAttr = fn$1.removeData;
var data$1 = elesfn$h;

var elesfn$i = {};

function defineDegreeFunction(callback) {
  return function (includeLoops) {
    var self = this;

    if (includeLoops === undefined) {
      includeLoops = true;
    }

    if (self.length === 0) {
      return;
    }

    if (self.isNode() && !self.removed()) {
      var degree = 0;
      var node = self[0];
      var connectedEdges = node._private.edges;

      for (var i = 0; i < connectedEdges.length; i++) {
        var edge = connectedEdges[i];

        if (!includeLoops && edge.isLoop()) {
          continue;
        }

        degree += callback(node, edge);
      }

      return degree;
    } else {
      return;
    }
  };
}

extend(elesfn$i, {
  degree: defineDegreeFunction(function (node, edge) {
    if (edge.source().same(edge.target())) {
      return 2;
    } else {
      return 1;
    }
  }),
  indegree: defineDegreeFunction(function (node, edge) {
    if (edge.target().same(node)) {
      return 1;
    } else {
      return 0;
    }
  }),
  outdegree: defineDegreeFunction(function (node, edge) {
    if (edge.source().same(node)) {
      return 1;
    } else {
      return 0;
    }
  })
});

function defineDegreeBoundsFunction(degreeFn, callback) {
  return function (includeLoops) {
    var ret;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      var ele = nodes[i];
      var degree = ele[degreeFn](includeLoops);

      if (degree !== undefined && (ret === undefined || callback(degree, ret))) {
        ret = degree;
      }
    }

    return ret;
  };
}

extend(elesfn$i, {
  minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {
    return degree < min;
  }),
  maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {
    return degree > max;
  }),
  minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {
    return degree < min;
  }),
  maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {
    return degree > max;
  }),
  minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {
    return degree < min;
  }),
  maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {
    return degree > max;
  })
});
extend(elesfn$i, {
  totalDegree: function totalDegree(includeLoops) {
    var total = 0;
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      total += nodes[i].degree(includeLoops);
    }

    return total;
  }
});

var fn$2, elesfn$j;

var beforePositionSet = function beforePositionSet(eles, newPos, silent) {
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (!ele.locked()) {
      var oldPos = ele._private.position;
      var delta = {
        x: newPos.x != null ? newPos.x - oldPos.x : 0,
        y: newPos.y != null ? newPos.y - oldPos.y : 0
      };

      if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {
        ele.children().shift(delta, silent);
      }

      ele.shiftCachedBoundingBox(delta);
    }
  }
};

var positionDef = {
  field: 'position',
  bindingEvent: 'position',
  allowBinding: true,
  allowSetting: true,
  settingEvent: 'position',
  settingTriggersEvent: true,
  triggerFnName: 'emitAndNotify',
  allowGetting: true,
  validKeys: ['x', 'y'],
  beforeGet: function beforeGet(ele) {
    ele.updateCompoundBounds();
  },
  beforeSet: function beforeSet(eles, newPos) {
    beforePositionSet(eles, newPos, false);
  },
  onSet: function onSet(eles) {
    eles.dirtyCompoundBoundsCache();
  },
  canSet: function canSet(ele) {
    return !ele.locked();
  }
};
fn$2 = elesfn$j = {
  position: define$3.data(positionDef),
  // position but no notification to renderer
  silentPosition: define$3.data(extend({}, positionDef, {
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: false,
    beforeSet: function beforeSet(eles, newPos) {
      beforePositionSet(eles, newPos, true);
    }
  })),
  positions: function positions(pos, silent) {
    if (plainObject(pos)) {
      if (silent) {
        this.silentPosition(pos);
      } else {
        this.position(pos);
      }
    } else if (fn(pos)) {
      var _fn = pos;
      var cy = this.cy();
      cy.startBatch();

      for (var i = 0; i < this.length; i++) {
        var ele = this[i];

        var _pos = void 0;

        if (_pos = _fn(ele, i)) {
          if (silent) {
            ele.silentPosition(_pos);
          } else {
            ele.position(_pos);
          }
        }
      }

      cy.endBatch();
    }

    return this; // chaining
  },
  silentPositions: function silentPositions(pos) {
    return this.positions(pos, true);
  },
  shift: function shift(dim, val, silent) {
    var delta;

    if (plainObject(dim)) {
      delta = {
        x: number(dim.x) ? dim.x : 0,
        y: number(dim.y) ? dim.y : 0
      };
      silent = val;
    } else if (string(dim) && number(val)) {
      delta = {
        x: 0,
        y: 0
      };
      delta[dim] = val;
    }

    if (delta != null) {
      var cy = this.cy();
      cy.startBatch();

      for (var i = 0; i < this.length; i++) {
        var ele = this[i];
        var pos = ele.position();
        var newPos = {
          x: pos.x + delta.x,
          y: pos.y + delta.y
        };

        if (silent) {
          ele.silentPosition(newPos);
        } else {
          ele.position(newPos);
        }
      }

      cy.endBatch();
    }

    return this;
  },
  silentShift: function silentShift(dim, val) {
    if (plainObject(dim)) {
      this.shift(dim, true);
    } else if (string(dim) && number(val)) {
      this.shift(dim, val, true);
    }

    return this;
  },
  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function renderedPosition(dim, val) {
    var ele = this[0];
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();
    var rpos = plainObject(dim) ? dim : undefined;
    var setting = rpos !== undefined || val !== undefined && string(dim);

    if (ele && ele.isNode()) {
      // must have an element and must be a node to return position
      if (setting) {
        for (var i = 0; i < this.length; i++) {
          var _ele = this[i];

          if (val !== undefined) {
            // set one dimension
            _ele.position(dim, (val - pan[dim]) / zoom);
          } else if (rpos !== undefined) {
            // set whole position
            _ele.position(renderedToModelPosition(rpos, zoom, pan));
          }
        }
      } else {
        // getting
        var pos = ele.position();
        rpos = modelToRenderedPosition(pos, zoom, pan);

        if (dim === undefined) {
          // then return the whole rendered position
          return rpos;
        } else {
          // then return the specified dimension
          return rpos[dim];
        }
      }
    } else if (!setting) {
      return undefined; // for empty collection case
    }

    return this; // chaining
  },
  // get/set the position relative to the parent
  relativePosition: function relativePosition(dim, val) {
    var ele = this[0];
    var cy = this.cy();
    var ppos = plainObject(dim) ? dim : undefined;
    var setting = ppos !== undefined || val !== undefined && string(dim);
    var hasCompoundNodes = cy.hasCompoundNodes();

    if (ele && ele.isNode()) {
      // must have an element and must be a node to return position
      if (setting) {
        for (var i = 0; i < this.length; i++) {
          var _ele2 = this[i];
          var parent = hasCompoundNodes ? _ele2.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if (hasParent) {
            parent = parent[0];
          }

          var origin = relativeToParent ? parent.position() : {
            x: 0,
            y: 0
          };

          if (val !== undefined) {
            // set one dimension
            _ele2.position(dim, val + origin[dim]);
          } else if (ppos !== undefined) {
            // set whole position
            _ele2.position({
              x: ppos.x + origin.x,
              y: ppos.y + origin.y
            });
          }
        }
      } else {
        // getting
        var pos = ele.position();

        var _parent = hasCompoundNodes ? ele.parent() : null;

        var _hasParent = _parent && _parent.length > 0;

        var _relativeToParent = _hasParent;

        if (_hasParent) {
          _parent = _parent[0];
        }

        var _origin = _relativeToParent ? _parent.position() : {
          x: 0,
          y: 0
        };

        ppos = {
          x: pos.x - _origin.x,
          y: pos.y - _origin.y
        };

        if (dim === undefined) {
          // then return the whole rendered position
          return ppos;
        } else {
          // then return the specified dimension
          return ppos[dim];
        }
      }
    } else if (!setting) {
      return undefined; // for empty collection case
    }

    return this; // chaining
  }
}; // aliases

fn$2.modelPosition = fn$2.point = fn$2.position;
fn$2.modelPositions = fn$2.points = fn$2.positions;
fn$2.renderedPoint = fn$2.renderedPosition;
fn$2.relativePoint = fn$2.relativePosition;
var position = elesfn$j;

var fn$3, elesfn$k;
fn$3 = elesfn$k = {};

elesfn$k.renderedBoundingBox = function (options) {
  var bb = this.boundingBox(options);
  var cy = this.cy();
  var zoom = cy.zoom();
  var pan = cy.pan();
  var x1 = bb.x1 * zoom + pan.x;
  var x2 = bb.x2 * zoom + pan.x;
  var y1 = bb.y1 * zoom + pan.y;
  var y2 = bb.y2 * zoom + pan.y;
  return {
    x1: x1,
    x2: x2,
    y1: y1,
    y2: y2,
    w: x2 - x1,
    h: y2 - y1
  };
};

elesfn$k.dirtyCompoundBoundsCache = function () {
  var cy = this.cy();

  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
    return this;
  }

  this.forEachUp(function (ele) {
    if (ele.isParent()) {
      var _p = ele._private;
      _p.compoundBoundsClean = false;
      _p.bbCache = null;
      ele.emitAndNotify('bounds');
    }
  });
  return this;
};

elesfn$k.updateCompoundBounds = function () {
  var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var cy = this.cy(); // not possible to do on non-compound graphs or with the style disabled

  if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {
    return this;
  } // save cycles when batching -- but bounds will be stale (or not exist yet)


  if (!force && cy.batching()) {
    return this;
  }

  function update(parent) {
    if (!parent.isParent()) {
      return;
    }

    var _p = parent._private;
    var children = parent.children();
    var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';
    var min = {
      width: {
        val: parent.pstyle('min-width').pfValue,
        left: parent.pstyle('min-width-bias-left'),
        right: parent.pstyle('min-width-bias-right')
      },
      height: {
        val: parent.pstyle('min-height').pfValue,
        top: parent.pstyle('min-height-bias-top'),
        bottom: parent.pstyle('min-height-bias-bottom')
      }
    };
    var bb = children.boundingBox({
      includeLabels: includeLabels,
      includeOverlays: false,
      // updating the compound bounds happens outside of the regular
      // cache cycle (i.e. before fired events)
      useCache: false
    });
    var pos = _p.position; // if children take up zero area then keep position and fall back on stylesheet w/h

    if (bb.w === 0 || bb.h === 0) {
      bb = {
        w: parent.pstyle('width').pfValue,
        h: parent.pstyle('height').pfValue
      };
      bb.x1 = pos.x - bb.w / 2;
      bb.x2 = pos.x + bb.w / 2;
      bb.y1 = pos.y - bb.h / 2;
      bb.y2 = pos.y + bb.h / 2;
    }

    function computeBiasValues(propDiff, propBias, propBiasComplement) {
      var biasDiff = 0;
      var biasComplementDiff = 0;
      var biasTotal = propBias + propBiasComplement;

      if (propDiff > 0 && biasTotal > 0) {
        biasDiff = propBias / biasTotal * propDiff;
        biasComplementDiff = propBiasComplement / biasTotal * propDiff;
      }

      return {
        biasDiff: biasDiff,
        biasComplementDiff: biasComplementDiff
      };
    }

    function computePaddingValues(width, height, paddingObject, relativeTo) {
      // Assuming percentage is number from 0 to 1
      if (paddingObject.units === '%') {
        switch (relativeTo) {
          case 'width':
            return width > 0 ? paddingObject.pfValue * width : 0;

          case 'height':
            return height > 0 ? paddingObject.pfValue * height : 0;

          case 'average':
            return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;

          case 'min':
            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;

          case 'max':
            return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;

          default:
            return 0;
        }
      } else if (paddingObject.units === 'px') {
        return paddingObject.pfValue;
      } else {
        return 0;
      }
    }

    var leftVal = min.width.left.value;

    if (min.width.left.units === 'px' && min.width.val > 0) {
      leftVal = leftVal * 100 / min.width.val;
    }

    var rightVal = min.width.right.value;

    if (min.width.right.units === 'px' && min.width.val > 0) {
      rightVal = rightVal * 100 / min.width.val;
    }

    var topVal = min.height.top.value;

    if (min.height.top.units === 'px' && min.height.val > 0) {
      topVal = topVal * 100 / min.height.val;
    }

    var bottomVal = min.height.bottom.value;

    if (min.height.bottom.units === 'px' && min.height.val > 0) {
      bottomVal = bottomVal * 100 / min.height.val;
    }

    var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);
    var diffLeft = widthBiasDiffs.biasDiff;
    var diffRight = widthBiasDiffs.biasComplementDiff;
    var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);
    var diffTop = heightBiasDiffs.biasDiff;
    var diffBottom = heightBiasDiffs.biasComplementDiff;
    _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);
    _p.autoWidth = Math.max(bb.w, min.width.val);
    pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;
    _p.autoHeight = Math.max(bb.h, min.height.val);
    pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;
  }

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var _p = ele._private;

    if (!_p.compoundBoundsClean) {
      update(ele);

      if (!cy.batching()) {
        _p.compoundBoundsClean = true;
      }
    }
  }

  return this;
};

var noninf = function noninf(x) {
  if (x === Infinity || x === -Infinity) {
    return 0;
  }

  return x;
};

var updateBounds = function updateBounds(b, x1, y1, x2, y2) {
  // don't update with zero area boxes
  if (x2 - x1 === 0 || y2 - y1 === 0) {
    return;
  } // don't update with null dim


  if (x1 == null || y1 == null || x2 == null || y2 == null) {
    return;
  }

  b.x1 = x1 < b.x1 ? x1 : b.x1;
  b.x2 = x2 > b.x2 ? x2 : b.x2;
  b.y1 = y1 < b.y1 ? y1 : b.y1;
  b.y2 = y2 > b.y2 ? y2 : b.y2;
  b.w = b.x2 - b.x1;
  b.h = b.y2 - b.y1;
};

var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {
  if (b2 == null) {
    return b;
  }

  return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);
};

var prefixedProperty = function prefixedProperty(obj, field, prefix) {
  return getPrefixedProperty(obj, field, prefix);
};

var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {
  if (ele.cy().headless()) {
    return;
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var halfArW = rstyle.arrowWidth / 2;
  var arrowType = ele.pstyle(prefix + '-arrow-shape').value;
  var x;
  var y;

  if (arrowType !== 'none') {
    if (prefix === 'source') {
      x = rstyle.srcX;
      y = rstyle.srcY;
    } else if (prefix === 'target') {
      x = rstyle.tgtX;
      y = rstyle.tgtY;
    } else {
      x = rstyle.midX;
      y = rstyle.midY;
    } // always store the individual arrow bounds


    var bbs = _p.arrowBounds = _p.arrowBounds || {};
    var bb = bbs[prefix] = bbs[prefix] || {};
    bb.x1 = x - halfArW;
    bb.y1 = y - halfArW;
    bb.x2 = x + halfArW;
    bb.y2 = y + halfArW;
    bb.w = bb.x2 - bb.x1;
    bb.h = bb.y2 - bb.y1;
    expandBoundingBox(bb, 1);
    updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);
  }
};

var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {
  if (ele.cy().headless()) {
    return;
  }

  var prefixDash;

  if (prefix) {
    prefixDash = prefix + '-';
  } else {
    prefixDash = '';
  }

  var _p = ele._private;
  var rstyle = _p.rstyle;
  var label = ele.pstyle(prefixDash + 'label').strValue;

  if (label) {
    var halign = ele.pstyle('text-halign');
    var valign = ele.pstyle('text-valign');
    var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);
    var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);
    var labelX = prefixedProperty(rstyle, 'labelX', prefix);
    var labelY = prefixedProperty(rstyle, 'labelY', prefix);
    var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;
    var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;
    var isEdge = ele.isEdge();
    var rotation = ele.pstyle(prefixDash + 'text-rotation');
    var outlineWidth = ele.pstyle('text-outline-width').pfValue;
    var borderWidth = ele.pstyle('text-border-width').pfValue;
    var halfBorderWidth = borderWidth / 2;
    var padding = ele.pstyle('text-background-padding').pfValue;
    var lh = labelHeight;
    var lw = labelWidth;
    var lw_2 = lw / 2;
    var lh_2 = lh / 2;
    var lx1, lx2, ly1, ly2;

    if (isEdge) {
      lx1 = labelX - lw_2;
      lx2 = labelX + lw_2;
      ly1 = labelY - lh_2;
      ly2 = labelY + lh_2;
    } else {
      switch (halign.value) {
        case 'left':
          lx1 = labelX - lw;
          lx2 = labelX;
          break;

        case 'center':
          lx1 = labelX - lw_2;
          lx2 = labelX + lw_2;
          break;

        case 'right':
          lx1 = labelX;
          lx2 = labelX + lw;
          break;
      }

      switch (valign.value) {
        case 'top':
          ly1 = labelY - lh;
          ly2 = labelY;
          break;

        case 'center':
          ly1 = labelY - lh_2;
          ly2 = labelY + lh_2;
          break;

        case 'bottom':
          ly1 = labelY;
          ly2 = labelY + lh;
          break;
      }
    } // shift by margin and expand by outline and border


    lx1 += marginX - Math.max(outlineWidth, halfBorderWidth) - padding;
    lx2 += marginX + Math.max(outlineWidth, halfBorderWidth) + padding;
    ly1 += marginY - Math.max(outlineWidth, halfBorderWidth) - padding;
    ly2 += marginY + Math.max(outlineWidth, halfBorderWidth) + padding; // always store the unrotated label bounds separately

    var bbPrefix = prefix || 'main';
    var bbs = _p.labelBounds;
    var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};
    bb.x1 = lx1;
    bb.y1 = ly1;
    bb.x2 = lx2;
    bb.y2 = ly2;
    bb.w = lx2 - lx1;
    bb.h = ly2 - ly1;
    expandBoundingBox(bb, 1); // expand to work around browser dimension inaccuracies

    var isAutorotate = isEdge && rotation.strValue === 'autorotate';
    var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;

    if (isAutorotate || isPfValue) {
      var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;
      var cos = Math.cos(theta);
      var sin = Math.sin(theta); // rotation point (default value for center-center)

      var xo = (lx1 + lx2) / 2;
      var yo = (ly1 + ly2) / 2;

      if (!isEdge) {
        switch (halign.value) {
          case 'left':
            xo = lx2;
            break;

          case 'right':
            xo = lx1;
            break;
        }

        switch (valign.value) {
          case 'top':
            yo = ly2;
            break;

          case 'bottom':
            yo = ly1;
            break;
        }
      }

      var rotate = function rotate(x, y) {
        x = x - xo;
        y = y - yo;
        return {
          x: x * cos - y * sin + xo,
          y: x * sin + y * cos + yo
        };
      };

      var px1y1 = rotate(lx1, ly1);
      var px1y2 = rotate(lx1, ly2);
      var px2y1 = rotate(lx2, ly1);
      var px2y2 = rotate(lx2, ly2);
      lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
      lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);
      ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
      ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);
    }

    var bbPrefixRot = bbPrefix + 'Rot';
    var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};
    bbRot.x1 = lx1;
    bbRot.y1 = ly1;
    bbRot.x2 = lx2;
    bbRot.y2 = ly2;
    bbRot.w = lx2 - lx1;
    bbRot.h = ly2 - ly1;
    updateBounds(bounds, lx1, ly1, lx2, ly2);
    updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);
  }

  return bounds;
}; // get the bounding box of the elements (in raw model position)


var boundingBoxImpl = function boundingBoxImpl(ele, options) {
  var cy = ele._private.cy;
  var styleEnabled = cy.styleEnabled();
  var headless = cy.headless();
  var bounds = makeBoundingBox();
  var _p = ele._private;
  var isNode = ele.isNode();
  var isEdge = ele.isEdge();
  var ex1, ex2, ey1, ey2; // extrema of body / lines

  var x, y; // node pos

  var rstyle = _p.rstyle;
  var manualExpansion = isNode && styleEnabled ? ele.pstyle('bounds-expansion').pfValue : [0]; // must use `display` prop only, as reading `compound.width()` causes recursion
  // (other factors like width values will be considered later in this function anyway)

  var isDisplayed = function isDisplayed(ele) {
    return ele.pstyle('display').value !== 'none';
  };

  var displayed = !styleEnabled || isDisplayed(ele) // must take into account connected nodes b/c of implicit edge hiding on display:none node
  && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));

  if (displayed) {
    // displayed suffices, since we will find zero area eles anyway
    var overlayOpacity = 0;
    var overlayPadding = 0;

    if (styleEnabled && options.includeOverlays) {
      overlayOpacity = ele.pstyle('overlay-opacity').value;

      if (overlayOpacity !== 0) {
        overlayPadding = ele.pstyle('overlay-padding').value;
      }
    }

    var w = 0;
    var wHalf = 0;

    if (styleEnabled) {
      w = ele.pstyle('width').pfValue;
      wHalf = w / 2;
    }

    if (isNode && options.includeNodes) {
      var pos = ele.position();
      x = pos.x;
      y = pos.y;

      var _w = ele.outerWidth();

      var halfW = _w / 2;
      var h = ele.outerHeight();
      var halfH = h / 2; // handle node dimensions
      /////////////////////////

      ex1 = x - halfW;
      ex2 = x + halfW;
      ey1 = y - halfH;
      ey2 = y + halfH;
      updateBounds(bounds, ex1, ey1, ex2, ey2);
    } else if (isEdge && options.includeEdges) {
      if (styleEnabled && !headless) {
        var curveStyle = ele.pstyle('curve-style').strValue; // handle edge dimensions (rough box estimate)
        //////////////////////////////////////////////

        ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);
        ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);
        ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);
        ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY); // take into account edge width

        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;
        updateBounds(bounds, ex1, ey1, ex2, ey2); // precise edges
        ////////////////

        if (curveStyle === 'haystack') {
          var hpts = rstyle.haystackPts;

          if (hpts && hpts.length === 2) {
            ex1 = hpts[0].x;
            ey1 = hpts[0].y;
            ex2 = hpts[1].x;
            ey2 = hpts[1].y;

            if (ex1 > ex2) {
              var temp = ex1;
              ex1 = ex2;
              ex2 = temp;
            }

            if (ey1 > ey2) {
              var _temp = ey1;
              ey1 = ey2;
              ey2 = _temp;
            }

            updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);
          }
        } else if (curveStyle === 'bezier' || curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'taxi') {
          var pts;

          switch (curveStyle) {
            case 'bezier':
            case 'unbundled-bezier':
              pts = rstyle.bezierPts;
              break;

            case 'segments':
            case 'taxi':
              pts = rstyle.linePts;
              break;
          }

          if (pts != null) {
            for (var j = 0; j < pts.length; j++) {
              var pt = pts[j];
              ex1 = pt.x - wHalf;
              ex2 = pt.x + wHalf;
              ey1 = pt.y - wHalf;
              ey2 = pt.y + wHalf;
              updateBounds(bounds, ex1, ey1, ex2, ey2);
            }
          }
        } // bezier-like or segment-like edge

      } else {
        // headless or style disabled
        // fallback on source and target positions
        //////////////////////////////////////////
        var n1 = ele.source();
        var n1pos = n1.position();
        var n2 = ele.target();
        var n2pos = n2.position();
        ex1 = n1pos.x;
        ex2 = n2pos.x;
        ey1 = n1pos.y;
        ey2 = n2pos.y;

        if (ex1 > ex2) {
          var _temp2 = ex1;
          ex1 = ex2;
          ex2 = _temp2;
        }

        if (ey1 > ey2) {
          var _temp3 = ey1;
          ey1 = ey2;
          ey2 = _temp3;
        } // take into account edge width


        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;
        updateBounds(bounds, ex1, ey1, ex2, ey2);
      } // headless or style disabled

    } // edges
    // handle edge arrow size
    /////////////////////////


    if (styleEnabled && options.includeEdges && isEdge) {
      updateBoundsFromArrow(bounds, ele, 'mid-source');
      updateBoundsFromArrow(bounds, ele, 'mid-target');
      updateBoundsFromArrow(bounds, ele, 'source');
      updateBoundsFromArrow(bounds, ele, 'target');
    } // ghost
    ////////


    if (styleEnabled) {
      var ghost = ele.pstyle('ghost').value === 'yes';

      if (ghost) {
        var gx = ele.pstyle('ghost-offset-x').pfValue;
        var gy = ele.pstyle('ghost-offset-y').pfValue;
        updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);
      }
    } // always store the body bounds separately from the labels


    var bbBody = _p.bodyBounds = _p.bodyBounds || {};
    assignBoundingBox(bbBody, bounds);
    expandBoundingBoxSides(bbBody, manualExpansion);
    expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies
    // overlay
    //////////

    if (styleEnabled) {
      ex1 = bounds.x1;
      ex2 = bounds.x2;
      ey1 = bounds.y1;
      ey2 = bounds.y2;
      updateBounds(bounds, ex1 - overlayPadding, ey1 - overlayPadding, ex2 + overlayPadding, ey2 + overlayPadding);
    } // always store the body bounds separately from the labels


    var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};
    assignBoundingBox(bbOverlay, bounds);
    expandBoundingBoxSides(bbOverlay, manualExpansion);
    expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies
    // handle label dimensions
    //////////////////////////

    var bbLabels = _p.labelBounds = _p.labelBounds || {};

    if (bbLabels.all != null) {
      clearBoundingBox(bbLabels.all);
    } else {
      bbLabels.all = makeBoundingBox();
    }

    if (styleEnabled && options.includeLabels) {
      if (options.includeMainLabels) {
        updateBoundsFromLabel(bounds, ele, null);
      }

      if (isEdge) {
        if (options.includeSourceLabels) {
          updateBoundsFromLabel(bounds, ele, 'source');
        }

        if (options.includeTargetLabels) {
          updateBoundsFromLabel(bounds, ele, 'target');
        }
      }
    } // style enabled for labels

  } // if displayed


  bounds.x1 = noninf(bounds.x1);
  bounds.y1 = noninf(bounds.y1);
  bounds.x2 = noninf(bounds.x2);
  bounds.y2 = noninf(bounds.y2);
  bounds.w = noninf(bounds.x2 - bounds.x1);
  bounds.h = noninf(bounds.y2 - bounds.y1);

  if (bounds.w > 0 && bounds.h > 0 && displayed) {
    expandBoundingBoxSides(bounds, manualExpansion); // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides

    expandBoundingBox(bounds, 1);
  }

  return bounds;
};

var getKey = function getKey(opts) {
  var i = 0;

  var tf = function tf(val) {
    return (val ? 1 : 0) << i++;
  };

  var key = 0;
  key += tf(opts.incudeNodes);
  key += tf(opts.includeEdges);
  key += tf(opts.includeLabels);
  key += tf(opts.includeMainLabels);
  key += tf(opts.includeSourceLabels);
  key += tf(opts.includeTargetLabels);
  key += tf(opts.includeOverlays);
  return key;
};

var getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {
  if (ele.isEdge()) {
    var p1 = ele.source().position();
    var p2 = ele.target().position();

    var r = function r(x) {
      return Math.round(x);
    };

    return hashIntsArray([r(p1.x), r(p1.y), r(p2.x), r(p2.y)]);
  } else {
    return 0;
  }
};

var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {
  var _p = ele._private;
  var bb;
  var isEdge = ele.isEdge();
  var key = opts == null ? defBbOptsKey : getKey(opts);
  var usingDefOpts = key === defBbOptsKey;
  var currPosKey = getBoundingBoxPosKey(ele);
  var isPosKeySame = _p.bbCachePosKey === currPosKey;
  var useCache = opts.useCache && isPosKeySame;

  var isDirty = function isDirty(ele) {
    return ele._private.bbCache == null;
  };

  var needRecalc = !useCache || isDirty(ele) || isEdge && isDirty(ele.source()) || isDirty(ele.target());

  if (needRecalc) {
    if (!isPosKeySame) {
      ele.recalculateRenderedStyle();
    }

    bb = boundingBoxImpl(ele, defBbOpts);
    _p.bbCache = bb;
    _p.bbCacheShift.x = _p.bbCacheShift.y = 0;
    _p.bbCachePosKey = currPosKey;
  } else {
    bb = _p.bbCache;
  }

  if (!needRecalc && (_p.bbCacheShift.x !== 0 || _p.bbCacheShift.y !== 0)) {
    var shift = assignShiftToBoundingBox;
    var delta = _p.bbCacheShift;

    var safeShift = function safeShift(bb, delta) {
      if (bb != null) {
        shift(bb, delta);
      }
    };

    shift(bb, delta);
    var bodyBounds = _p.bodyBounds,
        overlayBounds = _p.overlayBounds,
        labelBounds = _p.labelBounds,
        arrowBounds = _p.arrowBounds;
    safeShift(bodyBounds, delta);
    safeShift(overlayBounds, delta);

    if (arrowBounds != null) {
      safeShift(arrowBounds.source, delta);
      safeShift(arrowBounds.target, delta);
      safeShift(arrowBounds['mid-source'], delta);
      safeShift(arrowBounds['mid-target'], delta);
    }

    if (labelBounds != null) {
      safeShift(labelBounds.main, delta);
      safeShift(labelBounds.all, delta);
      safeShift(labelBounds.source, delta);
      safeShift(labelBounds.target, delta);
    }
  } // always reset the shift, because we either applied the shift or cleared it by doing a fresh recalc


  _p.bbCacheShift.x = _p.bbCacheShift.y = 0; // not using def opts => need to build up bb from combination of sub bbs

  if (!usingDefOpts) {
    var isNode = ele.isNode();
    bb = makeBoundingBox();

    if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {
      if (opts.includeOverlays) {
        updateBoundsFromBox(bb, _p.overlayBounds);
      } else {
        updateBoundsFromBox(bb, _p.bodyBounds);
      }
    }

    if (opts.includeLabels) {
      if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {
        updateBoundsFromBox(bb, _p.labelBounds.all);
      } else {
        if (opts.includeMainLabels) {
          updateBoundsFromBox(bb, _p.labelBounds.mainRot);
        }

        if (opts.includeSourceLabels) {
          updateBoundsFromBox(bb, _p.labelBounds.sourceRot);
        }

        if (opts.includeTargetLabels) {
          updateBoundsFromBox(bb, _p.labelBounds.targetRot);
        }
      }
    }

    bb.w = bb.x2 - bb.x1;
    bb.h = bb.y2 - bb.y1;
  }

  return bb;
};

var defBbOpts = {
  includeNodes: true,
  includeEdges: true,
  includeLabels: true,
  includeMainLabels: true,
  includeSourceLabels: true,
  includeTargetLabels: true,
  includeOverlays: true,
  useCache: true
};
var defBbOptsKey = getKey(defBbOpts);
var filledBbOpts = defaults(defBbOpts);

elesfn$k.boundingBox = function (options) {
  var bounds; // the main usecase is ele.boundingBox() for a single element with no/def options
  // specified s.t. the cache is used, so check for this case to make it faster by
  // avoiding the overhead of the rest of the function

  if (this.length === 1 && this[0]._private.bbCache != null && (options === undefined || options.useCache === undefined || options.useCache === true)) {
    if (options === undefined) {
      options = defBbOpts;
    } else {
      options = filledBbOpts(options);
    }

    bounds = cachedBoundingBoxImpl(this[0], options);
  } else {
    bounds = makeBoundingBox();
    options = options || defBbOpts;
    var opts = filledBbOpts(options);
    var eles = this;
    var cy = eles.cy();
    var styleEnabled = cy.styleEnabled();

    if (styleEnabled) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var _p = ele._private;
        var currPosKey = getBoundingBoxPosKey(ele);
        var isPosKeySame = _p.bbCachePosKey === currPosKey;
        var useCache = opts.useCache && isPosKeySame;
        ele.recalculateRenderedStyle(useCache);
      }
    }

    this.updateCompoundBounds();

    for (var _i = 0; _i < eles.length; _i++) {
      var _ele = eles[_i];
      updateBoundsFromBox(bounds, cachedBoundingBoxImpl(_ele, opts));
    }
  }

  bounds.x1 = noninf(bounds.x1);
  bounds.y1 = noninf(bounds.y1);
  bounds.x2 = noninf(bounds.x2);
  bounds.y2 = noninf(bounds.y2);
  bounds.w = noninf(bounds.x2 - bounds.x1);
  bounds.h = noninf(bounds.y2 - bounds.y1);
  return bounds;
};

elesfn$k.dirtyBoundingBoxCache = function () {
  for (var i = 0; i < this.length; i++) {
    var _p = this[i]._private;
    _p.bbCache = null;
    _p.bbCacheShift.x = _p.bbCacheShift.y = 0;
    _p.bbCachePosKey = null;
    _p.bodyBounds = null;
    _p.overlayBounds = null;
    _p.labelBounds.all = null;
    _p.labelBounds.source = null;
    _p.labelBounds.target = null;
    _p.labelBounds.main = null;
    _p.labelBounds.sourceRot = null;
    _p.labelBounds.targetRot = null;
    _p.labelBounds.mainRot = null;
    _p.arrowBounds.source = null;
    _p.arrowBounds.target = null;
    _p.arrowBounds['mid-source'] = null;
    _p.arrowBounds['mid-target'] = null;
  }

  this.emitAndNotify('bounds');
  return this;
};

elesfn$k.shiftCachedBoundingBox = function (delta) {
  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var _p = ele._private;
    var bb = _p.bbCache;

    if (bb != null) {
      _p.bbCacheShift.x += delta.x;
      _p.bbCacheShift.y += delta.y;
    }
  }

  this.emitAndNotify('bounds');
  return this;
}; // private helper to get bounding box for custom node positions
// - good for perf in certain cases but currently requires dirtying the rendered style
// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...
// - try to use for only things like discrete layouts where the node position would change anyway


elesfn$k.boundingBoxAt = function (fn) {
  var nodes = this.nodes();
  var cy = this.cy();
  var hasCompoundNodes = cy.hasCompoundNodes();

  if (hasCompoundNodes) {
    nodes = nodes.filter(function (node) {
      return !node.isParent();
    });
  }

  if (plainObject(fn)) {
    var obj = fn;

    fn = function fn() {
      return obj;
    };
  }

  var storeOldPos = function storeOldPos(node, i) {
    return node._private.bbAtOldPos = fn(node, i);
  };

  var getOldPos = function getOldPos(node) {
    return node._private.bbAtOldPos;
  };

  cy.startBatch();
  nodes.forEach(storeOldPos).silentPositions(fn);

  if (hasCompoundNodes) {
    this.updateCompoundBounds(true); // force update b/c we're inside a batch cycle
  }

  var bb = copyBoundingBox(this.boundingBox({
    useCache: false
  }));
  nodes.silentPositions(getOldPos);
  cy.endBatch();
  return bb;
};

fn$3.boundingbox = fn$3.bb = fn$3.boundingBox;
fn$3.renderedBoundingbox = fn$3.renderedBoundingBox;
var bounds = elesfn$k;

var fn$4, elesfn$l;
fn$4 = elesfn$l = {};

var defineDimFns = function defineDimFns(opts) {
  opts.uppercaseName = capitalize(opts.name);
  opts.autoName = 'auto' + opts.uppercaseName;
  opts.labelName = 'label' + opts.uppercaseName;
  opts.outerName = 'outer' + opts.uppercaseName;
  opts.uppercaseOuterName = capitalize(opts.outerName);

  fn$4[opts.name] = function dimImpl() {
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if (ele) {
      if (styleEnabled) {
        if (ele.isParent()) {
          ele.updateCompoundBounds();
          return _p[opts.autoName] || 0;
        }

        var d = ele.pstyle(opts.name);

        switch (d.strValue) {
          case 'label':
            ele.recalculateRenderedStyle();
            return _p.rstyle[opts.labelName] || 0;

          default:
            return d.pfValue;
        }
      } else {
        return 1;
      }
    }
  };

  fn$4['outer' + opts.uppercaseName] = function outerDimImpl() {
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if (ele) {
      if (styleEnabled) {
        var dim = ele[opts.name]();
        var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side

        var padding = 2 * ele.padding();
        return dim + border + padding;
      } else {
        return 1;
      }
    }
  };

  fn$4['rendered' + opts.uppercaseName] = function renderedDimImpl() {
    var ele = this[0];

    if (ele) {
      var d = ele[opts.name]();
      return d * this.cy().zoom();
    }
  };

  fn$4['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {
    var ele = this[0];

    if (ele) {
      var od = ele[opts.outerName]();
      return od * this.cy().zoom();
    }
  };
};

defineDimFns({
  name: 'width'
});
defineDimFns({
  name: 'height'
});

elesfn$l.padding = function () {
  var ele = this[0];
  var _p = ele._private;

  if (ele.isParent()) {
    ele.updateCompoundBounds();

    if (_p.autoPadding !== undefined) {
      return _p.autoPadding;
    } else {
      return ele.pstyle('padding').pfValue;
    }
  } else {
    return ele.pstyle('padding').pfValue;
  }
};

elesfn$l.paddedHeight = function () {
  var ele = this[0];
  return ele.height() + 2 * ele.padding();
};

elesfn$l.paddedWidth = function () {
  var ele = this[0];
  return ele.width() + 2 * ele.padding();
};

var widthHeight = elesfn$l;

var ifEdge = function ifEdge(ele, getValue) {
  if (ele.isEdge()) {
    return getValue(ele);
  }
};

var ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {
  if (ele.isEdge()) {
    var cy = ele.cy();
    return modelToRenderedPosition(getPoint(ele), cy.zoom(), cy.pan());
  }
};

var ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {
  if (ele.isEdge()) {
    var cy = ele.cy();
    var pan = cy.pan();
    var zoom = cy.zoom();
    return getPoints(ele).map(function (p) {
      return modelToRenderedPosition(p, zoom, pan);
    });
  }
};

var controlPoints = function controlPoints(ele) {
  return ele.renderer().getControlPoints(ele);
};

var segmentPoints = function segmentPoints(ele) {
  return ele.renderer().getSegmentPoints(ele);
};

var sourceEndpoint = function sourceEndpoint(ele) {
  return ele.renderer().getSourceEndpoint(ele);
};

var targetEndpoint = function targetEndpoint(ele) {
  return ele.renderer().getTargetEndpoint(ele);
};

var midpoint = function midpoint(ele) {
  return ele.renderer().getEdgeMidpoint(ele);
};

var pts = {
  controlPoints: {
    get: controlPoints,
    mult: true
  },
  segmentPoints: {
    get: segmentPoints,
    mult: true
  },
  sourceEndpoint: {
    get: sourceEndpoint
  },
  targetEndpoint: {
    get: targetEndpoint
  },
  midpoint: {
    get: midpoint
  }
};

var renderedName = function renderedName(name) {
  return 'rendered' + name[0].toUpperCase() + name.substr(1);
};

var edgePoints = Object.keys(pts).reduce(function (obj, name) {
  var spec = pts[name];
  var rName = renderedName(name);

  obj[name] = function () {
    return ifEdge(this, spec.get);
  };

  if (spec.mult) {
    obj[rName] = function () {
      return ifEdgeRenderedPositions(this, spec.get);
    };
  } else {
    obj[rName] = function () {
      return ifEdgeRenderedPosition(this, spec.get);
    };
  }

  return obj;
}, {});

var dimensions = extend({}, position, bounds, widthHeight, edgePoints);

/*!
Event object based on jQuery events, MIT license

https://jquery.org/license/
https://tldrlegal.com/license/mit-license
https://github.com/jquery/jquery/blob/master/src/event.js
*/
var Event = function Event(src, props) {
  this.recycle(src, props);
};

function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
} // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


Event.prototype = {
  instanceString: function instanceString() {
    return 'event';
  },
  recycle: function recycle(src, props) {
    this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;

    if (src != null && src.preventDefault) {
      // Browser Event object
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;
    } else if (src != null && src.type) {
      // Plain object containing all event details
      props = src;
    } else {
      // Event string
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props != null) {
      // more efficient to manually copy fields we use
      this.originalEvent = props.originalEvent;
      this.type = props.type != null ? props.type : this.type;
      this.cy = props.cy;
      this.target = props.target;
      this.position = props.position;
      this.renderedPosition = props.renderedPosition;
      this.namespace = props.namespace;
      this.layout = props.layout;
    }

    if (this.cy != null && this.position != null && this.renderedPosition == null) {
      // create a rendered position based on the passed position
      var pos = this.position;
      var zoom = this.cy.zoom();
      var pan = this.cy.pan();
      this.renderedPosition = {
        x: pos.x * zoom + pan.x,
        y: pos.y * zoom + pan.y
      };
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || Date.now();
  },
  preventDefault: function preventDefault() {
    this.isDefaultPrevented = returnTrue;
    var e = this.originalEvent;

    if (!e) {
      return;
    } // if preventDefault exists run it on the original event


    if (e.preventDefault) {
      e.preventDefault();
    }
  },
  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = returnTrue;
    var e = this.originalEvent;

    if (!e) {
      return;
    } // if stopPropagation exists run it on the original event


    if (e.stopPropagation) {
      e.stopPropagation();
    }
  },
  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

var eventRegex = /^([^.]+)(\.(?:[^.]+))?$/; // regex for matching event strings (e.g. "click.namespace")

var universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally

var defaults$8 = {
  qualifierCompare: function qualifierCompare(q1, q2) {
    return q1 === q2;
  },
  eventMatches: function eventMatches()
  /*context, listener, eventObj*/
  {
    return true;
  },
  addEventFields: function addEventFields()
  /*context, evt*/
  {},
  callbackContext: function callbackContext(context
  /*, listener, eventObj*/
  ) {
    return context;
  },
  beforeEmit: function beforeEmit()
  /* context, listener, eventObj */
  {},
  afterEmit: function afterEmit()
  /* context, listener, eventObj */
  {},
  bubble: function bubble()
  /*context*/
  {
    return false;
  },
  parent: function parent()
  /*context*/
  {
    return null;
  },
  context: null
};
var defaultsKeys = Object.keys(defaults$8);
var emptyOpts = {};

function Emitter() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;
  var context = arguments.length > 1 ? arguments[1] : undefined;

  // micro-optimisation vs Object.assign() -- reduces Element instantiation time
  for (var i = 0; i < defaultsKeys.length; i++) {
    var key = defaultsKeys[i];
    this[key] = opts[key] || defaults$8[key];
  }

  this.context = context || this.context;
  this.listeners = [];
  this.emitting = 0;
}

var p = Emitter.prototype;

var forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {
  if (fn(qualifier)) {
    callback = qualifier;
    qualifier = null;
  }

  if (confOverrides) {
    if (conf == null) {
      conf = confOverrides;
    } else {
      conf = extend({}, conf, confOverrides);
    }
  }

  var eventList = array(events) ? events : events.split(/\s+/);

  for (var i = 0; i < eventList.length; i++) {
    var evt = eventList[i];

    if (emptyString(evt)) {
      continue;
    }

    var match = evt.match(eventRegex); // type[.namespace]

    if (match) {
      var type = match[1];
      var namespace = match[2] ? match[2] : null;
      var ret = handler(self, evt, type, namespace, qualifier, callback, conf);

      if (ret === false) {
        break;
      } // allow exiting early

    }
  }
};

var makeEventObj = function makeEventObj(self, obj) {
  self.addEventFields(self.context, obj);
  return new Event(obj.type, obj);
};

var forEachEventObj = function forEachEventObj(self, handler, events) {
  if (event(events)) {
    handler(self, events);
    return;
  } else if (plainObject(events)) {
    handler(self, makeEventObj(self, events));
    return;
  }

  var eventList = array(events) ? events : events.split(/\s+/);

  for (var i = 0; i < eventList.length; i++) {
    var evt = eventList[i];

    if (emptyString(evt)) {
      continue;
    }

    var match = evt.match(eventRegex); // type[.namespace]

    if (match) {
      var type = match[1];
      var namespace = match[2] ? match[2] : null;
      var eventObj = makeEventObj(self, {
        type: type,
        namespace: namespace,
        target: self.context
      });
      handler(self, eventObj);
    }
  }
};

p.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {
  forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {
    if (fn(callback)) {
      self.listeners.push({
        event: event,
        // full event string
        callback: callback,
        // callback to run
        type: type,
        // the event type (e.g. 'click')
        namespace: namespace,
        // the event namespace (e.g. ".foo")
        qualifier: qualifier,
        // a restriction on whether to match this emitter
        conf: conf // additional configuration

      });
    }
  }, events, qualifier, callback, conf, confOverrides);
  return this;
};

p.one = function (events, qualifier, callback, conf) {
  return this.on(events, qualifier, callback, conf, {
    one: true
  });
};

p.removeListener = p.off = function (events, qualifier, callback, conf) {
  var _this = this;

  if (this.emitting !== 0) {
    this.listeners = copyArray(this.listeners);
  }

  var listeners = this.listeners;

  var _loop = function _loop(i) {
    var listener = listeners[i];
    forEachEvent(_this, function (self, event, type, namespace, qualifier, callback
    /*, conf*/
    ) {
      if ((listener.type === type || events === '*') && (!namespace && listener.namespace !== '.*' || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {
        listeners.splice(i, 1);
        return false;
      }
    }, events, qualifier, callback, conf);
  };

  for (var i = listeners.length - 1; i >= 0; i--) {
    _loop(i);
  }

  return this;
};

p.removeAllListeners = function () {
  return this.removeListener('*');
};

p.emit = p.trigger = function (events, extraParams, manualCallback) {
  var listeners = this.listeners;
  var numListenersBeforeEmit = listeners.length;
  this.emitting++;

  if (!array(extraParams)) {
    extraParams = [extraParams];
  }

  forEachEventObj(this, function (self, eventObj) {
    if (manualCallback != null) {
      listeners = [{
        event: eventObj.event,
        type: eventObj.type,
        namespace: eventObj.namespace,
        callback: manualCallback
      }];
      numListenersBeforeEmit = listeners.length;
    }

    var _loop2 = function _loop2(i) {
      var listener = listeners[i];

      if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {
        var args = [eventObj];

        if (extraParams != null) {
          push(args, extraParams);
        }

        self.beforeEmit(self.context, listener, eventObj);

        if (listener.conf && listener.conf.one) {
          self.listeners = self.listeners.filter(function (l) {
            return l !== listener;
          });
        }

        var context = self.callbackContext(self.context, listener, eventObj);
        var ret = listener.callback.apply(context, args);
        self.afterEmit(self.context, listener, eventObj);

        if (ret === false) {
          eventObj.stopPropagation();
          eventObj.preventDefault();
        }
      } // if listener matches

    };

    for (var i = 0; i < numListenersBeforeEmit; i++) {
      _loop2(i);
    } // for listener


    if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {
      self.parent(self.context).emit(eventObj, extraParams);
    }
  }, events);
  this.emitting--;
  return this;
};

var emitterOptions = {
  qualifierCompare: function qualifierCompare(selector1, selector2) {
    if (selector1 == null || selector2 == null) {
      return selector1 == null && selector2 == null;
    } else {
      return selector1.sameText(selector2);
    }
  },
  eventMatches: function eventMatches(ele, listener, eventObj) {
    var selector = listener.qualifier;

    if (selector != null) {
      return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
    }

    return true;
  },
  addEventFields: function addEventFields(ele, evt) {
    evt.cy = ele.cy();
    evt.target = ele;
  },
  callbackContext: function callbackContext(ele, listener, eventObj) {
    return listener.qualifier != null ? eventObj.target : ele;
  },
  beforeEmit: function beforeEmit(context, listener
  /*, eventObj*/
  ) {
    if (listener.conf && listener.conf.once) {
      listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);
    }
  },
  bubble: function bubble() {
    return true;
  },
  parent: function parent(ele) {
    return ele.isChild() ? ele.parent() : ele.cy();
  }
};

var argSelector = function argSelector(arg) {
  if (string(arg)) {
    return new Selector(arg);
  } else {
    return arg;
  }
};

var elesfn$m = {
  createEmitter: function createEmitter() {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var _p = ele._private;

      if (!_p.emitter) {
        _p.emitter = new Emitter(emitterOptions, ele);
      }
    }

    return this;
  },
  emitter: function emitter() {
    return this._private.emitter;
  },
  on: function on(events, selector, callback) {
    var argSel = argSelector(selector);

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().on(events, argSel, callback);
    }

    return this;
  },
  removeListener: function removeListener(events, selector, callback) {
    var argSel = argSelector(selector);

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().removeListener(events, argSel, callback);
    }

    return this;
  },
  removeAllListeners: function removeAllListeners() {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().removeAllListeners();
    }

    return this;
  },
  one: function one(events, selector, callback) {
    var argSel = argSelector(selector);

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().one(events, argSel, callback);
    }

    return this;
  },
  once: function once(events, selector, callback) {
    var argSel = argSelector(selector);

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().on(events, argSel, callback, {
        once: true,
        onceCollection: this
      });
    }
  },
  emit: function emit(events, extraParams) {
    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      ele.emitter().emit(events, extraParams);
    }

    return this;
  },
  emitAndNotify: function emitAndNotify(event, extraParams) {
    // for internal use only
    if (this.length === 0) {
      return;
    } // empty collections don't need to notify anything
    // notify renderer


    this.cy().notify(event, this);
    this.emit(event, extraParams);
    return this;
  }
};
define$3.eventAliasesOn(elesfn$m);

var elesfn$n = {
  nodes: function nodes(selector) {
    return this.filter(function (ele) {
      return ele.isNode();
    }).filter(selector);
  },
  edges: function edges(selector) {
    return this.filter(function (ele) {
      return ele.isEdge();
    }).filter(selector);
  },
  // internal helper to get nodes and edges as separate collections with single iteration over elements
  byGroup: function byGroup() {
    var nodes = this.spawn();
    var edges = this.spawn();

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];

      if (ele.isNode()) {
        nodes.merge(ele);
      } else {
        edges.merge(ele);
      }
    }

    return {
      nodes: nodes,
      edges: edges
    };
  },
  filter: function filter(_filter, thisArg) {
    if (_filter === undefined) {
      // check this first b/c it's the most common/performant case
      return this;
    } else if (string(_filter) || elementOrCollection(_filter)) {
      return new Selector(_filter).filter(this);
    } else if (fn(_filter)) {
      var filterEles = this.spawn();
      var eles = this;

      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);

        if (include) {
          filterEles.merge(ele);
        }
      }

      return filterEles;
    }

    return this.spawn(); // if not handled by above, give 'em an empty collection
  },
  not: function not(toRemove) {
    if (!toRemove) {
      return this;
    } else {
      if (string(toRemove)) {
        toRemove = this.filter(toRemove);
      }

      var elements = [];
      var rMap = toRemove._private.map;

      for (var i = 0; i < this.length; i++) {
        var element = this[i];
        var remove = rMap.has(element.id());

        if (!remove) {
          elements.push(element);
        }
      }

      return this.spawn(elements);
    }
  },
  absoluteComplement: function absoluteComplement() {
    var cy = this.cy();
    return cy.mutableElements().not(this);
  },
  intersect: function intersect(other) {
    // if a selector is specified, then filter by it instead
    if (string(other)) {
      var selector = other;
      return this.filter(selector);
    }

    var elements = [];
    var col1 = this;
    var col2 = other;
    var col1Smaller = this.length < other.length;
    var map2 = col1Smaller ? col2._private.map : col1._private.map;
    var col = col1Smaller ? col1 : col2;

    for (var i = 0; i < col.length; i++) {
      var id = col[i]._private.data.id;
      var entry = map2.get(id);

      if (entry) {
        elements.push(entry.ele);
      }
    }

    return this.spawn(elements);
  },
  xor: function xor(other) {
    var cy = this._private.cy;

    if (string(other)) {
      other = cy.$(other);
    }

    var elements = [];
    var col1 = this;
    var col2 = other;

    var add = function add(col, other) {
      for (var i = 0; i < col.length; i++) {
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other.hasElementWithId(id);

        if (!inOther) {
          elements.push(ele);
        }
      }
    };

    add(col1, col2);
    add(col2, col1);
    return this.spawn(elements);
  },
  diff: function diff(other) {
    var cy = this._private.cy;

    if (string(other)) {
      other = cy.$(other);
    }

    var left = [];
    var right = [];
    var both = [];
    var col1 = this;
    var col2 = other;

    var add = function add(col, other, retEles) {
      for (var i = 0; i < col.length; i++) {
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other.hasElementWithId(id);

        if (inOther) {
          both.push(ele);
        } else {
          retEles.push(ele);
        }
      }
    };

    add(col1, col2, left);
    add(col2, col1, right);
    return {
      left: this.spawn(left, {
        unique: true
      }),
      right: this.spawn(right, {
        unique: true
      }),
      both: this.spawn(both, {
        unique: true
      })
    };
  },
  add: function add(toAdd) {
    var cy = this._private.cy;

    if (!toAdd) {
      return this;
    }

    if (string(toAdd)) {
      var selector = toAdd;
      toAdd = cy.mutableElements().filter(selector);
    }

    var elements = [];

    for (var i = 0; i < this.length; i++) {
      elements.push(this[i]);
    }

    var map = this._private.map;

    for (var _i = 0; _i < toAdd.length; _i++) {
      var add = !map.has(toAdd[_i].id());

      if (add) {
        elements.push(toAdd[_i]);
      }
    }

    return this.spawn(elements);
  },
  // in place merge on calling collection
  merge: function merge(toAdd) {
    var _p = this._private;
    var cy = _p.cy;

    if (!toAdd) {
      return this;
    }

    if (toAdd && string(toAdd)) {
      var selector = toAdd;
      toAdd = cy.mutableElements().filter(selector);
    }

    var map = _p.map;

    for (var i = 0; i < toAdd.length; i++) {
      var toAddEle = toAdd[i];
      var id = toAddEle._private.data.id;
      var add = !map.has(id);

      if (add) {
        var index = this.length++;
        this[index] = toAddEle;
        map.set(id, {
          ele: toAddEle,
          index: index
        });
      } else {
        // replace
        var _index = map.get(id).index;
        this[_index] = toAddEle;
        map.set(id, {
          ele: toAddEle,
          index: _index
        });
      }
    }

    return this; // chaining
  },
  unmergeAt: function unmergeAt(i) {
    var ele = this[i];
    var id = ele.id();
    var _p = this._private;
    var map = _p.map; // remove ele

    this[i] = undefined;
    map["delete"](id);
    var unmergedLastEle = i === this.length - 1; // replace empty spot with last ele in collection

    if (this.length > 1 && !unmergedLastEle) {
      var lastEleI = this.length - 1;
      var lastEle = this[lastEleI];
      var lastEleId = lastEle._private.data.id;
      this[lastEleI] = undefined;
      this[i] = lastEle;
      map.set(lastEleId, {
        ele: lastEle,
        index: i
      });
    } // the collection is now 1 ele smaller


    this.length--;
    return this;
  },
  // remove single ele in place in calling collection
  unmergeOne: function unmergeOne(ele) {
    ele = ele[0];
    var _p = this._private;
    var id = ele._private.data.id;
    var map = _p.map;
    var entry = map.get(id);

    if (!entry) {
      return this; // no need to remove
    }

    var i = entry.index;
    this.unmergeAt(i);
    return this;
  },
  // remove eles in place on calling collection
  unmerge: function unmerge(toRemove) {
    var cy = this._private.cy;

    if (!toRemove) {
      return this;
    }

    if (toRemove && string(toRemove)) {
      var selector = toRemove;
      toRemove = cy.mutableElements().filter(selector);
    }

    for (var i = 0; i < toRemove.length; i++) {
      this.unmergeOne(toRemove[i]);
    }

    return this; // chaining
  },
  unmergeBy: function unmergeBy(toRmFn) {
    for (var i = this.length - 1; i >= 0; i--) {
      var ele = this[i];

      if (toRmFn(ele)) {
        this.unmergeAt(i);
      }
    }

    return this;
  },
  map: function map(mapFn, thisArg) {
    var arr = [];
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);
      arr.push(ret);
    }

    return arr;
  },
  reduce: function reduce(fn, initialValue) {
    var val = initialValue;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      val = fn(val, eles[i], i, eles);
    }

    return val;
  },
  max: function max(valFn, thisArg) {
    var max = -Infinity;
    var maxEle;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

      if (val > max) {
        max = val;
        maxEle = ele;
      }
    }

    return {
      value: max,
      ele: maxEle
    };
  },
  min: function min(valFn, thisArg) {
    var min = Infinity;
    var minEle;
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];
      var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);

      if (val < min) {
        min = val;
        minEle = ele;
      }
    }

    return {
      value: min,
      ele: minEle
    };
  }
}; // aliases

var fn$5 = elesfn$n;
fn$5['u'] = fn$5['|'] = fn$5['+'] = fn$5.union = fn$5.or = fn$5.add;
fn$5['\\'] = fn$5['!'] = fn$5['-'] = fn$5.difference = fn$5.relativeComplement = fn$5.subtract = fn$5.not;
fn$5['n'] = fn$5['&'] = fn$5['.'] = fn$5.and = fn$5.intersection = fn$5.intersect;
fn$5['^'] = fn$5['(+)'] = fn$5['(-)'] = fn$5.symmetricDifference = fn$5.symdiff = fn$5.xor;
fn$5.fnFilter = fn$5.filterFn = fn$5.stdFilter = fn$5.filter;
fn$5.complement = fn$5.abscomp = fn$5.absoluteComplement;

var elesfn$o = {
  isNode: function isNode() {
    return this.group() === 'nodes';
  },
  isEdge: function isEdge() {
    return this.group() === 'edges';
  },
  isLoop: function isLoop() {
    return this.isEdge() && this.source()[0] === this.target()[0];
  },
  isSimple: function isSimple() {
    return this.isEdge() && this.source()[0] !== this.target()[0];
  },
  group: function group() {
    var ele = this[0];

    if (ele) {
      return ele._private.group;
    }
  }
};

/**
 *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),
 *  and z-index (low to high).  These styles affect how this applies:
 *
 *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the
 *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from
 *      root to leaves of the compound graph.  The last drawn is `top`.
 *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.
 *      `manual` ignores this convention and draws based on the `z-index` value setting.
 *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher
 *      `z-index` will be drawn on top of an element with a lower `z-index`.
 */

var zIndexSort = function zIndexSort(a, b) {
  var cy = a.cy();
  var hasCompoundNodes = cy.hasCompoundNodes();

  function getDepth(ele) {
    var style = ele.pstyle('z-compound-depth');

    if (style.value === 'auto') {
      return hasCompoundNodes ? ele.zDepth() : 0;
    } else if (style.value === 'bottom') {
      return -1;
    } else if (style.value === 'top') {
      return MAX_INT;
    } // 'orphan'


    return 0;
  }

  var depthDiff = getDepth(a) - getDepth(b);

  if (depthDiff !== 0) {
    return depthDiff;
  }

  function getEleDepth(ele) {
    var style = ele.pstyle('z-index-compare');

    if (style.value === 'auto') {
      return ele.isNode() ? 1 : 0;
    } // 'manual'


    return 0;
  }

  var eleDiff = getEleDepth(a) - getEleDepth(b);

  if (eleDiff !== 0) {
    return eleDiff;
  }

  var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;

  if (zDiff !== 0) {
    return zDiff;
  } // compare indices in the core (order added to graph w/ last on top)


  return a.poolIndex() - b.poolIndex();
};

var elesfn$p = {
  forEach: function forEach(fn$1, thisArg) {
    if (fn(fn$1)) {
      var N = this.length;

      for (var i = 0; i < N; i++) {
        var ele = this[i];
        var ret = thisArg ? fn$1.apply(thisArg, [ele, i, this]) : fn$1(ele, i, this);

        if (ret === false) {
          break;
        } // exit each early on return false

      }
    }

    return this;
  },
  toArray: function toArray() {
    var array = [];

    for (var i = 0; i < this.length; i++) {
      array.push(this[i]);
    }

    return array;
  },
  slice: function slice(start, end) {
    var array = [];
    var thisSize = this.length;

    if (end == null) {
      end = thisSize;
    }

    if (start == null) {
      start = 0;
    }

    if (start < 0) {
      start = thisSize + start;
    }

    if (end < 0) {
      end = thisSize + end;
    }

    for (var i = start; i >= 0 && i < end && i < thisSize; i++) {
      array.push(this[i]);
    }

    return this.spawn(array);
  },
  size: function size() {
    return this.length;
  },
  eq: function eq(i) {
    return this[i] || this.spawn();
  },
  first: function first() {
    return this[0] || this.spawn();
  },
  last: function last() {
    return this[this.length - 1] || this.spawn();
  },
  empty: function empty() {
    return this.length === 0;
  },
  nonempty: function nonempty() {
    return !this.empty();
  },
  sort: function sort(sortFn) {
    if (!fn(sortFn)) {
      return this;
    }

    var sorted = this.toArray().sort(sortFn);
    return this.spawn(sorted);
  },
  sortByZIndex: function sortByZIndex() {
    return this.sort(zIndexSort);
  },
  zDepth: function zDepth() {
    var ele = this[0];

    if (!ele) {
      return undefined;
    } // let cy = ele.cy();


    var _p = ele._private;
    var group = _p.group;

    if (group === 'nodes') {
      var depth = _p.data.parent ? ele.parents().size() : 0;

      if (!ele.isParent()) {
        return MAX_INT - 1; // childless nodes always on top
      }

      return depth;
    } else {
      var src = _p.source;
      var tgt = _p.target;
      var srcDepth = src.zDepth();
      var tgtDepth = tgt.zDepth();
      return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent
    }
  }
};
elesfn$p.each = elesfn$p.forEach;

var getLayoutDimensionOptions = defaults({
  nodeDimensionsIncludeLabels: false
});
var elesfn$q = {
  // Calculates and returns node dimensions { x, y } based on options given
  layoutDimensions: function layoutDimensions(options) {
    options = getLayoutDimensionOptions(options);
    var dims;

    if (!this.takesUpSpace()) {
      dims = {
        w: 0,
        h: 0
      };
    } else if (options.nodeDimensionsIncludeLabels) {
      var bbDim = this.boundingBox();
      dims = {
        w: bbDim.w,
        h: bbDim.h
      };
    } else {
      dims = {
        w: this.outerWidth(),
        h: this.outerHeight()
      };
    } // sanitise the dimensions for external layouts (avoid division by zero)


    if (dims.w === 0 || dims.h === 0) {
      dims.w = dims.h = 1;
    }

    return dims;
  },
  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function layoutPositions(layout, options, fn) {
    var nodes = this.nodes();
    var cy = this.cy();
    var layoutEles = options.eles; // nodes & edges

    var getMemoizeKey = function getMemoizeKey(node) {
      return node.id();
    };

    var fnMem = memoize(fn, getMemoizeKey); // memoized version of position function

    layout.emit({
      type: 'layoutstart',
      layout: layout
    });
    layout.animations = [];

    var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {
      var center = {
        x: nodesBb.x1 + nodesBb.w / 2,
        y: nodesBb.y1 + nodesBb.h / 2
      };
      var spacingVector = {
        // scale from center of bounding box (not necessarily 0,0)
        x: (pos.x - center.x) * spacing,
        y: (pos.y - center.y) * spacing
      };
      return {
        x: center.x + spacingVector.x,
        y: center.y + spacingVector.y
      };
    };

    var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;

    var spacingBb = function spacingBb() {
      if (!useSpacingFactor) {
        return null;
      }

      var bb = makeBoundingBox();

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var pos = fnMem(node, i);
        expandBoundingBoxByPoint(bb, pos.x, pos.y);
      }

      return bb;
    };

    var bb = spacingBb();
    var getFinalPos = memoize(function (node, i) {
      var newPos = fnMem(node, i);

      if (useSpacingFactor) {
        var spacing = Math.abs(options.spacingFactor);
        newPos = calculateSpacing(spacing, bb, newPos);
      }

      if (options.transform != null) {
        newPos = options.transform(node, newPos);
      }

      return newPos;
    }, getMemoizeKey);

    if (options.animate) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var newPos = getFinalPos(node, i);
        var animateNode = options.animateFilter == null || options.animateFilter(node, i);

        if (animateNode) {
          var ani = node.animation({
            position: newPos,
            duration: options.animationDuration,
            easing: options.animationEasing
          });
          layout.animations.push(ani);
        } else {
          node.position(newPos);
        }
      }

      if (options.fit) {
        var fitAni = cy.animation({
          fit: {
            boundingBox: layoutEles.boundingBoxAt(getFinalPos),
            padding: options.padding
          },
          duration: options.animationDuration,
          easing: options.animationEasing
        });
        layout.animations.push(fitAni);
      } else if (options.zoom !== undefined && options.pan !== undefined) {
        var zoomPanAni = cy.animation({
          zoom: options.zoom,
          pan: options.pan,
          duration: options.animationDuration,
          easing: options.animationEasing
        });
        layout.animations.push(zoomPanAni);
      }

      layout.animations.forEach(function (ani) {
        return ani.play();
      });
      layout.one('layoutready', options.ready);
      layout.emit({
        type: 'layoutready',
        layout: layout
      });
      Promise$1.all(layout.animations.map(function (ani) {
        return ani.promise();
      })).then(function () {
        layout.one('layoutstop', options.stop);
        layout.emit({
          type: 'layoutstop',
          layout: layout
        });
      });
    } else {
      nodes.positions(getFinalPos);

      if (options.fit) {
        cy.fit(options.eles, options.padding);
      }

      if (options.zoom != null) {
        cy.zoom(options.zoom);
      }

      if (options.pan) {
        cy.pan(options.pan);
      }

      layout.one('layoutready', options.ready);
      layout.emit({
        type: 'layoutready',
        layout: layout
      });
      layout.one('layoutstop', options.stop);
      layout.emit({
        type: 'layoutstop',
        layout: layout
      });
    }

    return this; // chaining
  },
  layout: function layout(options) {
    var cy = this.cy();
    return cy.makeLayout(extend({}, options, {
      eles: this
    }));
  }
}; // aliases:

elesfn$q.createLayout = elesfn$q.makeLayout = elesfn$q.layout;

function styleCache(key, fn, ele) {
  var _p = ele._private;
  var cache = _p.styleCache = _p.styleCache || [];
  var val;

  if ((val = cache[key]) != null) {
    return val;
  } else {
    val = cache[key] = fn(ele);
    return val;
  }
}

function cacheStyleFunction(key, fn) {
  key = hashString(key);
  return function cachedStyleFunction(ele) {
    return styleCache(key, fn, ele);
  };
}

function cachePrototypeStyleFunction(key, fn) {
  key = hashString(key);

  var selfFn = function selfFn(ele) {
    return fn.call(ele);
  };

  return function cachedPrototypeStyleFunction() {
    var ele = this[0];

    if (ele) {
      return styleCache(key, selfFn, ele);
    }
  };
}

var elesfn$r = {
  recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {
    var cy = this.cy();
    var renderer = cy.renderer();
    var styleEnabled = cy.styleEnabled();

    if (renderer && styleEnabled) {
      renderer.recalculateRenderedStyle(this, useCache);
    }

    return this;
  },
  dirtyStyleCache: function dirtyStyleCache() {
    var cy = this.cy();

    var dirty = function dirty(ele) {
      return ele._private.styleCache = null;
    };

    if (cy.hasCompoundNodes()) {
      var eles;
      eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
      eles.merge(eles.connectedEdges());
      eles.forEach(dirty);
    } else {
      this.forEach(function (ele) {
        dirty(ele);
        ele.connectedEdges().forEach(dirty);
      });
    }

    return this;
  },
  // fully updates (recalculates) the style for the elements
  updateStyle: function updateStyle(notifyRenderer) {
    var cy = this._private.cy;

    if (!cy.styleEnabled()) {
      return this;
    }

    if (cy.batching()) {
      var bEles = cy._private.batchStyleEles;
      bEles.merge(this);
      return this; // chaining and exit early when batching
    }

    var hasCompounds = cy.hasCompoundNodes();
    var style = cy.style();
    var updatedEles = this;
    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if (hasCompounds) {
      // then add everything up and down for compound selector checks
      updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());
    }

    var changedEles = style.apply(updatedEles);

    if (notifyRenderer) {
      changedEles.emitAndNotify('style'); // let renderer know we changed style
    } else {
      changedEles.emit('style'); // just fire the event
    }

    return this; // chaining
  },
  // get the internal parsed style object for the specified property
  parsedStyle: function parsedStyle(property) {
    var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var ele = this[0];
    var cy = ele.cy();

    if (!cy.styleEnabled()) {
      return;
    }

    if (ele) {
      var overriddenStyle = ele._private.style[property];

      if (overriddenStyle != null) {
        return overriddenStyle;
      } else if (includeNonDefault) {
        return cy.style().getDefaultProperty(property);
      } else {
        return null;
      }
    }
  },
  numericStyle: function numericStyle(property) {
    var ele = this[0];

    if (!ele.cy().styleEnabled()) {
      return;
    }

    if (ele) {
      var pstyle = ele.pstyle(property);
      return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;
    }
  },
  numericStyleUnits: function numericStyleUnits(property) {
    var ele = this[0];

    if (!ele.cy().styleEnabled()) {
      return;
    }

    if (ele) {
      return ele.pstyle(property).units;
    }
  },
  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedStyle: function renderedStyle(property) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var ele = this[0];

    if (ele) {
      return cy.style().getRenderedStyle(ele, property);
    }
  },
  // read the calculated css style of the element or override the style (via a bypass)
  style: function style(name, value) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var updateTransitions = false;
    var style = cy.style();

    if (plainObject(name)) {
      // then extend the bypass
      var props = name;
      style.applyBypass(this, props, updateTransitions);
      this.emitAndNotify('style'); // let the renderer know we've updated style
    } else if (string(name)) {
      if (value === undefined) {
        // then get the property from the style
        var ele = this[0];

        if (ele) {
          return style.getStylePropertyValue(ele, name);
        } else {
          // empty collection => can't get any value
          return;
        }
      } else {
        // then set the bypass with the property value
        style.applyBypass(this, name, value, updateTransitions);
        this.emitAndNotify('style'); // let the renderer know we've updated style
      }
    } else if (name === undefined) {
      var _ele = this[0];

      if (_ele) {
        return style.getRawStyle(_ele);
      } else {
        // empty collection => can't get any value
        return;
      }
    }

    return this; // chaining
  },
  removeStyle: function removeStyle(names) {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return this;
    }

    var updateTransitions = false;
    var style = cy.style();
    var eles = this;

    if (names === undefined) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        style.removeAllBypasses(ele, updateTransitions);
      }
    } else {
      names = names.split(/\s+/);

      for (var _i = 0; _i < eles.length; _i++) {
        var _ele2 = eles[_i];
        style.removeBypasses(_ele2, names, updateTransitions);
      }
    }

    this.emitAndNotify('style'); // let the renderer know we've updated style

    return this; // chaining
  },
  show: function show() {
    this.css('display', 'element');
    return this; // chaining
  },
  hide: function hide() {
    this.css('display', 'none');
    return this; // chaining
  },
  effectiveOpacity: function effectiveOpacity() {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return 1;
    }

    var hasCompoundNodes = cy.hasCompoundNodes();
    var ele = this[0];

    if (ele) {
      var _p = ele._private;
      var parentOpacity = ele.pstyle('opacity').value;

      if (!hasCompoundNodes) {
        return parentOpacity;
      }

      var parents = !_p.data.parent ? null : ele.parents();

      if (parents) {
        for (var i = 0; i < parents.length; i++) {
          var parent = parents[i];
          var opacity = parent.pstyle('opacity').value;
          parentOpacity = opacity * parentOpacity;
        }
      }

      return parentOpacity;
    }
  },
  transparent: function transparent() {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return false;
    }

    var ele = this[0];
    var hasCompoundNodes = ele.cy().hasCompoundNodes();

    if (ele) {
      if (!hasCompoundNodes) {
        return ele.pstyle('opacity').value === 0;
      } else {
        return ele.effectiveOpacity() === 0;
      }
    }
  },
  backgrounding: function backgrounding() {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return false;
    }

    var ele = this[0];
    return ele._private.backgrounding ? true : false;
  }
};

function checkCompound(ele, parentOk) {
  var _p = ele._private;
  var parents = _p.data.parent ? ele.parents() : null;

  if (parents) {
    for (var i = 0; i < parents.length; i++) {
      var parent = parents[i];

      if (!parentOk(parent)) {
        return false;
      }
    }
  }

  return true;
}

function defineDerivedStateFunction(specs) {
  var ok = specs.ok;
  var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;
  var parentOk = specs.parentOk || specs.ok;
  return function () {
    var cy = this.cy();

    if (!cy.styleEnabled()) {
      return true;
    }

    var ele = this[0];
    var hasCompoundNodes = cy.hasCompoundNodes();

    if (ele) {
      var _p = ele._private;

      if (!ok(ele)) {
        return false;
      }

      if (ele.isNode()) {
        return !hasCompoundNodes || checkCompound(ele, parentOk);
      } else {
        var src = _p.source;
        var tgt = _p.target;
        return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));
      }
    }
  };
}

var eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {
  return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);
});
elesfn$r.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({
  ok: eleTakesUpSpace
}));
var eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {
  return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);
});
var parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {
  return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);
});
elesfn$r.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({
  ok: eleInteractive,
  parentOk: parentInteractive,
  edgeOkViaNode: eleTakesUpSpace
}));

elesfn$r.noninteractive = function () {
  var ele = this[0];

  if (ele) {
    return !ele.interactive();
  }
};

var eleVisible = cacheStyleFunction('eleVisible', function (ele) {
  return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);
});
var edgeVisibleViaNode = eleTakesUpSpace;
elesfn$r.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({
  ok: eleVisible,
  edgeOkViaNode: edgeVisibleViaNode
}));

elesfn$r.hidden = function () {
  var ele = this[0];

  if (ele) {
    return !ele.visible();
  }
};

elesfn$r.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function () {
  if (!this.cy().styleEnabled()) {
    return false;
  }

  return !this.removed() && this.pstyle('curve-style').value === 'bezier' && this.takesUpSpace();
});
elesfn$r.bypass = elesfn$r.css = elesfn$r.style;
elesfn$r.renderedCss = elesfn$r.renderedStyle;
elesfn$r.removeBypass = elesfn$r.removeCss = elesfn$r.removeStyle;
elesfn$r.pstyle = elesfn$r.parsedStyle;

var elesfn$s = {};

function defineSwitchFunction(params) {
  return function () {
    var args = arguments;
    var changedEles = []; // e.g. cy.nodes().select( data, handler )

    if (args.length === 2) {
      var data = args[0];
      var handler = args[1];
      this.on(params.event, data, handler);
    } // e.g. cy.nodes().select( handler )
    else if (args.length === 1 && fn(args[0])) {
        var _handler = args[0];
        this.on(params.event, _handler);
      } // e.g. cy.nodes().select()
      // e.g. (private) cy.nodes().select(['tapselect'])
      else if (args.length === 0 || args.length === 1 && array(args[0])) {
          var addlEvents = args.length === 1 ? args[0] : null;

          for (var i = 0; i < this.length; i++) {
            var ele = this[i];
            var able = !params.ableField || ele._private[params.ableField];
            var changed = ele._private[params.field] != params.value;

            if (params.overrideAble) {
              var overrideAble = params.overrideAble(ele);

              if (overrideAble !== undefined) {
                able = overrideAble;

                if (!overrideAble) {
                  return this;
                } // to save cycles assume not able for all on override

              }
            }

            if (able) {
              ele._private[params.field] = params.value;

              if (changed) {
                changedEles.push(ele);
              }
            }
          }

          var changedColl = this.spawn(changedEles);
          changedColl.updateStyle(); // change of state => possible change of style

          changedColl.emit(params.event);

          if (addlEvents) {
            changedColl.emit(addlEvents);
          }
        }

    return this;
  };
}

function defineSwitchSet(params) {
  elesfn$s[params.field] = function () {
    var ele = this[0];

    if (ele) {
      if (params.overrideField) {
        var val = params.overrideField(ele);

        if (val !== undefined) {
          return val;
        }
      }

      return ele._private[params.field];
    }
  };

  elesfn$s[params.on] = defineSwitchFunction({
    event: params.on,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: true
  });
  elesfn$s[params.off] = defineSwitchFunction({
    event: params.off,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: false
  });
}

defineSwitchSet({
  field: 'locked',
  overrideField: function overrideField(ele) {
    return ele.cy().autolock() ? true : undefined;
  },
  on: 'lock',
  off: 'unlock'
});
defineSwitchSet({
  field: 'grabbable',
  overrideField: function overrideField(ele) {
    return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;
  },
  on: 'grabify',
  off: 'ungrabify'
});
defineSwitchSet({
  field: 'selected',
  ableField: 'selectable',
  overrideAble: function overrideAble(ele) {
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'select',
  off: 'unselect'
});
defineSwitchSet({
  field: 'selectable',
  overrideField: function overrideField(ele) {
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'selectify',
  off: 'unselectify'
});
elesfn$s.deselect = elesfn$s.unselect;

elesfn$s.grabbed = function () {
  var ele = this[0];

  if (ele) {
    return ele._private.grabbed;
  }
};

defineSwitchSet({
  field: 'active',
  on: 'activate',
  off: 'unactivate'
});
defineSwitchSet({
  field: 'pannable',
  on: 'panify',
  off: 'unpanify'
});

elesfn$s.inactive = function () {
  var ele = this[0];

  if (ele) {
    return !ele._private.active;
  }
};

var elesfn$t = {}; // DAG functions
////////////////

var defineDagExtremity = function defineDagExtremity(params) {
  return function dagExtremityImpl(selector) {
    var eles = this;
    var ret = [];

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];

      if (!ele.isNode()) {
        continue;
      }

      var disqualified = false;
      var edges = ele.connectedEdges();

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {
          disqualified = true;
          break;
        }
      }

      if (!disqualified) {
        ret.push(ele);
      }
    }

    return this.spawn(ret, {
      unique: true
    }).filter(selector);
  };
};

var defineDagOneHop = function defineDagOneHop(params) {
  return function (selector) {
    var eles = this;
    var oEles = [];

    for (var i = 0; i < eles.length; i++) {
      var ele = eles[i];

      if (!ele.isNode()) {
        continue;
      }

      var edges = ele.connectedEdges();

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        var src = edge.source();
        var tgt = edge.target();

        if (params.outgoing && src === ele) {
          oEles.push(edge);
          oEles.push(tgt);
        } else if (params.incoming && tgt === ele) {
          oEles.push(edge);
          oEles.push(src);
        }
      }
    }

    return this.spawn(oEles, {
      unique: true
    }).filter(selector);
  };
};

var defineDagAllHops = function defineDagAllHops(params) {
  return function (selector) {
    var eles = this;
    var sEles = [];
    var sElesIds = {};

    for (;;) {
      var next = params.outgoing ? eles.outgoers() : eles.incomers();

      if (next.length === 0) {
        break;
      } // done if none left


      var newNext = false;

      for (var i = 0; i < next.length; i++) {
        var n = next[i];
        var nid = n.id();

        if (!sElesIds[nid]) {
          sElesIds[nid] = true;
          sEles.push(n);
          newNext = true;
        }
      }

      if (!newNext) {
        break;
      } // done if touched all outgoers already


      eles = next;
    }

    return this.spawn(sEles, {
      unique: true
    }).filter(selector);
  };
};

elesfn$t.clearTraversalCache = function () {
  for (var i = 0; i < this.length; i++) {
    this[i]._private.traversalCache = null;
  }
};

extend(elesfn$t, {
  // get the root nodes in the DAG
  roots: defineDagExtremity({
    noIncomingEdges: true
  }),
  // get the leaf nodes in the DAG
  leaves: defineDagExtremity({
    noOutgoingEdges: true
  }),
  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: cache(defineDagOneHop({
    outgoing: true
  }), 'outgoers'),
  // aka DAG descendants
  successors: defineDagAllHops({
    outgoing: true
  }),
  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: cache(defineDagOneHop({
    incoming: true
  }), 'incomers'),
  // aka DAG ancestors
  predecessors: defineDagAllHops({
    incoming: true
  })
}); // Neighbourhood functions
//////////////////////////

extend(elesfn$t, {
  neighborhood: cache(function (selector) {
    var elements = [];
    var nodes = this.nodes();

    for (var i = 0; i < nodes.length; i++) {
      // for all nodes
      var node = nodes[i];
      var connectedEdges = node.connectedEdges(); // for each connected edge, add the edge and the other node

      for (var j = 0; j < connectedEdges.length; j++) {
        var edge = connectedEdges[j];
        var src = edge.source();
        var tgt = edge.target();
        var otherNode = node === src ? tgt : src; // need check in case of loop

        if (otherNode.length > 0) {
          elements.push(otherNode[0]); // add node 1 hop away
        } // add connected edge


        elements.push(edge[0]);
      }
    }

    return this.spawn(elements, {
      unique: true
    }).filter(selector);
  }, 'neighborhood'),
  closedNeighborhood: function closedNeighborhood(selector) {
    return this.neighborhood().add(this).filter(selector);
  },
  openNeighborhood: function openNeighborhood(selector) {
    return this.neighborhood(selector);
  }
}); // aliases

elesfn$t.neighbourhood = elesfn$t.neighborhood;
elesfn$t.closedNeighbourhood = elesfn$t.closedNeighborhood;
elesfn$t.openNeighbourhood = elesfn$t.openNeighborhood; // Edge functions
/////////////////

extend(elesfn$t, {
  source: cache(function sourceImpl(selector) {
    var ele = this[0];
    var src;

    if (ele) {
      src = ele._private.source || ele.cy().collection();
    }

    return src && selector ? src.filter(selector) : src;
  }, 'source'),
  target: cache(function targetImpl(selector) {
    var ele = this[0];
    var tgt;

    if (ele) {
      tgt = ele._private.target || ele.cy().collection();
    }

    return tgt && selector ? tgt.filter(selector) : tgt;
  }, 'target'),
  sources: defineSourceFunction({
    attr: 'source'
  }),
  targets: defineSourceFunction({
    attr: 'target'
  })
});

function defineSourceFunction(params) {
  return function sourceImpl(selector) {
    var sources = [];

    for (var i = 0; i < this.length; i++) {
      var ele = this[i];
      var src = ele._private[params.attr];

      if (src) {
        sources.push(src);
      }
    }

    return this.spawn(sources, {
      unique: true
    }).filter(selector);
  };
}

extend(elesfn$t, {
  edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),
  edgesTo: cache(defineEdgesWithFunction({
    thisIsSrc: true
  }), 'edgesTo')
});

function defineEdgesWithFunction(params) {
  return function edgesWithImpl(otherNodes) {
    var elements = [];
    var cy = this._private.cy;
    var p = params || {}; // get elements if a selector is specified

    if (string(otherNodes)) {
      otherNodes = cy.$(otherNodes);
    }

    for (var h = 0; h < otherNodes.length; h++) {
      var edges = otherNodes[h]._private.edges;

      for (var i = 0; i < edges.length; i++) {
        var edge = edges[i];
        var edgeData = edge._private.data;
        var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);
        var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);
        var edgeConnectsThisAndOther = thisToOther || otherToThis;

        if (!edgeConnectsThisAndOther) {
          continue;
        }

        if (p.thisIsSrc || p.thisIsTgt) {
          if (p.thisIsSrc && !thisToOther) {
            continue;
          }

          if (p.thisIsTgt && !otherToThis) {
            continue;
          }
        }

        elements.push(edge);
      }
    }

    return this.spawn(elements, {
      unique: true
    });
  };
}

extend(elesfn$t, {
  connectedEdges: cache(function (selector) {
    var retEles = [];
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var node = eles[i];

      if (!node.isNode()) {
        continue;
      }

      var edges = node._private.edges;

      for (var j = 0; j < edges.length; j++) {
        var edge = edges[j];
        retEles.push(edge);
      }
    }

    return this.spawn(retEles, {
      unique: true
    }).filter(selector);
  }, 'connectedEdges'),
  connectedNodes: cache(function (selector) {
    var retEles = [];
    var eles = this;

    for (var i = 0; i < eles.length; i++) {
      var edge = eles[i];

      if (!edge.isEdge()) {
        continue;
      }

      retEles.push(edge.source()[0]);
      retEles.push(edge.target()[0]);
    }

    return this.spawn(retEles, {
      unique: true
    }).filter(selector);
  }, 'connectedNodes'),
  parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),
  codirectedEdges: cache(defineParallelEdgesFunction({
    codirected: true
  }), 'codirectedEdges')
});

function defineParallelEdgesFunction(params) {
  var defaults = {
    codirected: false
  };
  params = extend({}, defaults, params);
  return function parallelEdgesImpl(selector) {
    // micro-optimised for renderer
    var elements = [];
    var edges = this.edges();
    var p = params; // look at all the edges in the collection

    for (var i = 0; i < edges.length; i++) {
      var edge1 = edges[i];
      var edge1_p = edge1._private;
      var src1 = edge1_p.source;
      var srcid1 = src1._private.data.id;
      var tgtid1 = edge1_p.data.target;
      var srcEdges1 = src1._private.edges; // look at edges connected to the src node of this edge

      for (var j = 0; j < srcEdges1.length; j++) {
        var edge2 = srcEdges1[j];
        var edge2data = edge2._private.data;
        var tgtid2 = edge2data.target;
        var srcid2 = edge2data.source;
        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

        if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {
          elements.push(edge2);
        }
      }
    }

    return this.spawn(elements, {
      unique: true
    }).filter(selector);
  };
} // Misc functions
/////////////////


extend(elesfn$t, {
  components: function components(root) {
    var self = this;
    var cy = self.cy();
    var visited = cy.collection();
    var unvisited = root == null ? self.nodes() : root.nodes();
    var components = [];

    if (root != null && unvisited.empty()) {
      // root may contain only edges
      unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides
    }

    var visitInComponent = function visitInComponent(node, component) {
      visited.merge(node);
      unvisited.unmerge(node);
      component.merge(node);
    };

    if (unvisited.empty()) {
      return self.spawn();
    }

    var _loop = function _loop() {
      // each iteration yields a component
      var cmpt = cy.collection();
      components.push(cmpt);
      var root = unvisited[0];
      visitInComponent(root, cmpt);
      self.bfs({
        directed: false,
        roots: root,
        visit: function visit(v) {
          return visitInComponent(v, cmpt);
        }
      });
      cmpt.forEach(function (node) {
        node.connectedEdges().forEach(function (e) {
          // connectedEdges() usually cached
          if (self.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {
            // has() is cheap
            cmpt.merge(e); // forEach() only considers nodes -- sets N at call time
          }
        });
      });
    };

    do {
      _loop();
    } while (unvisited.length > 0);

    return components;
  },
  component: function component() {
    var ele = this[0];
    return ele.cy().mutableElements().components(ele)[0];
  }
});
elesfn$t.componentsOf = elesfn$t.components;

var idFactory = {
  generate: function generate(cy, element, tryThisId) {
    var id = tryThisId != null ? tryThisId : uuid();

    while (cy.hasElementWithId(id)) {
      id = uuid();
    }

    return id;
  }
}; // represents a set of nodes, edges, or both together

var Collection = function Collection(cy, elements, options) {
  if (cy === undefined || !core(cy)) {
    error('A collection must have a reference to the core');
    return;
  }

  var map = new Map$1();
  var createdElements = false;

  if (!elements) {
    elements = [];
  } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {
    createdElements = true; // make elements from json and restore all at once later

    var eles = [];
    var elesIds = new Set$1();

    for (var i = 0, l = elements.length; i < l; i++) {
      var json = elements[i];

      if (json.data == null) {
        json.data = {};
      }

      var _data = json.data; // make sure newly created elements have valid ids

      if (_data.id == null) {
        _data.id = idFactory.generate(cy, json);
      } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {
        continue; // can't create element if prior id already exists
      }

      var ele = new Element(cy, json, false);
      eles.push(ele);
      elesIds.add(_data.id);
    }

    elements = eles;
  }

  this.length = 0;

  for (var _i = 0, _l = elements.length; _i < _l; _i++) {
    var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements

    if (element$1 == null) {
      continue;
    }

    var id = element$1._private.data.id;

    if (options == null || options.unique && !map.has(id)) {
      map.set(id, {
        index: this.length,
        ele: element$1
      });
      this[this.length] = element$1;
      this.length++;
    }
  }

  this._private = {
    cy: cy,
    map: map
  }; // restore the elements if we created them from json

  if (createdElements) {
    this.restore();
  }
}; // Functions
////////////////////////////////////////////////////////////////////////////////////////////////////
// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes


var elesfn$u = Element.prototype = Collection.prototype;

elesfn$u.instanceString = function () {
  return 'collection';
};

elesfn$u.spawn = function (cy, eles, opts) {
  if (!core(cy)) {
    // cy is optional
    opts = eles;
    eles = cy;
    cy = this.cy();
  }

  return new Collection(cy, eles, opts);
};

elesfn$u.spawnSelf = function () {
  return this.spawn(this);
};

elesfn$u.cy = function () {
  return this._private.cy;
};

elesfn$u.renderer = function () {
  return this._private.cy.renderer();
};

elesfn$u.element = function () {
  return this[0];
};

elesfn$u.collection = function () {
  if (collection(this)) {
    return this;
  } else {
    // an element
    return new Collection(this._private.cy, [this]);
  }
};

elesfn$u.unique = function () {
  return new Collection(this._private.cy, this, {
    unique: true
  });
};

elesfn$u.hasElementWithId = function (id) {
  id = '' + id; // id must be string

  return this._private.map.has(id);
};

elesfn$u.getElementById = function (id) {
  id = '' + id; // id must be string

  var cy = this._private.cy;

  var entry = this._private.map.get(id);

  return entry ? entry.ele : new Collection(cy); // get ele or empty collection
};

elesfn$u.$id = elesfn$u.getElementById;

elesfn$u.poolIndex = function () {
  var cy = this._private.cy;
  var eles = cy._private.elements;
  var id = this[0]._private.data.id;
  return eles._private.map.get(id).index;
};

elesfn$u.indexOf = function (ele) {
  var id = ele[0]._private.data.id;
  return this._private.map.get(id).index;
};

elesfn$u.indexOfId = function (id) {
  id = '' + id; // id must be string

  return this._private.map.get(id).index;
};

elesfn$u.json = function (obj) {
  var ele = this.element();
  var cy = this.cy();

  if (ele == null && obj) {
    return this;
  } // can't set to no eles


  if (ele == null) {
    return undefined;
  } // can't get from no eles


  var p = ele._private;

  if (plainObject(obj)) {
    // set
    cy.startBatch();

    if (obj.data) {
      ele.data(obj.data);
      var _data2 = p.data;

      if (ele.isEdge()) {
        // source and target are immutable via data()
        var move = false;
        var spec = {};
        var src = obj.data.source;
        var tgt = obj.data.target;

        if (src != null && src != _data2.source) {
          spec.source = '' + src; // id must be string

          move = true;
        }

        if (tgt != null && tgt != _data2.target) {
          spec.target = '' + tgt; // id must be string

          move = true;
        }

        if (move) {
          ele = ele.move(spec);
        }
      } else {
        // parent is immutable via data()
        var parent = obj.data.parent;

        if ((parent != null || _data2.parent != null) && parent != _data2.parent) {
          if (parent === undefined) {
            // can't set undefined imperatively, so use null
            parent = null;
          }

          if (parent != null) {
            parent = '' + parent; // id must be string
          }

          ele = ele.move({
            parent: parent
          });
        }
      }
    }

    if (obj.position) {
      ele.position(obj.position);
    } // ignore group -- immutable


    var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {
      var obj_k = obj[k];

      if (obj_k != null && obj_k !== p[k]) {
        if (obj_k) {
          ele[trueFnName]();
        } else {
          ele[falseFnName]();
        }
      }
    };

    checkSwitch('removed', 'remove', 'restore');
    checkSwitch('selected', 'select', 'unselect');
    checkSwitch('selectable', 'selectify', 'unselectify');
    checkSwitch('locked', 'lock', 'unlock');
    checkSwitch('grabbable', 'grabify', 'ungrabify');
    checkSwitch('pannable', 'panify', 'unpanify');

    if (obj.classes != null) {
      ele.classes(obj.classes);
    }

    cy.endBatch();
    return this;
  } else if (obj === undefined) {
    // get
    var json = {
      data: copy(p.data),
      position: copy(p.position),
      group: p.group,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbable: p.grabbable,
      pannable: p.pannable,
      classes: null
    };
    json.classes = '';
    var i = 0;
    p.classes.forEach(function (cls) {
      return json.classes += i++ === 0 ? cls : ' ' + cls;
    });
    return json;
  }
};

elesfn$u.jsons = function () {
  var jsons = [];

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var json = ele.json();
    jsons.push(json);
  }

  return jsons;
};

elesfn$u.clone = function () {
  var cy = this.cy();
  var elesArr = [];

  for (var i = 0; i < this.length; i++) {
    var ele = this[i];
    var json = ele.json();
    var clone = new Element(cy, json, false); // NB no restore

    elesArr.push(clone);
  }

  return new Collection(cy, elesArr);
};

elesfn$u.copy = elesfn$u.clone;

elesfn$u.restore = function () {
  var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var self = this;
  var cy = self.cy();
  var cy_p = cy._private; // create arrays of nodes and edges, since we need to
  // restore the nodes first

  var nodes = [];
  var edges = [];
  var elements;

  for (var _i2 = 0, l = self.length; _i2 < l; _i2++) {
    var ele = self[_i2];

    if (addToPool && !ele.removed()) {
      // don't need to handle this ele
      continue;
    } // keep nodes first in the array and edges after


    if (ele.isNode()) {
      // put to front of array if node
      nodes.push(ele);
    } else {
      // put to end of array if edge
      edges.push(ele);
    }
  }

  elements = nodes.concat(edges);
  var i;

  var removeFromElements = function removeFromElements() {
    elements.splice(i, 1);
    i--;
  }; // now, restore each element


  for (i = 0; i < elements.length; i++) {
    var _ele = elements[i];
    var _private = _ele._private;
    var _data3 = _private.data; // the traversal cache should start fresh when ele is added

    _ele.clearTraversalCache(); // set id and validate


    if (!addToPool && !_private.removed) ; else if (_data3.id === undefined) {
      _data3.id = idFactory.generate(cy, _ele);
    } else if (number(_data3.id)) {
      _data3.id = '' + _data3.id; // now it's a string
    } else if (emptyString(_data3.id) || !string(_data3.id)) {
      error('Can not create element with invalid string ID `' + _data3.id + '`'); // can't create element if it has empty string as id or non-string id

      removeFromElements();
      continue;
    } else if (cy.hasElementWithId(_data3.id)) {
      error('Can not create second element with ID `' + _data3.id + '`'); // can't create element if one already has that id

      removeFromElements();
      continue;
    }

    var id = _data3.id; // id is finalised, now let's keep a ref

    if (_ele.isNode()) {
      // extra checks for nodes
      var pos = _private.position; // make sure the nodes have a defined position

      if (pos.x == null) {
        pos.x = 0;
      }

      if (pos.y == null) {
        pos.y = 0;
      }
    }

    if (_ele.isEdge()) {
      // extra checks for edges
      var edge = _ele;
      var fields = ['source', 'target'];
      var fieldsLength = fields.length;
      var badSourceOrTarget = false;

      for (var j = 0; j < fieldsLength; j++) {
        var field = fields[j];
        var val = _data3[field];

        if (number(val)) {
          val = _data3[field] = '' + _data3[field]; // now string
        }

        if (val == null || val === '') {
          // can't create if source or target is not defined properly
          error('Can not create edge `' + id + '` with unspecified ' + field);
          badSourceOrTarget = true;
        } else if (!cy.hasElementWithId(val)) {
          // can't create edge if one of its nodes doesn't exist
          error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
          badSourceOrTarget = true;
        }
      }

      if (badSourceOrTarget) {
        removeFromElements();
        continue;
      } // can't create this


      var src = cy.getElementById(_data3.source);
      var tgt = cy.getElementById(_data3.target); // only one edge in node if loop

      if (src.same(tgt)) {
        src._private.edges.push(edge);
      } else {
        src._private.edges.push(edge);

        tgt._private.edges.push(edge);
      }

      edge._private.source = src;
      edge._private.target = tgt;
    } // if is edge
    // create mock ids / indexes maps for element so it can be used like collections


    _private.map = new Map$1();

    _private.map.set(id, {
      ele: _ele,
      index: 0
    });

    _private.removed = false;

    if (addToPool) {
      cy.addToPool(_ele);
    }
  } // for each element
  // do compound node sanity checks


  for (var _i3 = 0; _i3 < nodes.length; _i3++) {
    // each node
    var node = nodes[_i3];
    var _data4 = node._private.data;

    if (number(_data4.parent)) {
      // then automake string
      _data4.parent = '' + _data4.parent;
    }

    var parentId = _data4.parent;
    var specifiedParent = parentId != null;

    if (specifiedParent) {
      var parent = cy.getElementById(parentId);

      if (parent.empty()) {
        // non-existant parent; just remove it
        _data4.parent = undefined;
      } else {
        var selfAsParent = false;
        var ancestor = parent;

        while (!ancestor.empty()) {
          if (node.same(ancestor)) {
            // mark self as parent and remove from data
            selfAsParent = true;
            _data4.parent = undefined; // remove parent reference
            // exit or we loop forever

            break;
          }

          ancestor = ancestor.parent();
        }

        if (!selfAsParent) {
          // connect with children
          parent[0]._private.children.push(node);

          node._private.parent = parent[0]; // let the core know we have a compound graph

          cy_p.hasCompoundNodes = true;
        }
      } // else

    } // if specified parent

  } // for each node


  if (elements.length > 0) {
    var restored = new Collection(cy, elements);

    for (var _i4 = 0; _i4 < restored.length; _i4++) {
      var _ele2 = restored[_i4];

      if (_ele2.isNode()) {
        continue;
      } // adding an edge invalidates the traversal caches for the parallel edges


      _ele2.parallelEdges().clearTraversalCache(); // adding an edge invalidates the traversal cache for the connected nodes


      _ele2.source().clearTraversalCache();

      _ele2.target().clearTraversalCache();
    }

    var toUpdateStyle;

    if (cy_p.hasCompoundNodes) {
      toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());
    } else {
      toUpdateStyle = restored;
    }

    toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);

    if (notifyRenderer) {
      restored.emitAndNotify('add');
    } else if (addToPool) {
      restored.emit('add');
    }
  }

  return self; // chainability
};

elesfn$u.removed = function () {
  var ele = this[0];
  return ele && ele._private.removed;
};

elesfn$u.inside = function () {
  var ele = this[0];
  return ele && !ele._private.removed;
};

elesfn$u.remove = function () {
  var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var self = this;
  var elesToRemove = [];
  var elesToRemoveIds = {};
  var cy = self._private.cy; // add connected edges

  function addConnectedEdges(node) {
    var edges = node._private.edges;

    for (var i = 0; i < edges.length; i++) {
      add(edges[i]);
    }
  } // add descendant nodes


  function addChildren(node) {
    var children = node._private.children;

    for (var i = 0; i < children.length; i++) {
      add(children[i]);
    }
  }

  function add(ele) {
    var alreadyAdded = elesToRemoveIds[ele.id()];

    if (removeFromPool && ele.removed() || alreadyAdded) {
      return;
    } else {
      elesToRemoveIds[ele.id()] = true;
    }

    if (ele.isNode()) {
      elesToRemove.push(ele); // nodes are removed last

      addConnectedEdges(ele);
      addChildren(ele);
    } else {
      elesToRemove.unshift(ele); // edges are removed first
    }
  } // make the list of elements to remove
  // (may be removing more than specified due to connected edges etc)


  for (var i = 0, l = self.length; i < l; i++) {
    var ele = self[i];
    add(ele);
  }

  function removeEdgeRef(node, edge) {
    var connectedEdges = node._private.edges;
    removeFromArray(connectedEdges, edge); // removing an edges invalidates the traversal cache for its nodes

    node.clearTraversalCache();
  }

  function removeParallelRef(pllEdge) {
    // removing an edge invalidates the traversal caches for the parallel edges
    pllEdge.clearTraversalCache();
  }

  var alteredParents = [];
  alteredParents.ids = {};

  function removeChildRef(parent, ele) {
    ele = ele[0];
    parent = parent[0];
    var children = parent._private.children;
    var pid = parent.id();
    removeFromArray(children, ele); // remove parent => child ref

    ele._private.parent = null; // remove child => parent ref

    if (!alteredParents.ids[pid]) {
      alteredParents.ids[pid] = true;
      alteredParents.push(parent);
    }
  }

  self.dirtyCompoundBoundsCache();

  if (removeFromPool) {
    cy.removeFromPool(elesToRemove); // remove from core pool
  }

  for (var _i5 = 0; _i5 < elesToRemove.length; _i5++) {
    var _ele3 = elesToRemove[_i5];

    if (_ele3.isEdge()) {
      // remove references to this edge in its connected nodes
      var src = _ele3.source()[0];

      var tgt = _ele3.target()[0];

      removeEdgeRef(src, _ele3);
      removeEdgeRef(tgt, _ele3);

      var pllEdges = _ele3.parallelEdges();

      for (var j = 0; j < pllEdges.length; j++) {
        var pllEdge = pllEdges[j];
        removeParallelRef(pllEdge);

        if (pllEdge.isBundledBezier()) {
          pllEdge.dirtyBoundingBoxCache();
        }
      }
    } else {
      // remove reference to parent
      var parent = _ele3.parent();

      if (parent.length !== 0) {
        removeChildRef(parent, _ele3);
      }
    }

    if (removeFromPool) {
      // mark as removed
      _ele3._private.removed = true;
    }
  } // check to see if we have a compound graph or not


  var elesStillInside = cy._private.elements;
  cy._private.hasCompoundNodes = false;

  for (var _i6 = 0; _i6 < elesStillInside.length; _i6++) {
    var _ele4 = elesStillInside[_i6];

    if (_ele4.isParent()) {
      cy._private.hasCompoundNodes = true;
      break;
    }
  }

  var removedElements = new Collection(this.cy(), elesToRemove);

  if (removedElements.size() > 0) {
    // must manually notify since trigger won't do this automatically once removed
    if (notifyRenderer) {
      removedElements.emitAndNotify('remove');
    } else if (removeFromPool) {
      removedElements.emit('remove');
    }
  } // the parents who were modified by the removal need their style updated


  for (var _i7 = 0; _i7 < alteredParents.length; _i7++) {
    var _ele5 = alteredParents[_i7];

    if (!removeFromPool || !_ele5.removed()) {
      _ele5.updateStyle();
    }
  }

  return removedElements;
};

elesfn$u.move = function (struct) {
  var cy = this._private.cy;
  var eles = this; // just clean up refs, caches, etc. in the same way as when removing and then restoring
  // (our calls to remove/restore do not remove from the graph or make events)

  var notifyRenderer = false;
  var modifyPool = false;

  var toString = function toString(id) {
    return id == null ? id : '' + id;
  }; // id must be string


  if (struct.source !== undefined || struct.target !== undefined) {
    var srcId = toString(struct.source);
    var tgtId = toString(struct.target);
    var srcExists = srcId != null && cy.hasElementWithId(srcId);
    var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);

    if (srcExists || tgtExists) {
      cy.batch(function () {
        // avoid duplicate style updates
        eles.remove(notifyRenderer, modifyPool); // clean up refs etc.

        eles.emitAndNotify('moveout');

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var _data5 = ele._private.data;

          if (ele.isEdge()) {
            if (srcExists) {
              _data5.source = srcId;
            }

            if (tgtExists) {
              _data5.target = tgtId;
            }
          }
        }

        eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.
      });
      eles.emitAndNotify('move');
    }
  } else if (struct.parent !== undefined) {
    // move node to new parent
    var parentId = toString(struct.parent);
    var parentExists = parentId === null || cy.hasElementWithId(parentId);

    if (parentExists) {
      var pidToAssign = parentId === null ? undefined : parentId;
      cy.batch(function () {
        // avoid duplicate style updates
        var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.

        updated.emitAndNotify('moveout');

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          var _data6 = ele._private.data;

          if (ele.isNode()) {
            _data6.parent = pidToAssign;
          }
        }

        updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.
      });
      eles.emitAndNotify('move');
    }
  }

  return this;
};

[elesfn$c, elesfn$d, elesfn$e, elesfn$f, elesfn$g, data$1, elesfn$i, dimensions, elesfn$m, elesfn$n, elesfn$o, elesfn$p, elesfn$q, elesfn$r, elesfn$s, elesfn$t].forEach(function (props) {
  extend(elesfn$u, props);
});

var corefn = {
  add: function add(opts) {
    var elements;
    var cy = this; // add the elements

    if (elementOrCollection(opts)) {
      var eles = opts;

      if (eles._private.cy === cy) {
        // same instance => just restore
        elements = eles.restore();
      } else {
        // otherwise, copy from json
        var jsons = [];

        for (var i = 0; i < eles.length; i++) {
          var ele = eles[i];
          jsons.push(ele.json());
        }

        elements = new Collection(cy, jsons);
      }
    } // specify an array of options
    else if (array(opts)) {
        var _jsons = opts;
        elements = new Collection(cy, _jsons);
      } // specify via opts.nodes and opts.edges
      else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {
          var elesByGroup = opts;
          var _jsons2 = [];
          var grs = ['nodes', 'edges'];

          for (var _i = 0, il = grs.length; _i < il; _i++) {
            var group = grs[_i];
            var elesArray = elesByGroup[group];

            if (array(elesArray)) {
              for (var j = 0, jl = elesArray.length; j < jl; j++) {
                var json = extend({
                  group: group
                }, elesArray[j]);

                _jsons2.push(json);
              }
            }
          }

          elements = new Collection(cy, _jsons2);
        } // specify options for one element
        else {
            var _json = opts;
            elements = new Element(cy, _json).collection();
          }

    return elements;
  },
  remove: function remove(collection) {
    if (elementOrCollection(collection)) ; else if (string(collection)) {
      var selector = collection;
      collection = this.$(selector);
    }

    return collection.remove();
  }
};

/* global Float32Array */

/*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
function generateCubicBezier(mX1, mY1, mX2, mY2) {
  var NEWTON_ITERATIONS = 4,
      NEWTON_MIN_SLOPE = 0.001,
      SUBDIVISION_PRECISION = 0.0000001,
      SUBDIVISION_MAX_ITERATIONS = 10,
      kSplineTableSize = 11,
      kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
      float32ArraySupported = typeof Float32Array !== 'undefined';
  /* Must contain four arguments. */

  if (arguments.length !== 4) {
    return false;
  }
  /* Arguments must be numbers. */


  for (var i = 0; i < 4; ++i) {
    if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
      return false;
    }
  }
  /* X values must be in the [0, 1] range. */


  mX1 = Math.min(mX1, 1);
  mX2 = Math.min(mX2, 1);
  mX1 = Math.max(mX1, 0);
  mX2 = Math.max(mX2, 0);
  var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function newtonRaphsonIterate(aX, aGuessT) {
    for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function calcSampleValues() {
    for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {
      mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);
    }
  }

  function binarySubdivide(aX, aA, aB) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  }

  function getTForX(aX) {
    var intervalStart = 0.0,
        currentSample = 1,
        lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }

    --currentSample;
    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
        guessForT = intervalStart + dist * kSampleStepSize,
        initialSlope = getSlope(guessForT, mX1, mX2);

    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
    }
  }

  var _precomputed = false;

  function precompute() {
    _precomputed = true;

    if (mX1 !== mY1 || mX2 !== mY2) {
      calcSampleValues();
    }
  }

  var f = function f(aX) {
    if (!_precomputed) {
      precompute();
    }

    if (mX1 === mY1 && mX2 === mY2) {
      return aX;
    }

    if (aX === 0) {
      return 0;
    }

    if (aX === 1) {
      return 1;
    }

    return calcBezier(getTForX(aX), mY1, mY2);
  };

  f.getControlPoints = function () {
    return [{
      x: mX1,
      y: mY1
    }, {
      x: mX2,
      y: mY2
    }];
  };

  var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";

  f.toString = function () {
    return str;
  };

  return f;
}

/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */

/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
var generateSpringRK4 = function () {
  function springAccelerationForState(state) {
    return -state.tension * state.x - state.friction * state.v;
  }

  function springEvaluateStateWithDerivative(initialState, dt, derivative) {
    var state = {
      x: initialState.x + derivative.dx * dt,
      v: initialState.v + derivative.dv * dt,
      tension: initialState.tension,
      friction: initialState.friction
    };
    return {
      dx: state.v,
      dv: springAccelerationForState(state)
    };
  }

  function springIntegrateState(state, dt) {
    var a = {
      dx: state.v,
      dv: springAccelerationForState(state)
    },
        b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
        c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
        d = springEvaluateStateWithDerivative(state, dt, c),
        dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
        dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);
    state.x = state.x + dxdt * dt;
    state.v = state.v + dvdt * dt;
    return state;
  }

  return function springRK4Factory(tension, friction, duration) {
    var initState = {
      x: -1,
      v: 0,
      tension: null,
      friction: null
    },
        path = [0],
        time_lapsed = 0,
        tolerance = 1 / 10000,
        DT = 16 / 1000,
        have_duration,
        dt,
        last_state;
    tension = parseFloat(tension) || 500;
    friction = parseFloat(friction) || 20;
    duration = duration || null;
    initState.tension = tension;
    initState.friction = friction;
    have_duration = duration !== null;
    /* Calculate the actual time it takes for this animation to complete with the provided conditions. */

    if (have_duration) {
      /* Run the simulation without a duration. */
      time_lapsed = springRK4Factory(tension, friction);
      /* Compute the adjusted time delta. */

      dt = time_lapsed / duration * DT;
    } else {
      dt = DT;
    }

    for (;;) {
      /* Next/step function .*/
      last_state = springIntegrateState(last_state || initState, dt);
      /* Store the position. */

      path.push(1 + last_state.x);
      time_lapsed += 16;
      /* If the change threshold is reached, break. */

      if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
        break;
      }
    }
    /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
       computed path and returns a snapshot of the position according to a given percentComplete. */


    return !have_duration ? time_lapsed : function (percentComplete) {
      return path[percentComplete * (path.length - 1) | 0];
    };
  };
}();

var cubicBezier = function cubicBezier(t1, p1, t2, p2) {
  var bezier = generateCubicBezier(t1, p1, t2, p2);
  return function (start, end, percent) {
    return start + (end - start) * bezier(percent);
  };
};

var easings = {
  'linear': function linear(start, end, percent) {
    return start + (end - start) * percent;
  },
  // default easings
  'ease': cubicBezier(0.25, 0.1, 0.25, 1),
  'ease-in': cubicBezier(0.42, 0, 1, 1),
  'ease-out': cubicBezier(0, 0, 0.58, 1),
  'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),
  // sine
  'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),
  'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),
  'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),
  // quad
  'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),
  'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),
  'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),
  // cubic
  'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),
  'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),
  'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),
  // quart
  'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),
  'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),
  'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),
  // quint
  'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),
  'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),
  'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),
  // expo
  'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),
  'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),
  'ease-in-out-expo': cubicBezier(1, 0, 0, 1),
  // circ
  'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),
  'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),
  'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),
  // user param easings...
  'spring': function spring(tension, friction, duration) {
    if (duration === 0) {
      // can't get a spring w/ duration 0
      return easings.linear; // duration 0 => jump to end so impl doesn't matter
    }

    var spring = generateSpringRK4(tension, friction, duration);
    return function (start, end, percent) {
      return start + (end - start) * spring(percent);
    };
  },
  'cubic-bezier': cubicBezier
};

function getEasedValue(type, start, end, percent, easingFn) {
  if (percent === 1) {
    return end;
  }

  var val = easingFn(start, end, percent);

  if (type == null) {
    return val;
  }

  if (type.roundValue || type.color) {
    val = Math.round(val);
  }

  if (type.min !== undefined) {
    val = Math.max(val, type.min);
  }

  if (type.max !== undefined) {
    val = Math.min(val, type.max);
  }

  return val;
}

function getValue(prop, spec) {
  if (prop.pfValue != null || prop.value != null) {
    if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {
      return prop.pfValue;
    } else {
      return prop.value;
    }
  } else {
    return prop;
  }
}

function ease(startProp, endProp, percent, easingFn, propSpec) {
  var type = propSpec != null ? propSpec.type : null;

  if (percent < 0) {
    percent = 0;
  } else if (percent > 1) {
    percent = 1;
  }

  var start = getValue(startProp, propSpec);
  var end = getValue(endProp, propSpec);

  if (number(start) && number(end)) {
    return getEasedValue(type, start, end, percent, easingFn);
  } else if (array(start) && array(end)) {
    var easedArr = [];

    for (var i = 0; i < end.length; i++) {
      var si = start[i];
      var ei = end[i];

      if (si != null && ei != null) {
        var val = getEasedValue(type, si, ei, percent, easingFn);
        easedArr.push(val);
      } else {
        easedArr.push(ei);
      }
    }

    return easedArr;
  }

  return undefined;
}

function step(self, ani, now, isCore) {
  var isEles = !isCore;
  var _p = self._private;
  var ani_p = ani._private;
  var pEasing = ani_p.easing;
  var startTime = ani_p.startTime;
  var cy = isCore ? self : self.cy();
  var style = cy.style();

  if (!ani_p.easingImpl) {
    if (pEasing == null) {
      // use default
      ani_p.easingImpl = easings['linear'];
    } else {
      // then define w/ name
      var easingVals;

      if (string(pEasing)) {
        var easingProp = style.parse('transition-timing-function', pEasing);
        easingVals = easingProp.value;
      } else {
        // then assume preparsed array
        easingVals = pEasing;
      }

      var name, args;

      if (string(easingVals)) {
        name = easingVals;
        args = [];
      } else {
        name = easingVals[1];
        args = easingVals.slice(2).map(function (n) {
          return +n;
        });
      }

      if (args.length > 0) {
        // create with args
        if (name === 'spring') {
          args.push(ani_p.duration); // need duration to generate spring
        }

        ani_p.easingImpl = easings[name].apply(null, args);
      } else {
        // static impl by name
        ani_p.easingImpl = easings[name];
      }
    }
  }

  var easing = ani_p.easingImpl;
  var percent;

  if (ani_p.duration === 0) {
    percent = 1;
  } else {
    percent = (now - startTime) / ani_p.duration;
  }

  if (ani_p.applying) {
    percent = ani_p.progress;
  }

  if (percent < 0) {
    percent = 0;
  } else if (percent > 1) {
    percent = 1;
  }

  if (ani_p.delay == null) {
    // then update
    var startPos = ani_p.startPosition;
    var endPos = ani_p.position;

    if (endPos && isEles && !self.locked()) {
      var newPos = {};

      if (valid(startPos.x, endPos.x)) {
        newPos.x = ease(startPos.x, endPos.x, percent, easing);
      }

      if (valid(startPos.y, endPos.y)) {
        newPos.y = ease(startPos.y, endPos.y, percent, easing);
      }

      self.position(newPos);
    }

    var startPan = ani_p.startPan;
    var endPan = ani_p.pan;
    var pan = _p.pan;
    var animatingPan = endPan != null && isCore;

    if (animatingPan) {
      if (valid(startPan.x, endPan.x)) {
        pan.x = ease(startPan.x, endPan.x, percent, easing);
      }

      if (valid(startPan.y, endPan.y)) {
        pan.y = ease(startPan.y, endPan.y, percent, easing);
      }

      self.emit('pan');
    }

    var startZoom = ani_p.startZoom;
    var endZoom = ani_p.zoom;
    var animatingZoom = endZoom != null && isCore;

    if (animatingZoom) {
      if (valid(startZoom, endZoom)) {
        _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);
      }

      self.emit('zoom');
    }

    if (animatingPan || animatingZoom) {
      self.emit('viewport');
    }

    var props = ani_p.style;

    if (props && props.length > 0 && isEles) {
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        var _name = prop.name;
        var end = prop;
        var start = ani_p.startStyle[_name];
        var propSpec = style.properties[start.name];
        var easedVal = ease(start, end, percent, easing, propSpec);
        style.overrideBypass(self, _name, easedVal);
      } // for props


      self.emit('style');
    } // if

  }

  ani_p.progress = percent;
  return percent;
}

function valid(start, end) {
  if (start == null || end == null) {
    return false;
  }

  if (number(start) && number(end)) {
    return true;
  } else if (start && end) {
    return true;
  }

  return false;
}

function startAnimation(self, ani, now, isCore) {
  var ani_p = ani._private;
  ani_p.started = true;
  ani_p.startTime = now - ani_p.progress * ani_p.duration;
}

function stepAll(now, cy) {
  var eles = cy._private.aniEles;
  var doneEles = [];

  function stepOne(ele, isCore) {
    var _p = ele._private;
    var current = _p.animation.current;
    var queue = _p.animation.queue;
    var ranAnis = false; // cancel all animations on display:none ele

    if (!isCore && ele.pstyle('display').value === 'none') {
      // put all current and queue animations in this tick's current list
      // and empty the lists for the element
      current = current.splice(0, current.length).concat(queue.splice(0, queue.length)); // stop all animations

      for (var i = 0; i < current.length; i++) {
        current[i].stop();
      }
    } // if nothing currently animating, get something from the queue


    if (current.length === 0) {
      var next = queue.shift();

      if (next) {
        current.push(next);
      }
    }

    var callbacks = function callbacks(_callbacks) {
      for (var j = _callbacks.length - 1; j >= 0; j--) {
        var cb = _callbacks[j];
        cb();
      }

      _callbacks.splice(0, _callbacks.length);
    }; // step and remove if done


    for (var _i = current.length - 1; _i >= 0; _i--) {
      var ani = current[_i];
      var ani_p = ani._private;

      if (ani_p.stopped) {
        current.splice(_i, 1);
        ani_p.hooked = false;
        ani_p.playing = false;
        ani_p.started = false;
        callbacks(ani_p.frames);
        continue;
      }

      if (!ani_p.playing && !ani_p.applying) {
        continue;
      } // an apply() while playing shouldn't do anything


      if (ani_p.playing && ani_p.applying) {
        ani_p.applying = false;
      }

      if (!ani_p.started) {
        startAnimation(ele, ani, now);
      }

      step(ele, ani, now, isCore);

      if (ani_p.applying) {
        ani_p.applying = false;
      }

      callbacks(ani_p.frames);

      if (ani_p.step != null) {
        ani_p.step(now);
      }

      if (ani.completed()) {
        current.splice(_i, 1);
        ani_p.hooked = false;
        ani_p.playing = false;
        ani_p.started = false;
        callbacks(ani_p.completes);
      }

      ranAnis = true;
    }

    if (!isCore && current.length === 0 && queue.length === 0) {
      doneEles.push(ele);
    }

    return ranAnis;
  } // stepElement
  // handle all eles


  var ranEleAni = false;

  for (var e = 0; e < eles.length; e++) {
    var ele = eles[e];
    var handledThisEle = stepOne(ele);
    ranEleAni = ranEleAni || handledThisEle;
  } // each element


  var ranCoreAni = stepOne(cy, true); // notify renderer

  if (ranEleAni || ranCoreAni) {
    if (eles.length > 0) {
      cy.notify('draw', eles);
    } else {
      cy.notify('draw');
    }
  } // remove elements from list of currently animating if its queues are empty


  eles.unmerge(doneEles);
  cy.emit('step');
} // stepAll

var corefn$1 = {
  // pull in animation functions
  animate: define$3.animate(),
  animation: define$3.animation(),
  animated: define$3.animated(),
  clearQueue: define$3.clearQueue(),
  delay: define$3.delay(),
  delayAnimation: define$3.delayAnimation(),
  stop: define$3.stop(),
  addToAnimationPool: function addToAnimationPool(eles) {
    var cy = this;

    if (!cy.styleEnabled()) {
      return;
    } // save cycles when no style used


    cy._private.aniEles.merge(eles);
  },
  stopAnimationLoop: function stopAnimationLoop() {
    this._private.animationsRunning = false;
  },
  startAnimationLoop: function startAnimationLoop() {
    var cy = this;
    cy._private.animationsRunning = true;

    if (!cy.styleEnabled()) {
      return;
    } // save cycles when no style used
    // NB the animation loop will exec in headless environments if style enabled
    // and explicit cy.destroy() is necessary to stop the loop


    function headlessStep() {
      if (!cy._private.animationsRunning) {
        return;
      }

      requestAnimationFrame(function animationStep(now) {
        stepAll(now, cy);
        headlessStep();
      });
    }

    var renderer = cy.renderer();

    if (renderer && renderer.beforeRender) {
      // let the renderer schedule animations
      renderer.beforeRender(function rendererAnimationStep(willDraw, now) {
        stepAll(now, cy);
      }, renderer.beforeRenderPriorities.animations);
    } else {
      // manage the animation loop ourselves
      headlessStep(); // first call
    }
  }
};

var emitterOptions$1 = {
  qualifierCompare: function qualifierCompare(selector1, selector2) {
    if (selector1 == null || selector2 == null) {
      return selector1 == null && selector2 == null;
    } else {
      return selector1.sameText(selector2);
    }
  },
  eventMatches: function eventMatches(cy, listener, eventObj) {
    var selector = listener.qualifier;

    if (selector != null) {
      return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);
    }

    return true;
  },
  addEventFields: function addEventFields(cy, evt) {
    evt.cy = cy;
    evt.target = cy;
  },
  callbackContext: function callbackContext(cy, listener, eventObj) {
    return listener.qualifier != null ? eventObj.target : cy;
  }
};

var argSelector$1 = function argSelector(arg) {
  if (string(arg)) {
    return new Selector(arg);
  } else {
    return arg;
  }
};

var elesfn$v = {
  createEmitter: function createEmitter() {
    var _p = this._private;

    if (!_p.emitter) {
      _p.emitter = new Emitter(emitterOptions$1, this);
    }

    return this;
  },
  emitter: function emitter() {
    return this._private.emitter;
  },
  on: function on(events, selector, callback) {
    this.emitter().on(events, argSelector$1(selector), callback);
    return this;
  },
  removeListener: function removeListener(events, selector, callback) {
    this.emitter().removeListener(events, argSelector$1(selector), callback);
    return this;
  },
  removeAllListeners: function removeAllListeners() {
    this.emitter().removeAllListeners();
    return this;
  },
  one: function one(events, selector, callback) {
    this.emitter().one(events, argSelector$1(selector), callback);
    return this;
  },
  once: function once(events, selector, callback) {
    this.emitter().one(events, argSelector$1(selector), callback);
    return this;
  },
  emit: function emit(events, extraParams) {
    this.emitter().emit(events, extraParams);
    return this;
  },
  emitAndNotify: function emitAndNotify(event, eles) {
    this.emit(event);
    this.notify(event, eles);
    return this;
  }
};
define$3.eventAliasesOn(elesfn$v);

var corefn$2 = {
  png: function png(options) {
    var renderer = this._private.renderer;
    options = options || {};
    return renderer.png(options);
  },
  jpg: function jpg(options) {
    var renderer = this._private.renderer;
    options = options || {};
    options.bg = options.bg || '#fff';
    return renderer.jpg(options);
  }
};
corefn$2.jpeg = corefn$2.jpg;

var corefn$3 = {
  layout: function layout(options) {
    var cy = this;

    if (options == null) {
      error('Layout options must be specified to make a layout');
      return;
    }

    if (options.name == null) {
      error('A `name` must be specified to make a layout');
      return;
    }

    var name = options.name;
    var Layout = cy.extension('layout', name);

    if (Layout == null) {
      error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');
      return;
    }

    var eles;

    if (string(options.eles)) {
      eles = cy.$(options.eles);
    } else {
      eles = options.eles != null ? options.eles : cy.$();
    }

    var layout = new Layout(extend({}, options, {
      cy: cy,
      eles: eles
    }));
    return layout;
  }
};
corefn$3.createLayout = corefn$3.makeLayout = corefn$3.layout;

var corefn$4 = {
  notify: function notify(eventName, eventEles) {
    var _p = this._private;

    if (this.batching()) {
      _p.batchNotifications = _p.batchNotifications || {};
      var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();

      if (eventEles != null) {
        eles.merge(eventEles);
      }

      return; // notifications are disabled during batching
    }

    if (!_p.notificationsEnabled) {
      return;
    } // exit on disabled


    var renderer = this.renderer(); // exit if destroy() called on core or renderer in between frames #1499 #1528

    if (this.destroyed() || !renderer) {
      return;
    }

    renderer.notify(eventName, eventEles);
  },
  notifications: function notifications(bool) {
    var p = this._private;

    if (bool === undefined) {
      return p.notificationsEnabled;
    } else {
      p.notificationsEnabled = bool ? true : false;
    }

    return this;
  },
  noNotifications: function noNotifications(callback) {
    this.notifications(false);
    callback();
    this.notifications(true);
  },
  batching: function batching() {
    return this._private.batchCount > 0;
  },
  startBatch: function startBatch() {
    var _p = this._private;

    if (_p.batchCount == null) {
      _p.batchCount = 0;
    }

    if (_p.batchCount === 0) {
      _p.batchStyleEles = this.collection();
      _p.batchNotifications = {};
    }

    _p.batchCount++;
    return this;
  },
  endBatch: function endBatch() {
    var _p = this._private;

    if (_p.batchCount === 0) {
      return this;
    }

    _p.batchCount--;

    if (_p.batchCount === 0) {
      // update style for dirty eles
      _p.batchStyleEles.updateStyle();

      var renderer = this.renderer(); // notify the renderer of queued eles and event types

      Object.keys(_p.batchNotifications).forEach(function (eventName) {
        var eles = _p.batchNotifications[eventName];

        if (eles.empty()) {
          renderer.notify(eventName);
        } else {
          renderer.notify(eventName, eles);
        }
      });
    }

    return this;
  },
  batch: function batch(callback) {
    this.startBatch();
    callback();
    this.endBatch();
    return this;
  },
  // for backwards compatibility
  batchData: function batchData(map) {
    var cy = this;
    return this.batch(function () {
      var ids = Object.keys(map);

      for (var i = 0; i < ids.length; i++) {
        var id = ids[i];
        var data = map[id];
        var ele = cy.getElementById(id);
        ele.data(data);
      }
    });
  }
};

var rendererDefaults = defaults({
  hideEdgesOnViewport: false,
  textureOnViewport: false,
  motionBlur: false,
  motionBlurOpacity: 0.05,
  pixelRatio: undefined,
  desktopTapThreshold: 4,
  touchTapThreshold: 8,
  wheelSensitivity: 1,
  debug: false,
  showFps: false
});
var corefn$5 = {
  renderTo: function renderTo(context, zoom, pan, pxRatio) {
    var r = this._private.renderer;
    r.renderTo(context, zoom, pan, pxRatio);
    return this;
  },
  renderer: function renderer() {
    return this._private.renderer;
  },
  forceRender: function forceRender() {
    this.notify('draw');
    return this;
  },
  resize: function resize() {
    this.invalidateSize();
    this.emitAndNotify('resize');
    return this;
  },
  initRenderer: function initRenderer(options) {
    var cy = this;
    var RendererProto = cy.extension('renderer', options.name);

    if (RendererProto == null) {
      error("Can not initialise: No such renderer `".concat(options.name, "` found. Did you forget to import it and `cytoscape.use()` it?"));
      return;
    }

    if (options.wheelSensitivity !== undefined) {
      warn("You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.");
    }

    var rOpts = rendererDefaults(options);
    rOpts.cy = cy;
    cy._private.renderer = new RendererProto(rOpts);
    this.notify('init');
  },
  destroyRenderer: function destroyRenderer() {
    var cy = this;
    cy.notify('destroy'); // destroy the renderer

    var domEle = cy.container();

    if (domEle) {
      domEle._cyreg = null;

      while (domEle.childNodes.length > 0) {
        domEle.removeChild(domEle.childNodes[0]);
      }
    }

    cy._private.renderer = null; // to be extra safe, remove the ref

    cy.mutableElements().forEach(function (ele) {
      var _p = ele._private;
      _p.rscratch = {};
      _p.rstyle = {};
      _p.animation.current = [];
      _p.animation.queue = [];
    });
  },
  onRender: function onRender(fn) {
    return this.on('render', fn);
  },
  offRender: function offRender(fn) {
    return this.off('render', fn);
  }
};
corefn$5.invalidateDimensions = corefn$5.resize;

var corefn$6 = {
  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function collection(eles, opts) {
    if (string(eles)) {
      return this.$(eles);
    } else if (elementOrCollection(eles)) {
      return eles.collection();
    } else if (array(eles)) {
      return new Collection(this, eles, opts);
    }

    return new Collection(this);
  },
  nodes: function nodes(selector) {
    var nodes = this.$(function (ele) {
      return ele.isNode();
    });

    if (selector) {
      return nodes.filter(selector);
    }

    return nodes;
  },
  edges: function edges(selector) {
    var edges = this.$(function (ele) {
      return ele.isEdge();
    });

    if (selector) {
      return edges.filter(selector);
    }

    return edges;
  },
  // search the graph like jQuery
  $: function $(selector) {
    var eles = this._private.elements;

    if (selector) {
      return eles.filter(selector);
    } else {
      return eles.spawnSelf();
    }
  },
  mutableElements: function mutableElements() {
    return this._private.elements;
  }
}; // aliases

corefn$6.elements = corefn$6.filter = corefn$6.$;

var styfn = {}; // keys for style blocks, e.g. ttfftt

var TRUE = 't';
var FALSE = 'f'; // (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it

styfn.apply = function (eles) {
  var self = this;
  var _p = self._private;
  var cy = _p.cy;
  var updatedEles = cy.collection();

  if (_p.newStyle) {
    // clear style caches
    _p.contextStyles = {};
    _p.propDiffs = {};
    self.cleanElements(eles, true);
  }

  for (var ie = 0; ie < eles.length; ie++) {
    var ele = eles[ie];
    var cxtMeta = self.getContextMeta(ele);

    if (cxtMeta.empty) {
      continue;
    }

    var cxtStyle = self.getContextStyle(cxtMeta);
    var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);

    if (!_p.newStyle) {
      self.updateTransitions(ele, app.diffProps);
    }

    var hintsDiff = self.updateStyleHints(ele);

    if (hintsDiff) {
      updatedEles.merge(ele);
    }
  } // for elements


  _p.newStyle = false;
  return updatedEles;
};

styfn.getPropertiesDiff = function (oldCxtKey, newCxtKey) {
  var self = this;
  var cache = self._private.propDiffs = self._private.propDiffs || {};
  var dualCxtKey = oldCxtKey + '-' + newCxtKey;
  var cachedVal = cache[dualCxtKey];

  if (cachedVal) {
    return cachedVal;
  }

  var diffProps = [];
  var addedProp = {};

  for (var i = 0; i < self.length; i++) {
    var cxt = self[i];
    var oldHasCxt = oldCxtKey[i] === TRUE;
    var newHasCxt = newCxtKey[i] === TRUE;
    var cxtHasDiffed = oldHasCxt !== newHasCxt;
    var cxtHasMappedProps = cxt.mappedProperties.length > 0;

    if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {
      var props = void 0;

      if (cxtHasDiffed && cxtHasMappedProps) {
        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
      } else if (cxtHasDiffed) {
        props = cxt.properties; // need to check them all
      } else if (cxtHasMappedProps) {
        props = cxt.mappedProperties; // only need to check mapped
      }

      for (var j = 0; j < props.length; j++) {
        var prop = props[j];
        var name = prop.name; // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
        // is cached)

        var laterCxtOverrides = false;

        for (var k = i + 1; k < self.length; k++) {
          var laterCxt = self[k];
          var hasLaterCxt = newCxtKey[k] === TRUE;

          if (!hasLaterCxt) {
            continue;
          } // can't override unless the context is active


          laterCxtOverrides = laterCxt.properties[prop.name] != null;

          if (laterCxtOverrides) {
            break;
          } // exit early as long as one later context overrides

        }

        if (!addedProp[name] && !laterCxtOverrides) {
          addedProp[name] = true;
          diffProps.push(name);
        }
      } // for props

    } // if

  } // for contexts


  cache[dualCxtKey] = diffProps;
  return diffProps;
};

styfn.getContextMeta = function (ele) {
  var self = this;
  var cxtKey = '';
  var diffProps;
  var prevKey = ele._private.styleCxtKey || '';

  if (self._private.newStyle) {
    prevKey = ''; // since we need to apply all style if a fresh stylesheet
  } // get the cxt key


  for (var i = 0; i < self.length; i++) {
    var context = self[i];
    var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'

    if (contextSelectorMatches) {
      cxtKey += TRUE;
    } else {
      cxtKey += FALSE;
    }
  } // for context


  diffProps = self.getPropertiesDiff(prevKey, cxtKey);
  ele._private.styleCxtKey = cxtKey;
  return {
    key: cxtKey,
    diffPropNames: diffProps,
    empty: diffProps.length === 0
  };
}; // gets a computed ele style object based on matched contexts


styfn.getContextStyle = function (cxtMeta) {
  var cxtKey = cxtMeta.key;
  var self = this;
  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {}; // if already computed style, returned cached copy

  if (cxtStyles[cxtKey]) {
    return cxtStyles[cxtKey];
  }

  var style = {
    _private: {
      key: cxtKey
    }
  };

  for (var i = 0; i < self.length; i++) {
    var cxt = self[i];
    var hasCxt = cxtKey[i] === TRUE;

    if (!hasCxt) {
      continue;
    }

    for (var j = 0; j < cxt.properties.length; j++) {
      var prop = cxt.properties[j];
      style[prop.name] = prop;
    }
  }

  cxtStyles[cxtKey] = style;
  return style;
};

styfn.applyContextStyle = function (cxtMeta, cxtStyle, ele) {
  var self = this;
  var diffProps = cxtMeta.diffPropNames;
  var retDiffProps = {};
  var types = self.types;

  for (var i = 0; i < diffProps.length; i++) {
    var diffPropName = diffProps[i];
    var cxtProp = cxtStyle[diffPropName];
    var eleProp = ele.pstyle(diffPropName);

    if (!cxtProp) {
      // no context prop means delete
      if (!eleProp) {
        continue; // no existing prop means nothing needs to be removed
        // nb affects initial application on mapped values like control-point-distances
      } else if (eleProp.bypass) {
        cxtProp = {
          name: diffPropName,
          deleteBypassed: true
        };
      } else {
        cxtProp = {
          name: diffPropName,
          "delete": true
        };
      }
    } // save cycles when the context prop doesn't need to be applied


    if (eleProp === cxtProp) {
      continue;
    } // save cycles when a mapped context prop doesn't need to be applied


    if (cxtProp.mapped === types.fn // context prop is function mapper
    && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)
    && eleProp.mapping != null // ele prop is a concrete value from from a mapper
    && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper
    ) {
        // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)
        var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy

        var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss

        if (fnValue === mapping.prevFnValue) {
          continue;
        }
      }

    var retDiffProp = retDiffProps[diffPropName] = {
      prev: eleProp
    };
    self.applyParsedProperty(ele, cxtProp);
    retDiffProp.next = ele.pstyle(diffPropName);

    if (retDiffProp.next && retDiffProp.next.bypass) {
      retDiffProp.next = retDiffProp.next.bypassed;
    }
  }

  return {
    diffProps: retDiffProps
  };
};

styfn.updateStyleHints = function (ele) {
  var _p = ele._private;
  var self = this;
  var propNames = self.propertyGroupNames;
  var propGrKeys = self.propertyGroupKeys;

  var propHash = function propHash(ele, propNames, seedKey) {
    return self.getPropertiesHash(ele, propNames, seedKey);
  };

  var oldStyleKey = _p.styleKey;

  if (ele.removed()) {
    return false;
  }

  var isNode = _p.group === 'nodes'; // get the style key hashes per prop group
  // but lazily -- only use non-default prop values to reduce the number of hashes
  //

  var overriddenStyles = ele._private.style;
  propNames = Object.keys(overriddenStyles);

  for (var i = 0; i < propGrKeys.length; i++) {
    var grKey = propGrKeys[i];
    _p.styleKeys[grKey] = 0;
  }

  var updateGrKey = function updateGrKey(val, grKey) {
    return _p.styleKeys[grKey] = hashInt(val, _p.styleKeys[grKey]);
  };

  var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {
    for (var j = 0; j < strVal.length; j++) {
      updateGrKey(strVal.charCodeAt(j), grKey);
    }
  }; // - hashing works on 32 bit ints b/c we use bitwise ops
  // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)
  // - raise up small numbers so more significant digits are seen by hashing
  // - make small numbers larger than a normal value to avoid collisions
  // - works in practice and it's relatively cheap


  var N = 2000000000;

  var cleanNum = function cleanNum(val) {
    return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;
  };

  for (var _i = 0; _i < propNames.length; _i++) {
    var name = propNames[_i];
    var parsedProp = overriddenStyles[name];

    if (parsedProp == null) {
      continue;
    }

    var propInfo = this.properties[name];
    var type = propInfo.type;
    var _grKey = propInfo.groupKey;
    var normalizedNumberVal = void 0;

    if (propInfo.hashOverride != null) {
      normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);
    } else if (parsedProp.pfValue != null) {
      normalizedNumberVal = parsedProp.pfValue;
    } // might not be a number if it allows enums


    var numberVal = propInfo.enums == null ? parsedProp.value : null;
    var haveNormNum = normalizedNumberVal != null;
    var haveUnitedNum = numberVal != null;
    var haveNum = haveNormNum || haveUnitedNum;
    var units = parsedProp.units; // numbers are cheaper to hash than strings
    // 1 hash op vs n hash ops (for length n string)

    if (type.number && haveNum) {
      var v = haveNormNum ? normalizedNumberVal : numberVal;

      if (type.multiple) {
        for (var _i2 = 0; _i2 < v.length; _i2++) {
          updateGrKey(cleanNum(v[_i2]), _grKey);
        }
      } else {
        updateGrKey(cleanNum(v), _grKey);
      }

      if (!haveNormNum && units != null) {
        updateGrKeyWStr(units, _grKey);
      }
    } else {
      updateGrKeyWStr(parsedProp.strValue, _grKey);
    }
  } // overall style key
  //


  var hash = 0;

  for (var _i3 = 0; _i3 < propGrKeys.length; _i3++) {
    var _grKey2 = propGrKeys[_i3];
    var grHash = _p.styleKeys[_grKey2];
    hash = hashInt(grHash, hash);
  }

  _p.styleKey = hash; // label dims
  //

  var labelDimsKey = _p.labelDimsKey = _p.styleKeys.labelDimensions;
  _p.labelKey = propHash(ele, ['label'], labelDimsKey);
  _p.labelStyleKey = hashInt(_p.styleKeys.commonLabel, _p.labelKey);

  if (!isNode) {
    _p.sourceLabelKey = propHash(ele, ['source-label'], labelDimsKey);
    _p.sourceLabelStyleKey = hashInt(_p.styleKeys.commonLabel, _p.sourceLabelKey);
    _p.targetLabelKey = propHash(ele, ['target-label'], labelDimsKey);
    _p.targetLabelStyleKey = hashInt(_p.styleKeys.commonLabel, _p.targetLabelKey);
  } // node
  //


  if (isNode) {
    var _p$styleKeys = _p.styleKeys,
        nodeBody = _p$styleKeys.nodeBody,
        nodeBorder = _p$styleKeys.nodeBorder,
        backgroundImage = _p$styleKeys.backgroundImage,
        compound = _p$styleKeys.compound,
        pie = _p$styleKeys.pie;
    _p.nodeKey = hashIntsArray([nodeBorder, backgroundImage, compound, pie], nodeBody);
    _p.hasPie = pie != 0;
  }

  return oldStyleKey !== _p.styleKey;
};

styfn.clearStyleHints = function (ele) {
  var _p = ele._private;
  _p.styleKeys = {};
  _p.styleKey = null;
  _p.labelKey = null;
  _p.labelStyleKey = null;
  _p.sourceLabelKey = null;
  _p.sourceLabelStyleKey = null;
  _p.targetLabelKey = null;
  _p.targetLabelStyleKey = null;
  _p.nodeKey = null;
  _p.hasPie = null;
}; // apply a property to the style (for internal use)
// returns whether application was successful
//
// now, this function flattens the property, and here's how:
//
// for parsedProp:{ bypass: true, deleteBypass: true }
// no property is generated, instead the bypass property in the
// element's style is replaced by what's pointed to by the `bypassed`
// field in the bypass property (i.e. restoring the property the
// bypass was overriding)
//
// for parsedProp:{ mapped: truthy }
// the generated flattenedProp:{ mapping: prop }
//
// for parsedProp:{ bypass: true }
// the generated flattenedProp:{ bypassed: parsedProp }


styfn.applyParsedProperty = function (ele, parsedProp) {
  var self = this;
  var prop = parsedProp;
  var style = ele._private.style;
  var flatProp;
  var types = self.types;
  var type = self.properties[prop.name].type;
  var propIsBypass = prop.bypass;
  var origProp = style[prop.name];
  var origPropIsBypass = origProp && origProp.bypass;
  var _p = ele._private;
  var flatPropMapping = 'mapping';

  var getVal = function getVal(p) {
    if (p == null) {
      return null;
    } else if (p.pfValue != null) {
      return p.pfValue;
    } else {
      return p.value;
    }
  };

  var checkTriggers = function checkTriggers() {
    var fromVal = getVal(origProp);
    var toVal = getVal(prop);
    self.checkTriggers(ele, prop.name, fromVal, toVal);
  }; // edge sanity checks to prevent the client from making serious mistakes


  if (parsedProp.name === 'curve-style' && ele.isEdge() && ( // loops must be bundled beziers
  parsedProp.value !== 'bezier' && ele.isLoop() || // edges connected to compound nodes can not be haystacks
  parsedProp.value === 'haystack' && (ele.source().isParent() || ele.target().isParent()))) {
    prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);
  }

  if (prop["delete"]) {
    // delete the property and use the default value on falsey value
    style[prop.name] = undefined;
    checkTriggers();
    return true;
  }

  if (prop.deleteBypassed) {
    // delete the property that the
    if (!origProp) {
      checkTriggers();
      return true; // can't delete if no prop
    } else if (origProp.bypass) {
      // delete bypassed
      origProp.bypassed = undefined;
      checkTriggers();
      return true;
    } else {
      return false; // we're unsuccessful deleting the bypassed
    }
  } // check if we need to delete the current bypass


  if (prop.deleteBypass) {
    // then this property is just here to indicate we need to delete
    if (!origProp) {
      checkTriggers();
      return true; // property is already not defined
    } else if (origProp.bypass) {
      // then replace the bypass property with the original
      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
      style[prop.name] = origProp.bypassed;
      checkTriggers();
      return true;
    } else {
      return false; // we're unsuccessful deleting the bypass
    }
  }

  var printMappingErr = function printMappingErr() {
    warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');
  }; // put the property in the style objects


  switch (prop.mapped) {
    // flatten the property if mapped
    case types.mapData:
      {
        // flatten the field (e.g. data.foo.bar)
        var fields = prop.field.split('.');
        var fieldVal = _p.data;

        for (var i = 0; i < fields.length && fieldVal; i++) {
          var field = fields[i];
          fieldVal = fieldVal[field];
        }

        if (fieldVal == null) {
          printMappingErr();
          return false;
        }

        var percent;

        if (!number(fieldVal)) {
          // then don't apply and fall back on the existing style
          warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');
          return false;
        } else {
          var fieldWidth = prop.fieldMax - prop.fieldMin;

          if (fieldWidth === 0) {
            // safety check -- not strictly necessary as no props of zero range should be passed here
            percent = 0;
          } else {
            percent = (fieldVal - prop.fieldMin) / fieldWidth;
          }
        } // make sure to bound percent value


        if (percent < 0) {
          percent = 0;
        } else if (percent > 1) {
          percent = 1;
        }

        if (type.color) {
          var r1 = prop.valueMin[0];
          var r2 = prop.valueMax[0];
          var g1 = prop.valueMin[1];
          var g2 = prop.valueMax[1];
          var b1 = prop.valueMin[2];
          var b2 = prop.valueMax[2];
          var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
          var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];
          var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];
          flatProp = {
            // colours are simple, so just create the flat property instead of expensive string parsing
            bypass: prop.bypass,
            // we're a bypass if the mapping property is a bypass
            name: prop.name,
            value: clr,
            strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
          };
        } else if (type.number) {
          var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
          flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);
        } else {
          return false; // can only map to colours and numbers
        }

        if (!flatProp) {
          // if we can't flatten the property, then don't apply the property and fall back on the existing style
          printMappingErr();
          return false;
        }

        flatProp.mapping = prop; // keep a reference to the mapping

        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }
    // direct mapping

    case types.data:
      {
        // flatten the field (e.g. data.foo.bar)
        var _fields = prop.field.split('.');

        var _fieldVal = _p.data;

        for (var _i4 = 0; _i4 < _fields.length && _fieldVal; _i4++) {
          var _field = _fields[_i4];
          _fieldVal = _fieldVal[_field];
        }

        if (_fieldVal != null) {
          flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);
        }

        if (!flatProp) {
          // if we can't flatten the property, then don't apply and fall back on the existing style
          printMappingErr();
          return false;
        }

        flatProp.mapping = prop; // keep a reference to the mapping

        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }

    case types.fn:
      {
        var fn = prop.value;
        var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function

        prop.prevFnValue = fnRetVal;

        if (fnRetVal == null) {
          warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');
          return false;
        }

        flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);

        if (!flatProp) {
          warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');
          return false;
        }

        flatProp.mapping = copy(prop); // keep a reference to the mapping

        prop = flatProp; // the flattened (mapped) property is the one we want

        break;
      }

    case undefined:
      break;
    // just set the property

    default:
      return false;
    // not a valid mapping
  } // if the property is a bypass property, then link the resultant property to the original one


  if (propIsBypass) {
    if (origPropIsBypass) {
      // then this bypass overrides the existing one
      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
    } else {
      // then link the orig prop to the new bypass
      prop.bypassed = origProp;
    }

    style[prop.name] = prop; // and set
  } else {
    // prop is not bypass
    if (origPropIsBypass) {
      // then keep the orig prop (since it's a bypass) and link to the new prop
      origProp.bypassed = prop;
    } else {
      // then just replace the old prop with the new one
      style[prop.name] = prop;
    }
  }

  checkTriggers();
  return true;
};

styfn.cleanElements = function (eles, keepBypasses) {
  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    this.clearStyleHints(ele);
    ele.dirtyCompoundBoundsCache();
    ele.dirtyBoundingBoxCache();

    if (!keepBypasses) {
      ele._private.style = {};
    } else {
      var style = ele._private.style;
      var propNames = Object.keys(style);

      for (var j = 0; j < propNames.length; j++) {
        var propName = propNames[j];
        var eleProp = style[propName];

        if (eleProp != null) {
          if (eleProp.bypass) {
            eleProp.bypassed = null;
          } else {
            style[propName] = null;
          }
        }
      }
    }
  }
}; // updates the visual style for all elements (useful for manual style modification after init)


styfn.update = function () {
  var cy = this._private.cy;
  var eles = cy.mutableElements();
  eles.updateStyle();
}; // diffProps : { name => { prev, next } }


styfn.updateTransitions = function (ele, diffProps) {
  var self = this;
  var _p = ele._private;
  var props = ele.pstyle('transition-property').value;
  var duration = ele.pstyle('transition-duration').pfValue;
  var delay = ele.pstyle('transition-delay').pfValue;

  if (props.length > 0 && duration > 0) {
    var style = {}; // build up the style to animate towards

    var anyPrev = false;

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      var styProp = ele.pstyle(prop);
      var diffProp = diffProps[prop];

      if (!diffProp) {
        continue;
      }

      var prevProp = diffProp.prev;
      var fromProp = prevProp;
      var toProp = diffProp.next != null ? diffProp.next : styProp;
      var diff = false;
      var initVal = void 0;
      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

      if (!fromProp) {
        continue;
      } // consider px values


      if (number(fromProp.pfValue) && number(toProp.pfValue)) {
        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy

        initVal = fromProp.pfValue + initDt * diff; // consider numerical values
      } else if (number(fromProp.value) && number(toProp.value)) {
        diff = toProp.value - fromProp.value; // nonzero is truthy

        initVal = fromProp.value + initDt * diff; // consider colour values
      } else if (array(fromProp.value) && array(toProp.value)) {
        diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];
        initVal = fromProp.strValue;
      } // the previous value is good for an animation only if it's different


      if (diff) {
        style[prop] = toProp.strValue; // to val

        this.applyBypass(ele, prop, initVal); // from val

        anyPrev = true;
      }
    } // end if props allow ani
    // can't transition if there's nothing previous to transition from


    if (!anyPrev) {
      return;
    }

    _p.transitioning = true;
    new Promise$1(function (resolve) {
      if (delay > 0) {
        ele.delayAnimation(delay).play().promise().then(resolve);
      } else {
        resolve();
      }
    }).then(function () {
      return ele.animation({
        style: style,
        duration: duration,
        easing: ele.pstyle('transition-timing-function').value,
        queue: false
      }).play().promise();
    }).then(function () {
      // if( !isBypass ){
      self.removeBypasses(ele, props);
      ele.emitAndNotify('style'); // }

      _p.transitioning = false;
    });
  } else if (_p.transitioning) {
    this.removeBypasses(ele, props);
    ele.emitAndNotify('style');
    _p.transitioning = false;
  }
};

styfn.checkTrigger = function (ele, name, fromValue, toValue, getTrigger, onTrigger) {
  var prop = this.properties[name];
  var triggerCheck = getTrigger(prop);

  if (triggerCheck != null && triggerCheck(fromValue, toValue)) {
    onTrigger(prop);
  }
};

styfn.checkZOrderTrigger = function (ele, name, fromValue, toValue) {
  var _this = this;

  this.checkTrigger(ele, name, fromValue, toValue, function (prop) {
    return prop.triggersZOrder;
  }, function () {
    _this._private.cy.notify('zorder', ele);
  });
};

styfn.checkBoundsTrigger = function (ele, name, fromValue, toValue) {
  this.checkTrigger(ele, name, fromValue, toValue, function (prop) {
    return prop.triggersBounds;
  }, function (prop) {
    ele.dirtyCompoundBoundsCache();
    ele.dirtyBoundingBoxCache(); // if the prop change makes the bb of pll bezier edges invalid,
    // then dirty the pll edge bb cache as well

    if ( // only for beziers -- so performance of other edges isn't affected
    (ele.pstyle('curve-style').value === 'bezier' // already a bezier
    // was just now changed to or from a bezier:
    || name === 'curve-style' && (fromValue === 'bezier' || toValue === 'bezier')) && prop.triggersBoundsOfParallelBeziers) {
      ele.parallelEdges().forEach(function (pllEdge) {
        if (pllEdge.isBundledBezier()) {
          pllEdge.dirtyBoundingBoxCache();
        }
      });
    }
  });
};

styfn.checkTriggers = function (ele, name, fromValue, toValue) {
  ele.dirtyStyleCache();
  this.checkZOrderTrigger(ele, name, fromValue, toValue);
  this.checkBoundsTrigger(ele, name, fromValue, toValue);
};

var styfn$1 = {}; // bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property

styfn$1.applyBypass = function (eles, name, value, updateTransitions) {
  var self = this;
  var props = [];
  var isBypass = true; // put all the properties (can specify one or many) in an array after parsing them

  if (name === '*' || name === '**') {
    // apply to all property names
    if (value !== undefined) {
      for (var i = 0; i < self.properties.length; i++) {
        var prop = self.properties[i];
        var _name = prop.name;
        var parsedProp = this.parse(_name, value, true);

        if (parsedProp) {
          props.push(parsedProp);
        }
      }
    }
  } else if (string(name)) {
    // then parse the single property
    var _parsedProp = this.parse(name, value, true);

    if (_parsedProp) {
      props.push(_parsedProp);
    }
  } else if (plainObject(name)) {
    // then parse each property
    var specifiedProps = name;
    updateTransitions = value;
    var names = Object.keys(specifiedProps);

    for (var _i = 0; _i < names.length; _i++) {
      var _name2 = names[_i];
      var _value = specifiedProps[_name2];

      if (_value === undefined) {
        // try camel case name too
        _value = specifiedProps[dash2camel(_name2)];
      }

      if (_value !== undefined) {
        var _parsedProp2 = this.parse(_name2, _value, true);

        if (_parsedProp2) {
          props.push(_parsedProp2);
        }
      }
    }
  } else {
    // can't do anything without well defined properties
    return false;
  } // we've failed if there are no valid properties


  if (props.length === 0) {
    return false;
  } // now, apply the bypass properties on the elements


  var ret = false; // return true if at least one succesful bypass applied

  for (var _i2 = 0; _i2 < eles.length; _i2++) {
    // for each ele
    var ele = eles[_i2];
    var diffProps = {};
    var diffProp = void 0;

    for (var j = 0; j < props.length; j++) {
      // for each prop
      var _prop = props[j];

      if (updateTransitions) {
        var prevProp = ele.pstyle(_prop.name);
        diffProp = diffProps[_prop.name] = {
          prev: prevProp
        };
      }

      ret = this.applyParsedProperty(ele, _prop) || ret;

      if (updateTransitions) {
        diffProp.next = ele.pstyle(_prop.name);
      }
    } // for props


    if (ret) {
      this.updateStyleHints(ele);
    }

    if (updateTransitions) {
      this.updateTransitions(ele, diffProps, isBypass);
    }
  } // for eles


  return ret;
}; // only useful in specific cases like animation


styfn$1.overrideBypass = function (eles, name, value) {
  name = camel2dash(name);

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var prop = ele._private.style[name];
    var type = this.properties[name].type;
    var isColor = type.color;
    var isMulti = type.mutiple;
    var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;

    if (!prop || !prop.bypass) {
      // need a bypass if one doesn't exist
      this.applyBypass(ele, name, value);
    } else {
      prop.value = value;

      if (prop.pfValue != null) {
        prop.pfValue = value;
      }

      if (isColor) {
        prop.strValue = 'rgb(' + value.join(',') + ')';
      } else if (isMulti) {
        prop.strValue = value.join(' ');
      } else {
        prop.strValue = '' + value;
      }

      this.updateStyleHints(ele);
    }

    this.checkTriggers(ele, name, oldValue, value);
  }
};

styfn$1.removeAllBypasses = function (eles, updateTransitions) {
  return this.removeBypasses(eles, this.propertyNames, updateTransitions);
};

styfn$1.removeBypasses = function (eles, props, updateTransitions) {
  var isBypass = true;

  for (var j = 0; j < eles.length; j++) {
    var ele = eles[j];
    var diffProps = {};

    for (var i = 0; i < props.length; i++) {
      var name = props[i];
      var prop = this.properties[name];
      var prevProp = ele.pstyle(prop.name);

      if (!prevProp || !prevProp.bypass) {
        // if a bypass doesn't exist for the prop, nothing needs to be removed
        continue;
      }

      var value = ''; // empty => remove bypass

      var parsedProp = this.parse(name, value, true);
      var diffProp = diffProps[prop.name] = {
        prev: prevProp
      };
      this.applyParsedProperty(ele, parsedProp);
      diffProp.next = ele.pstyle(prop.name);
    } // for props


    this.updateStyleHints(ele);

    if (updateTransitions) {
      this.updateTransitions(ele, diffProps, isBypass);
    }
  } // for eles

};

var styfn$2 = {}; // gets what an em size corresponds to in pixels relative to a dom element

styfn$2.getEmSizeInPixels = function () {
  var px = this.containerCss('font-size');

  if (px != null) {
    return parseFloat(px);
  } else {
    return 1; // for headless
  }
}; // gets css property from the core container


styfn$2.containerCss = function (propName) {
  var cy = this._private.cy;
  var domElement = cy.container();

  if (window$1 && domElement && window$1.getComputedStyle) {
    return window$1.getComputedStyle(domElement).getPropertyValue(propName);
  }
};

var styfn$3 = {}; // gets the rendered style for an element

styfn$3.getRenderedStyle = function (ele, prop) {
  if (prop) {
    return this.getStylePropertyValue(ele, prop, true);
  } else {
    return this.getRawStyle(ele, true);
  }
}; // gets the raw style for an element


styfn$3.getRawStyle = function (ele, isRenderedVal) {
  var self = this;
  ele = ele[0]; // insure it's an element

  if (ele) {
    var rstyle = {};

    for (var i = 0; i < self.properties.length; i++) {
      var prop = self.properties[i];
      var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);

      if (val != null) {
        rstyle[prop.name] = val;
        rstyle[dash2camel(prop.name)] = val;
      }
    }

    return rstyle;
  }
};

styfn$3.getIndexedStyle = function (ele, property, subproperty, index) {
  var pstyle = ele.pstyle(property)[subproperty][index];
  return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];
};

styfn$3.getStylePropertyValue = function (ele, propName, isRenderedVal) {
  var self = this;
  ele = ele[0]; // insure it's an element

  if (ele) {
    var prop = self.properties[propName];

    if (prop.alias) {
      prop = prop.pointsTo;
    }

    var type = prop.type;
    var styleProp = ele.pstyle(prop.name);

    if (styleProp) {
      var value = styleProp.value,
          units = styleProp.units,
          strValue = styleProp.strValue;

      if (isRenderedVal && type.number && value != null && number(value)) {
        var zoom = ele.cy().zoom();

        var getRenderedValue = function getRenderedValue(val) {
          return val * zoom;
        };

        var getValueStringWithUnits = function getValueStringWithUnits(val, units) {
          return getRenderedValue(val) + units;
        };

        var isArrayValue = array(value);
        var haveUnits = isArrayValue ? units.every(function (u) {
          return u != null;
        }) : units != null;

        if (haveUnits) {
          if (isArrayValue) {
            return value.map(function (v, i) {
              return getValueStringWithUnits(v, units[i]);
            }).join(' ');
          } else {
            return getValueStringWithUnits(value, units);
          }
        } else {
          if (isArrayValue) {
            return value.map(function (v) {
              return string(v) ? v : '' + getRenderedValue(v);
            }).join(' ');
          } else {
            return '' + getRenderedValue(value);
          }
        }
      } else if (strValue != null) {
        return strValue;
      }
    }

    return null;
  }
};

styfn$3.getAnimationStartStyle = function (ele, aniProps) {
  var rstyle = {};

  for (var i = 0; i < aniProps.length; i++) {
    var aniProp = aniProps[i];
    var name = aniProp.name;
    var styleProp = ele.pstyle(name);

    if (styleProp !== undefined) {
      // then make a prop of it
      if (plainObject(styleProp)) {
        styleProp = this.parse(name, styleProp.strValue);
      } else {
        styleProp = this.parse(name, styleProp);
      }
    }

    if (styleProp) {
      rstyle[name] = styleProp;
    }
  }

  return rstyle;
};

styfn$3.getPropsList = function (propsObj) {
  var self = this;
  var rstyle = [];
  var style = propsObj;
  var props = self.properties;

  if (style) {
    var names = Object.keys(style);

    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      var val = style[name];
      var prop = props[name] || props[camel2dash(name)];
      var styleProp = this.parse(prop.name, val);

      if (styleProp) {
        rstyle.push(styleProp);
      }
    }
  }

  return rstyle;
};

styfn$3.getNonDefaultPropertiesHash = function (ele, propNames, seed) {
  var hash = seed;
  var name, val, strVal, chVal;
  var i, j;

  for (i = 0; i < propNames.length; i++) {
    name = propNames[i];
    val = ele.pstyle(name, false);

    if (val == null) {
      continue;
    } else if (val.pfValue != null) {
      hash = hashInt(chVal, hash);
    } else {
      strVal = val.strValue;

      for (j = 0; j < strVal.length; j++) {
        chVal = strVal.charCodeAt(j);
        hash = hashInt(chVal, hash);
      }
    }
  }

  return hash;
};

styfn$3.getPropertiesHash = styfn$3.getNonDefaultPropertiesHash;

var styfn$4 = {};

styfn$4.appendFromJson = function (json) {
  var style = this;

  for (var i = 0; i < json.length; i++) {
    var context = json[i];
    var selector = context.selector;
    var props = context.style || context.css;
    var names = Object.keys(props);
    style.selector(selector); // apply selector

    for (var j = 0; j < names.length; j++) {
      var name = names[j];
      var value = props[name];
      style.css(name, value); // apply property
    }
  }

  return style;
}; // accessible cy.style() function


styfn$4.fromJson = function (json) {
  var style = this;
  style.resetToDefault();
  style.appendFromJson(json);
  return style;
}; // get json from cy.style() api


styfn$4.json = function () {
  var json = [];

  for (var i = this.defaultLength; i < this.length; i++) {
    var cxt = this[i];
    var selector = cxt.selector;
    var props = cxt.properties;
    var css = {};

    for (var j = 0; j < props.length; j++) {
      var prop = props[j];
      css[prop.name] = prop.strValue;
    }

    json.push({
      selector: !selector ? 'core' : selector.toString(),
      style: css
    });
  }

  return json;
};

var styfn$5 = {};

styfn$5.appendFromString = function (string) {
  var self = this;
  var style = this;
  var remaining = '' + string;
  var selAndBlockStr;
  var blockRem;
  var propAndValStr; // remove comments from the style string

  remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

  function removeSelAndBlockFromRemaining() {
    // remove the parsed selector and block from the remaining text to parse
    if (remaining.length > selAndBlockStr.length) {
      remaining = remaining.substr(selAndBlockStr.length);
    } else {
      remaining = '';
    }
  }

  function removePropAndValFromRem() {
    // remove the parsed property and value from the remaining block text to parse
    if (blockRem.length > propAndValStr.length) {
      blockRem = blockRem.substr(propAndValStr.length);
    } else {
      blockRem = '';
    }
  }

  for (;;) {
    var nothingLeftToParse = remaining.match(/^\s*$/);

    if (nothingLeftToParse) {
      break;
    }

    var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

    if (!selAndBlock) {
      warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
      break;
    }

    selAndBlockStr = selAndBlock[0]; // parse the selector

    var selectorStr = selAndBlock[1];

    if (selectorStr !== 'core') {
      var selector = new Selector(selectorStr);

      if (selector.invalid) {
        warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr); // skip this selector and block

        removeSelAndBlockFromRemaining();
        continue;
      }
    } // parse the block of properties and values


    var blockStr = selAndBlock[2];
    var invalidBlock = false;
    blockRem = blockStr;
    var props = [];

    for (;;) {
      var _nothingLeftToParse = blockRem.match(/^\s*$/);

      if (_nothingLeftToParse) {
        break;
      }

      var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

      if (!propAndVal) {
        warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
        invalidBlock = true;
        break;
      }

      propAndValStr = propAndVal[0];
      var propStr = propAndVal[1];
      var valStr = propAndVal[2];
      var prop = self.properties[propStr];

      if (!prop) {
        warn('Skipping property: Invalid property name in: ' + propAndValStr); // skip this property in the block

        removePropAndValFromRem();
        continue;
      }

      var parsedProp = style.parse(propStr, valStr);

      if (!parsedProp) {
        warn('Skipping property: Invalid property definition in: ' + propAndValStr); // skip this property in the block

        removePropAndValFromRem();
        continue;
      }

      props.push({
        name: propStr,
        val: valStr
      });
      removePropAndValFromRem();
    }

    if (invalidBlock) {
      removeSelAndBlockFromRemaining();
      break;
    } // put the parsed block in the style


    style.selector(selectorStr);

    for (var i = 0; i < props.length; i++) {
      var _prop = props[i];
      style.css(_prop.name, _prop.val);
    }

    removeSelAndBlockFromRemaining();
  }

  return style;
};

styfn$5.fromString = function (string) {
  var style = this;
  style.resetToDefault();
  style.appendFromString(string);
  return style;
};

var styfn$6 = {};

(function () {
  var number = number$1;
  var rgba = rgbaNoBackRefs;
  var hsla = hslaNoBackRefs;
  var hex3$1 = hex3;
  var hex6$1 = hex6;

  var data = function data(prefix) {
    return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$';
  };

  var mapData = function mapData(prefix) {
    var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;
    return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
  };

  var urlRegexes = ['^url\\s*\\(\\s*[\'"]?(.+?)[\'"]?\\s*\\)$', '^(none)$', '^(.+)$']; // each visual style property has a type and needs to be validated according to it

  styfn$6.types = {
    time: {
      number: true,
      min: 0,
      units: 's|ms',
      implicitUnits: 'ms'
    },
    percent: {
      number: true,
      min: 0,
      max: 100,
      units: '%',
      implicitUnits: '%'
    },
    percentages: {
      number: true,
      min: 0,
      max: 100,
      units: '%',
      implicitUnits: '%',
      multiple: true
    },
    zeroOneNumber: {
      number: true,
      min: 0,
      max: 1,
      unitless: true
    },
    zeroOneNumbers: {
      number: true,
      min: 0,
      max: 1,
      unitless: true,
      multiple: true
    },
    nOneOneNumber: {
      number: true,
      min: -1,
      max: 1,
      unitless: true
    },
    nonNegativeInt: {
      number: true,
      min: 0,
      integer: true,
      unitless: true
    },
    position: {
      enums: ['parent', 'origin']
    },
    nodeSize: {
      number: true,
      min: 0,
      enums: ['label']
    },
    number: {
      number: true,
      unitless: true
    },
    numbers: {
      number: true,
      unitless: true,
      multiple: true
    },
    positiveNumber: {
      number: true,
      unitless: true,
      min: 0,
      strictMin: true
    },
    size: {
      number: true,
      min: 0
    },
    bidirectionalSize: {
      number: true
    },
    // allows negative
    bidirectionalSizes: {
      number: true,
      multiple: true
    },
    // allows negative
    sizeMaybePercent: {
      number: true,
      min: 0,
      allowPercent: true
    },
    axisDirection: {
      enums: ['horizontal', 'leftward', 'rightward', 'vertical', 'upward', 'downward', 'auto']
    },
    paddingRelativeTo: {
      enums: ['width', 'height', 'average', 'min', 'max']
    },
    bgWH: {
      number: true,
      min: 0,
      allowPercent: true,
      enums: ['auto'],
      multiple: true
    },
    bgPos: {
      number: true,
      allowPercent: true,
      multiple: true
    },
    bgRelativeTo: {
      enums: ['inner', 'include-padding'],
      multiple: true
    },
    bgRepeat: {
      enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'],
      multiple: true
    },
    bgFit: {
      enums: ['none', 'contain', 'cover'],
      multiple: true
    },
    bgCrossOrigin: {
      enums: ['anonymous', 'use-credentials'],
      multiple: true
    },
    bgClip: {
      enums: ['none', 'node'],
      multiple: true
    },
    color: {
      color: true
    },
    colors: {
      color: true,
      multiple: true
    },
    fill: {
      enums: ['solid', 'linear-gradient', 'radial-gradient']
    },
    bool: {
      enums: ['yes', 'no']
    },
    lineStyle: {
      enums: ['solid', 'dotted', 'dashed']
    },
    lineCap: {
      enums: ['butt', 'round', 'square']
    },
    borderStyle: {
      enums: ['solid', 'dotted', 'dashed', 'double']
    },
    curveStyle: {
      enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments', 'straight', 'taxi']
    },
    fontFamily: {
      regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$'
    },
    fontStyle: {
      enums: ['italic', 'normal', 'oblique']
    },
    fontWeight: {
      enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900]
    },
    textDecoration: {
      enums: ['none', 'underline', 'overline', 'line-through']
    },
    textTransform: {
      enums: ['none', 'uppercase', 'lowercase']
    },
    textWrap: {
      enums: ['none', 'wrap', 'ellipsis']
    },
    textOverflowWrap: {
      enums: ['whitespace', 'anywhere']
    },
    textBackgroundShape: {
      enums: ['rectangle', 'roundrectangle', 'round-rectangle']
    },
    nodeShape: {
      enums: ['rectangle', 'roundrectangle', 'round-rectangle', 'cutrectangle', 'cut-rectangle', 'bottomroundrectangle', 'bottom-round-rectangle', 'barrel', 'ellipse', 'triangle', 'round-triangle', 'square', 'pentagon', 'round-pentagon', 'hexagon', 'round-hexagon', 'concavehexagon', 'concave-hexagon', 'heptagon', 'round-heptagon', 'octagon', 'round-octagon', 'tag', 'round-tag', 'star', 'diamond', 'round-diamond', 'vee', 'rhomboid', 'polygon']
    },
    compoundIncludeLabels: {
      enums: ['include', 'exclude']
    },
    arrowShape: {
      enums: ['tee', 'triangle', 'triangle-tee', 'triangle-cross', 'triangle-backcurve', 'vee', 'square', 'circle', 'diamond', 'chevron', 'none']
    },
    arrowFill: {
      enums: ['filled', 'hollow']
    },
    display: {
      enums: ['element', 'none']
    },
    visibility: {
      enums: ['hidden', 'visible']
    },
    zCompoundDepth: {
      enums: ['bottom', 'orphan', 'auto', 'top']
    },
    zIndexCompare: {
      enums: ['auto', 'manual']
    },
    valign: {
      enums: ['top', 'center', 'bottom']
    },
    halign: {
      enums: ['left', 'center', 'right']
    },
    justification: {
      enums: ['left', 'center', 'right', 'auto']
    },
    text: {
      string: true
    },
    data: {
      mapping: true,
      regex: data('data')
    },
    layoutData: {
      mapping: true,
      regex: data('layoutData')
    },
    scratch: {
      mapping: true,
      regex: data('scratch')
    },
    mapData: {
      mapping: true,
      regex: mapData('mapData')
    },
    mapLayoutData: {
      mapping: true,
      regex: mapData('mapLayoutData')
    },
    mapScratch: {
      mapping: true,
      regex: mapData('mapScratch')
    },
    fn: {
      mapping: true,
      fn: true
    },
    url: {
      regexes: urlRegexes,
      singleRegexMatchValue: true
    },
    urls: {
      regexes: urlRegexes,
      singleRegexMatchValue: true,
      multiple: true
    },
    propList: {
      propList: true
    },
    angle: {
      number: true,
      units: 'deg|rad',
      implicitUnits: 'rad'
    },
    textRotation: {
      number: true,
      units: 'deg|rad',
      implicitUnits: 'rad',
      enums: ['none', 'autorotate']
    },
    polygonPointList: {
      number: true,
      multiple: true,
      evenMultiple: true,
      min: -1,
      max: 1,
      unitless: true
    },
    edgeDistances: {
      enums: ['intersection', 'node-position']
    },
    edgeEndpoint: {
      number: true,
      multiple: true,
      units: '%|px|em|deg|rad',
      implicitUnits: 'px',
      enums: ['inside-to-node', 'outside-to-node', 'outside-to-node-or-label', 'outside-to-line', 'outside-to-line-or-label'],
      singleEnum: true,
      validate: function validate(valArr, unitsArr) {
        switch (valArr.length) {
          case 2:
            // can be % or px only
            return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';

          case 1:
            // can be enum, deg, or rad only
            return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';

          default:
            return false;
        }
      }
    },
    easing: {
      regexes: ['^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$', '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'],
      enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']
    },
    gradientDirection: {
      enums: ['to-bottom', 'to-top', 'to-left', 'to-right', 'to-bottom-right', 'to-bottom-left', 'to-top-right', 'to-top-left', 'to-right-bottom', 'to-left-bottom', 'to-right-top', 'to-left-top']
    },
    boundsExpansion: {
      number: true,
      multiple: true,
      min: 0,
      validate: function validate(valArr) {
        var length = valArr.length;
        return length === 1 || length === 2 || length === 4;
      }
    }
  };
  var diff = {
    zeroNonZero: function zeroNonZero(val1, val2) {
      if ((val1 == null || val2 == null) && val1 !== val2) {
        return true; // null cases could represent any value
      }

      if (val1 == 0 && val2 != 0) {
        return true;
      } else if (val1 != 0 && val2 == 0) {
        return true;
      } else {
        return false;
      }
    },
    any: function any(val1, val2) {
      return val1 != val2;
    }
  }; // define visual style properties
  //
  // - n.b. adding a new group of props may require updates to updateStyleHints()
  // - adding new props to an existing group gets handled automatically

  var t = styfn$6.types;
  var mainLabel = [{
    name: 'label',
    type: t.text,
    triggersBounds: diff.any
  }, {
    name: 'text-rotation',
    type: t.textRotation,
    triggersBounds: diff.any
  }, {
    name: 'text-margin-x',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'text-margin-y',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }];
  var sourceLabel = [{
    name: 'source-label',
    type: t.text,
    triggersBounds: diff.any
  }, {
    name: 'source-text-rotation',
    type: t.textRotation,
    triggersBounds: diff.any
  }, {
    name: 'source-text-margin-x',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'source-text-margin-y',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'source-text-offset',
    type: t.size,
    triggersBounds: diff.any
  }];
  var targetLabel = [{
    name: 'target-label',
    type: t.text,
    triggersBounds: diff.any
  }, {
    name: 'target-text-rotation',
    type: t.textRotation,
    triggersBounds: diff.any
  }, {
    name: 'target-text-margin-x',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'target-text-margin-y',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'target-text-offset',
    type: t.size,
    triggersBounds: diff.any
  }];
  var labelDimensions = [{
    name: 'font-family',
    type: t.fontFamily,
    triggersBounds: diff.any
  }, {
    name: 'font-style',
    type: t.fontStyle,
    triggersBounds: diff.any
  }, {
    name: 'font-weight',
    type: t.fontWeight,
    triggersBounds: diff.any
  }, {
    name: 'font-size',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'text-transform',
    type: t.textTransform,
    triggersBounds: diff.any
  }, {
    name: 'text-wrap',
    type: t.textWrap,
    triggersBounds: diff.any
  }, {
    name: 'text-overflow-wrap',
    type: t.textOverflowWrap,
    triggersBounds: diff.any
  }, {
    name: 'text-max-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'text-outline-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'line-height',
    type: t.positiveNumber,
    triggersBounds: diff.any
  }];
  var commonLabel = [{
    name: 'text-valign',
    type: t.valign,
    triggersBounds: diff.any
  }, {
    name: 'text-halign',
    type: t.halign,
    triggersBounds: diff.any
  }, {
    name: 'color',
    type: t.color
  }, {
    name: 'text-outline-color',
    type: t.color
  }, {
    name: 'text-outline-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'text-background-color',
    type: t.color
  }, {
    name: 'text-background-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'text-background-padding',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'text-border-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'text-border-color',
    type: t.color
  }, {
    name: 'text-border-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'text-border-style',
    type: t.borderStyle,
    triggersBounds: diff.any
  }, {
    name: 'text-background-shape',
    type: t.textBackgroundShape,
    triggersBounds: diff.any
  }, {
    name: 'text-justification',
    type: t.justification
  }];
  var behavior = [{
    name: 'events',
    type: t.bool
  }, {
    name: 'text-events',
    type: t.bool
  }];
  var visibility = [{
    name: 'display',
    type: t.display,
    triggersZOrder: diff.any,
    triggersBounds: diff.any,
    triggersBoundsOfParallelBeziers: true
  }, {
    name: 'visibility',
    type: t.visibility,
    triggersZOrder: diff.any
  }, {
    name: 'opacity',
    type: t.zeroOneNumber,
    triggersZOrder: diff.zeroNonZero
  }, {
    name: 'text-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'min-zoomed-font-size',
    type: t.size
  }, {
    name: 'z-compound-depth',
    type: t.zCompoundDepth,
    triggersZOrder: diff.any
  }, {
    name: 'z-index-compare',
    type: t.zIndexCompare,
    triggersZOrder: diff.any
  }, {
    name: 'z-index',
    type: t.nonNegativeInt,
    triggersZOrder: diff.any
  }];
  var overlay = [{
    name: 'overlay-padding',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'overlay-color',
    type: t.color
  }, {
    name: 'overlay-opacity',
    type: t.zeroOneNumber,
    triggersBounds: diff.zeroNonZero
  }];
  var transition = [{
    name: 'transition-property',
    type: t.propList
  }, {
    name: 'transition-duration',
    type: t.time
  }, {
    name: 'transition-delay',
    type: t.time
  }, {
    name: 'transition-timing-function',
    type: t.easing
  }];

  var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {
    if (parsedProp.value === 'label') {
      return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)
    } else {
      return parsedProp.pfValue;
    }
  };

  var nodeBody = [{
    name: 'height',
    type: t.nodeSize,
    triggersBounds: diff.any,
    hashOverride: nodeSizeHashOverride
  }, {
    name: 'width',
    type: t.nodeSize,
    triggersBounds: diff.any,
    hashOverride: nodeSizeHashOverride
  }, {
    name: 'shape',
    type: t.nodeShape,
    triggersBounds: diff.any
  }, {
    name: 'shape-polygon-points',
    type: t.polygonPointList,
    triggersBounds: diff.any
  }, {
    name: 'background-color',
    type: t.color
  }, {
    name: 'background-fill',
    type: t.fill
  }, {
    name: 'background-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'background-blacken',
    type: t.nOneOneNumber
  }, {
    name: 'background-gradient-stop-colors',
    type: t.colors
  }, {
    name: 'background-gradient-stop-positions',
    type: t.percentages
  }, {
    name: 'background-gradient-direction',
    type: t.gradientDirection
  }, {
    name: 'padding',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'padding-relative-to',
    type: t.paddingRelativeTo,
    triggersBounds: diff.any
  }, {
    name: 'bounds-expansion',
    type: t.boundsExpansion,
    triggersBounds: diff.any
  }];
  var nodeBorder = [{
    name: 'border-color',
    type: t.color
  }, {
    name: 'border-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'border-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'border-style',
    type: t.borderStyle
  }];
  var backgroundImage = [{
    name: 'background-image',
    type: t.urls
  }, {
    name: 'background-image-crossorigin',
    type: t.bgCrossOrigin
  }, {
    name: 'background-image-opacity',
    type: t.zeroOneNumbers
  }, {
    name: 'background-position-x',
    type: t.bgPos
  }, {
    name: 'background-position-y',
    type: t.bgPos
  }, {
    name: 'background-width-relative-to',
    type: t.bgRelativeTo
  }, {
    name: 'background-height-relative-to',
    type: t.bgRelativeTo
  }, {
    name: 'background-repeat',
    type: t.bgRepeat
  }, {
    name: 'background-fit',
    type: t.bgFit
  }, {
    name: 'background-clip',
    type: t.bgClip
  }, {
    name: 'background-width',
    type: t.bgWH
  }, {
    name: 'background-height',
    type: t.bgWH
  }, {
    name: 'background-offset-x',
    type: t.bgPos
  }, {
    name: 'background-offset-y',
    type: t.bgPos
  }];
  var compound = [{
    name: 'position',
    type: t.position,
    triggersBounds: diff.any
  }, {
    name: 'compound-sizing-wrt-labels',
    type: t.compoundIncludeLabels,
    triggersBounds: diff.any
  }, {
    name: 'min-width',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'min-width-bias-left',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'min-width-bias-right',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'min-height',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'min-height-bias-top',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'min-height-bias-bottom',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }];
  var edgeLine = [{
    name: 'line-style',
    type: t.lineStyle
  }, {
    name: 'line-color',
    type: t.color
  }, {
    name: 'line-fill',
    type: t.fill
  }, {
    name: 'line-cap',
    type: t.lineCap
  }, {
    name: 'line-dash-pattern',
    type: t.numbers
  }, {
    name: 'line-dash-offset',
    type: t.number
  }, {
    name: 'line-gradient-stop-colors',
    type: t.colors
  }, {
    name: 'line-gradient-stop-positions',
    type: t.percentages
  }, {
    name: 'curve-style',
    type: t.curveStyle,
    triggersBounds: diff.any,
    triggersBoundsOfParallelBeziers: true
  }, {
    name: 'haystack-radius',
    type: t.zeroOneNumber,
    triggersBounds: diff.any
  }, {
    name: 'source-endpoint',
    type: t.edgeEndpoint,
    triggersBounds: diff.any
  }, {
    name: 'target-endpoint',
    type: t.edgeEndpoint,
    triggersBounds: diff.any
  }, {
    name: 'control-point-step-size',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'control-point-distances',
    type: t.bidirectionalSizes,
    triggersBounds: diff.any
  }, {
    name: 'control-point-weights',
    type: t.numbers,
    triggersBounds: diff.any
  }, {
    name: 'segment-distances',
    type: t.bidirectionalSizes,
    triggersBounds: diff.any
  }, {
    name: 'segment-weights',
    type: t.numbers,
    triggersBounds: diff.any
  }, {
    name: 'taxi-turn',
    type: t.sizeMaybePercent,
    triggersBounds: diff.any
  }, {
    name: 'taxi-turn-min-distance',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'taxi-direction',
    type: t.axisDirection,
    triggersBounds: diff.any
  }, {
    name: 'edge-distances',
    type: t.edgeDistances,
    triggersBounds: diff.any
  }, {
    name: 'arrow-scale',
    type: t.positiveNumber,
    triggersBounds: diff.any
  }, {
    name: 'loop-direction',
    type: t.angle,
    triggersBounds: diff.any
  }, {
    name: 'loop-sweep',
    type: t.angle,
    triggersBounds: diff.any
  }, {
    name: 'source-distance-from-node',
    type: t.size,
    triggersBounds: diff.any
  }, {
    name: 'target-distance-from-node',
    type: t.size,
    triggersBounds: diff.any
  }];
  var ghost = [{
    name: 'ghost',
    type: t.bool,
    triggersBounds: diff.any
  }, {
    name: 'ghost-offset-x',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'ghost-offset-y',
    type: t.bidirectionalSize,
    triggersBounds: diff.any
  }, {
    name: 'ghost-opacity',
    type: t.zeroOneNumber
  }];
  var core = [{
    name: 'selection-box-color',
    type: t.color
  }, {
    name: 'selection-box-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'selection-box-border-color',
    type: t.color
  }, {
    name: 'selection-box-border-width',
    type: t.size
  }, {
    name: 'active-bg-color',
    type: t.color
  }, {
    name: 'active-bg-opacity',
    type: t.zeroOneNumber
  }, {
    name: 'active-bg-size',
    type: t.size
  }, {
    name: 'outside-texture-bg-color',
    type: t.color
  }, {
    name: 'outside-texture-bg-opacity',
    type: t.zeroOneNumber
  }]; // pie backgrounds for nodes

  var pie = [];
  styfn$6.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)

  pie.push({
    name: 'pie-size',
    type: t.sizeMaybePercent
  });

  for (var i = 1; i <= styfn$6.pieBackgroundN; i++) {
    pie.push({
      name: 'pie-' + i + '-background-color',
      type: t.color
    });
    pie.push({
      name: 'pie-' + i + '-background-size',
      type: t.percent
    });
    pie.push({
      name: 'pie-' + i + '-background-opacity',
      type: t.zeroOneNumber
    });
  } // edge arrows


  var edgeArrow = [];
  var arrowPrefixes = styfn$6.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];
  [{
    name: 'arrow-shape',
    type: t.arrowShape,
    triggersBounds: diff.any
  }, {
    name: 'arrow-color',
    type: t.color
  }, {
    name: 'arrow-fill',
    type: t.arrowFill
  }].forEach(function (prop) {
    arrowPrefixes.forEach(function (prefix) {
      var name = prefix + '-' + prop.name;
      var type = prop.type,
          triggersBounds = prop.triggersBounds;
      edgeArrow.push({
        name: name,
        type: type,
        triggersBounds: triggersBounds
      });
    });
  }, {});
  var props = styfn$6.properties = [].concat(behavior, transition, visibility, overlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, backgroundImage, pie, compound, edgeLine, edgeArrow, core);
  var propGroups = styfn$6.propertyGroups = {
    // common to all eles
    behavior: behavior,
    transition: transition,
    visibility: visibility,
    overlay: overlay,
    ghost: ghost,
    // labels
    commonLabel: commonLabel,
    labelDimensions: labelDimensions,
    mainLabel: mainLabel,
    sourceLabel: sourceLabel,
    targetLabel: targetLabel,
    // node props
    nodeBody: nodeBody,
    nodeBorder: nodeBorder,
    backgroundImage: backgroundImage,
    pie: pie,
    compound: compound,
    // edge props
    edgeLine: edgeLine,
    edgeArrow: edgeArrow,
    core: core
  };
  var propGroupNames = styfn$6.propertyGroupNames = {};
  var propGroupKeys = styfn$6.propertyGroupKeys = Object.keys(propGroups);
  propGroupKeys.forEach(function (key) {
    propGroupNames[key] = propGroups[key].map(function (prop) {
      return prop.name;
    });
    propGroups[key].forEach(function (prop) {
      return prop.groupKey = key;
    });
  }); // define aliases

  var aliases = styfn$6.aliases = [{
    name: 'content',
    pointsTo: 'label'
  }, {
    name: 'control-point-distance',
    pointsTo: 'control-point-distances'
  }, {
    name: 'control-point-weight',
    pointsTo: 'control-point-weights'
  }, {
    name: 'edge-text-rotation',
    pointsTo: 'text-rotation'
  }, {
    name: 'padding-left',
    pointsTo: 'padding'
  }, {
    name: 'padding-right',
    pointsTo: 'padding'
  }, {
    name: 'padding-top',
    pointsTo: 'padding'
  }, {
    name: 'padding-bottom',
    pointsTo: 'padding'
  }]; // list of property names

  styfn$6.propertyNames = props.map(function (p) {
    return p.name;
  }); // allow access of properties by name ( e.g. style.properties.height )

  for (var _i = 0; _i < props.length; _i++) {
    var prop = props[_i];
    props[prop.name] = prop; // allow lookup by name
  } // map aliases


  for (var _i2 = 0; _i2 < aliases.length; _i2++) {
    var alias = aliases[_i2];
    var pointsToProp = props[alias.pointsTo];
    var aliasProp = {
      name: alias.name,
      alias: true,
      pointsTo: pointsToProp
    }; // add alias prop for parsing

    props.push(aliasProp);
    props[alias.name] = aliasProp; // allow lookup by name
  }
})();

styfn$6.getDefaultProperty = function (name) {
  return this.getDefaultProperties()[name];
};

styfn$6.getDefaultProperties = function () {
  var _p = this._private;

  if (_p.defaultProperties != null) {
    return _p.defaultProperties;
  }

  var rawProps = extend({
    // core props
    'selection-box-color': '#ddd',
    'selection-box-opacity': 0.65,
    'selection-box-border-color': '#aaa',
    'selection-box-border-width': 1,
    'active-bg-color': 'black',
    'active-bg-opacity': 0.15,
    'active-bg-size': 30,
    'outside-texture-bg-color': '#000',
    'outside-texture-bg-opacity': 0.125,
    // common node/edge props
    'events': 'yes',
    'text-events': 'no',
    'text-valign': 'top',
    'text-halign': 'center',
    'text-justification': 'auto',
    'line-height': 1,
    'color': '#000',
    'text-outline-color': '#000',
    'text-outline-width': 0,
    'text-outline-opacity': 1,
    'text-opacity': 1,
    'text-decoration': 'none',
    'text-transform': 'none',
    'text-wrap': 'none',
    'text-overflow-wrap': 'whitespace',
    'text-max-width': 9999,
    'text-background-color': '#000',
    'text-background-opacity': 0,
    'text-background-shape': 'rectangle',
    'text-background-padding': 0,
    'text-border-opacity': 0,
    'text-border-width': 0,
    'text-border-style': 'solid',
    'text-border-color': '#000',
    'font-family': 'Helvetica Neue, Helvetica, sans-serif',
    'font-style': 'normal',
    'font-weight': 'normal',
    'font-size': 16,
    'min-zoomed-font-size': 0,
    'text-rotation': 'none',
    'source-text-rotation': 'none',
    'target-text-rotation': 'none',
    'visibility': 'visible',
    'display': 'element',
    'opacity': 1,
    'z-compound-depth': 'auto',
    'z-index-compare': 'auto',
    'z-index': 0,
    'label': '',
    'text-margin-x': 0,
    'text-margin-y': 0,
    'source-label': '',
    'source-text-offset': 0,
    'source-text-margin-x': 0,
    'source-text-margin-y': 0,
    'target-label': '',
    'target-text-offset': 0,
    'target-text-margin-x': 0,
    'target-text-margin-y': 0,
    'overlay-opacity': 0,
    'overlay-color': '#000',
    'overlay-padding': 10,
    'transition-property': 'none',
    'transition-duration': 0,
    'transition-delay': 0,
    'transition-timing-function': 'linear',
    // node props
    'background-blacken': 0,
    'background-color': '#999',
    'background-fill': 'solid',
    'background-opacity': 1,
    'background-image': 'none',
    'background-image-crossorigin': 'anonymous',
    'background-image-opacity': 1,
    'background-position-x': '50%',
    'background-position-y': '50%',
    'background-offset-x': 0,
    'background-offset-y': 0,
    'background-width-relative-to': 'include-padding',
    'background-height-relative-to': 'include-padding',
    'background-repeat': 'no-repeat',
    'background-fit': 'none',
    'background-clip': 'node',
    'background-width': 'auto',
    'background-height': 'auto',
    'border-color': '#000',
    'border-opacity': 1,
    'border-width': 0,
    'border-style': 'solid',
    'height': 30,
    'width': 30,
    'shape': 'ellipse',
    'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',
    'bounds-expansion': 0,
    // node gradient
    'background-gradient-direction': 'to-bottom',
    'background-gradient-stop-colors': '#999',
    'background-gradient-stop-positions': '0%',
    // ghost props
    'ghost': 'no',
    'ghost-offset-y': 0,
    'ghost-offset-x': 0,
    'ghost-opacity': 0,
    // compound props
    'padding': 0,
    'padding-relative-to': 'width',
    'position': 'origin',
    'compound-sizing-wrt-labels': 'include',
    'min-width': 0,
    'min-width-bias-left': 0,
    'min-width-bias-right': 0,
    'min-height': 0,
    'min-height-bias-top': 0,
    'min-height-bias-bottom': 0
  }, {
    // node pie bg
    'pie-size': '100%'
  }, [{
    name: 'pie-{{i}}-background-color',
    value: 'black'
  }, {
    name: 'pie-{{i}}-background-size',
    value: '0%'
  }, {
    name: 'pie-{{i}}-background-opacity',
    value: 1
  }].reduce(function (css, prop) {
    for (var i = 1; i <= styfn$6.pieBackgroundN; i++) {
      var name = prop.name.replace('{{i}}', i);
      var val = prop.value;
      css[name] = val;
    }

    return css;
  }, {}), {
    // edge props
    'line-style': 'solid',
    'line-color': '#999',
    'line-fill': 'solid',
    'line-cap': 'butt',
    'line-gradient-stop-colors': '#999',
    'line-gradient-stop-positions': '0%',
    'control-point-step-size': 40,
    'control-point-weights': 0.5,
    'segment-weights': 0.5,
    'segment-distances': 20,
    'taxi-turn': '50%',
    'taxi-turn-min-distance': 10,
    'taxi-direction': 'auto',
    'edge-distances': 'intersection',
    'curve-style': 'haystack',
    'haystack-radius': 0,
    'arrow-scale': 1,
    'loop-direction': '-45deg',
    'loop-sweep': '-90deg',
    'source-distance-from-node': 0,
    'target-distance-from-node': 0,
    'source-endpoint': 'outside-to-node',
    'target-endpoint': 'outside-to-node',
    'line-dash-pattern': [6, 3],
    'line-dash-offset': 0
  }, [{
    name: 'arrow-shape',
    value: 'none'
  }, {
    name: 'arrow-color',
    value: '#999'
  }, {
    name: 'arrow-fill',
    value: 'filled'
  }].reduce(function (css, prop) {
    styfn$6.arrowPrefixes.forEach(function (prefix) {
      var name = prefix + '-' + prop.name;
      var val = prop.value;
      css[name] = val;
    });
    return css;
  }, {}));
  var parsedProps = {};

  for (var i = 0; i < this.properties.length; i++) {
    var prop = this.properties[i];

    if (prop.pointsTo) {
      continue;
    }

    var name = prop.name;
    var val = rawProps[name];
    var parsedProp = this.parse(name, val);
    parsedProps[name] = parsedProp;
  }

  _p.defaultProperties = parsedProps;
  return _p.defaultProperties;
};

styfn$6.addDefaultStylesheet = function () {
  this.selector(':parent').css({
    'shape': 'rectangle',
    'padding': 10,
    'background-color': '#eee',
    'border-color': '#ccc',
    'border-width': 1
  }).selector('edge').css({
    'width': 3
  }).selector(':loop').css({
    'curve-style': 'bezier'
  }).selector('edge:compound').css({
    'curve-style': 'bezier',
    'source-endpoint': 'outside-to-line',
    'target-endpoint': 'outside-to-line'
  }).selector(':selected').css({
    'background-color': '#0169D9',
    'line-color': '#0169D9',
    'source-arrow-color': '#0169D9',
    'target-arrow-color': '#0169D9',
    'mid-source-arrow-color': '#0169D9',
    'mid-target-arrow-color': '#0169D9'
  }).selector(':parent:selected').css({
    'background-color': '#CCE1F9',
    'border-color': '#aec8e5'
  }).selector(':active').css({
    'overlay-color': 'black',
    'overlay-padding': 10,
    'overlay-opacity': 0.25
  });
  this.defaultLength = this.length;
};

var styfn$7 = {}; // a caching layer for property parsing

styfn$7.parse = function (name, value, propIsBypass, propIsFlat) {
  var self = this; // function values can't be cached in all cases, and there isn't much benefit of caching them anyway

  if (fn(value)) {
    return self.parseImplWarn(name, value, propIsBypass, propIsFlat);
  }

  var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;
  var bypassKey = propIsBypass ? 't' : 'f';
  var valueKey = '' + value;
  var argHash = hashStrings(name, valueKey, bypassKey, flatKey);
  var propCache = self.propCache = self.propCache || [];
  var ret;

  if (!(ret = propCache[argHash])) {
    ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);
  } // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden
  // - mappings can't be shared b/c mappings are per-element


  if (propIsBypass || propIsFlat === 'mapping') {
    // need a copy since props are mutated later in their lifecycles
    ret = copy(ret);

    if (ret) {
      ret.value = copy(ret.value); // because it could be an array, e.g. colour
    }
  }

  return ret;
};

styfn$7.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {
  var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);

  if (!prop && value != null) {
    warn("The style property `".concat(name, ": ").concat(value, "` is invalid"));
  }

  return prop;
}; // parse a property; return null on invalid; return parsed property otherwise
// fields :
// - name : the name of the property
// - value : the parsed, native-typed value of the property
// - strValue : a string value that represents the property value in valid css
// - bypass : true iff the property is a bypass property


styfn$7.parseImpl = function (name, value, propIsBypass, propIsFlat) {
  var self = this;
  name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

  var property = self.properties[name];
  var passedValue = value;
  var types = self.types;

  if (!property) {
    return null;
  } // return null on property of unknown name


  if (value === undefined) {
    return null;
  } // can't assign undefined
  // the property may be an alias


  if (property.alias) {
    property = property.pointsTo;
    name = property.name;
  }

  var valueIsString = string(value);

  if (valueIsString) {
    // trim the value to make parsing easier
    value = value.trim();
  }

  var type = property.type;

  if (!type) {
    return null;
  } // no type, no luck
  // check if bypass is null or empty string (i.e. indication to delete bypass property)


  if (propIsBypass && (value === '' || value === null)) {
    return {
      name: name,
      value: value,
      bypass: true,
      deleteBypass: true
    };
  } // check if value is a function used as a mapper


  if (fn(value)) {
    return {
      name: name,
      value: value,
      strValue: 'fn',
      mapped: types.fn,
      bypass: propIsBypass
    };
  } // check if value is mapped


  var data, mapData;

  if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== 'a') ; else if (value.length >= 7 && value[0] === 'd' && (data = new RegExp(types.data.regex).exec(value))) {
    if (propIsBypass) {
      return false;
    } // mappers not allowed in bypass


    var mapped = types.data;
    return {
      name: name,
      value: data,
      strValue: '' + value,
      mapped: mapped,
      field: data[1],
      bypass: propIsBypass
    };
  } else if (value.length >= 10 && value[0] === 'm' && (mapData = new RegExp(types.mapData.regex).exec(value))) {
    if (propIsBypass) {
      return false;
    } // mappers not allowed in bypass


    if (type.multiple) {
      return false;
    } // impossible to map to num


    var _mapped = types.mapData; // we can map only if the type is a colour or a number

    if (!(type.color || type.number)) {
      return false;
    }

    var valueMin = this.parse(name, mapData[4]); // parse to validate

    if (!valueMin || valueMin.mapped) {
      return false;
    } // can't be invalid or mapped


    var valueMax = this.parse(name, mapData[5]); // parse to validate

    if (!valueMax || valueMax.mapped) {
      return false;
    } // can't be invalid or mapped
    // check if valueMin and valueMax are the same


    if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {
      warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');
      return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range
    } else if (type.color) {
      var c1 = valueMin.value;
      var c2 = valueMax.value;
      var same = c1[0] === c2[0] // red
      && c1[1] === c2[1] // green
      && c1[2] === c2[2] // blue
      && ( // optional alpha
      c1[3] === c2[3] // same alpha outright
      || (c1[3] == null || c1[3] === 1) && ( // full opacity for colour 1?
      c2[3] == null || c2[3] === 1) // full opacity for colour 2?
      );

      if (same) {
        return false;
      } // can't make a mapper without a range

    }

    return {
      name: name,
      value: mapData,
      strValue: '' + value,
      mapped: _mapped,
      field: mapData[1],
      fieldMin: parseFloat(mapData[2]),
      // min & max are numeric
      fieldMax: parseFloat(mapData[3]),
      valueMin: valueMin.value,
      valueMax: valueMax.value,
      bypass: propIsBypass
    };
  }

  if (type.multiple && propIsFlat !== 'multiple') {
    var vals;

    if (valueIsString) {
      vals = value.split(/\s+/);
    } else if (array(value)) {
      vals = value;
    } else {
      vals = [value];
    }

    if (type.evenMultiple && vals.length % 2 !== 0) {
      return null;
    }

    var valArr = [];
    var unitsArr = [];
    var pfValArr = [];
    var strVal = '';
    var hasEnum = false;

    for (var i = 0; i < vals.length; i++) {
      var p = self.parse(name, vals[i], propIsBypass, 'multiple');
      hasEnum = hasEnum || string(p.value);
      valArr.push(p.value);
      pfValArr.push(p.pfValue != null ? p.pfValue : p.value);
      unitsArr.push(p.units);
      strVal += (i > 0 ? ' ' : '') + p.strValue;
    }

    if (type.validate && !type.validate(valArr, unitsArr)) {
      return null;
    }

    if (type.singleEnum && hasEnum) {
      if (valArr.length === 1 && string(valArr[0])) {
        return {
          name: name,
          value: valArr[0],
          strValue: valArr[0],
          bypass: propIsBypass
        };
      } else {
        return null;
      }
    }

    return {
      name: name,
      value: valArr,
      pfValue: pfValArr,
      strValue: strVal,
      bypass: propIsBypass,
      units: unitsArr
    };
  } // several types also allow enums


  var checkEnums = function checkEnums() {
    for (var _i = 0; _i < type.enums.length; _i++) {
      var en = type.enums[_i];

      if (en === value) {
        return {
          name: name,
          value: value,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null;
  }; // check the type and return the appropriate object


  if (type.number) {
    var units;
    var implicitUnits = 'px'; // not set => px

    if (type.units) {
      // use specified units if set
      units = type.units;
    }

    if (type.implicitUnits) {
      implicitUnits = type.implicitUnits;
    }

    if (!type.unitless) {
      if (valueIsString) {
        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');

        if (units) {
          unitsRegex = units;
        } // only allow explicit units if so set


        var match = value.match('^(' + number$1 + ')(' + unitsRegex + ')?' + '$');

        if (match) {
          value = match[1];
          units = match[2] || implicitUnits;
        }
      } else if (!units || type.implicitUnits) {
        units = implicitUnits; // implicitly px if unspecified
      }
    }

    value = parseFloat(value); // if not a number and enums not allowed, then the value is invalid

    if (isNaN(value) && type.enums === undefined) {
      return null;
    } // check if this number type also accepts special keywords in place of numbers
    // (i.e. `left`, `auto`, etc)


    if (isNaN(value) && type.enums !== undefined) {
      value = passedValue;
      return checkEnums();
    } // check if value must be an integer


    if (type.integer && !integer(value)) {
      return null;
    } // check value is within range


    if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {
      return null;
    }

    var ret = {
      name: name,
      value: value,
      strValue: '' + value + (units ? units : ''),
      units: units,
      bypass: propIsBypass
    }; // normalise value in pixels

    if (type.unitless || units !== 'px' && units !== 'em') {
      ret.pfValue = value;
    } else {
      ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;
    } // normalise value in ms


    if (units === 'ms' || units === 's') {
      ret.pfValue = units === 'ms' ? value : 1000 * value;
    } // normalise value in rad


    if (units === 'deg' || units === 'rad') {
      ret.pfValue = units === 'rad' ? value : deg2rad(value);
    } // normalize value in %


    if (units === '%') {
      ret.pfValue = value / 100;
    }

    return ret;
  } else if (type.propList) {
    var props = [];
    var propsStr = '' + value;

    if (propsStr === 'none') ; else {
      // go over each prop
      var propsSplit = propsStr.split(/\s*,\s*|\s+/);

      for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {
        var propName = propsSplit[_i2].trim();

        if (self.properties[propName]) {
          props.push(propName);
        } else {
          warn('`' + propName + '` is not a valid property name');
        }
      }

      if (props.length === 0) {
        return null;
      }
    }

    return {
      name: name,
      value: props,
      strValue: props.length === 0 ? 'none' : props.join(' '),
      bypass: propIsBypass
    };
  } else if (type.color) {
    var tuple = color2tuple(value);

    if (!tuple) {
      return null;
    }

    return {
      name: name,
      value: tuple,
      pfValue: tuple,
      strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',
      // n.b. no spaces b/c of multiple support
      bypass: propIsBypass
    };
  } else if (type.regex || type.regexes) {
    // first check enums
    if (type.enums) {
      var enumProp = checkEnums();

      if (enumProp) {
        return enumProp;
      }
    }

    var regexes = type.regexes ? type.regexes : [type.regex];

    for (var _i3 = 0; _i3 < regexes.length; _i3++) {
      var regex = new RegExp(regexes[_i3]); // make a regex from the type string

      var m = regex.exec(value);

      if (m) {
        // regex matches
        return {
          name: name,
          value: type.singleRegexMatchValue ? m[1] : m,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null; // didn't match any
  } else if (type.string) {
    // just return
    return {
      name: name,
      value: '' + value,
      strValue: '' + value,
      bypass: propIsBypass
    };
  } else if (type.enums) {
    // check enums last because it's a combo type in others
    return checkEnums();
  } else {
    return null; // not a type we can handle
  }
};

var Style = function Style(cy) {
  if (!(this instanceof Style)) {
    return new Style(cy);
  }

  if (!core(cy)) {
    error('A style must have a core reference');
    return;
  }

  this._private = {
    cy: cy,
    coreStyle: {}
  };
  this.length = 0;
  this.resetToDefault();
};

var styfn$8 = Style.prototype;

styfn$8.instanceString = function () {
  return 'style';
}; // remove all contexts


styfn$8.clear = function () {
  for (var i = 0; i < this.length; i++) {
    this[i] = undefined;
  }

  this.length = 0;
  var _p = this._private;
  _p.newStyle = true;
  return this; // chaining
};

styfn$8.resetToDefault = function () {
  this.clear();
  this.addDefaultStylesheet();
  return this;
}; // builds a style object for the 'core' selector


styfn$8.core = function (propName) {
  return this._private.coreStyle[propName] || this.getDefaultProperty(propName);
}; // create a new context from the specified selector string and switch to that context


styfn$8.selector = function (selectorStr) {
  // 'core' is a special case and does not need a selector
  var selector = selectorStr === 'core' ? null : new Selector(selectorStr);
  var i = this.length++; // new context means new index

  this[i] = {
    selector: selector,
    properties: [],
    mappedProperties: [],
    index: i
  };
  return this; // chaining
}; // add one or many css rules to the current context


styfn$8.css = function () {
  var self = this;
  var args = arguments;

  if (args.length === 1) {
    var map = args[0];

    for (var i = 0; i < self.properties.length; i++) {
      var prop = self.properties[i];
      var mapVal = map[prop.name];

      if (mapVal === undefined) {
        mapVal = map[dash2camel(prop.name)];
      }

      if (mapVal !== undefined) {
        this.cssRule(prop.name, mapVal);
      }
    }
  } else if (args.length === 2) {
    this.cssRule(args[0], args[1]);
  } // do nothing if args are invalid


  return this; // chaining
};

styfn$8.style = styfn$8.css; // add a single css rule to the current context

styfn$8.cssRule = function (name, value) {
  // name-value pair
  var property = this.parse(name, value); // add property to current context if valid

  if (property) {
    var i = this.length - 1;
    this[i].properties.push(property);
    this[i].properties[property.name] = property; // allow access by name as well

    if (property.name.match(/pie-(\d+)-background-size/) && property.value) {
      this._private.hasPie = true;
    }

    if (property.mapped) {
      this[i].mappedProperties.push(property);
    } // add to core style if necessary


    var currentSelectorIsCore = !this[i].selector;

    if (currentSelectorIsCore) {
      this._private.coreStyle[property.name] = property;
    }
  }

  return this; // chaining
};

styfn$8.append = function (style) {
  if (stylesheet(style)) {
    style.appendToStyle(this);
  } else if (array(style)) {
    this.appendFromJson(style);
  } else if (string(style)) {
    this.appendFromString(style);
  } // you probably wouldn't want to append a Style, since you'd duplicate the default parts


  return this;
}; // static function


Style.fromJson = function (cy, json) {
  var style = new Style(cy);
  style.fromJson(json);
  return style;
};

Style.fromString = function (cy, string) {
  return new Style(cy).fromString(string);
};

[styfn, styfn$1, styfn$2, styfn$3, styfn$4, styfn$5, styfn$6, styfn$7].forEach(function (props) {
  extend(styfn$8, props);
});
Style.types = styfn$8.types;
Style.properties = styfn$8.properties;
Style.propertyGroups = styfn$8.propertyGroups;
Style.propertyGroupNames = styfn$8.propertyGroupNames;
Style.propertyGroupKeys = styfn$8.propertyGroupKeys;

var corefn$7 = {
  style: function style(newStyle) {
    if (newStyle) {
      var s = this.setStyle(newStyle);
      s.update();
    }

    return this._private.style;
  },
  setStyle: function setStyle(style) {
    var _p = this._private;

    if (stylesheet(style)) {
      _p.style = style.generateStyle(this);
    } else if (array(style)) {
      _p.style = Style.fromJson(this, style);
    } else if (string(style)) {
      _p.style = Style.fromString(this, style);
    } else {
      _p.style = Style(this);
    }

    return _p.style;
  }
};

var defaultSelectionType = 'single';
var corefn$8 = {
  autolock: function autolock(bool) {
    if (bool !== undefined) {
      this._private.autolock = bool ? true : false;
    } else {
      return this._private.autolock;
    }

    return this; // chaining
  },
  autoungrabify: function autoungrabify(bool) {
    if (bool !== undefined) {
      this._private.autoungrabify = bool ? true : false;
    } else {
      return this._private.autoungrabify;
    }

    return this; // chaining
  },
  autounselectify: function autounselectify(bool) {
    if (bool !== undefined) {
      this._private.autounselectify = bool ? true : false;
    } else {
      return this._private.autounselectify;
    }

    return this; // chaining
  },
  selectionType: function selectionType(selType) {
    var _p = this._private;

    if (_p.selectionType == null) {
      _p.selectionType = defaultSelectionType;
    }

    if (selType !== undefined) {
      if (selType === 'additive' || selType === 'single') {
        _p.selectionType = selType;
      }
    } else {
      return _p.selectionType;
    }

    return this;
  },
  panningEnabled: function panningEnabled(bool) {
    if (bool !== undefined) {
      this._private.panningEnabled = bool ? true : false;
    } else {
      return this._private.panningEnabled;
    }

    return this; // chaining
  },
  userPanningEnabled: function userPanningEnabled(bool) {
    if (bool !== undefined) {
      this._private.userPanningEnabled = bool ? true : false;
    } else {
      return this._private.userPanningEnabled;
    }

    return this; // chaining
  },
  zoomingEnabled: function zoomingEnabled(bool) {
    if (bool !== undefined) {
      this._private.zoomingEnabled = bool ? true : false;
    } else {
      return this._private.zoomingEnabled;
    }

    return this; // chaining
  },
  userZoomingEnabled: function userZoomingEnabled(bool) {
    if (bool !== undefined) {
      this._private.userZoomingEnabled = bool ? true : false;
    } else {
      return this._private.userZoomingEnabled;
    }

    return this; // chaining
  },
  boxSelectionEnabled: function boxSelectionEnabled(bool) {
    if (bool !== undefined) {
      this._private.boxSelectionEnabled = bool ? true : false;
    } else {
      return this._private.boxSelectionEnabled;
    }

    return this; // chaining
  },
  pan: function pan() {
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    switch (args.length) {
      case 0:
        // .pan()
        return pan;

      case 1:
        if (string(args[0])) {
          // .pan('x')
          dim = args[0];
          return pan[dim];
        } else if (plainObject(args[0])) {
          // .pan({ x: 0, y: 100 })
          if (!this._private.panningEnabled) {
            return this;
          }

          dims = args[0];
          x = dims.x;
          y = dims.y;

          if (number(x)) {
            pan.x = x;
          }

          if (number(y)) {
            pan.y = y;
          }

          this.emit('pan viewport');
        }

        break;

      case 2:
        // .pan('x', 100)
        if (!this._private.panningEnabled) {
          return this;
        }

        dim = args[0];
        val = args[1];

        if ((dim === 'x' || dim === 'y') && number(val)) {
          pan[dim] = val;
        }

        this.emit('pan viewport');
        break;

      default:
        break;
      // invalid
    }

    this.notify('viewport');
    return this; // chaining
  },
  panBy: function panBy(arg0, arg1) {
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    if (!this._private.panningEnabled) {
      return this;
    }

    switch (args.length) {
      case 1:
        if (plainObject(arg0)) {
          // .panBy({ x: 0, y: 100 })
          dims = args[0];
          x = dims.x;
          y = dims.y;

          if (number(x)) {
            pan.x += x;
          }

          if (number(y)) {
            pan.y += y;
          }

          this.emit('pan viewport');
        }

        break;

      case 2:
        // .panBy('x', 100)
        dim = arg0;
        val = arg1;

        if ((dim === 'x' || dim === 'y') && number(val)) {
          pan[dim] += val;
        }

        this.emit('pan viewport');
        break;

      default:
        break;
      // invalid
    }

    this.notify('viewport');
    return this; // chaining
  },
  fit: function fit(elements, padding) {
    var viewportState = this.getFitViewport(elements, padding);

    if (viewportState) {
      var _p = this._private;
      _p.zoom = viewportState.zoom;
      _p.pan = viewportState.pan;
      this.emit('pan zoom viewport');
      this.notify('viewport');
    }

    return this; // chaining
  },
  getFitViewport: function getFitViewport(elements, padding) {
    if (number(elements) && padding === undefined) {
      // elements is optional
      padding = elements;
      elements = undefined;
    }

    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
      return;
    }

    var bb;

    if (string(elements)) {
      var sel = elements;
      elements = this.$(sel);
    } else if (boundingBox(elements)) {
      // assume bb
      var bbe = elements;
      bb = {
        x1: bbe.x1,
        y1: bbe.y1,
        x2: bbe.x2,
        y2: bbe.y2
      };
      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;
    } else if (!elementOrCollection(elements)) {
      elements = this.mutableElements();
    }

    if (elementOrCollection(elements) && elements.empty()) {
      return;
    } // can't fit to nothing


    bb = bb || elements.boundingBox();
    var w = this.width();
    var h = this.height();
    var zoom;
    padding = number(padding) ? padding : 0;

    if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {
      zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h); // crop zoom

      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;
      var pan = {
        // now pan to middle
        x: (w - zoom * (bb.x1 + bb.x2)) / 2,
        y: (h - zoom * (bb.y1 + bb.y2)) / 2
      };
      return {
        zoom: zoom,
        pan: pan
      };
    }

    return;
  },
  zoomRange: function zoomRange(min, max) {
    var _p = this._private;

    if (max == null) {
      var opts = min;
      min = opts.min;
      max = opts.max;
    }

    if (number(min) && number(max) && min <= max) {
      _p.minZoom = min;
      _p.maxZoom = max;
    } else if (number(min) && max === undefined && min <= _p.maxZoom) {
      _p.minZoom = min;
    } else if (number(max) && min === undefined && max >= _p.minZoom) {
      _p.maxZoom = max;
    }

    return this;
  },
  minZoom: function minZoom(zoom) {
    if (zoom === undefined) {
      return this._private.minZoom;
    } else {
      return this.zoomRange({
        min: zoom
      });
    }
  },
  maxZoom: function maxZoom(zoom) {
    if (zoom === undefined) {
      return this._private.maxZoom;
    } else {
      return this.zoomRange({
        max: zoom
      });
    }
  },
  getZoomedViewport: function getZoomedViewport(params) {
    var _p = this._private;
    var currentPan = _p.pan;
    var currentZoom = _p.zoom;
    var pos; // in rendered px

    var zoom;
    var bail = false;

    if (!_p.zoomingEnabled) {
      // zooming disabled
      bail = true;
    }

    if (number(params)) {
      // then set the zoom
      zoom = params;
    } else if (plainObject(params)) {
      // then zoom about a point
      zoom = params.level;

      if (params.position != null) {
        pos = modelToRenderedPosition(params.position, currentZoom, currentPan);
      } else if (params.renderedPosition != null) {
        pos = params.renderedPosition;
      }

      if (pos != null && !_p.panningEnabled) {
        // panning disabled
        bail = true;
      }
    } // crop zoom


    zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;
    zoom = zoom < _p.minZoom ? _p.minZoom : zoom; // can't zoom with invalid params

    if (bail || !number(zoom) || zoom === currentZoom || pos != null && (!number(pos.x) || !number(pos.y))) {
      return null;
    }

    if (pos != null) {
      // set zoom about position
      var pan1 = currentPan;
      var zoom1 = currentZoom;
      var zoom2 = zoom;
      var pan2 = {
        x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,
        y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y
      };
      return {
        zoomed: true,
        panned: true,
        zoom: zoom2,
        pan: pan2
      };
    } else {
      // just set the zoom
      return {
        zoomed: true,
        panned: false,
        zoom: zoom,
        pan: currentPan
      };
    }
  },
  zoom: function zoom(params) {
    if (params === undefined) {
      // get
      return this._private.zoom;
    } else {
      // set
      var vp = this.getZoomedViewport(params);
      var _p = this._private;

      if (vp == null || !vp.zoomed) {
        return this;
      }

      _p.zoom = vp.zoom;

      if (vp.panned) {
        _p.pan.x = vp.pan.x;
        _p.pan.y = vp.pan.y;
      }

      this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');
      this.notify('viewport');
      return this; // chaining
    }
  },
  viewport: function viewport(opts) {
    var _p = this._private;
    var zoomDefd = true;
    var panDefd = true;
    var events = []; // to trigger

    var zoomFailed = false;
    var panFailed = false;

    if (!opts) {
      return this;
    }

    if (!number(opts.zoom)) {
      zoomDefd = false;
    }

    if (!plainObject(opts.pan)) {
      panDefd = false;
    }

    if (!zoomDefd && !panDefd) {
      return this;
    }

    if (zoomDefd) {
      var z = opts.zoom;

      if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {
        zoomFailed = true;
      } else {
        _p.zoom = z;
        events.push('zoom');
      }
    }

    if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {
      var p = opts.pan;

      if (number(p.x)) {
        _p.pan.x = p.x;
        panFailed = false;
      }

      if (number(p.y)) {
        _p.pan.y = p.y;
        panFailed = false;
      }

      if (!panFailed) {
        events.push('pan');
      }
    }

    if (events.length > 0) {
      events.push('viewport');
      this.emit(events.join(' '));
      this.notify('viewport');
    }

    return this; // chaining
  },
  center: function center(elements) {
    var pan = this.getCenterPan(elements);

    if (pan) {
      this._private.pan = pan;
      this.emit('pan viewport');
      this.notify('viewport');
    }

    return this; // chaining
  },
  getCenterPan: function getCenterPan(elements, zoom) {
    if (!this._private.panningEnabled) {
      return;
    }

    if (string(elements)) {
      var selector = elements;
      elements = this.mutableElements().filter(selector);
    } else if (!elementOrCollection(elements)) {
      elements = this.mutableElements();
    }

    if (elements.length === 0) {
      return;
    } // can't centre pan to nothing


    var bb = elements.boundingBox();
    var w = this.width();
    var h = this.height();
    zoom = zoom === undefined ? this._private.zoom : zoom;
    var pan = {
      // middle
      x: (w - zoom * (bb.x1 + bb.x2)) / 2,
      y: (h - zoom * (bb.y1 + bb.y2)) / 2
    };
    return pan;
  },
  reset: function reset() {
    if (!this._private.panningEnabled || !this._private.zoomingEnabled) {
      return this;
    }

    this.viewport({
      pan: {
        x: 0,
        y: 0
      },
      zoom: 1
    });
    return this; // chaining
  },
  invalidateSize: function invalidateSize() {
    this._private.sizeCache = null;
  },
  size: function size() {
    var _p = this._private;
    var container = _p.container;
    return _p.sizeCache = _p.sizeCache || (container ? function () {
      var style = window$1.getComputedStyle(container);

      var val = function val(name) {
        return parseFloat(style.getPropertyValue(name));
      };

      return {
        width: container.clientWidth - val('padding-left') - val('padding-right'),
        height: container.clientHeight - val('padding-top') - val('padding-bottom')
      };
    }() : {
      // fallback if no container (not 0 b/c can be used for dividing etc)
      width: 1,
      height: 1
    });
  },
  width: function width() {
    return this.size().width;
  },
  height: function height() {
    return this.size().height;
  },
  extent: function extent() {
    var pan = this._private.pan;
    var zoom = this._private.zoom;
    var rb = this.renderedExtent();
    var b = {
      x1: (rb.x1 - pan.x) / zoom,
      x2: (rb.x2 - pan.x) / zoom,
      y1: (rb.y1 - pan.y) / zoom,
      y2: (rb.y2 - pan.y) / zoom
    };
    b.w = b.x2 - b.x1;
    b.h = b.y2 - b.y1;
    return b;
  },
  renderedExtent: function renderedExtent() {
    var width = this.width();
    var height = this.height();
    return {
      x1: 0,
      y1: 0,
      x2: width,
      y2: height,
      w: width,
      h: height
    };
  }
}; // aliases

corefn$8.centre = corefn$8.center; // backwards compatibility

corefn$8.autolockNodes = corefn$8.autolock;
corefn$8.autoungrabifyNodes = corefn$8.autoungrabify;

var fn$6 = {
  data: define$3.data({
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  }),
  removeData: define$3.removeData({
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true
  }),
  scratch: define$3.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  }),
  removeScratch: define$3.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true
  })
}; // aliases

fn$6.attr = fn$6.data;
fn$6.removeAttr = fn$6.removeData;

var Core = function Core(opts) {
  var cy = this;
  opts = extend({}, opts);
  var container = opts.container; // allow for passing a wrapped jquery object
  // e.g. cytoscape({ container: $('#cy') })

  if (container && !htmlElement(container) && htmlElement(container[0])) {
    container = container[0];
  }

  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery

  reg = reg || {};

  if (reg && reg.cy) {
    reg.cy.destroy();
    reg = {}; // old instance => replace reg completely
  }

  var readies = reg.readies = reg.readies || [];

  if (container) {
    container._cyreg = reg;
  } // make sure container assoc'd reg points to this cy


  reg.cy = cy;
  var head = window$1 !== undefined && container !== undefined && !opts.headless;
  var options = opts;
  options.layout = extend({
    name: head ? 'grid' : 'null'
  }, options.layout);
  options.renderer = extend({
    name: head ? 'canvas' : 'null'
  }, options.renderer);

  var defVal = function defVal(def, val, altVal) {
    if (val !== undefined) {
      return val;
    } else if (altVal !== undefined) {
      return altVal;
    } else {
      return def;
    }
  };

  var _p = this._private = {
    container: container,
    // html dom ele container
    ready: false,
    // whether ready has been triggered
    options: options,
    // cached options
    elements: new Collection(this),
    // elements in the graph
    listeners: [],
    // list of listeners
    aniEles: new Collection(this),
    // elements being animated
    data: {},
    // data for the core
    scratch: {},
    // scratch object for core
    layout: null,
    renderer: null,
    destroyed: false,
    // whether destroy was called
    notificationsEnabled: true,
    // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: defVal(true, options.zoomingEnabled),
    userZoomingEnabled: defVal(true, options.userZoomingEnabled),
    panningEnabled: defVal(true, options.panningEnabled),
    userPanningEnabled: defVal(true, options.userPanningEnabled),
    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
    autolock: defVal(false, options.autolock, options.autolockNodes),
    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
    autounselectify: defVal(false, options.autounselectify),
    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
    zoom: number(options.zoom) ? options.zoom : 1,
    pan: {
      x: plainObject(options.pan) && number(options.pan.x) ? options.pan.x : 0,
      y: plainObject(options.pan) && number(options.pan.y) ? options.pan.y : 0
    },
    animation: {
      // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: false
  };

  this.createEmitter(); // set selection type

  this.selectionType(options.selectionType); // init zoom bounds

  this.zoomRange({
    min: options.minZoom,
    max: options.maxZoom
  });

  var loadExtData = function loadExtData(extData, next) {
    var anyIsPromise = extData.some(promise);

    if (anyIsPromise) {
      return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init
    } else {
      next(extData); // exec synchronously for convenience
    }
  }; // start with the default stylesheet so we have something before loading an external stylesheet


  if (_p.styleEnabled) {
    cy.setStyle([]);
  } // create the renderer


  var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options

  cy.initRenderer(rendererOptions);

  var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {
    cy.notifications(false); // remove old elements

    var oldEles = cy.mutableElements();

    if (oldEles.length > 0) {
      oldEles.remove();
    }

    if (elements != null) {
      if (plainObject(elements) || array(elements)) {
        cy.add(elements);
      }
    }

    cy.one('layoutready', function (e) {
      cy.notifications(true);
      cy.emit(e); // we missed this event by turning notifications off, so pass it on

      cy.one('load', onload);
      cy.emitAndNotify('load');
    }).one('layoutstop', function () {
      cy.one('done', ondone);
      cy.emit('done');
    });
    var layoutOpts = extend({}, cy._private.options.layout);
    layoutOpts.eles = cy.elements();
    cy.layout(layoutOpts).run();
  };

  loadExtData([options.style, options.elements], function (thens) {
    var initStyle = thens[0];
    var initEles = thens[1]; // init style

    if (_p.styleEnabled) {
      cy.style().append(initStyle);
    } // initial load


    setElesAndLayout(initEles, function () {
      // onready
      cy.startAnimationLoop();
      _p.ready = true; // if a ready callback is specified as an option, the bind it

      if (fn(options.ready)) {
        cy.on('ready', options.ready);
      } // bind all the ready handlers registered before creating this instance


      for (var i = 0; i < readies.length; i++) {
        var fn$1 = readies[i];
        cy.on('ready', fn$1);
      }

      if (reg) {
        reg.readies = [];
      } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc


      cy.emit('ready');
    }, options.done);
  });
};

var corefn$9 = Core.prototype; // short alias

extend(corefn$9, {
  instanceString: function instanceString() {
    return 'core';
  },
  isReady: function isReady() {
    return this._private.ready;
  },
  destroyed: function destroyed() {
    return this._private.destroyed;
  },
  ready: function ready(fn) {
    if (this.isReady()) {
      this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event
    } else {
      this.on('ready', fn);
    }

    return this;
  },
  destroy: function destroy() {
    var cy = this;
    if (cy.destroyed()) return;
    cy.stopAnimationLoop();
    cy.destroyRenderer();
    this.emit('destroy');
    cy._private.destroyed = true;
    return cy;
  },
  hasElementWithId: function hasElementWithId(id) {
    return this._private.elements.hasElementWithId(id);
  },
  getElementById: function getElementById(id) {
    return this._private.elements.getElementById(id);
  },
  hasCompoundNodes: function hasCompoundNodes() {
    return this._private.hasCompoundNodes;
  },
  headless: function headless() {
    return this._private.renderer.isHeadless();
  },
  styleEnabled: function styleEnabled() {
    return this._private.styleEnabled;
  },
  addToPool: function addToPool(eles) {
    this._private.elements.merge(eles);

    return this; // chaining
  },
  removeFromPool: function removeFromPool(eles) {
    this._private.elements.unmerge(eles);

    return this;
  },
  container: function container() {
    return this._private.container || null;
  },
  mount: function mount(container) {
    if (container == null) {
      return;
    }

    var cy = this;
    var _p = cy._private;
    var options = _p.options;

    if (!htmlElement(container) && htmlElement(container[0])) {
      container = container[0];
    }

    cy.stopAnimationLoop();
    cy.destroyRenderer();
    _p.container = container;
    _p.styleEnabled = true;
    cy.invalidateSize();
    cy.initRenderer(extend({}, options, options.renderer, {
      // allow custom renderer name to be re-used, otherwise use canvas
      name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name
    }));
    cy.startAnimationLoop();
    cy.style(options.style);
    cy.emit('mount');
    return cy;
  },
  unmount: function unmount() {
    var cy = this;
    cy.stopAnimationLoop();
    cy.destroyRenderer();
    cy.initRenderer({
      name: 'null'
    });
    cy.emit('unmount');
    return cy;
  },
  options: function options() {
    return copy(this._private.options);
  },
  json: function json(obj) {
    var cy = this;
    var _p = cy._private;
    var eles = cy.mutableElements();

    var getFreshRef = function getFreshRef(ele) {
      return cy.getElementById(ele.id());
    };

    if (plainObject(obj)) {
      // set
      cy.startBatch();

      if (obj.elements) {
        var idInJson = {};

        var updateEles = function updateEles(jsons, gr) {
          var toAdd = [];
          var toMod = [];

          for (var i = 0; i < jsons.length; i++) {
            var json = jsons[i];
            var id = '' + json.data.id; // id must be string

            var ele = cy.getElementById(id);
            idInJson[id] = true;

            if (ele.length !== 0) {
              // existing element should be updated
              toMod.push({
                ele: ele,
                json: json
              });
            } else {
              // otherwise should be added
              if (gr) {
                json.group = gr;
                toAdd.push(json);
              } else {
                toAdd.push(json);
              }
            }
          }

          cy.add(toAdd);

          for (var _i = 0; _i < toMod.length; _i++) {
            var _toMod$_i = toMod[_i],
                _ele = _toMod$_i.ele,
                _json = _toMod$_i.json;

            _ele.json(_json);
          }
        };

        if (array(obj.elements)) {
          // elements: []
          updateEles(obj.elements);
        } else {
          // elements: { nodes: [], edges: [] }
          var grs = ['nodes', 'edges'];

          for (var i = 0; i < grs.length; i++) {
            var gr = grs[i];
            var elements = obj.elements[gr];

            if (array(elements)) {
              updateEles(elements, gr);
            }
          }
        }

        var parentsToRemove = cy.collection();
        eles.filter(function (ele) {
          return !idInJson[ele.id()];
        }).forEach(function (ele) {
          if (ele.isParent()) {
            parentsToRemove.merge(ele);
          } else {
            ele.remove();
          }
        }); // so that children are not removed w/parent

        parentsToRemove.forEach(function (ele) {
          return ele.children().move({
            parent: null
          });
        }); // intermediate parents may be moved by prior line, so make sure we remove by fresh refs

        parentsToRemove.forEach(function (ele) {
          return getFreshRef(ele).remove();
        });
      }

      if (obj.style) {
        cy.style(obj.style);
      }

      if (obj.zoom != null && obj.zoom !== _p.zoom) {
        cy.zoom(obj.zoom);
      }

      if (obj.pan) {
        if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {
          cy.pan(obj.pan);
        }
      }

      if (obj.data) {
        cy.data(obj.data);
      }

      var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify'];

      for (var _i2 = 0; _i2 < fields.length; _i2++) {
        var f = fields[_i2];

        if (obj[f] != null) {
          cy[f](obj[f]);
        }
      }

      cy.endBatch();
      return this; // chaining
    } else {
      // get
      var flat = !!obj;
      var json = {};

      if (flat) {
        json.elements = this.elements().map(function (ele) {
          return ele.json();
        });
      } else {
        json.elements = {};
        eles.forEach(function (ele) {
          var group = ele.group();

          if (!json.elements[group]) {
            json.elements[group] = [];
          }

          json.elements[group].push(ele.json());
        });
      }

      if (this._private.styleEnabled) {
        json.style = cy.style().json();
      }

      json.data = copy(cy.data());
      var options = _p.options;
      json.zoomingEnabled = _p.zoomingEnabled;
      json.userZoomingEnabled = _p.userZoomingEnabled;
      json.zoom = _p.zoom;
      json.minZoom = _p.minZoom;
      json.maxZoom = _p.maxZoom;
      json.panningEnabled = _p.panningEnabled;
      json.userPanningEnabled = _p.userPanningEnabled;
      json.pan = copy(_p.pan);
      json.boxSelectionEnabled = _p.boxSelectionEnabled;
      json.renderer = copy(options.renderer);
      json.hideEdgesOnViewport = options.hideEdgesOnViewport;
      json.textureOnViewport = options.textureOnViewport;
      json.wheelSensitivity = options.wheelSensitivity;
      json.motionBlur = options.motionBlur;
      return json;
    }
  }
});
corefn$9.$id = corefn$9.getElementById;
[corefn, corefn$1, elesfn$v, corefn$2, corefn$3, corefn$4, corefn$5, corefn$6, corefn$7, corefn$8, fn$6].forEach(function (props) {
  extend(corefn$9, props);
});

/* eslint-disable no-unused-vars */

var defaults$9 = {
  fit: true,
  // whether to fit the viewport to the graph
  directed: false,
  // whether the tree is directed downwards (or edges can point in any direction if false)
  padding: 30,
  // padding on fit
  circle: false,
  // put depths in concentric circles if true, put depths top down if false
  grid: false,
  // whether to create an even grid into which the DAG is placed (circle:false only)
  spacingFactor: 1.75,
  // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  roots: undefined,
  // the roots of the trees
  maximal: false,
  // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only)
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled,
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts

};
/* eslint-enable */

var getInfo = function getInfo(ele) {
  return ele.scratch('breadthfirst');
};

var setInfo = function setInfo(ele, obj) {
  return ele.scratch('breadthfirst', obj);
};

function BreadthFirstLayout(options) {
  this.options = extend({}, defaults$9, options);
}

BreadthFirstLayout.prototype.run = function () {
  var params = this.options;
  var options = params;
  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().filter(function (n) {
    return !n.isParent();
  });
  var graph = eles;
  var directed = options.directed;
  var maximal = options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code

  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var roots;

  if (elementOrCollection(options.roots)) {
    roots = options.roots;
  } else if (array(options.roots)) {
    var rootsArray = [];

    for (var i = 0; i < options.roots.length; i++) {
      var id = options.roots[i];
      var ele = cy.getElementById(id);
      rootsArray.push(ele);
    }

    roots = cy.collection(rootsArray);
  } else if (string(options.roots)) {
    roots = cy.$(options.roots);
  } else {
    if (directed) {
      roots = nodes.roots();
    } else {
      var components = eles.components();
      roots = cy.collection();

      var _loop = function _loop(_i) {
        var comp = components[_i];
        var maxDegree = comp.maxDegree(false);
        var compRoots = comp.filter(function (ele) {
          return ele.degree(false) === maxDegree;
        });
        roots = roots.add(compRoots);
      };

      for (var _i = 0; _i < components.length; _i++) {
        _loop(_i);
      }
    }
  }

  var depths = [];
  var foundByBfs = {};

  var addToDepth = function addToDepth(ele, d) {
    if (depths[d] == null) {
      depths[d] = [];
    }

    var i = depths[d].length;
    depths[d].push(ele);
    setInfo(ele, {
      index: i,
      depth: d
    });
  };

  var changeDepth = function changeDepth(ele, newDepth) {
    var _getInfo = getInfo(ele),
        depth = _getInfo.depth,
        index = _getInfo.index;

    depths[depth][index] = null;
    addToDepth(ele, newDepth);
  }; // find the depths of the nodes


  graph.bfs({
    roots: roots,
    directed: options.directed,
    visit: function visit(node, edge, pNode, i, depth) {
      var ele = node[0];
      var id = ele.id();
      addToDepth(ele, depth);
      foundByBfs[id] = true;
    }
  }); // check for nodes not found by bfs

  var orphanNodes = [];

  for (var _i2 = 0; _i2 < nodes.length; _i2++) {
    var _ele = nodes[_i2];

    if (foundByBfs[_ele.id()]) {
      continue;
    } else {
      orphanNodes.push(_ele);
    }
  } // assign the nodes a depth and index


  var assignDepthsAt = function assignDepthsAt(i) {
    var eles = depths[i];

    for (var j = 0; j < eles.length; j++) {
      var _ele2 = eles[j];

      if (_ele2 == null) {
        eles.splice(j, 1);
        j--;
        continue;
      }

      setInfo(_ele2, {
        depth: i,
        index: j
      });
    }
  };

  var assignDepths = function assignDepths() {
    for (var _i3 = 0; _i3 < depths.length; _i3++) {
      assignDepthsAt(_i3);
    }
  };

  var adjustMaximally = function adjustMaximally(ele, shifted) {
    var eInfo = getInfo(ele);
    var incomers = ele.incomers().filter(function (el) {
      return el.isNode() && eles.has(el);
    });
    var maxDepth = -1;
    var id = ele.id();

    for (var k = 0; k < incomers.length; k++) {
      var incmr = incomers[k];
      var iInfo = getInfo(incmr);
      maxDepth = Math.max(maxDepth, iInfo.depth);
    }

    if (eInfo.depth <= maxDepth) {
      if (shifted[id]) {
        return null;
      }

      changeDepth(ele, maxDepth + 1);
      shifted[id] = true;
      return true;
    }

    return false;
  }; // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)


  if (directed && maximal) {
    var Q = [];
    var shifted = {};

    var enqueue = function enqueue(n) {
      return Q.push(n);
    };

    var dequeue = function dequeue() {
      return Q.shift();
    };

    nodes.forEach(function (n) {
      return Q.push(n);
    });

    while (Q.length > 0) {
      var _ele3 = dequeue();

      var didShift = adjustMaximally(_ele3, shifted);

      if (didShift) {
        _ele3.outgoers().filter(function (el) {
          return el.isNode() && eles.has(el);
        }).forEach(enqueue);
      } else if (didShift === null) {
        warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');
        break; // exit on failure
      }
    }
  }

  assignDepths(); // clear holes
  // find min distance we need to leave between nodes

  var minDistance = 0;

  if (options.avoidOverlap) {
    for (var _i4 = 0; _i4 < nodes.length; _i4++) {
      var n = nodes[_i4];
      var nbb = n.layoutDimensions(options);
      var w = nbb.w;
      var h = nbb.h;
      minDistance = Math.max(minDistance, w, h);
    }
  } // get the weighted percent for an element based on its connectivity to other levels


  var cachedWeightedPercent = {};

  var getWeightedPercent = function getWeightedPercent(ele) {
    if (cachedWeightedPercent[ele.id()]) {
      return cachedWeightedPercent[ele.id()];
    }

    var eleDepth = getInfo(ele).depth;
    var neighbors = ele.neighborhood();
    var percent = 0;
    var samples = 0;

    for (var _i5 = 0; _i5 < neighbors.length; _i5++) {
      var neighbor = neighbors[_i5];

      if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {
        continue;
      }

      var bf = getInfo(neighbor);
      var index = bf.index;
      var depth = bf.depth; // unassigned neighbours shouldn't affect the ordering

      if (index == null || depth == null) {
        continue;
      }

      var nDepth = depths[depth].length;

      if (depth < eleDepth) {
        // only get influenced by elements above
        percent += index / nDepth;
        samples++;
      }
    }

    samples = Math.max(1, samples);
    percent = percent / samples;

    if (samples === 0) {
      // put lone nodes at the start
      percent = 0;
    }

    cachedWeightedPercent[ele.id()] = percent;
    return percent;
  }; // rearrange the indices in each depth level based on connectivity


  var sortFn = function sortFn(a, b) {
    var apct = getWeightedPercent(a);
    var bpct = getWeightedPercent(b);
    var diff = apct - bpct;

    if (diff === 0) {
      return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons
    } else {
      return diff;
    }
  }; // sort each level to make connected nodes closer


  for (var _i6 = 0; _i6 < depths.length; _i6++) {
    depths[_i6].sort(sortFn);

    assignDepthsAt(_i6);
  } // assign orphan nodes to a new top-level depth


  var orphanDepth = [];

  for (var _i7 = 0; _i7 < orphanNodes.length; _i7++) {
    orphanDepth.push(orphanNodes[_i7]);
  }

  depths.unshift(orphanDepth);
  assignDepths();
  var biggestDepthSize = 0;

  for (var _i8 = 0; _i8 < depths.length; _i8++) {
    biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);
  }

  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.x1 + bb.h / 2
  };
  var maxDepthSize = depths.reduce(function (max, eles) {
    return Math.max(max, eles.length);
  }, 0);

  var getPosition = function getPosition(ele) {
    var _getInfo2 = getInfo(ele),
        depth = _getInfo2.depth,
        index = _getInfo2.index;

    var depthSize = depths[depth].length;
    var distanceX = Math.max(bb.w / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);
    var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);
    var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);
    radiusStepSize = Math.max(radiusStepSize, minDistance);

    if (!options.circle) {
      var epos = {
        x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,
        y: (depth + 1) * distanceY
      };
      return epos;
    } else {
      var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);
      var theta = 2 * Math.PI / depths[depth].length * index;

      if (depth === 0 && depths[0].length === 1) {
        radius = 1;
      }

      return {
        x: center.x + radius * Math.cos(theta),
        y: center.y + radius * Math.sin(theta)
      };
    }
  };

  nodes.layoutPositions(this, options, getPosition);
  return this; // chaining
};

var defaults$a = {
  fit: true,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox and radius if not enough space
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  radius: undefined,
  // the radius of the circle
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: undefined,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: undefined,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 

};

function CircleLayout(options) {
  this.options = extend({}, defaults$a, options);
}

CircleLayout.prototype.run = function () {
  var params = this.options;
  var options = params;
  var cy = params.cy;
  var eles = options.eles;
  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
  var nodes = eles.nodes().not(':parent');

  if (options.sort) {
    nodes = nodes.sort(options.sort);
  }

  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };
  var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;
  var dTheta = sweep / Math.max(1, nodes.length - 1);
  var r;
  var minDistance = 0;

  for (var i = 0; i < nodes.length; i++) {
    var n = nodes[i];
    var nbb = n.layoutDimensions(options);
    var w = nbb.w;
    var h = nbb.h;
    minDistance = Math.max(minDistance, w, h);
  }

  if (number(options.radius)) {
    r = options.radius;
  } else if (nodes.length <= 1) {
    r = 0;
  } else {
    r = Math.min(bb.h, bb.w) / 2 - minDistance;
  } // calculate the radius


  if (nodes.length > 1 && options.avoidOverlap) {
    // but only if more than one node (can't overlap)
    minDistance *= 1.75; // just to have some nice spacing

    var dcos = Math.cos(dTheta) - Math.cos(0);
    var dsin = Math.sin(dTheta) - Math.sin(0);
    var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

    r = Math.max(rMin, r);
  }

  var getPos = function getPos(ele, i) {
    var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);
    var rx = r * Math.cos(theta);
    var ry = r * Math.sin(theta);
    var pos = {
      x: center.x + rx,
      y: center.y + ry
    };
    return pos;
  };

  nodes.layoutPositions(this, options, getPos);
  return this; // chaining
};

var defaults$b = {
  fit: true,
  // whether to fit the viewport to the graph
  padding: 30,
  // the padding on fit
  startAngle: 3 / 2 * Math.PI,
  // where nodes start in radians
  sweep: undefined,
  // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true,
  // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: false,
  // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10,
  // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  height: undefined,
  // height of layout area (overrides container height)
  width: undefined,
  // width of layout area (overrides container width)
  spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  concentric: function concentric(node) {
    // returns numeric value for each node, placing higher nodes in levels towards the centre
    return node.degree();
  },
  levelWidth: function levelWidth(nodes) {
    // the letiation of concentric values in each level
    return nodes.maxDegree() / 4;
  },
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts

};

function ConcentricLayout(options) {
  this.options = extend({}, defaults$b, options);
}

ConcentricLayout.prototype.run = function () {
  var params = this.options;
  var options = params;
  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;
  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');
  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });
  var center = {
    x: bb.x1 + bb.w / 2,
    y: bb.y1 + bb.h / 2
  };
  var nodeValues = []; // { node, value }

  var maxNodeSize = 0;

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var value = void 0; // calculate the node value

    value = options.concentric(node);
    nodeValues.push({
      value: value,
      node: node
    }); // for style mapping

    node._private.scratch.concentric = value;
  } // in case we used the `concentric` in style


  nodes.updateStyle(); // calculate max size now based on potentially updated mappers

  for (var _i = 0; _i < nodes.length; _i++) {
    var _node = nodes[_i];

    var nbb = _node.layoutDimensions(options);

    maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);
  } // sort node values in descreasing order


  nodeValues.sort(function (a, b) {
    return b.value - a.value;
  });
  var levelWidth = options.levelWidth(nodes); // put the values into levels

  var levels = [[]];
  var currentLevel = levels[0];

  for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {
    var val = nodeValues[_i2];

    if (currentLevel.length > 0) {
      var diff = Math.abs(currentLevel[0].value - val.value);

      if (diff >= levelWidth) {
        currentLevel = [];
        levels.push(currentLevel);
      }
    }

    currentLevel.push(val);
  } // create positions from levels


  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

  if (!options.avoidOverlap) {
    // then strictly constrain to bb
    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
    var maxR = Math.min(bb.w, bb.h) / 2 - minDist;
    var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);
    minDist = Math.min(minDist, rStep);
  } // find the metrics for each level


  var r = 0;

  for (var _i3 = 0; _i3 < levels.length; _i3++) {
    var level = levels[_i3];
    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;
    var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius

    if (level.length > 1 && options.avoidOverlap) {
      // but only if more than one node (can't overlap)
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping

      r = Math.max(rMin, r);
    }

    level.r = r;
    r += minDist;
  }

  if (options.equidistant) {
    var rDeltaMax = 0;
    var _r = 0;

    for (var _i4 = 0; _i4 < levels.length; _i4++) {
      var _level = levels[_i4];
      var rDelta = _level.r - _r;
      rDeltaMax = Math.max(rDeltaMax, rDelta);
    }

    _r = 0;

    for (var _i5 = 0; _i5 < levels.length; _i5++) {
      var _level2 = levels[_i5];

      if (_i5 === 0) {
        _r = _level2.r;
      }

      _level2.r = _r;
      _r += rDeltaMax;
    }
  } // calculate the node positions


  var pos = {}; // id => position

  for (var _i6 = 0; _i6 < levels.length; _i6++) {
    var _level3 = levels[_i6];
    var _dTheta = _level3.dTheta;
    var _r2 = _level3.r;

    for (var j = 0; j < _level3.length; j++) {
      var _val = _level3[j];
      var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;
      var p = {
        x: center.x + _r2 * Math.cos(theta),
        y: center.y + _r2 * Math.sin(theta)
      };
      pos[_val.node.id()] = p;
    }
  } // position the nodes


  nodes.layoutPositions(this, options, function (ele) {
    var id = ele.id();
    return pos[id];
  });
  return this; // chaining
};

/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*/
var DEBUG;
/**
 * @brief :  default layout options
 */

var defaults$c = {
  // Called on `layoutready`
  ready: function ready() {},
  // Called on `layoutstop`
  stop: function stop() {},
  // Whether to animate while running the layout
  // true : Animate continuously as the layout is running
  // false : Just show the end result
  // 'end' : Animate with the end result, from the initial positions to the end positions
  animate: true,
  // Easing of the animation for animate:'end'
  animationEasing: undefined,
  // The duration of the animation for animate:'end'
  animationDuration: undefined,
  // A function that determines whether the node should be animated
  // All nodes animated by default on animate enabled
  // Non-animated nodes are positioned immediately when the layout starts
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // The layout animates only after this many milliseconds for animate:true
  // (prevents flashing on fast runs)
  animationThreshold: 250,
  // Number of iterations between consecutive screen positions update
  refresh: 20,
  // Whether to fit the network view after when done
  fit: true,
  // Padding on fit
  padding: 30,
  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox: undefined,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  nodeDimensionsIncludeLabels: false,
  // Randomize the initial positions of the nodes (true) or use existing positions (false)
  randomize: false,
  // Extra spacing between components in non-compound graphs
  componentSpacing: 40,
  // Node repulsion (non overlapping) multiplier
  nodeRepulsion: function nodeRepulsion(node) {
    return 2048;
  },
  // Node repulsion (overlapping) multiplier
  nodeOverlap: 4,
  // Ideal edge (non nested) length
  idealEdgeLength: function idealEdgeLength(edge) {
    return 32;
  },
  // Divisor to compute edge forces
  edgeElasticity: function edgeElasticity(edge) {
    return 32;
  },
  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor: 1.2,
  // Gravity force (constant)
  gravity: 1,
  // Maximum number of iterations to perform
  numIter: 1000,
  // Initial temperature (maximum node displacement)
  initialTemp: 1000,
  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor: 0.99,
  // Lower temperature threshold (below this point the layout will end)
  minTemp: 1.0
};
/**
 * @brief       : constructor
 * @arg options : object containing layout options
 */

function CoseLayout(options) {
  this.options = extend({}, defaults$c, options);
  this.options.layout = this;
}
/**
 * @brief : runs the layout
 */


CoseLayout.prototype.run = function () {
  var options = this.options;
  var cy = options.cy;
  var layout = this;
  layout.stopped = false;

  if (options.animate === true || options.animate === false) {
    layout.emit({
      type: 'layoutstart',
      layout: layout
    });
  } // Set DEBUG - Global variable


  if (true === options.debug) {
    DEBUG = true;
  } else {
    DEBUG = false;
  } // Initialize layout info


  var layoutInfo = createLayoutInfo(cy, layout, options); // Show LayoutInfo contents if debugging

  if (DEBUG) {
    printLayoutInfo(layoutInfo);
  } // If required, randomize node positions


  if (options.randomize) {
    randomizePositions(layoutInfo);
  }

  var startTime = performanceNow();

  var refresh = function refresh() {
    refreshPositions(layoutInfo, cy, options); // Fit the graph if necessary

    if (true === options.fit) {
      cy.fit(options.padding);
    }
  };

  var mainLoop = function mainLoop(i) {
    if (layout.stopped || i >= options.numIter) {
      // logDebug("Layout manually stopped. Stopping computation in step " + i);
      return false;
    } // Do one step in the phisical simulation


    step$1(layoutInfo, options); // Update temperature

    layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor; // logDebug("New temperature: " + layoutInfo.temperature);

    if (layoutInfo.temperature < options.minTemp) {
      // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
      return false;
    }

    return true;
  };

  var done = function done() {
    if (options.animate === true || options.animate === false) {
      refresh(); // Layout has finished

      layout.one('layoutstop', options.stop);
      layout.emit({
        type: 'layoutstop',
        layout: layout
      });
    } else {
      var nodes = options.eles.nodes();
      var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);
      nodes.layoutPositions(layout, options, getScaledPos);
    }
  };

  var i = 0;
  var loopRet = true;

  if (options.animate === true) {
    var frame = function frame() {
      var f = 0;

      while (loopRet && f < options.refresh) {
        loopRet = mainLoop(i);
        i++;
        f++;
      }

      if (!loopRet) {
        // it's done
        separateComponents(layoutInfo, options);
        done();
      } else {
        var now = performanceNow();

        if (now - startTime >= options.animationThreshold) {
          refresh();
        }

        requestAnimationFrame(frame);
      }
    };

    frame();
  } else {
    while (loopRet) {
      loopRet = mainLoop(i);
      i++;
    }

    separateComponents(layoutInfo, options);
    done();
  }

  return this; // chaining
};
/**
 * @brief : called on continuous layouts to stop them before they finish
 */


CoseLayout.prototype.stop = function () {
  this.stopped = true;

  if (this.thread) {
    this.thread.stop();
  }

  this.emit('layoutstop');
  return this; // chaining
};

CoseLayout.prototype.destroy = function () {
  if (this.thread) {
    this.thread.stop();
  }

  return this; // chaining
};
/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */


var createLayoutInfo = function createLayoutInfo(cy, layout, options) {
  // Shortcut
  var edges = options.eles.edges();
  var nodes = options.eles.nodes();
  var layoutInfo = {
    isCompound: cy.hasCompoundNodes(),
    layoutNodes: [],
    idToIndex: {},
    nodeSize: nodes.size(),
    graphSet: [],
    indexToGraph: [],
    layoutEdges: [],
    edgeSize: edges.size(),
    temperature: options.initialTemp,
    clientWidth: cy.width(),
    clientHeight: cy.width(),
    boundingBox: makeBoundingBox(options.boundingBox ? options.boundingBox : {
      x1: 0,
      y1: 0,
      w: cy.width(),
      h: cy.height()
    })
  };
  var components = options.eles.components();
  var id2cmptId = {};

  for (var i = 0; i < components.length; i++) {
    var component = components[i];

    for (var j = 0; j < component.length; j++) {
      var node = component[j];
      id2cmptId[node.id()] = i;
    }
  } // Iterate over all nodes, creating layout nodes


  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = nodes[i];
    var nbb = n.layoutDimensions(options);
    var tempNode = {};
    tempNode.isLocked = n.locked();
    tempNode.id = n.data('id');
    tempNode.parentId = n.data('parent');
    tempNode.cmptId = id2cmptId[n.id()];
    tempNode.children = [];
    tempNode.positionX = n.position('x');
    tempNode.positionY = n.position('y');
    tempNode.offsetX = 0;
    tempNode.offsetY = 0;
    tempNode.height = nbb.w;
    tempNode.width = nbb.h;
    tempNode.maxX = tempNode.positionX + tempNode.width / 2;
    tempNode.minX = tempNode.positionX - tempNode.width / 2;
    tempNode.maxY = tempNode.positionY + tempNode.height / 2;
    tempNode.minY = tempNode.positionY - tempNode.height / 2;
    tempNode.padLeft = parseFloat(n.style('padding'));
    tempNode.padRight = parseFloat(n.style('padding'));
    tempNode.padTop = parseFloat(n.style('padding'));
    tempNode.padBottom = parseFloat(n.style('padding')); // forces

    tempNode.nodeRepulsion = fn(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion; // Add new node

    layoutInfo.layoutNodes.push(tempNode); // Add entry to id-index map

    layoutInfo.idToIndex[tempNode.id] = i;
  } // Inline implementation of a queue, used for traversing the graph in BFS order


  var queue = [];
  var start = 0; // Points to the start the queue

  var end = -1; // Points to the end of the queue

  var tempGraph = []; // Second pass to add child information and
  // initialize queue for hierarchical traversal

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    var p_id = n.parentId; // Check if node n has a parent node

    if (null != p_id) {
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
    } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[++end] = n.id;
      tempGraph.push(n.id);
    }
  } // Add root graph to graphSet


  layoutInfo.graphSet.push(tempGraph); // Traverse the graph, level by level,

  while (start <= end) {
    // Get the node to visit and remove it from queue
    var node_id = queue[start++];
    var node_ix = layoutInfo.idToIndex[node_id];
    var node = layoutInfo.layoutNodes[node_ix];
    var children = node.children;

    if (children.length > 0) {
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push(children); // Add children to que queue to be visited

      for (var i = 0; i < children.length; i++) {
        queue[++end] = children[i];
      }
    }
  } // Create indexToGraph map


  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];

    for (var j = 0; j < graph.length; j++) {
      var index = layoutInfo.idToIndex[graph[j]];
      layoutInfo.indexToGraph[index] = i;
    }
  } // Iterate over all edges, creating Layout Edges


  for (var i = 0; i < layoutInfo.edgeSize; i++) {
    var e = edges[i];
    var tempEdge = {};
    tempEdge.id = e.data('id');
    tempEdge.sourceId = e.data('source');
    tempEdge.targetId = e.data('target'); // Compute ideal length

    var idealLength = fn(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;
    var elasticity = fn(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity; // Check if it's an inter graph edge

    var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];
    var targetIx = layoutInfo.idToIndex[tempEdge.targetId];
    var sourceGraph = layoutInfo.indexToGraph[sourceIx];
    var targetGraph = layoutInfo.indexToGraph[targetIx];

    if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo); // Compute sum of node depths, relative to lca graph

      var lcaGraph = layoutInfo.graphSet[lca];
      var depth = 0; // Source depth

      var tempNode = layoutInfo.layoutNodes[sourceIx];

      while (-1 === lcaGraph.indexOf(tempNode.id)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      } // Target depth


      tempNode = layoutInfo.layoutNodes[targetIx];

      while (-1 === lcaGraph.indexOf(tempNode.id)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      } // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
      //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
      //  ". Depth: " + depth);
      // Update idealLength


      idealLength *= depth * options.nestingFactor;
    }

    tempEdge.idealLength = idealLength;
    tempEdge.elasticity = elasticity;
    layoutInfo.layoutEdges.push(tempEdge);
  } // Finally, return layoutInfo object


  return layoutInfo;
};
/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 */


var findLCA = function findLCA(node1, node2, layoutInfo) {
  // Find their common ancester, starting from the root graph
  var res = findLCA_aux(node1, node2, 0, layoutInfo);

  if (2 > res.count) {
    // If aux function couldn't find the common ancester,
    // then it is the root graph
    return 0;
  } else {
    return res.graph;
  }
};
/**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 */


var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {
  var graph = layoutInfo.graphSet[graphIx]; // If both nodes belongs to graphIx

  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
    return {
      count: 2,
      graph: graphIx
    };
  } // Make recursive calls for all subgraphs


  var c = 0;

  for (var i = 0; i < graph.length; i++) {
    var nodeId = graph[i];
    var nodeIx = layoutInfo.idToIndex[nodeId];
    var children = layoutInfo.layoutNodes[nodeIx].children; // If the node has no child, skip it

    if (0 === children.length) {
      continue;
    }

    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
    var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);

    if (0 === result.count) {
      // Neither node1 nor node2 are present in this subgraph
      continue;
    } else if (1 === result.count) {
      // One of (node1, node2) is present in this subgraph
      c++;

      if (2 === c) {
        // We've already found both nodes, no need to keep searching
        break;
      }
    } else {
      // Both nodes are present in this subgraph
      return result;
    }
  }

  return {
    count: c,
    graph: graphIx
  };
};
/**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 */


if (false) { var printLayoutInfo; }
/**
 * @brief : Randomizes the position of all nodes
 */


var randomizePositions = function randomizePositions(layoutInfo, cy) {
  var width = layoutInfo.clientWidth;
  var height = layoutInfo.clientHeight;

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i]; // No need to randomize compound nodes or locked nodes

    if (0 === n.children.length && !n.isLocked) {
      n.positionX = Math.random() * width;
      n.positionY = Math.random() * height;
    }
  }
};

var getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {
  var bb = layoutInfo.boundingBox;
  var coseBB = {
    x1: Infinity,
    x2: -Infinity,
    y1: Infinity,
    y2: -Infinity
  };

  if (options.boundingBox) {
    nodes.forEach(function (node) {
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];
      coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);
      coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);
      coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);
      coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);
    });
    coseBB.w = coseBB.x2 - coseBB.x1;
    coseBB.h = coseBB.y2 - coseBB.y1;
  }

  return function (ele, i) {
    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];

    if (options.boundingBox) {
      // then add extra bounding box constraint
      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;
      return {
        x: bb.x1 + pctX * bb.w,
        y: bb.y1 + pctY * bb.h
      };
    } else {
      return {
        x: lnode.positionX,
        y: lnode.positionY
      };
    }
  };
};
/**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */


var refreshPositions = function refreshPositions(layoutInfo, cy, options) {
  // var s = 'Refreshing positions';
  // logDebug(s);
  var layout = options.layout;
  var nodes = options.eles.nodes();
  var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);
  nodes.positions(getScaledPos); // Trigger layoutReady only on first call

  if (true !== layoutInfo.ready) {
    // s = 'Triggering layoutready';
    // logDebug(s);
    layoutInfo.ready = true;
    layout.one('layoutready', options.ready);
    layout.emit({
      type: 'layoutready',
      layout: this
    });
  }
};
/**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */
// var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };

/**
 * @brief          : Performs one iteration of the physical simulation
 * @arg layoutInfo : LayoutInfo object already initialized
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */


var step$1 = function step(layoutInfo, options, _step) {
  // var s = "\n\n###############################";
  // s += "\nSTEP: " + step;
  // s += "\n###############################\n";
  // logDebug(s);
  // Calculate node repulsions
  calculateNodeForces(layoutInfo, options); // Calculate edge forces

  calculateEdgeForces(layoutInfo); // Calculate gravity forces

  calculateGravityForces(layoutInfo, options); // Propagate forces from parent to child

  propagateForces(layoutInfo); // Update positions based on calculated forces

  updatePositions(layoutInfo);
};
/**
 * @brief : Computes the node repulsion forces
 */


var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {
  // Go through each of the graphs in graphSet
  // Nodes only repel each other if they belong to the same graph
  // var s = 'calculateNodeForces';
  // logDebug(s);
  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    var numNodes = graph.length; // s = "Set: " + graph.toString();
    // logDebug(s);
    // Now get all the pairs of nodes
    // Only get each pair once, (A, B) = (B, A)

    for (var j = 0; j < numNodes; j++) {
      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];

      for (var k = j + 1; k < numNodes; k++) {
        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
        nodeRepulsion(node1, node2, layoutInfo, options);
      }
    }
  }
};

var randomDistance = function randomDistance(max) {
  return -max + 2 * max * Math.random();
};
/**
 * @brief : Compute the node repulsion forces between a pair of nodes
 */


var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {
  // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;
  var cmptId1 = node1.cmptId;
  var cmptId2 = node2.cmptId;

  if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {
    return;
  } // Get direction of line connecting both node centers


  var directionX = node2.positionX - node1.positionX;
  var directionY = node2.positionY - node1.positionY;
  var maxRandDist = 1; // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;
  // If both centers are the same, apply a random force

  if (0 === directionX && 0 === directionY) {
    directionX = randomDistance(maxRandDist);
    directionY = randomDistance(maxRandDist);
  }

  var overlap = nodesOverlap(node1, node2, directionX, directionY);

  if (overlap > 0) {
    // s += "\nNodes DO overlap.";
    // s += "\nOverlap: " + overlap;
    // If nodes overlap, repulsion force is proportional
    // to the overlap
    var force = options.nodeOverlap * overlap; // Compute the module and components of the force vector

    var distance = Math.sqrt(directionX * directionX + directionY * directionY); // s += "\nDistance: " + distance;

    var forceX = force * directionX / distance;
    var forceY = force * directionY / distance;
  } else {
    // s += "\nNodes do NOT overlap.";
    // If there's no overlap, force is inversely proportional
    // to squared distance
    // Get clipping points for both nodes
    var point1 = findClippingPoint(node1, directionX, directionY);
    var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY); // Use clipping points to compute distance

    var distanceX = point2.x - point1.x;
    var distanceY = point2.y - point1.y;
    var distanceSqr = distanceX * distanceX + distanceY * distanceY;
    var distance = Math.sqrt(distanceSqr); // s += "\nDistance: " + distance;
    // Compute the module and components of the force vector

    var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;
    var forceX = force * distanceX / distance;
    var forceY = force * distanceY / distance;
  } // Apply force


  if (!node1.isLocked) {
    node1.offsetX -= forceX;
    node1.offsetY -= forceY;
  }

  if (!node2.isLocked) {
    node2.offsetX += forceX;
    node2.offsetY += forceY;
  } // s += "\nForceX: " + forceX + " ForceY: " + forceY;
  // logDebug(s);


  return;
};
/**
 * @brief  : Determines whether two nodes overlap or not
 * @return : Amount of overlapping (0 => no overlap)
 */


var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {
  if (dX > 0) {
    var overlapX = node1.maxX - node2.minX;
  } else {
    var overlapX = node2.maxX - node1.minX;
  }

  if (dY > 0) {
    var overlapY = node1.maxY - node2.minY;
  } else {
    var overlapY = node2.maxY - node1.minY;
  }

  if (overlapX >= 0 && overlapY >= 0) {
    return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
  } else {
    return 0;
  }
};
/**
 * @brief : Finds the point in which an edge (direction dX, dY) intersects
 *          the rectangular bounding box of it's source/target node
 */


var findClippingPoint = function findClippingPoint(node, dX, dY) {
  // Shorcuts
  var X = node.positionX;
  var Y = node.positionY;
  var H = node.height || 1;
  var W = node.width || 1;
  var dirSlope = dY / dX;
  var nodeSlope = H / W; // var s = 'Computing clipping point of node ' + node.id +
  //   " . Height:  " + H + ", Width: " + W +
  //   "\nDirection " + dX + ", " + dY;
  //
  // Compute intersection

  var res = {}; // Case: Vertical direction (up)

  if (0 === dX && 0 < dY) {
    res.x = X; // s += "\nUp direction";

    res.y = Y + H / 2;
    return res;
  } // Case: Vertical direction (down)


  if (0 === dX && 0 > dY) {
    res.x = X;
    res.y = Y + H / 2; // s += "\nDown direction";

    return res;
  } // Case: Intersects the right border


  if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
    res.x = X + W / 2;
    res.y = Y + W * dY / 2 / dX; // s += "\nRightborder";

    return res;
  } // Case: Intersects the left border


  if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {
    res.x = X - W / 2;
    res.y = Y - W * dY / 2 / dX; // s += "\nLeftborder";

    return res;
  } // Case: Intersects the top border


  if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
    res.x = X + H * dX / 2 / dY;
    res.y = Y + H / 2; // s += "\nTop border";

    return res;
  } // Case: Intersects the bottom border


  if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {
    res.x = X - H * dX / 2 / dY;
    res.y = Y - H / 2; // s += "\nBottom border";

    return res;
  } // s += "\nClipping point found at " + res.x + ", " + res.y;
  // logDebug(s);


  return res;
};
/**
 * @brief : Calculates all edge forces
 */


var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {
  // Iterate over all edges
  for (var i = 0; i < layoutInfo.edgeSize; i++) {
    // Get edge, source & target nodes
    var edge = layoutInfo.layoutEdges[i];
    var sourceIx = layoutInfo.idToIndex[edge.sourceId];
    var source = layoutInfo.layoutNodes[sourceIx];
    var targetIx = layoutInfo.idToIndex[edge.targetId];
    var target = layoutInfo.layoutNodes[targetIx]; // Get direction of line connecting both node centers

    var directionX = target.positionX - source.positionX;
    var directionY = target.positionY - source.positionY; // If both centers are the same, do nothing.
    // A random force has already been applied as node repulsion

    if (0 === directionX && 0 === directionY) {
      continue;
    } // Get clipping points for both nodes


    var point1 = findClippingPoint(source, directionX, directionY);
    var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);
    var lx = point2.x - point1.x;
    var ly = point2.y - point1.y;
    var l = Math.sqrt(lx * lx + ly * ly);
    var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;

    if (0 !== l) {
      var forceX = force * lx / l;
      var forceY = force * ly / l;
    } else {
      var forceX = 0;
      var forceY = 0;
    } // Add this force to target and source nodes


    if (!source.isLocked) {
      source.offsetX += forceX;
      source.offsetY += forceY;
    }

    if (!target.isLocked) {
      target.offsetX -= forceX;
      target.offsetY -= forceY;
    } // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
    // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
    // logDebug(s);

  }
};
/**
 * @brief : Computes gravity forces for all nodes
 */


var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {
  var distThreshold = 1; // var s = 'calculateGravityForces';
  // logDebug(s);

  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    var numNodes = graph.length; // s = "Set: " + graph.toString();
    // logDebug(s);
    // Compute graph center

    if (0 === i) {
      var centerX = layoutInfo.clientHeight / 2;
      var centerY = layoutInfo.clientWidth / 2;
    } else {
      // Get Parent node for this graph, and use its position as center
      var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
      var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
      var centerX = parent.positionX;
      var centerY = parent.positionY;
    } // s = "Center found at: " + centerX + ", " + centerY;
    // logDebug(s);
    // Apply force to all nodes in graph


    for (var j = 0; j < numNodes; j++) {
      var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]]; // s = "Node: " + node.id;

      if (node.isLocked) {
        continue;
      }

      var dx = centerX - node.positionX;
      var dy = centerY - node.positionY;
      var d = Math.sqrt(dx * dx + dy * dy);

      if (d > distThreshold) {
        var fx = options.gravity * dx / d;
        var fy = options.gravity * dy / d;
        node.offsetX += fx;
        node.offsetY += fy; // s += ": Applied force: " + fx + ", " + fy;
      } // s += ": skypped since it's too close to center";
        // logDebug(s);

    }
  }
};
/**
 * @brief          : This function propagates the existing offsets from
 *                   parent nodes to its descendents.
 * @arg layoutInfo : layoutInfo Object
 * @arg cy         : cytoscape Object
 * @arg options    : Layout options
 */


var propagateForces = function propagateForces(layoutInfo, options) {
  // Inline implementation of a queue, used for traversing the graph in BFS order
  var queue = [];
  var start = 0; // Points to the start the queue

  var end = -1; // Points to the end of the queue
  // logDebug('propagateForces');
  // Start by visiting the nodes in the root graph

  queue.push.apply(queue, layoutInfo.graphSet[0]);
  end += layoutInfo.graphSet[0].length; // Traverse the graph, level by level,

  while (start <= end) {
    // Get the node to visit and remove it from queue
    var nodeId = queue[start++];
    var nodeIndex = layoutInfo.idToIndex[nodeId];
    var node = layoutInfo.layoutNodes[nodeIndex];
    var children = node.children; // We only need to process the node if it's compound

    if (0 < children.length && !node.isLocked) {
      var offX = node.offsetX;
      var offY = node.offsetY; // var s = "Propagating offset from parent node : " + node.id +
      //   ". OffsetX: " + offX + ". OffsetY: " + offY;
      // s += "\n Children: " + children.toString();
      // logDebug(s);

      for (var i = 0; i < children.length; i++) {
        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]]; // Propagate offset

        childNode.offsetX += offX;
        childNode.offsetY += offY; // Add children to queue to be visited

        queue[++end] = children[i];
      } // Reset parent offsets


      node.offsetX = 0;
      node.offsetY = 0;
    }
  }
};
/**
 * @brief : Updates the layout model positions, based on
 *          the accumulated forces
 */


var updatePositions = function updatePositions(layoutInfo, options) {
  // var s = 'Updating positions';
  // logDebug(s);
  // Reset boundaries for compound nodes
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    if (0 < n.children.length) {
      // logDebug("Resetting boundaries of compound node: " + n.id);
      n.maxX = undefined;
      n.minX = undefined;
      n.maxY = undefined;
      n.minY = undefined;
    }
  }

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    if (0 < n.children.length || n.isLocked) {
      // No need to set compound or locked node position
      // logDebug("Skipping position update of node: " + n.id);
      continue;
    } // s = "Node: " + n.id + " Previous position: (" +
    // n.positionX + ", " + n.positionY + ").";
    // Limit displacement in order to improve stability


    var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
    n.positionX += tempForce.x;
    n.positionY += tempForce.y;
    n.offsetX = 0;
    n.offsetY = 0;
    n.minX = n.positionX - n.width;
    n.maxX = n.positionX + n.width;
    n.minY = n.positionY - n.height;
    n.maxY = n.positionY + n.height; // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
    // logDebug(s);
    // Update ancestry boudaries

    updateAncestryBoundaries(n, layoutInfo);
  } // Update size, position of compund nodes


  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    if (0 < n.children.length && !n.isLocked) {
      n.positionX = (n.maxX + n.minX) / 2;
      n.positionY = (n.maxY + n.minY) / 2;
      n.width = n.maxX - n.minX;
      n.height = n.maxY - n.minY; // s = "Updating position, size of compound node " + n.id;
      // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
      // s += "\nWidth: " + n.width + ", Height: " + n.height;
      // logDebug(s);
    }
  }
};
/**
 * @brief : Limits a force (forceX, forceY) to be not
 *          greater (in modulo) than max.
 8          Preserves force direction.
  */


var limitForce = function limitForce(forceX, forceY, max) {
  // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
  var force = Math.sqrt(forceX * forceX + forceY * forceY);

  if (force > max) {
    var res = {
      x: max * forceX / force,
      y: max * forceY / force
    };
  } else {
    var res = {
      x: forceX,
      y: forceY
    };
  } // s += ".\nResult: (" + res.x + ", " + res.y + ")";
  // logDebug(s);


  return res;
};
/**
 * @brief : Function used for keeping track of compound node
 *          sizes, since they should bound all their subnodes.
 */


var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {
  // var s = "Propagating new position/size of node " + node.id;
  var parentId = node.parentId;

  if (null == parentId) {
    // If there's no parent, we are done
    // s += ". No parent node.";
    // logDebug(s);
    return;
  } // Get Parent Node


  var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
  var flag = false; // MaxX

  if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
    p.maxX = node.maxX + p.padRight;
    flag = true; // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
  } // MinX


  if (null == p.minX || node.minX - p.padLeft < p.minX) {
    p.minX = node.minX - p.padLeft;
    flag = true; // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
  } // MaxY


  if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
    p.maxY = node.maxY + p.padBottom;
    flag = true; // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
  } // MinY


  if (null == p.minY || node.minY - p.padTop < p.minY) {
    p.minY = node.minY - p.padTop;
    flag = true; // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
  } // If updated boundaries, propagate changes upward


  if (flag) {
    // logDebug(s);
    return updateAncestryBoundaries(p, layoutInfo);
  } // s += ". No changes in boundaries/position of parent node " + p.id;
  // logDebug(s);


  return;
};

var separateComponents = function separateComponents(layoutInfo, options) {
  var nodes = layoutInfo.layoutNodes;
  var components = [];

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var cid = node.cmptId;
    var component = components[cid] = components[cid] || [];
    component.push(node);
  }

  var totalA = 0;

  for (var i = 0; i < components.length; i++) {
    var c = components[i];

    if (!c) {
      continue;
    }

    c.x1 = Infinity;
    c.x2 = -Infinity;
    c.y1 = Infinity;
    c.y2 = -Infinity;

    for (var j = 0; j < c.length; j++) {
      var n = c[j];
      c.x1 = Math.min(c.x1, n.positionX - n.width / 2);
      c.x2 = Math.max(c.x2, n.positionX + n.width / 2);
      c.y1 = Math.min(c.y1, n.positionY - n.height / 2);
      c.y2 = Math.max(c.y2, n.positionY + n.height / 2);
    }

    c.w = c.x2 - c.x1;
    c.h = c.y2 - c.y1;
    totalA += c.w * c.h;
  }

  components.sort(function (c1, c2) {
    return c2.w * c2.h - c1.w * c1.h;
  });
  var x = 0;
  var y = 0;
  var usedW = 0;
  var rowH = 0;
  var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;

  for (var i = 0; i < components.length; i++) {
    var c = components[i];

    if (!c) {
      continue;
    }

    for (var j = 0; j < c.length; j++) {
      var n = c[j];

      if (!n.isLocked) {
        n.positionX += x - c.x1;
        n.positionY += y - c.y1;
      }
    }

    x += c.w + options.componentSpacing;
    usedW += c.w + options.componentSpacing;
    rowH = Math.max(rowH, c.h);

    if (usedW > maxRowW) {
      y += rowH + options.componentSpacing;
      x = 0;
      usedW = 0;
      rowH = 0;
    }
  }
};

var defaults$d = {
  fit: true,
  // whether to fit the viewport to the graph
  padding: 30,
  // padding used on fit
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true,
  // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10,
  // extra spacing around nodes when avoidOverlap: true
  nodeDimensionsIncludeLabels: false,
  // Excludes the label when calculating node bounding boxes for the layout algorithm
  spacingFactor: undefined,
  // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  condense: false,
  // uses all available space on false, uses minimal space on true
  rows: undefined,
  // force num of rows in the grid
  cols: undefined,
  // force num of columns in the grid
  position: function position(node) {},
  // returns { row, col } for element
  sort: undefined,
  // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 

};

function GridLayout(options) {
  this.options = extend({}, defaults$d, options);
}

GridLayout.prototype.run = function () {
  var params = this.options;
  var options = params;
  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  if (options.sort) {
    nodes = nodes.sort(options.sort);
  }

  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });

  if (bb.h === 0 || bb.w === 0) {
    nodes.layoutPositions(this, options, function (ele) {
      return {
        x: bb.x1,
        y: bb.y1
      };
    });
  } else {
    // width/height * splits^2 = cells where splits is number of times to split width
    var cells = nodes.size();
    var splits = Math.sqrt(cells * bb.h / bb.w);
    var rows = Math.round(splits);
    var cols = Math.round(bb.w / bb.h * splits);

    var small = function small(val) {
      if (val == null) {
        return Math.min(rows, cols);
      } else {
        var min = Math.min(rows, cols);

        if (min == rows) {
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var large = function large(val) {
      if (val == null) {
        return Math.max(rows, cols);
      } else {
        var max = Math.max(rows, cols);

        if (max == rows) {
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var oRows = options.rows;
    var oCols = options.cols != null ? options.cols : options.columns; // if rows or columns were set in options, use those values

    if (oRows != null && oCols != null) {
      rows = oRows;
      cols = oCols;
    } else if (oRows != null && oCols == null) {
      rows = oRows;
      cols = Math.ceil(cells / rows);
    } else if (oRows == null && oCols != null) {
      cols = oCols;
      rows = Math.ceil(cells / cols);
    } // otherwise use the automatic values and adjust accordingly
    // if rounding was up, see if we can reduce rows or columns
    else if (cols * rows > cells) {
        var sm = small();
        var lg = large(); // reducing the small side takes away the most cells, so try it first

        if ((sm - 1) * lg >= cells) {
          small(sm - 1);
        } else if ((lg - 1) * sm >= cells) {
          large(lg - 1);
        }
      } else {
        // if rounding was too low, add rows or columns
        while (cols * rows < cells) {
          var _sm = small();

          var _lg = large(); // try to add to larger side first (adds less in multiplication)


          if ((_lg + 1) * _sm >= cells) {
            large(_lg + 1);
          } else {
            small(_sm + 1);
          }
        }
      }

    var cellWidth = bb.w / cols;
    var cellHeight = bb.h / rows;

    if (options.condense) {
      cellWidth = 0;
      cellHeight = 0;
    }

    if (options.avoidOverlap) {
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        var pos = node._private.position;

        if (pos.x == null || pos.y == null) {
          // for bb
          pos.x = 0;
          pos.y = 0;
        }

        var nbb = node.layoutDimensions(options);
        var p = options.avoidOverlapPadding;
        var w = nbb.w + p;
        var h = nbb.h + p;
        cellWidth = Math.max(cellWidth, w);
        cellHeight = Math.max(cellHeight, h);
      }
    }

    var cellUsed = {}; // e.g. 'c-0-2' => true

    var used = function used(row, col) {
      return cellUsed['c-' + row + '-' + col] ? true : false;
    };

    var use = function use(row, col) {
      cellUsed['c-' + row + '-' + col] = true;
    }; // to keep track of current cell position


    var row = 0;
    var col = 0;

    var moveToNextCell = function moveToNextCell() {
      col++;

      if (col >= cols) {
        col = 0;
        row++;
      }
    }; // get a cache of all the manual positions


    var id2manPos = {};

    for (var _i = 0; _i < nodes.length; _i++) {
      var _node = nodes[_i];
      var rcPos = options.position(_node);

      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
        // must have at least row or col def'd
        var _pos = {
          row: rcPos.row,
          col: rcPos.col
        };

        if (_pos.col === undefined) {
          // find unused col
          _pos.col = 0;

          while (used(_pos.row, _pos.col)) {
            _pos.col++;
          }
        } else if (_pos.row === undefined) {
          // find unused row
          _pos.row = 0;

          while (used(_pos.row, _pos.col)) {
            _pos.row++;
          }
        }

        id2manPos[_node.id()] = _pos;
        use(_pos.row, _pos.col);
      }
    }

    var getPos = function getPos(element, i) {
      var x, y;

      if (element.locked() || element.isParent()) {
        return false;
      } // see if we have a manual position set


      var rcPos = id2manPos[element.id()];

      if (rcPos) {
        x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;
        y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;
      } else {
        // otherwise set automatically
        while (used(row, col)) {
          moveToNextCell();
        }

        x = col * cellWidth + cellWidth / 2 + bb.x1;
        y = row * cellHeight + cellHeight / 2 + bb.y1;
        use(row, col);
        moveToNextCell();
      }

      return {
        x: x,
        y: y
      };
    };

    nodes.layoutPositions(this, options, getPos);
  }

  return this; // chaining
};

var defaults$e = {
  ready: function ready() {},
  // on layoutready
  stop: function stop() {} // on layoutstop

}; // constructor
// options : object containing layout options

function NullLayout(options) {
  this.options = extend({}, defaults$e, options);
} // runs the layout


NullLayout.prototype.run = function () {
  var options = this.options;
  var eles = options.eles; // elements to consider in the layout

  var layout = this; // cy is automatically populated for us in the constructor
  // (disable eslint for next line as this serves as example layout code to external developers)
  // eslint-disable-next-line no-unused-vars

  var cy = options.cy;
  layout.emit('layoutstart'); // puts all nodes at (0, 0)
  // n.b. most layouts would use layoutPositions(), instead of positions() and manual events

  eles.nodes().positions(function () {
    return {
      x: 0,
      y: 0
    };
  }); // trigger layoutready when each node has had its position set at least once

  layout.one('layoutready', options.ready);
  layout.emit('layoutready'); // trigger layoutstop when the layout stops (e.g. finishes)

  layout.one('layoutstop', options.stop);
  layout.emit('layoutstop');
  return this; // chaining
}; // called on continuous layouts to stop them before they finish


NullLayout.prototype.stop = function () {
  return this; // chaining
};

var defaults$f = {
  positions: undefined,
  // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: undefined,
  // the zoom level to set (prob want fit = false if set)
  pan: undefined,
  // the pan level to set (prob want fit = false if set)
  fit: true,
  // whether to fit to viewport
  padding: 30,
  // padding on fit
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts

};

function PresetLayout(options) {
  this.options = extend({}, defaults$f, options);
}

PresetLayout.prototype.run = function () {
  var options = this.options;
  var eles = options.eles;
  var nodes = eles.nodes();
  var posIsFn = fn(options.positions);

  function getPosition(node) {
    if (options.positions == null) {
      return copyPosition(node.position());
    }

    if (posIsFn) {
      return options.positions(node);
    }

    var pos = options.positions[node._private.data.id];

    if (pos == null) {
      return null;
    }

    return pos;
  }

  nodes.layoutPositions(this, options, function (node, i) {
    var position = getPosition(node);

    if (node.locked() || position == null) {
      return false;
    }

    return position;
  });
  return this; // chaining
};

var defaults$g = {
  fit: true,
  // whether to fit to viewport
  padding: 30,
  // fit padding
  boundingBox: undefined,
  // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: false,
  // whether to transition the node positions
  animationDuration: 500,
  // duration of animation in ms if enabled
  animationEasing: undefined,
  // easing of animation if enabled
  animateFilter: function animateFilter(node, i) {
    return true;
  },
  // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts
  ready: undefined,
  // callback on layoutready
  stop: undefined,
  // callback on layoutstop
  transform: function transform(node, position) {
    return position;
  } // transform a given node position. Useful for changing flow direction in discrete layouts 

};

function RandomLayout(options) {
  this.options = extend({}, defaults$g, options);
}

RandomLayout.prototype.run = function () {
  var options = this.options;
  var cy = options.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');
  var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {
    x1: 0,
    y1: 0,
    w: cy.width(),
    h: cy.height()
  });

  var getPos = function getPos(node, i) {
    return {
      x: bb.x1 + Math.round(Math.random() * bb.w),
      y: bb.y1 + Math.round(Math.random() * bb.h)
    };
  };

  nodes.layoutPositions(this, options, getPos);
  return this; // chaining
};

var layout = [{
  name: 'breadthfirst',
  impl: BreadthFirstLayout
}, {
  name: 'circle',
  impl: CircleLayout
}, {
  name: 'concentric',
  impl: ConcentricLayout
}, {
  name: 'cose',
  impl: CoseLayout
}, {
  name: 'grid',
  impl: GridLayout
}, {
  name: 'null',
  impl: NullLayout
}, {
  name: 'preset',
  impl: PresetLayout
}, {
  name: 'random',
  impl: RandomLayout
}];

function NullRenderer(options) {
  this.options = options;
  this.notifications = 0; // for testing
}

var noop$1 = function noop() {};

var throwImgErr = function throwImgErr() {
  throw new Error('A headless instance can not render images');
};

NullRenderer.prototype = {
  recalculateRenderedStyle: noop$1,
  notify: function notify() {
    this.notifications++;
  },
  init: noop$1,
  isHeadless: function isHeadless() {
    return true;
  },
  png: throwImgErr,
  jpg: throwImgErr
};

var BRp = {};
BRp.arrowShapeWidth = 0.3;

BRp.registerArrowShapes = function () {
  var arrowShapes = this.arrowShapes = {};
  var renderer = this; // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {
    var x1 = translation.x - size / 2 - padding;
    var x2 = translation.x + size / 2 + padding;
    var y1 = translation.y - size / 2 - padding;
    var y2 = translation.y + size / 2 + padding;
    var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;
    return inside;
  };

  var transform = function transform(x, y, size, angle, translation) {
    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);
    var xScaled = xRotated * size;
    var yScaled = yRotated * size;
    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;
    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  var transformPoints = function transformPoints(pts, size, angle, translation) {
    var retPts = [];

    for (var i = 0; i < pts.length; i += 2) {
      var x = pts[i];
      var y = pts[i + 1];
      retPts.push(transform(x, y, size, angle, translation));
    }

    return retPts;
  };

  var pointsToArr = function pointsToArr(pts) {
    var ret = [];

    for (var i = 0; i < pts.length; i++) {
      var p = pts[i];
      ret.push(p.x, p.y);
    }

    return ret;
  };

  var standardGap = function standardGap(edge) {
    return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;
  };

  var defineArrowShape = function defineArrowShape(name, defn) {
    if (string(defn)) {
      defn = arrowShapes[defn];
    }

    arrowShapes[name] = extend({
      name: name,
      points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],
      collide: function collide(x, y, size, angle, translation, padding) {
        var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
        var inside = pointInsidePolygonPoints(x, y, points);
        return inside;
      },
      roughCollide: bbCollide,
      draw: function draw(context, size, angle, translation) {
        var points = transformPoints(this.points, size, angle, translation);
        renderer.arrowShapeImpl('polygon')(context, points);
      },
      spacing: function spacing(edge) {
        return 0;
      },
      gap: standardGap
    }, defn);
  };

  defineArrowShape('none', {
    collide: falsify,
    roughCollide: falsify,
    draw: noop,
    spacing: zeroify,
    gap: zeroify
  });
  defineArrowShape('triangle', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3]
  });
  defineArrowShape('arrow', 'triangle');
  defineArrowShape('triangle-backcurve', {
    points: arrowShapes['triangle'].points,
    controlPoint: [0, -0.15],
    roughCollide: bbCollide,
    draw: function draw(context, size, angle, translation, edgeWidth) {
      var ptsTrans = transformPoints(this.points, size, angle, translation);
      var ctrlPt = this.controlPoint;
      var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);
      renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);
    },
    gap: function gap(edge) {
      return standardGap(edge) * 0.8;
    }
  });
  defineArrowShape('triangle-tee', {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],
    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
      var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));
      var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);
      return inside;
    },
    draw: function draw(context, size, angle, translation, edgeWidth) {
      var triPts = transformPoints(this.points, size, angle, translation);
      var teePts = transformPoints(this.pointsTee, size, angle, translation);
      renderer.arrowShapeImpl(this.name)(context, triPts, teePts);
    }
  });
  defineArrowShape('triangle-cross', {
    points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],
    baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle
    -0.15, -0.4, 0.15, -0.4, // second half of the rectangle
    0.15, -0.4],
    crossLinePts: function crossLinePts(size, edgeWidth) {
      // shift points so that the distance between the cross points matches edge width
      var p = this.baseCrossLinePts.slice();
      var shiftFactor = edgeWidth / size;
      var y0 = 3;
      var y1 = 5;
      p[y0] = p[y0] - shiftFactor;
      p[y1] = p[y1] - shiftFactor;
      return p;
    },
    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));
      var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));
      var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);
      return inside;
    },
    draw: function draw(context, size, angle, translation, edgeWidth) {
      var triPts = transformPoints(this.points, size, angle, translation);
      var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);
      renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);
    }
  });
  defineArrowShape('vee', {
    points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],
    gap: function gap(edge) {
      return standardGap(edge) * 0.525;
    }
  });
  defineArrowShape('circle', {
    radius: 0.15,
    collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {
      var t = translation;
      var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);
      return inside;
    },
    draw: function draw(context, size, angle, translation, edgeWidth) {
      renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);
    },
    spacing: function spacing(edge) {
      return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;
    }
  });
  defineArrowShape('tee', {
    points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],
    spacing: function spacing(edge) {
      return 1;
    },
    gap: function gap(edge) {
      return 1;
    }
  });
  defineArrowShape('square', {
    points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]
  });
  defineArrowShape('diamond', {
    points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],
    gap: function gap(edge) {
      return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
    }
  });
  defineArrowShape('chevron', {
    points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],
    gap: function gap(edge) {
      return 0.95 * edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;
    }
  });
};

var BRp$1 = {}; // Project mouse

BRp$1.projectIntoViewport = function (clientX, clientY) {
  var cy = this.cy;
  var offsets = this.findContainerClientCoords();
  var offsetLeft = offsets[0];
  var offsetTop = offsets[1];
  var scale = offsets[4];
  var pan = cy.pan();
  var zoom = cy.zoom();
  var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;
  var y = ((clientY - offsetTop) / scale - pan.y) / zoom;
  return [x, y];
};

BRp$1.findContainerClientCoords = function () {
  if (this.containerBB) {
    return this.containerBB;
  }

  var container = this.container;
  var rect = container.getBoundingClientRect();
  var style = window$1.getComputedStyle(container);

  var styleValue = function styleValue(name) {
    return parseFloat(style.getPropertyValue(name));
  };

  var padding = {
    left: styleValue('padding-left'),
    right: styleValue('padding-right'),
    top: styleValue('padding-top'),
    bottom: styleValue('padding-bottom')
  };
  var border = {
    left: styleValue('border-left-width'),
    right: styleValue('border-right-width'),
    top: styleValue('border-top-width'),
    bottom: styleValue('border-bottom-width')
  };
  var clientWidth = container.clientWidth;
  var clientHeight = container.clientHeight;
  var paddingHor = padding.left + padding.right;
  var paddingVer = padding.top + padding.bottom;
  var borderHor = border.left + border.right;
  var scale = rect.width / (clientWidth + borderHor);
  var unscaledW = clientWidth - paddingHor;
  var unscaledH = clientHeight - paddingVer;
  var left = rect.left + padding.left + border.left;
  var top = rect.top + padding.top + border.top;
  return this.containerBB = [left, top, unscaledW, unscaledH, scale];
};

BRp$1.invalidateContainerClientCoordsCache = function () {
  this.containerBB = null;
};

BRp$1.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {
  return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];
};

BRp$1.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {
  var self = this;
  var r = this;
  var eles = r.getCachedZSortedEles();
  var near = []; // 1 node max, 1 edge max

  var zoom = r.cy.zoom();
  var hasCompounds = r.cy.hasCompoundNodes();
  var edgeThreshold = (isTouch ? 24 : 8) / zoom;
  var nodeThreshold = (isTouch ? 8 : 2) / zoom;
  var labelThreshold = (isTouch ? 8 : 2) / zoom;
  var minSqDist = Infinity;
  var nearEdge;
  var nearNode;

  if (interactiveElementsOnly) {
    eles = eles.interactive;
  }

  function addEle(ele, sqDist) {
    if (ele.isNode()) {
      if (nearNode) {
        return; // can't replace node
      } else {
        nearNode = ele;
        near.push(ele);
      }
    }

    if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {
      if (nearEdge) {
        // then replace existing edge
        // can replace only if same z-index
        if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value && nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {
          for (var i = 0; i < near.length; i++) {
            if (near[i].isEdge()) {
              near[i] = ele;
              nearEdge = ele;
              minSqDist = sqDist != null ? sqDist : minSqDist;
              break;
            }
          }
        }
      } else {
        near.push(ele);
        nearEdge = ele;
        minSqDist = sqDist != null ? sqDist : minSqDist;
      }
    }
  }

  function checkNode(node) {
    var width = node.outerWidth() + 2 * nodeThreshold;
    var height = node.outerHeight() + 2 * nodeThreshold;
    var hw = width / 2;
    var hh = height / 2;
    var pos = node.position();

    if (pos.x - hw <= x && x <= pos.x + hw // bb check x
    && pos.y - hh <= y && y <= pos.y + hh // bb check y
    ) {
        var shape = r.nodeShapes[self.getNodeShape(node)];

        if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {
          addEle(node, 0);
          return true;
        }
      }
  }

  function checkEdge(edge) {
    var _p = edge._private;
    var rs = _p.rscratch;
    var styleWidth = edge.pstyle('width').pfValue;
    var scale = edge.pstyle('arrow-scale').value;
    var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre

    var widthSq = width * width;
    var width2 = width * 2;
    var src = _p.source;
    var tgt = _p.target;
    var sqDist;

    if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {
      var pts = rs.allpts;

      for (var i = 0; i + 3 < pts.length; i += 2) {
        if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {
          addEle(edge, sqDist);
          return true;
        }
      }
    } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
      var pts = rs.allpts;

      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
        if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {
          addEle(edge, sqDist);
          return true;
        }
      }
    } // if we're close to the edge but didn't hit it, maybe we hit its arrows


    var src = src || _p.source;
    var tgt = tgt || _p.target;
    var arSize = self.getArrowWidth(styleWidth, scale);
    var arrows = [{
      name: 'source',
      x: rs.arrowStartX,
      y: rs.arrowStartY,
      angle: rs.srcArrowAngle
    }, {
      name: 'target',
      x: rs.arrowEndX,
      y: rs.arrowEndY,
      angle: rs.tgtArrowAngle
    }, {
      name: 'mid-source',
      x: rs.midX,
      y: rs.midY,
      angle: rs.midsrcArrowAngle
    }, {
      name: 'mid-target',
      x: rs.midX,
      y: rs.midY,
      angle: rs.midtgtArrowAngle
    }];

    for (var i = 0; i < arrows.length; i++) {
      var ar = arrows[i];
      var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];
      var edgeWidth = edge.pstyle('width').pfValue;

      if (shape.roughCollide(x, y, arSize, ar.angle, {
        x: ar.x,
        y: ar.y
      }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {
        x: ar.x,
        y: ar.y
      }, edgeWidth, edgeThreshold)) {
        addEle(edge);
        return true;
      }
    } // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)


    if (hasCompounds && near.length > 0) {
      checkNode(src);
      checkNode(tgt);
    }
  }

  function preprop(obj, name, pre) {
    return getPrefixedProperty(obj, name, pre);
  }

  function checkLabel(ele, prefix) {
    var _p = ele._private;
    var th = labelThreshold;
    var prefixDash;

    if (prefix) {
      prefixDash = prefix + '-';
    } else {
      prefixDash = '';
    }

    ele.boundingBox();
    var bb = _p.labelBounds[prefix || 'main'];
    var text = ele.pstyle(prefixDash + 'label').value;
    var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';

    if (!eventsEnabled || !text) {
      return;
    }

    var rstyle = _p.rstyle;
    var lx = preprop(rstyle, 'labelX', prefix);
    var ly = preprop(rstyle, 'labelY', prefix);
    var theta = preprop(_p.rscratch, 'labelAngle', prefix);
    var lx1 = bb.x1 - th;
    var lx2 = bb.x2 + th;
    var ly1 = bb.y1 - th;
    var ly2 = bb.y2 + th;

    if (theta) {
      var cos = Math.cos(theta);
      var sin = Math.sin(theta);

      var rotate = function rotate(x, y) {
        x = x - lx;
        y = y - ly;
        return {
          x: x * cos - y * sin + lx,
          y: x * sin + y * cos + ly
        };
      };

      var px1y1 = rotate(lx1, ly1);
      var px1y2 = rotate(lx1, ly2);
      var px2y1 = rotate(lx2, ly1);
      var px2y2 = rotate(lx2, ly2);
      var points = [px1y1.x, px1y1.y, px2y1.x, px2y1.y, px2y2.x, px2y2.y, px1y2.x, px1y2.y];

      if (pointInsidePolygonPoints(x, y, points)) {
        addEle(ele);
        return true;
      }
    } else {
      // do a cheaper bb check
      if (inBoundingBox(bb, x, y)) {
        addEle(ele);
        return true;
      }
    }
  }

  for (var i = eles.length - 1; i >= 0; i--) {
    // reverse order for precedence
    var ele = eles[i];

    if (ele.isNode()) {
      checkNode(ele) || checkLabel(ele);
    } else {
      // then edge
      checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');
    }
  }

  return near;
}; // 'Give me everything from this box'


BRp$1.getAllInBox = function (x1, y1, x2, y2) {
  var eles = this.getCachedZSortedEles().interactive;
  var box = [];
  var x1c = Math.min(x1, x2);
  var x2c = Math.max(x1, x2);
  var y1c = Math.min(y1, y2);
  var y2c = Math.max(y1, y2);
  x1 = x1c;
  x2 = x2c;
  y1 = y1c;
  y2 = y2c;
  var boxBb = makeBoundingBox({
    x1: x1,
    y1: y1,
    x2: x2,
    y2: y2
  });

  for (var e = 0; e < eles.length; e++) {
    var ele = eles[e];

    if (ele.isNode()) {
      var node = ele;
      var nodeBb = node.boundingBox({
        includeNodes: true,
        includeEdges: false,
        includeLabels: false
      });

      if (boundingBoxesIntersect(boxBb, nodeBb) && !boundingBoxInBoundingBox(nodeBb, boxBb)) {
        box.push(node);
      }
    } else {
      var edge = ele;
      var _p = edge._private;
      var rs = _p.rscratch;

      if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {
        continue;
      }

      if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {
        continue;
      }

      if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {
        var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
        var allInside = true;

        for (var i = 0; i < pts.length; i++) {
          if (!pointInBoundingBox(boxBb, pts[i])) {
            allInside = false;
            break;
          }
        }

        if (allInside) {
          box.push(edge);
        }
      } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {
        box.push(edge);
      }
    }
  }

  return box;
};

var BRp$2 = {};

BRp$2.calculateArrowAngles = function (edge) {
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';
  var isBezier = rs.edgeType === 'bezier';
  var isMultibezier = rs.edgeType === 'multibezier';
  var isSegments = rs.edgeType === 'segments';
  var isCompound = rs.edgeType === 'compound';
  var isSelf = rs.edgeType === 'self'; // Displacement gives direction for arrowhead orientation

  var dispX, dispY;
  var startX, startY, endX, endY, midX, midY;

  if (isHaystack) {
    startX = rs.haystackPts[0];
    startY = rs.haystackPts[1];
    endX = rs.haystackPts[2];
    endY = rs.haystackPts[3];
  } else {
    startX = rs.arrowStartX;
    startY = rs.arrowStartY;
    endX = rs.arrowEndX;
    endY = rs.arrowEndY;
  }

  midX = rs.midX;
  midY = rs.midY; // source
  //

  if (isSegments) {
    dispX = startX - rs.segpts[0];
    dispY = startY - rs.segpts[1];
  } else if (isMultibezier || isCompound || isSelf || isBezier) {
    var pts = rs.allpts;
    var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);
    var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);
    dispX = startX - bX;
    dispY = startY - bY;
  } else {
    dispX = startX - midX;
    dispY = startY - midY;
  }

  rs.srcArrowAngle = getAngleFromDisp(dispX, dispY); // mid target
  //

  var midX = rs.midX;
  var midY = rs.midY;

  if (isHaystack) {
    midX = (startX + endX) / 2;
    midY = (startY + endY) / 2;
  }

  dispX = endX - startX;
  dispY = endY - startY;

  if (isSegments) {
    var pts = rs.allpts;

    if (pts.length / 2 % 2 === 0) {
      var i2 = pts.length / 2;
      var i1 = i2 - 2;
      dispX = pts[i2] - pts[i1];
      dispY = pts[i2 + 1] - pts[i1 + 1];
    } else {
      var i2 = pts.length / 2 - 1;
      var i1 = i2 - 2;
      var i3 = i2 + 2;
      dispX = pts[i2] - pts[i1];
      dispY = pts[i2 + 1] - pts[i1 + 1];
    }
  } else if (isMultibezier || isCompound || isSelf) {
    var pts = rs.allpts;
    var cpts = rs.ctrlpts;
    var bp0x, bp0y;
    var bp1x, bp1y;

    if (cpts.length / 2 % 2 === 0) {
      var p0 = pts.length / 2 - 1; // startpt

      var ic = p0 + 2;
      var p1 = ic + 2;
      bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);
      bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);
      bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);
      bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);
    } else {
      var ic = pts.length / 2 - 1; // ctrpt

      var p0 = ic - 2; // startpt

      var p1 = ic + 2; // endpt

      bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);
      bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);
      bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);
      bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);
    }

    dispX = bp1x - bp0x;
    dispY = bp1y - bp0y;
  }

  rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);
  rs.midDispX = dispX;
  rs.midDispY = dispY; // mid source
  //

  dispX *= -1;
  dispY *= -1;

  if (isSegments) {
    var pts = rs.allpts;

    if (pts.length / 2 % 2 === 0) ; else {
      var i2 = pts.length / 2 - 1;
      var i3 = i2 + 2;
      dispX = -(pts[i3] - pts[i2]);
      dispY = -(pts[i3 + 1] - pts[i2 + 1]);
    }
  }

  rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY); // target
  //

  if (isSegments) {
    dispX = endX - rs.segpts[rs.segpts.length - 2];
    dispY = endY - rs.segpts[rs.segpts.length - 1];
  } else if (isMultibezier || isCompound || isSelf || isBezier) {
    var pts = rs.allpts;
    var l = pts.length;
    var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);
    var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);
    dispX = endX - bX;
    dispY = endY - bY;
  } else {
    dispX = endX - midX;
    dispY = endY - midY;
  }

  rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);
};

BRp$2.getArrowWidth = BRp$2.getArrowHeight = function (edgeWidth, scale) {
  var cache = this.arrowWidthCache = this.arrowWidthCache || {};
  var cachedVal = cache[edgeWidth + ', ' + scale];

  if (cachedVal) {
    return cachedVal;
  }

  cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;
  cache[edgeWidth + ', ' + scale] = cachedVal;
  return cachedVal;
};

var BRp$3 = {};

BRp$3.findHaystackPoints = function (edges) {
  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var _p = edge._private;
    var rs = _p.rscratch;

    if (!rs.haystack) {
      var angle = Math.random() * 2 * Math.PI;
      rs.source = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };
      angle = Math.random() * 2 * Math.PI;
      rs.target = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };
    }

    var src = _p.source;
    var tgt = _p.target;
    var srcPos = src.position();
    var tgtPos = tgt.position();
    var srcW = src.width();
    var tgtW = tgt.width();
    var srcH = src.height();
    var tgtH = tgt.height();
    var radius = edge.pstyle('haystack-radius').value;
    var halfRadius = radius / 2; // b/c have to half width/height

    rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];
    rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;
    rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2; // always override as haystack in case set to different type previously

    rs.edgeType = 'haystack';
    rs.haystack = true;
    this.storeEdgeProjections(edge);
    this.calculateArrowAngles(edge);
    this.recalculateEdgeLabelProjections(edge);
    this.calculateLabelAngles(edge);
  }
};

BRp$3.findSegmentsPoints = function (edge, pairInfo) {
  // Segments (multiple straight lines)
  var rs = edge._private.rscratch;
  var posPts = pairInfo.posPts,
      intersectionPts = pairInfo.intersectionPts,
      vectorNormInverse = pairInfo.vectorNormInverse;
  var edgeDistances = edge.pstyle('edge-distances').value;
  var segmentWs = edge.pstyle('segment-weights');
  var segmentDs = edge.pstyle('segment-distances');
  var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);
  rs.edgeType = 'segments';
  rs.segpts = [];

  for (var s = 0; s < segmentsN; s++) {
    var w = segmentWs.pfValue[s];
    var d = segmentDs.pfValue[s];
    var w1 = 1 - w;
    var w2 = w;
    var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;
    var adjustedMidpt = {
      x: midptPts.x1 * w1 + midptPts.x2 * w2,
      y: midptPts.y1 * w1 + midptPts.y2 * w2
    };
    rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);
  }
};

BRp$3.findLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {
  // Self-edge
  var rs = edge._private.rscratch;
  var dirCounts = pairInfo.dirCounts,
      srcPos = pairInfo.srcPos;
  var ctrlptDists = edge.pstyle('control-point-distances');
  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
  var loopDir = edge.pstyle('loop-direction').pfValue;
  var loopSwp = edge.pstyle('loop-sweep').pfValue;
  var stepSize = edge.pstyle('control-point-step-size').pfValue;
  rs.edgeType = 'self';
  var j = i;
  var loopDist = stepSize;

  if (edgeIsUnbundled) {
    j = 0;
    loopDist = ctrlptDist;
  }

  var loopAngle = loopDir - Math.PI / 2;
  var outAngle = loopAngle - loopSwp / 2;
  var inAngle = loopAngle + loopSwp / 2; // increase by step size for overlapping loops, keyed on direction and sweep values

  var dc = String(loopDir + '_' + loopSwp);
  j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];
  rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];
};

BRp$3.findCompoundLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {
  // Compound edge
  var rs = edge._private.rscratch;
  rs.edgeType = 'compound';
  var srcPos = pairInfo.srcPos,
      tgtPos = pairInfo.tgtPos,
      srcW = pairInfo.srcW,
      srcH = pairInfo.srcH,
      tgtW = pairInfo.tgtW,
      tgtH = pairInfo.tgtH;
  var stepSize = edge.pstyle('control-point-step-size').pfValue;
  var ctrlptDists = edge.pstyle('control-point-distances');
  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
  var j = i;
  var loopDist = stepSize;

  if (edgeIsUnbundled) {
    j = 0;
    loopDist = ctrlptDist;
  }

  var loopW = 50;
  var loopaPos = {
    x: srcPos.x - srcW / 2,
    y: srcPos.y - srcH / 2
  };
  var loopbPos = {
    x: tgtPos.x - tgtW / 2,
    y: tgtPos.y - tgtH / 2
  };
  var loopPos = {
    x: Math.min(loopaPos.x, loopbPos.x),
    y: Math.min(loopaPos.y, loopbPos.y)
  }; // avoids cases with impossible beziers

  var minCompoundStretch = 0.5;
  var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));
  var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));
  rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];
};

BRp$3.findStraightEdgePoints = function (edge) {
  // Straight edge within bundle
  edge._private.rscratch.edgeType = 'straight';
};

BRp$3.findBezierPoints = function (edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {
  var rs = edge._private.rscratch;
  var vectorNormInverse = pairInfo.vectorNormInverse,
      posPts = pairInfo.posPts,
      intersectionPts = pairInfo.intersectionPts;
  var edgeDistances = edge.pstyle('edge-distances').value;
  var stepSize = edge.pstyle('control-point-step-size').pfValue;
  var ctrlptDists = edge.pstyle('control-point-distances');
  var ctrlptWs = edge.pstyle('control-point-weights');
  var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;
  var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;
  var ctrlptWeight = ctrlptWs.value[0]; // (Multi)bezier

  var multi = edgeIsUnbundled;
  rs.edgeType = multi ? 'multibezier' : 'bezier';
  rs.ctrlpts = [];

  for (var b = 0; b < bezierN; b++) {
    var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);
    var manctrlptDist = void 0;
    var sign = signum(normctrlptDist);

    if (multi) {
      ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size

      ctrlptWeight = ctrlptWs.value[b];
    }

    if (edgeIsUnbundled) {
      // multi or single unbundled
      manctrlptDist = ctrlptDist;
    } else {
      manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
    }

    var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;
    var w1 = 1 - ctrlptWeight;
    var w2 = ctrlptWeight;
    var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;
    var adjustedMidpt = {
      x: midptPts.x1 * w1 + midptPts.x2 * w2,
      y: midptPts.y1 * w1 + midptPts.y2 * w2
    };
    rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);
  }
};

BRp$3.findTaxiPoints = function (edge, pairInfo) {
  // Taxicab geometry with two turns maximum
  var rs = edge._private.rscratch;
  rs.edgeType = 'segments';
  var VERTICAL = 'vertical';
  var HORIZONTAL = 'horizontal';
  var LEFTWARD = 'leftward';
  var RIGHTWARD = 'rightward';
  var DOWNWARD = 'downward';
  var UPWARD = 'upward';
  var AUTO = 'auto';
  var posPts = pairInfo.posPts,
      srcW = pairInfo.srcW,
      srcH = pairInfo.srcH,
      tgtW = pairInfo.tgtW,
      tgtH = pairInfo.tgtH;
  var edgeDistances = edge.pstyle('edge-distances').value;
  var dIncludesNodeBody = edgeDistances !== 'node-position';
  var taxiDir = edge.pstyle('taxi-direction').value;
  var rawTaxiDir = taxiDir; // unprocessed value

  var taxiTurn = edge.pstyle('taxi-turn');
  var taxiTurnPfVal = taxiTurn.pfValue;
  var minD = edge.pstyle('taxi-turn-min-distance').pfValue;
  var turnIsPercent = taxiTurn.units === '%';
  var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;
  var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;
  var pdx = posPts.x2 - posPts.x1;
  var pdy = posPts.y2 - posPts.y1; // take away the effective w/h from the magnitude of the delta value

  var subDWH = function subDWH(dxy, dwh) {
    if (dxy > 0) {
      return Math.max(dxy - dwh, 0);
    } else {
      return Math.min(dxy + dwh, 0);
    }
  };

  var dx = subDWH(pdx, dw);
  var dy = subDWH(pdy, dh);
  var isExplicitDir = false;

  if (taxiDir === AUTO) {
    taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;
  } else if (taxiDir === UPWARD || taxiDir === DOWNWARD) {
    taxiDir = VERTICAL;
    isExplicitDir = true;
  } else if (taxiDir === LEFTWARD || taxiDir === RIGHTWARD) {
    taxiDir = HORIZONTAL;
    isExplicitDir = true;
  }

  var isVert = taxiDir === VERTICAL;
  var l = isVert ? dy : dx;
  var pl = isVert ? pdy : pdx;
  var sgnL = signum(pl);
  var forcedDir = false;

  if (!(isExplicitDir && turnIsPercent) // forcing in this case would cause weird growing in the opposite direction
  && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {
    sgnL *= -1;
    l = sgnL * Math.abs(l);
    forcedDir = true;
  }

  var d = turnIsPercent ? taxiTurnPfVal * l : taxiTurnPfVal * sgnL;

  var getIsTooClose = function getIsTooClose(d) {
    return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);
  };

  var isTooCloseSrc = getIsTooClose(d);
  var isTooCloseTgt = getIsTooClose(l - d);
  var isTooClose = isTooCloseSrc || isTooCloseTgt;

  if (isTooClose && !forcedDir) {
    // non-ideal routing
    if (isVert) {
      // vertical fallbacks
      var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;
      var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;

      if (lShapeInsideSrc) {
        // horizontal Z-shape (direction not respected)
        var x = (posPts.x1 + posPts.x2) / 2;
        var y1 = posPts.y1,
            y2 = posPts.y2;
        rs.segpts = [x, y1, x, y2];
      } else if (lShapeInsideTgt) {
        // vertical Z-shape (distance not respected)
        var y = (posPts.y1 + posPts.y2) / 2;
        var x1 = posPts.x1,
            x2 = posPts.x2;
        rs.segpts = [x1, y, x2, y];
      } else {
        // L-shape fallback (turn distance not respected, but works well with tree siblings)
        rs.segpts = [posPts.x1, posPts.y2];
      }
    } else {
      // horizontal fallbacks
      var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;

      var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;

      if (_lShapeInsideSrc) {
        // vertical Z-shape (direction not respected)
        var _y = (posPts.y1 + posPts.y2) / 2;

        var _x = posPts.x1,
            _x2 = posPts.x2;
        rs.segpts = [_x, _y, _x2, _y];
      } else if (_lShapeInsideTgt) {
        // horizontal Z-shape (turn distance not respected)
        var _x3 = (posPts.x1 + posPts.x2) / 2;

        var _y2 = posPts.y1,
            _y3 = posPts.y2;
        rs.segpts = [_x3, _y2, _x3, _y3];
      } else {
        // L-shape (turn distance not respected, but works well for tree siblings)
        rs.segpts = [posPts.x2, posPts.y1];
      }
    }
  } else {
    // ideal routing
    if (isVert) {
      var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);

      var _x4 = posPts.x1,
          _x5 = posPts.x2;
      rs.segpts = [_x4, _y4, _x5, _y4];
    } else {
      // horizontal
      var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);

      var _y5 = posPts.y1,
          _y6 = posPts.y2;
      rs.segpts = [_x6, _y5, _x6, _y6];
    }
  }
};

BRp$3.tryToCorrectInvalidPoints = function (edge, pairInfo) {
  var rs = edge._private.rscratch; // can only correct beziers for now...

  if (rs.edgeType === 'bezier') {
    var srcPos = pairInfo.srcPos,
        tgtPos = pairInfo.tgtPos,
        srcW = pairInfo.srcW,
        srcH = pairInfo.srcH,
        tgtW = pairInfo.tgtW,
        tgtH = pairInfo.tgtH,
        srcShape = pairInfo.srcShape,
        tgtShape = pairInfo.tgtShape;
    var badStart = !number(rs.startX) || !number(rs.startY);
    var badAStart = !number(rs.arrowStartX) || !number(rs.arrowStartY);
    var badEnd = !number(rs.endX) || !number(rs.endY);
    var badAEnd = !number(rs.arrowEndX) || !number(rs.arrowEndY);
    var minCpADistFactor = 3;
    var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
    var minCpADist = minCpADistFactor * arrowW;
    var startACpDist = dist({
      x: rs.ctrlpts[0],
      y: rs.ctrlpts[1]
    }, {
      x: rs.startX,
      y: rs.startY
    });
    var closeStartACp = startACpDist < minCpADist;
    var endACpDist = dist({
      x: rs.ctrlpts[0],
      y: rs.ctrlpts[1]
    }, {
      x: rs.endX,
      y: rs.endY
    });
    var closeEndACp = endACpDist < minCpADist;
    var overlapping = false;

    if (badStart || badAStart || closeStartACp) {
      overlapping = true; // project control point along line from src centre to outside the src shape
      // (otherwise intersection will yield nothing)

      var cpD = {
        // delta
        x: rs.ctrlpts[0] - srcPos.x,
        y: rs.ctrlpts[1] - srcPos.y
      };
      var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line

      var cpM = {
        // normalised delta
        x: cpD.x / cpL,
        y: cpD.y / cpL
      };
      var radius = Math.max(srcW, srcH);
      var cpProj = {
        // *2 radius guarantees outside shape
        x: rs.ctrlpts[0] + cpM.x * 2 * radius,
        y: rs.ctrlpts[1] + cpM.y * 2 * radius
      };
      var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);

      if (closeStartACp) {
        rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
        rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
      } else {
        rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
        rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
      }
    }

    if (badEnd || badAEnd || closeEndACp) {
      overlapping = true; // project control point along line from tgt centre to outside the tgt shape
      // (otherwise intersection will yield nothing)

      var _cpD = {
        // delta
        x: rs.ctrlpts[0] - tgtPos.x,
        y: rs.ctrlpts[1] - tgtPos.y
      };

      var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line


      var _cpM = {
        // normalised delta
        x: _cpD.x / _cpL,
        y: _cpD.y / _cpL
      };

      var _radius = Math.max(srcW, srcH);

      var _cpProj = {
        // *2 radius guarantees outside shape
        x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,
        y: rs.ctrlpts[1] + _cpM.y * 2 * _radius
      };
      var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0);

      if (closeEndACp) {
        rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);
        rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);
      } else {
        rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;
        rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;
      }
    }

    if (overlapping) {
      // recalc endpts
      this.findEndpoints(edge);
    }
  }
};

BRp$3.storeAllpts = function (edge) {
  var rs = edge._private.rscratch;

  if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {
    rs.allpts = [];
    rs.allpts.push(rs.startX, rs.startY);

    for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {
      // ctrl pt itself
      rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]); // the midpt between ctrlpts as intermediate destination pts

      if (b + 3 < rs.ctrlpts.length) {
        rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);
      }
    }

    rs.allpts.push(rs.endX, rs.endY);
    var m, mt;

    if (rs.ctrlpts.length / 2 % 2 === 0) {
      m = rs.allpts.length / 2 - 1;
      rs.midX = rs.allpts[m];
      rs.midY = rs.allpts[m + 1];
    } else {
      m = rs.allpts.length / 2 - 3;
      mt = 0.5;
      rs.midX = qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);
      rs.midY = qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);
    }
  } else if (rs.edgeType === 'straight') {
    // need to calc these after endpts
    rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY]; // default midpt for labels etc

    rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;
    rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;
  } else if (rs.edgeType === 'segments') {
    rs.allpts = [];
    rs.allpts.push(rs.startX, rs.startY);
    rs.allpts.push.apply(rs.allpts, rs.segpts);
    rs.allpts.push(rs.endX, rs.endY);

    if (rs.segpts.length % 4 === 0) {
      var i2 = rs.segpts.length / 2;
      var i1 = i2 - 2;
      rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;
      rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;
    } else {
      var _i = rs.segpts.length / 2 - 1;

      rs.midX = rs.segpts[_i];
      rs.midY = rs.segpts[_i + 1];
    }
  }
};

BRp$3.checkForInvalidEdgeWarning = function (edge) {
  var rs = edge[0]._private.rscratch;

  if (rs.nodesOverlap || number(rs.startX) && number(rs.startY) && number(rs.endX) && number(rs.endY)) {
    rs.loggedErr = false;
  } else {
    if (!rs.loggedErr) {
      rs.loggedErr = true;
      warn('Edge `' + edge.id() + '` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.');
    }
  }
};

BRp$3.findEdgeControlPoints = function (edges) {
  var _this = this;

  if (!edges || edges.length === 0) {
    return;
  }

  var r = this;
  var cy = r.cy;
  var hasCompounds = cy.hasCompoundNodes();
  var hashTable = {
    map: new Map$1(),
    get: function get(pairId) {
      var map2 = this.map.get(pairId[0]);

      if (map2 != null) {
        return map2.get(pairId[1]);
      } else {
        return null;
      }
    },
    set: function set(pairId, val) {
      var map2 = this.map.get(pairId[0]);

      if (map2 == null) {
        map2 = new Map$1();
        this.map.set(pairId[0], map2);
      }

      map2.set(pairId[1], val);
    }
  };
  var pairIds = [];
  var haystackEdges = []; // create a table of edge (src, tgt) => list of edges between them

  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var _p = edge._private;
    var curveStyle = edge.pstyle('curve-style').value; // ignore edges who are not to be displayed
    // they shouldn't take up space

    if (edge.removed() || !edge.takesUpSpace()) {
      continue;
    }

    if (curveStyle === 'haystack') {
      haystackEdges.push(edge);
      continue;
    }

    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'straight' || curveStyle === 'taxi';
    var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';
    var src = _p.source;
    var tgt = _p.target;
    var srcIndex = src.poolIndex();
    var tgtIndex = tgt.poolIndex();
    var pairId = [srcIndex, tgtIndex].sort();
    var tableEntry = hashTable.get(pairId);

    if (tableEntry == null) {
      tableEntry = {
        eles: []
      };
      hashTable.set(pairId, tableEntry);
      pairIds.push(pairId);
    }

    tableEntry.eles.push(edge);

    if (edgeIsUnbundled) {
      tableEntry.hasUnbundled = true;
    }

    if (edgeIsBezier) {
      tableEntry.hasBezier = true;
    }
  } // for each pair (src, tgt), create the ctrl pts
  // Nested for loop is OK; total number of iterations for both loops = edgeCount


  var _loop = function _loop(p) {
    var pairId = pairIds[p];
    var pairInfo = hashTable.get(pairId);
    var swappedpairInfo = void 0;

    if (!pairInfo.hasUnbundled) {
      var pllEdges = pairInfo.eles[0].parallelEdges().filter(function (e) {
        return e.isBundledBezier();
      });
      clearArray(pairInfo.eles);
      pllEdges.forEach(function (edge) {
        return pairInfo.eles.push(edge);
      }); // for each pair id, the edges should be sorted by index

      pairInfo.eles.sort(function (edge1, edge2) {
        return edge1.poolIndex() - edge2.poolIndex();
      });
    }

    var firstEdge = pairInfo.eles[0];
    var src = firstEdge.source();
    var tgt = firstEdge.target(); // make sure src/tgt distinction is consistent w.r.t. pairId

    if (src.poolIndex() > tgt.poolIndex()) {
      var temp = src;
      src = tgt;
      tgt = temp;
    }

    var srcPos = pairInfo.srcPos = src.position();
    var tgtPos = pairInfo.tgtPos = tgt.position();
    var srcW = pairInfo.srcW = src.outerWidth();
    var srcH = pairInfo.srcH = src.outerHeight();
    var tgtW = pairInfo.tgtW = tgt.outerWidth();
    var tgtH = pairInfo.tgtH = tgt.outerHeight();

    var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];

    var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];

    pairInfo.dirCounts = {
      'north': 0,
      'west': 0,
      'south': 0,
      'east': 0,
      'northwest': 0,
      'southwest': 0,
      'northeast': 0,
      'southeast': 0
    };

    for (var _i2 = 0; _i2 < pairInfo.eles.length; _i2++) {
      var _edge = pairInfo.eles[_i2];
      var rs = _edge[0]._private.rscratch;

      var _curveStyle = _edge.pstyle('curve-style').value;

      var _edgeIsUnbundled = _curveStyle === 'unbundled-bezier' || _curveStyle === 'segments' || _curveStyle === 'taxi'; // whether the normalised pair order is the reverse of the edge's src-tgt order


      var edgeIsSwapped = !src.same(_edge.source());

      if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {
        pairInfo.calculatedIntersection = true; // pt outside src shape to calc distance/displacement from src to tgt

        var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);
        var srcIntn = pairInfo.srcIntn = srcOutside; // pt outside tgt shape to calc distance/displacement from src to tgt

        var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);
        var tgtIntn = pairInfo.tgtIntn = tgtOutside;
        var intersectionPts = pairInfo.intersectionPts = {
          x1: srcOutside[0],
          x2: tgtOutside[0],
          y1: srcOutside[1],
          y2: tgtOutside[1]
        };
        var posPts = pairInfo.posPts = {
          x1: srcPos.x,
          x2: tgtPos.x,
          y1: srcPos.y,
          y2: tgtPos.y
        };
        var dy = tgtOutside[1] - srcOutside[1];
        var dx = tgtOutside[0] - srcOutside[0];
        var l = Math.sqrt(dx * dx + dy * dy);
        var vector = pairInfo.vector = {
          x: dx,
          y: dy
        };
        var vectorNorm = pairInfo.vectorNorm = {
          x: vector.x / l,
          y: vector.y / l
        };
        var vectorNormInverse = {
          x: -vectorNorm.y,
          y: vectorNorm.x
        }; // if node shapes overlap, then no ctrl pts to draw

        pairInfo.nodesOverlap = !number(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y);
        pairInfo.vectorNormInverse = vectorNormInverse;
        swappedpairInfo = {
          nodesOverlap: pairInfo.nodesOverlap,
          dirCounts: pairInfo.dirCounts,
          calculatedIntersection: true,
          hasBezier: pairInfo.hasBezier,
          hasUnbundled: pairInfo.hasUnbundled,
          eles: pairInfo.eles,
          srcPos: tgtPos,
          tgtPos: srcPos,
          srcW: tgtW,
          srcH: tgtH,
          tgtW: srcW,
          tgtH: srcH,
          srcIntn: tgtIntn,
          tgtIntn: srcIntn,
          srcShape: tgtShape,
          tgtShape: srcShape,
          posPts: {
            x1: posPts.x2,
            y1: posPts.y2,
            x2: posPts.x1,
            y2: posPts.y1
          },
          intersectionPts: {
            x1: intersectionPts.x2,
            y1: intersectionPts.y2,
            x2: intersectionPts.x1,
            y2: intersectionPts.y1
          },
          vector: {
            x: -vector.x,
            y: -vector.y
          },
          vectorNorm: {
            x: -vectorNorm.x,
            y: -vectorNorm.y
          },
          vectorNormInverse: {
            x: -vectorNormInverse.x,
            y: -vectorNormInverse.y
          }
        };
      }

      var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;
      rs.nodesOverlap = passedPairInfo.nodesOverlap;
      rs.srcIntn = passedPairInfo.srcIntn;
      rs.tgtIntn = passedPairInfo.tgtIntn;

      if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {
        _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
      } else if (src === tgt) {
        _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);
      } else if (_curveStyle === 'segments') {
        _this.findSegmentsPoints(_edge, passedPairInfo);
      } else if (_curveStyle === 'taxi') {
        _this.findTaxiPoints(_edge, passedPairInfo);
      } else if (_curveStyle === 'straight' || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {
        _this.findStraightEdgePoints(_edge);
      } else {
        _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);
      }

      _this.findEndpoints(_edge);

      _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);

      _this.checkForInvalidEdgeWarning(_edge);

      _this.storeAllpts(_edge);

      _this.storeEdgeProjections(_edge);

      _this.calculateArrowAngles(_edge);

      _this.recalculateEdgeLabelProjections(_edge);

      _this.calculateLabelAngles(_edge);
    } // for pair edges

  };

  for (var p = 0; p < pairIds.length; p++) {
    _loop(p);
  } // for pair ids
  // haystacks avoid the expense of pairInfo stuff (intersections etc.)


  this.findHaystackPoints(haystackEdges);
};

function getPts(pts) {
  var retPts = [];

  if (pts == null) {
    return;
  }

  for (var i = 0; i < pts.length; i += 2) {
    var x = pts[i];
    var y = pts[i + 1];
    retPts.push({
      x: x,
      y: y
    });
  }

  return retPts;
}

BRp$3.getSegmentPoints = function (edge) {
  var rs = edge[0]._private.rscratch;
  var type = rs.edgeType;

  if (type === 'segments') {
    this.recalculateRenderedStyle(edge);
    return getPts(rs.segpts);
  }
};

BRp$3.getControlPoints = function (edge) {
  var rs = edge[0]._private.rscratch;
  var type = rs.edgeType;

  if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {
    this.recalculateRenderedStyle(edge);
    return getPts(rs.ctrlpts);
  }
};

BRp$3.getEdgeMidpoint = function (edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);
  return {
    x: rs.midX,
    y: rs.midY
  };
};

var BRp$4 = {};

BRp$4.manualEndptToPx = function (node, prop) {
  var r = this;
  var npos = node.position();
  var w = node.outerWidth();
  var h = node.outerHeight();

  if (prop.value.length === 2) {
    var p = [prop.pfValue[0], prop.pfValue[1]];

    if (prop.units[0] === '%') {
      p[0] = p[0] * w;
    }

    if (prop.units[1] === '%') {
      p[1] = p[1] * h;
    }

    p[0] += npos.x;
    p[1] += npos.y;
    return p;
  } else {
    var angle = prop.pfValue[0];
    angle = -Math.PI / 2 + angle; // start at 12 o'clock

    var l = 2 * Math.max(w, h);
    var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];
    return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);
  }
};

BRp$4.findEndpoints = function (edge) {
  var r = this;
  var intersect;
  var source = edge.source()[0];
  var target = edge.target()[0];
  var srcPos = source.position();
  var tgtPos = target.position();
  var tgtArShape = edge.pstyle('target-arrow-shape').value;
  var srcArShape = edge.pstyle('source-arrow-shape').value;
  var tgtDist = edge.pstyle('target-distance-from-node').pfValue;
  var srcDist = edge.pstyle('source-distance-from-node').pfValue;
  var curveStyle = edge.pstyle('curve-style').value;
  var rs = edge._private.rscratch;
  var et = rs.edgeType;
  var taxi = curveStyle === 'taxi';
  var self = et === 'self' || et === 'compound';
  var bezier = et === 'bezier' || et === 'multibezier' || self;
  var multi = et !== 'bezier';
  var lines = et === 'straight' || et === 'segments';
  var segments = et === 'segments';
  var hasEndpts = bezier || multi || lines;
  var overrideEndpts = self || taxi;
  var srcManEndpt = edge.pstyle('source-endpoint');
  var srcManEndptVal = overrideEndpts ? 'outside-to-node' : srcManEndpt.value;
  var tgtManEndpt = edge.pstyle('target-endpoint');
  var tgtManEndptVal = overrideEndpts ? 'outside-to-node' : tgtManEndpt.value;
  rs.srcManEndpt = srcManEndpt;
  rs.tgtManEndpt = tgtManEndpt;
  var p1; // last known point of edge on target side

  var p2; // last known point of edge on source side

  var p1_i; // point to intersect with target shape

  var p2_i; // point to intersect with source shape

  if (bezier) {
    var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];
    var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;
    p1 = cpEnd;
    p2 = cpStart;
  } else if (lines) {
    var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);
    var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);
    p1 = tgtArrowFromPt;
    p2 = srcArrowFromPt;
  }

  if (tgtManEndptVal === 'inside-to-node') {
    intersect = [tgtPos.x, tgtPos.y];
  } else if (tgtManEndpt.units) {
    intersect = this.manualEndptToPx(target, tgtManEndpt);
  } else if (tgtManEndptVal === 'outside-to-line') {
    intersect = rs.tgtIntn; // use cached value from ctrlpt calc
  } else {
    if (tgtManEndptVal === 'outside-to-node' || tgtManEndptVal === 'outside-to-node-or-label') {
      p1_i = p1;
    } else if (tgtManEndptVal === 'outside-to-line' || tgtManEndptVal === 'outside-to-line-or-label') {
      p1_i = [srcPos.x, srcPos.y];
    }

    intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);

    if (tgtManEndptVal === 'outside-to-node-or-label' || tgtManEndptVal === 'outside-to-line-or-label') {
      var trs = target._private.rscratch;
      var lw = trs.labelWidth;
      var lh = trs.labelHeight;
      var lx = trs.labelX;
      var ly = trs.labelY;
      var va = target.pstyle('text-valign').value;

      if (va === 'top') {
        ly -= lh / 2;
      } else if (va === 'bottom') {
        ly += lh / 2;
      }

      var ha = target.pstyle('text-halign').value;

      if (ha === 'left') {
        lx -= lw / 2;
      } else if (ha === 'right') {
        lx += lw / 2;
      }

      var labelIntersect = r.nodeShapes['rectangle'].intersectLine(lx, ly, lw, lh, p1_i[0], p1_i[1], 0);
      var refPt = srcPos;
      var intSqdist = sqdist(refPt, array2point(intersect));
      var labIntSqdist = sqdist(refPt, array2point(labelIntersect));

      if (labIntSqdist < intSqdist) {
        intersect = labelIntersect;
      }
    }
  }

  var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);
  var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);
  rs.endX = edgeEnd[0];
  rs.endY = edgeEnd[1];
  rs.arrowEndX = arrowEnd[0];
  rs.arrowEndY = arrowEnd[1];

  if (srcManEndptVal === 'inside-to-node') {
    intersect = [srcPos.x, srcPos.y];
  } else if (srcManEndpt.units) {
    intersect = this.manualEndptToPx(source, srcManEndpt);
  } else if (srcManEndptVal === 'outside-to-line') {
    intersect = rs.srcIntn; // use cached value from ctrlpt calc
  } else {
    if (srcManEndptVal === 'outside-to-node' || srcManEndptVal === 'outside-to-node-or-label') {
      p2_i = p2;
    } else if (srcManEndptVal === 'outside-to-line' || srcManEndptVal === 'outside-to-line-or-label') {
      p2_i = [tgtPos.x, tgtPos.y];
    }

    intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);

    if (srcManEndptVal === 'outside-to-node-or-label' || srcManEndptVal === 'outside-to-line-or-label') {
      var srs = source._private.rscratch;
      var _lw = srs.labelWidth;
      var _lh = srs.labelHeight;
      var _lx = srs.labelX;
      var _ly = srs.labelY;
      var _va = source.pstyle('text-valign').value;

      if (_va === 'top') {
        _ly -= _lh / 2;
      } else if (_va === 'bottom') {
        _ly += _lh / 2;
      }

      var _ha = source.pstyle('text-halign').value;

      if (_ha === 'left') {
        _lx -= _lw / 2;
      } else if (_ha === 'right') {
        _lx += _lw / 2;
      }

      var _labelIntersect = r.nodeShapes['rectangle'].intersectLine(_lx, _ly, _lw, _lh, p2_i[0], p2_i[1], 0);

      var _refPt = tgtPos;

      var _intSqdist = sqdist(_refPt, array2point(intersect));

      var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));

      if (_labIntSqdist < _intSqdist) {
        intersect = _labelIntersect;
      }
    }
  }

  var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);
  var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);
  rs.startX = edgeStart[0];
  rs.startY = edgeStart[1];
  rs.arrowStartX = arrowStart[0];
  rs.arrowStartY = arrowStart[1];

  if (hasEndpts) {
    if (!number(rs.startX) || !number(rs.startY) || !number(rs.endX) || !number(rs.endY)) {
      rs.badLine = true;
    } else {
      rs.badLine = false;
    }
  }
};

BRp$4.getSourceEndpoint = function (edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);

  switch (rs.edgeType) {
    case 'haystack':
      return {
        x: rs.haystackPts[0],
        y: rs.haystackPts[1]
      };

    default:
      return {
        x: rs.arrowStartX,
        y: rs.arrowStartY
      };
  }
};

BRp$4.getTargetEndpoint = function (edge) {
  var rs = edge[0]._private.rscratch;
  this.recalculateRenderedStyle(edge);

  switch (rs.edgeType) {
    case 'haystack':
      return {
        x: rs.haystackPts[2],
        y: rs.haystackPts[3]
      };

    default:
      return {
        x: rs.arrowEndX,
        y: rs.arrowEndY
      };
  }
};

var BRp$5 = {};

function pushBezierPts(r, edge, pts) {
  var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {
    return qbezierAt(p1, p2, p3, t);
  };

  var _p = edge._private;
  var bpts = _p.rstyle.bezierPts;

  for (var i = 0; i < r.bezierProjPcts.length; i++) {
    var p = r.bezierProjPcts[i];
    bpts.push({
      x: qbezierAt$1(pts[0], pts[2], pts[4], p),
      y: qbezierAt$1(pts[1], pts[3], pts[5], p)
    });
  }
}

BRp$5.storeEdgeProjections = function (edge) {
  var _p = edge._private;
  var rs = _p.rscratch;
  var et = rs.edgeType; // clear the cached points state

  _p.rstyle.bezierPts = null;
  _p.rstyle.linePts = null;
  _p.rstyle.haystackPts = null;

  if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {
    _p.rstyle.bezierPts = [];

    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
      pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));
    }
  } else if (et === 'segments') {
    var lpts = _p.rstyle.linePts = [];

    for (var i = 0; i + 1 < rs.allpts.length; i += 2) {
      lpts.push({
        x: rs.allpts[i],
        y: rs.allpts[i + 1]
      });
    }
  } else if (et === 'haystack') {
    var hpts = rs.haystackPts;
    _p.rstyle.haystackPts = [{
      x: hpts[0],
      y: hpts[1]
    }, {
      x: hpts[2],
      y: hpts[3]
    }];
  }

  _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;
};

BRp$5.recalculateEdgeProjections = function (edges) {
  this.findEdgeControlPoints(edges);
};

var BRp$6 = {};

BRp$6.recalculateNodeLabelProjection = function (node) {
  var content = node.pstyle('label').strValue;

  if (emptyString(content)) {
    return;
  }

  var textX, textY;
  var _p = node._private;
  var nodeWidth = node.width();
  var nodeHeight = node.height();
  var padding = node.padding();
  var nodePos = node.position();
  var textHalign = node.pstyle('text-halign').strValue;
  var textValign = node.pstyle('text-valign').strValue;
  var rs = _p.rscratch;
  var rstyle = _p.rstyle;

  switch (textHalign) {
    case 'left':
      textX = nodePos.x - nodeWidth / 2 - padding;
      break;

    case 'right':
      textX = nodePos.x + nodeWidth / 2 + padding;
      break;

    default:
      // e.g. center
      textX = nodePos.x;
  }

  switch (textValign) {
    case 'top':
      textY = nodePos.y - nodeHeight / 2 - padding;
      break;

    case 'bottom':
      textY = nodePos.y + nodeHeight / 2 + padding;
      break;

    default:
      // e.g. middle
      textY = nodePos.y;
  }

  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;
  this.applyLabelDimensions(node);
};

var lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {
  var angle = Math.atan(dy / dx);

  if (dx === 0 && angle < 0) {
    angle = angle * -1;
  }

  return angle;
};

var lineAngle = function lineAngle(p0, p1) {
  var dx = p1.x - p0.x;
  var dy = p1.y - p0.y;
  return lineAngleFromDelta(dx, dy);
};

var bezierAngle = function bezierAngle(p0, p1, p2, t) {
  var t0 = bound(0, t - 0.001, 1);
  var t1 = bound(0, t + 0.001, 1);
  var lp0 = qbezierPtAt(p0, p1, p2, t0);
  var lp1 = qbezierPtAt(p0, p1, p2, t1);
  return lineAngle(lp0, lp1);
};

BRp$6.recalculateEdgeLabelProjections = function (edge) {
  var p;
  var _p = edge._private;
  var rs = _p.rscratch;
  var r = this;
  var content = {
    mid: edge.pstyle('label').strValue,
    source: edge.pstyle('source-label').strValue,
    target: edge.pstyle('target-label').strValue
  };

  if (content.mid || content.source || content.target) ; else {
      return; // no labels => no calcs
    } // add center point to style so bounding box calculations can use it
  //


  p = {
    x: rs.midX,
    y: rs.midY
  };

  var setRs = function setRs(propName, prefix, value) {
    setPrefixedProperty(_p.rscratch, propName, prefix, value);
    setPrefixedProperty(_p.rstyle, propName, prefix, value);
  };

  setRs('labelX', null, p.x);
  setRs('labelY', null, p.y);
  var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);
  setRs('labelAutoAngle', null, midAngle);

  var createControlPointInfo = function createControlPointInfo() {
    if (createControlPointInfo.cache) {
      return createControlPointInfo.cache;
    } // use cache so only 1x per edge


    var ctrlpts = []; // store each ctrlpt info init

    for (var i = 0; i + 5 < rs.allpts.length; i += 4) {
      var p0 = {
        x: rs.allpts[i],
        y: rs.allpts[i + 1]
      };
      var p1 = {
        x: rs.allpts[i + 2],
        y: rs.allpts[i + 3]
      }; // ctrlpt

      var p2 = {
        x: rs.allpts[i + 4],
        y: rs.allpts[i + 5]
      };
      ctrlpts.push({
        p0: p0,
        p1: p1,
        p2: p2,
        startDist: 0,
        length: 0,
        segments: []
      });
    }

    var bpts = _p.rstyle.bezierPts;
    var nProjs = r.bezierProjPcts.length;

    function addSegment(cp, p0, p1, t0, t1) {
      var length = dist(p0, p1);
      var prevSegment = cp.segments[cp.segments.length - 1];
      var segment = {
        p0: p0,
        p1: p1,
        t0: t0,
        t1: t1,
        startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,
        length: length
      };
      cp.segments.push(segment);
      cp.length += length;
    } // update each ctrlpt with segment info


    for (var _i = 0; _i < ctrlpts.length; _i++) {
      var cp = ctrlpts[_i];
      var prevCp = ctrlpts[_i - 1];

      if (prevCp) {
        cp.startDist = prevCp.startDist + prevCp.length;
      }

      addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first

      for (var j = 0; j < nProjs - 1; j++) {
        addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);
      }

      addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last
    }

    return createControlPointInfo.cache = ctrlpts;
  };

  var calculateEndProjection = function calculateEndProjection(prefix) {
    var angle;
    var isSrc = prefix === 'source';

    if (!content[prefix]) {
      return;
    }

    var offset = edge.pstyle(prefix + '-text-offset').pfValue;

    switch (rs.edgeType) {
      case 'self':
      case 'compound':
      case 'bezier':
      case 'multibezier':
        {
          var cps = createControlPointInfo();
          var selected;
          var startDist = 0;
          var totalDist = 0; // find the segment we're on

          for (var i = 0; i < cps.length; i++) {
            var _cp = cps[isSrc ? i : cps.length - 1 - i];

            for (var j = 0; j < _cp.segments.length; j++) {
              var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];
              var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;
              startDist = totalDist;
              totalDist += _seg.length;

              if (totalDist >= offset || lastSeg) {
                selected = {
                  cp: _cp,
                  segment: _seg
                };
                break;
              }
            }

            if (selected) {
              break;
            }
          }

          var cp = selected.cp;
          var seg = selected.segment;
          var tSegment = (offset - startDist) / seg.length;
          var segDt = seg.t1 - seg.t0;
          var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;
          t = bound(0, t, 1);
          p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);
          angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);
          break;
        }

      case 'straight':
      case 'segments':
      case 'haystack':
        {
          var d = 0,
              di,
              d0;
          var p0, p1;
          var l = rs.allpts.length;

          for (var _i2 = 0; _i2 + 3 < l; _i2 += 2) {
            if (isSrc) {
              p0 = {
                x: rs.allpts[_i2],
                y: rs.allpts[_i2 + 1]
              };
              p1 = {
                x: rs.allpts[_i2 + 2],
                y: rs.allpts[_i2 + 3]
              };
            } else {
              p0 = {
                x: rs.allpts[l - 2 - _i2],
                y: rs.allpts[l - 1 - _i2]
              };
              p1 = {
                x: rs.allpts[l - 4 - _i2],
                y: rs.allpts[l - 3 - _i2]
              };
            }

            di = dist(p0, p1);
            d0 = d;
            d += di;

            if (d >= offset) {
              break;
            }
          }

          var pD = offset - d0;

          var _t = pD / di;

          _t = bound(0, _t, 1);
          p = lineAt(p0, p1, _t);
          angle = lineAngle(p0, p1);
          break;
        }
    }

    setRs('labelX', prefix, p.x);
    setRs('labelY', prefix, p.y);
    setRs('labelAutoAngle', prefix, angle);
  };

  calculateEndProjection('source');
  calculateEndProjection('target');
  this.applyLabelDimensions(edge);
};

BRp$6.applyLabelDimensions = function (ele) {
  this.applyPrefixedLabelDimensions(ele);

  if (ele.isEdge()) {
    this.applyPrefixedLabelDimensions(ele, 'source');
    this.applyPrefixedLabelDimensions(ele, 'target');
  }
};

BRp$6.applyPrefixedLabelDimensions = function (ele, prefix) {
  var _p = ele._private;
  var text = this.getLabelText(ele, prefix);
  var labelDims = this.calculateLabelDimensions(ele, text);
  var lineHeight = ele.pstyle('line-height').pfValue;
  var textWrap = ele.pstyle('text-wrap').strValue;
  var lines = getPrefixedProperty(_p.rscratch, 'labelWrapCachedLines', prefix) || [];
  var numLines = textWrap !== 'wrap' ? 1 : Math.max(lines.length, 1);
  var normPerLineHeight = labelDims.height / numLines;
  var labelLineHeight = normPerLineHeight * lineHeight;
  var width = labelDims.width;
  var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;
  setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, width);
  setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, width);
  setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, height);
  setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, height);
  setPrefixedProperty(_p.rscratch, 'labelLineHeight', prefix, labelLineHeight);
};

BRp$6.getLabelText = function (ele, prefix) {
  var _p = ele._private;
  var pfd = prefix ? prefix + '-' : '';
  var text = ele.pstyle(pfd + 'label').strValue;
  var textTransform = ele.pstyle('text-transform').value;

  var rscratch = function rscratch(propName, value) {
    if (value) {
      setPrefixedProperty(_p.rscratch, propName, prefix, value);
      return value;
    } else {
      return getPrefixedProperty(_p.rscratch, propName, prefix);
    }
  }; // for empty text, skip all processing


  if (!text) {
    return '';
  }

  if (textTransform == 'none') ; else if (textTransform == 'uppercase') {
    text = text.toUpperCase();
  } else if (textTransform == 'lowercase') {
    text = text.toLowerCase();
  }

  var wrapStyle = ele.pstyle('text-wrap').value;

  if (wrapStyle === 'wrap') {
    var labelKey = rscratch('labelKey'); // save recalc if the label is the same as before

    if (labelKey != null && rscratch('labelWrapKey') === labelKey) {
      return rscratch('labelWrapCachedText');
    }

    var zwsp = "\u200B";
    var lines = text.split('\n');
    var maxW = ele.pstyle('text-max-width').pfValue;
    var overflow = ele.pstyle('text-overflow-wrap').value;
    var overflowAny = overflow === 'anywhere';
    var wrappedLines = [];
    var wordsRegex = /[\s\u200b]+/;
    var wordSeparator = overflowAny ? '' : ' ';

    for (var l = 0; l < lines.length; l++) {
      var line = lines[l];
      var lineDims = this.calculateLabelDimensions(ele, line);
      var lineW = lineDims.width;

      if (overflowAny) {
        var processedLine = line.split('').join(zwsp);
        line = processedLine;
      }

      if (lineW > maxW) {
        // line is too long
        var words = line.split(wordsRegex);
        var subline = '';

        for (var w = 0; w < words.length; w++) {
          var word = words[w];
          var testLine = subline.length === 0 ? word : subline + wordSeparator + word;
          var testDims = this.calculateLabelDimensions(ele, testLine);
          var testW = testDims.width;

          if (testW <= maxW) {
            // word fits on current line
            subline += word + wordSeparator;
          } else {
            // word starts new line
            if (subline) {
              wrappedLines.push(subline);
            }

            subline = word + wordSeparator;
          }
        } // if there's remaining text, put it in a wrapped line


        if (!subline.match(/^[\s\u200b]+$/)) {
          wrappedLines.push(subline);
        }
      } else {
        // line is already short enough
        wrappedLines.push(line);
      }
    } // for


    rscratch('labelWrapCachedLines', wrappedLines);
    text = rscratch('labelWrapCachedText', wrappedLines.join('\n'));
    rscratch('labelWrapKey', labelKey);
  } else if (wrapStyle === 'ellipsis') {
    var _maxW = ele.pstyle('text-max-width').pfValue;
    var ellipsized = '';
    var ellipsis = "\u2026";
    var incLastCh = false;

    for (var i = 0; i < text.length; i++) {
      var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;

      if (widthWithNextCh > _maxW) {
        break;
      }

      ellipsized += text[i];

      if (i === text.length - 1) {
        incLastCh = true;
      }
    }

    if (!incLastCh) {
      ellipsized += ellipsis;
    }

    return ellipsized;
  } // if ellipsize


  return text;
};

BRp$6.getLabelJustification = function (ele) {
  var justification = ele.pstyle('text-justification').strValue;
  var textHalign = ele.pstyle('text-halign').strValue;

  if (justification === 'auto') {
    if (ele.isNode()) {
      switch (textHalign) {
        case 'left':
          return 'right';

        case 'right':
          return 'left';

        default:
          return 'center';
      }
    } else {
      return 'center';
    }
  } else {
    return justification;
  }
};

BRp$6.calculateLabelDimensions = function (ele, text) {
  var r = this;
  var cacheKey = hashString(text, ele._private.labelDimsKey);
  var cache = r.labelDimCache || (r.labelDimCache = []);
  var existingVal = cache[cacheKey];

  if (existingVal != null) {
    return existingVal;
  }

  var sizeMult = 1; // increase the scale to increase accuracy w.r.t. zoomed text

  var fStyle = ele.pstyle('font-style').strValue;
  var size = sizeMult * ele.pstyle('font-size').pfValue + 'px';
  var family = ele.pstyle('font-family').strValue;
  var weight = ele.pstyle('font-weight').strValue;
  var div = this.labelCalcDiv;

  if (!div) {
    div = this.labelCalcDiv = document.createElement('div'); // eslint-disable-line no-undef

    document.body.appendChild(div); // eslint-disable-line no-undef
  }

  var ds = div.style; // from ele style

  ds.fontFamily = family;
  ds.fontStyle = fStyle;
  ds.fontSize = size;
  ds.fontWeight = weight; // forced style

  ds.position = 'absolute';
  ds.left = '-9999px';
  ds.top = '-9999px';
  ds.zIndex = '-1';
  ds.visibility = 'hidden';
  ds.pointerEvents = 'none';
  ds.padding = '0';
  ds.lineHeight = '1';

  if (ele.pstyle('text-wrap').value === 'wrap') {
    ds.whiteSpace = 'pre'; // so newlines are taken into account
  } else {
    ds.whiteSpace = 'normal';
  } // put label content in div


  div.textContent = text;
  return cache[cacheKey] = {
    width: Math.ceil(div.clientWidth / sizeMult),
    height: Math.ceil(div.clientHeight / sizeMult)
  };
};

BRp$6.calculateLabelAngle = function (ele, prefix) {
  var _p = ele._private;
  var rs = _p.rscratch;
  var isEdge = ele.isEdge();
  var prefixDash = prefix ? prefix + '-' : '';
  var rot = ele.pstyle(prefixDash + 'text-rotation');
  var rotStr = rot.strValue;

  if (rotStr === 'none') {
    return 0;
  } else if (isEdge && rotStr === 'autorotate') {
    return rs.labelAutoAngle;
  } else if (rotStr === 'autorotate') {
    return 0;
  } else {
    return rot.pfValue;
  }
};

BRp$6.calculateLabelAngles = function (ele) {
  var r = this;
  var isEdge = ele.isEdge();
  var _p = ele._private;
  var rs = _p.rscratch;
  rs.labelAngle = r.calculateLabelAngle(ele);

  if (isEdge) {
    rs.sourceLabelAngle = r.calculateLabelAngle(ele, 'source');
    rs.targetLabelAngle = r.calculateLabelAngle(ele, 'target');
  }
};

var BRp$7 = {};
var TOO_SMALL_CUT_RECT = 28;
var warnedCutRect = false;

BRp$7.getNodeShape = function (node) {
  var r = this;
  var shape = node.pstyle('shape').value;

  if (shape === 'cutrectangle' && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {
    if (!warnedCutRect) {
      warn('The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead');
      warnedCutRect = true;
    }

    return 'rectangle';
  }

  if (node.isParent()) {
    if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'cutrectangle' || shape === 'barrel') {
      return shape;
    } else {
      return 'rectangle';
    }
  }

  if (shape === 'polygon') {
    var points = node.pstyle('shape-polygon-points').value;
    return r.nodeShapes.makePolygon(points).name;
  }

  return shape;
};

var BRp$8 = {};

BRp$8.registerCalculationListeners = function () {
  var cy = this.cy;
  var elesToUpdate = cy.collection();
  var r = this;

  var enqueue = function enqueue(eles) {
    var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    elesToUpdate.merge(eles);

    if (dirtyStyleCaches) {
      for (var i = 0; i < eles.length; i++) {
        var ele = eles[i];
        var _p = ele._private;
        var rstyle = _p.rstyle;
        rstyle.clean = false;
        rstyle.cleanConnected = false;
      }
    }
  };

  r.binder(cy).on('bounds.* dirty.*', function onDirtyBounds(e) {
    var ele = e.target;
    enqueue(ele);
  }).on('style.* background.*', function onDirtyStyle(e) {
    var ele = e.target;
    enqueue(ele, false);
  });

  var updateEleCalcs = function updateEleCalcs(willDraw) {
    if (willDraw) {
      var fns = r.onUpdateEleCalcsFns;

      for (var i = 0; i < elesToUpdate.length; i++) {
        var ele = elesToUpdate[i];
        var rstyle = ele._private.rstyle;

        if (ele.isNode() && !rstyle.cleanConnected) {
          enqueue(ele.connectedEdges());
          rstyle.cleanConnected = true;
        }
      }

      if (fns) {
        for (var i = 0; i < fns.length; i++) {
          var fn = fns[i];
          fn(willDraw, elesToUpdate);
        }
      }

      r.recalculateRenderedStyle(elesToUpdate);
      elesToUpdate = cy.collection();
    }
  };

  r.flushRenderedStyleQueue = function () {
    updateEleCalcs(true);
  };

  r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);
};

BRp$8.onUpdateEleCalcs = function (fn) {
  var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];
  fns.push(fn);
};

BRp$8.recalculateRenderedStyle = function (eles, useCache) {
  var edges = [];
  var nodes = []; // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()

  if (this.destroyed) {
    return;
  } // use cache by default for perf


  if (useCache === undefined) {
    useCache = true;
  }

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var _p = ele._private;
    var rstyle = _p.rstyle; // only update if dirty and in graph

    if (useCache && rstyle.clean || ele.removed()) {
      continue;
    } // only update if not display: none


    if (ele.pstyle('display').value === 'none') {
      continue;
    }

    if (_p.group === 'nodes') {
      nodes.push(ele);
    } else {
      // edges
      edges.push(ele);
    }

    rstyle.clean = true;
  } // update node data from projections


  for (var i = 0; i < nodes.length; i++) {
    var ele = nodes[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var pos = ele.position();
    this.recalculateNodeLabelProjection(ele);
    rstyle.nodeX = pos.x;
    rstyle.nodeY = pos.y;
    rstyle.nodeW = ele.pstyle('width').pfValue;
    rstyle.nodeH = ele.pstyle('height').pfValue;
  }

  this.recalculateEdgeProjections(edges); // update edge data from projections

  for (var i = 0; i < edges.length; i++) {
    var ele = edges[i];
    var _p = ele._private;
    var rstyle = _p.rstyle;
    var rs = _p.rscratch; // update rstyle positions

    rstyle.srcX = rs.arrowStartX;
    rstyle.srcY = rs.arrowStartY;
    rstyle.tgtX = rs.arrowEndX;
    rstyle.tgtY = rs.arrowEndY;
    rstyle.midX = rs.midX;
    rstyle.midY = rs.midY;
    rstyle.labelAngle = rs.labelAngle;
    rstyle.sourceLabelAngle = rs.sourceLabelAngle;
    rstyle.targetLabelAngle = rs.targetLabelAngle;
  }
};

var BRp$9 = {};

BRp$9.updateCachedGrabbedEles = function () {
  var eles = this.cachedZSortedEles;

  if (!eles) {
    // just let this be recalculated on the next z sort tick
    return;
  }

  eles.drag = [];
  eles.nondrag = [];
  var grabTargets = [];

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;

    if (ele.grabbed() && !ele.isParent()) {
      grabTargets.push(ele);
    } else if (rs.inDragLayer) {
      eles.drag.push(ele);
    } else {
      eles.nondrag.push(ele);
    }
  } // put the grab target nodes last so it's on top of its neighbourhood


  for (var i = 0; i < grabTargets.length; i++) {
    var ele = grabTargets[i];
    eles.drag.push(ele);
  }
};

BRp$9.invalidateCachedZSortedEles = function () {
  this.cachedZSortedEles = null;
};

BRp$9.getCachedZSortedEles = function (forceRecalc) {
  if (forceRecalc || !this.cachedZSortedEles) {
    var eles = this.cy.mutableElements().toArray();
    eles.sort(zIndexSort);
    eles.interactive = eles.filter(function (ele) {
      return ele.interactive();
    });
    this.cachedZSortedEles = eles;
    this.updateCachedGrabbedEles();
  } else {
    eles = this.cachedZSortedEles;
  }

  return eles;
};

var BRp$a = {};
[BRp$1, BRp$2, BRp$3, BRp$4, BRp$5, BRp$6, BRp$7, BRp$8, BRp$9].forEach(function (props) {
  extend(BRp$a, props);
});

var BRp$b = {};

BRp$b.getCachedImage = function (url, crossOrigin, onLoad) {
  var r = this;
  var imageCache = r.imageCache = r.imageCache || {};
  var cache = imageCache[url];

  if (cache) {
    if (!cache.image.complete) {
      cache.image.addEventListener('load', onLoad);
    }

    return cache.image;
  } else {
    cache = imageCache[url] = imageCache[url] || {};
    var image = cache.image = new Image(); // eslint-disable-line no-undef

    image.addEventListener('load', onLoad);
    image.addEventListener('error', function () {
      image.error = true;
    }); // #1582 safari doesn't load data uris with crossOrigin properly
    // https://bugs.webkit.org/show_bug.cgi?id=123978

    var dataUriPrefix = 'data:';
    var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;

    if (!isDataUri) {
      image.crossOrigin = crossOrigin; // prevent tainted canvas
    }

    image.src = url;
    return image;
  }
};

var BRp$c = {};
/* global document, window, ResizeObserver, MutationObserver */

BRp$c.registerBinding = function (target, event, handler, useCapture) {
  // eslint-disable-line no-unused-vars
  var args = Array.prototype.slice.apply(arguments, [1]); // copy

  var b = this.binder(target);
  return b.on.apply(b, args);
};

BRp$c.binder = function (tgt) {
  var r = this;
  var tgtIsDom = tgt === window || tgt === document || tgt === document.body || domElement(tgt);

  if (r.supportsPassiveEvents == null) {
    // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
    var supportsPassive = false;

    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function get() {
          supportsPassive = true;
          return true;
        }
      });
      window.addEventListener('test', null, opts);
    } catch (err) {// not supported
    }

    r.supportsPassiveEvents = supportsPassive;
  }

  var on = function on(event, handler, useCapture) {
    var args = Array.prototype.slice.call(arguments);

    if (tgtIsDom && r.supportsPassiveEvents) {
      // replace useCapture w/ opts obj
      args[2] = {
        capture: useCapture != null ? useCapture : false,
        passive: false,
        once: false
      };
    }

    r.bindings.push({
      target: tgt,
      args: args
    });
    (tgt.addEventListener || tgt.on).apply(tgt, args);
    return this;
  };

  return {
    on: on,
    addEventListener: on,
    addListener: on,
    bind: on
  };
};

BRp$c.nodeIsDraggable = function (node) {
  return node && node.isNode() && !node.locked() && node.grabbable();
};

BRp$c.nodeIsGrabbable = function (node) {
  return this.nodeIsDraggable(node) && node.interactive();
};

BRp$c.load = function () {
  var r = this;

  var isSelected = function isSelected(ele) {
    return ele.selected();
  };

  var triggerEvents = function triggerEvents(target, names, e, position) {
    if (target == null) {
      target = r.cy;
    }

    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      target.emit({
        originalEvent: e,
        type: name,
        position: position
      });
    }
  };

  var isMultSelKeyDown = function isMultSelKeyDown(e) {
    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
  };

  var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {
    var allowPassthrough = true;

    if (r.cy.hasCompoundNodes() && down && down.pannable()) {
      // a grabbable compound node below the ele => no passthrough panning
      for (var i = 0; downs && i < downs.length; i++) {
        var down = downs[i];

        if (down.isNode() && down.isParent()) {
          allowPassthrough = false;
          break;
        }
      }
    } else {
      allowPassthrough = true;
    }

    return allowPassthrough;
  };

  var setGrabbed = function setGrabbed(ele) {
    ele[0]._private.grabbed = true;
  };

  var setFreed = function setFreed(ele) {
    ele[0]._private.grabbed = false;
  };

  var setInDragLayer = function setInDragLayer(ele) {
    ele[0]._private.rscratch.inDragLayer = true;
  };

  var setOutDragLayer = function setOutDragLayer(ele) {
    ele[0]._private.rscratch.inDragLayer = false;
  };

  var setGrabTarget = function setGrabTarget(ele) {
    ele[0]._private.rscratch.isGrabTarget = true;
  };

  var removeGrabTarget = function removeGrabTarget(ele) {
    ele[0]._private.rscratch.isGrabTarget = false;
  };

  var addToDragList = function addToDragList(ele, opts) {
    var list = opts.addToList;
    var listHasEle = list.has(ele);

    if (!listHasEle) {
      list.merge(ele);
      setGrabbed(ele);
    }
  }; // helper function to determine which child nodes and inner edges
  // of a compound node to be dragged as well as the grabbed and selected nodes


  var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {
    if (!node.cy().hasCompoundNodes()) {
      return;
    }

    if (opts.inDragLayer == null && opts.addToList == null) {
      return;
    } // nothing to do


    var innerNodes = node.descendants();

    if (opts.inDragLayer) {
      innerNodes.forEach(setInDragLayer);
      innerNodes.connectedEdges().forEach(setInDragLayer);
    }

    if (opts.addToList) {
      opts.addToList.unmerge(innerNodes);
    }
  }; // adds the given nodes and its neighbourhood to the drag layer


  var addNodesToDrag = function addNodesToDrag(nodes, opts) {
    opts = opts || {};
    var hasCompoundNodes = nodes.cy().hasCompoundNodes();

    if (opts.inDragLayer) {
      nodes.forEach(setInDragLayer);
      nodes.neighborhood().stdFilter(function (ele) {
        return !hasCompoundNodes || ele.isEdge();
      }).forEach(setInDragLayer);
    }

    if (opts.addToList) {
      nodes.forEach(function (ele) {
        addToDragList(ele, opts);
      });
    }

    addDescendantsToDrag(nodes, opts); // always add to drag
    // also add nodes and edges related to the topmost ancestor

    updateAncestorsInDragLayer(nodes, {
      inDragLayer: opts.inDragLayer
    });
    r.updateCachedGrabbedEles();
  };

  var addNodeToDrag = addNodesToDrag;

  var freeDraggedElements = function freeDraggedElements(grabbedEles) {
    if (!grabbedEles) {
      return;
    } // just go over all elements rather than doing a bunch of (possibly expensive) traversals


    r.getCachedZSortedEles().forEach(function (ele) {
      setFreed(ele);
      setOutDragLayer(ele);
      removeGrabTarget(ele);
    });
    r.updateCachedGrabbedEles();
  }; // helper function to determine which ancestor nodes and edges should go
  // to the drag layer (or should be removed from drag layer).


  var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {
    if (opts.inDragLayer == null && opts.addToList == null) {
      return;
    } // nothing to do


    if (!node.cy().hasCompoundNodes()) {
      return;
    } // find top-level parent


    var parent = node.ancestors().orphans(); // no parent node: no nodes to add to the drag layer

    if (parent.same(node)) {
      return;
    }

    var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());
    var edges = nodes.connectedEdges();

    if (opts.inDragLayer) {
      edges.forEach(setInDragLayer);
      nodes.forEach(setInDragLayer);
    }

    if (opts.addToList) {
      nodes.forEach(function (ele) {
        addToDragList(ele, opts);
      });
    }
  };

  var blurActiveDomElement = function blurActiveDomElement() {
    if (document.activeElement != null && document.activeElement.blur != null) {
      document.activeElement.blur();
    }
  };

  var haveMutationsApi = typeof MutationObserver !== 'undefined';
  var haveResizeObserverApi = typeof ResizeObserver !== 'undefined'; // watch for when the cy container is removed from the dom

  if (haveMutationsApi) {
    r.removeObserver = new MutationObserver(function (mutns) {
      // eslint-disable-line no-undef
      for (var i = 0; i < mutns.length; i++) {
        var mutn = mutns[i];
        var rNodes = mutn.removedNodes;

        if (rNodes) {
          for (var j = 0; j < rNodes.length; j++) {
            var rNode = rNodes[j];

            if (rNode === r.container) {
              r.destroy();
              break;
            }
          }
        }
      }
    });

    if (r.container.parentNode) {
      r.removeObserver.observe(r.container.parentNode, {
        childList: true
      });
    }
  } else {
    r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {
      // eslint-disable-line no-unused-vars
      r.destroy();
    });
  }

  var onResize = util(function () {
    r.cy.resize();
  }, 100);

  if (haveMutationsApi) {
    r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef

    r.styleObserver.observe(r.container, {
      attributes: true
    });
  } // auto resize


  r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef

  if (haveResizeObserverApi) {
    r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef

    r.resizeObserver.observe(r.container);
  }

  var forEachUp = function forEachUp(domEle, fn) {
    while (domEle != null) {
      fn(domEle);
      domEle = domEle.parentNode;
    }
  };

  var invalidateCoords = function invalidateCoords() {
    r.invalidateContainerClientCoordsCache();
  };

  forEachUp(r.container, function (domEle) {
    r.registerBinding(domEle, 'transitionend', invalidateCoords);
    r.registerBinding(domEle, 'animationend', invalidateCoords);
    r.registerBinding(domEle, 'scroll', invalidateCoords);
  }); // stop right click menu from appearing on cy

  r.registerBinding(r.container, 'contextmenu', function (e) {
    e.preventDefault();
  });

  var inBoxSelection = function inBoxSelection() {
    return r.selection[4] !== 0;
  };

  var eventInContainer = function eventInContainer(e) {
    // save cycles if mouse events aren't to be captured
    var containerPageCoords = r.findContainerClientCoords();
    var x = containerPageCoords[0];
    var y = containerPageCoords[1];
    var width = containerPageCoords[2];
    var height = containerPageCoords[3];
    var positions = e.touches ? e.touches : [e];
    var atLeastOnePosInside = false;

    for (var i = 0; i < positions.length; i++) {
      var p = positions[i];

      if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {
        atLeastOnePosInside = true;
        break;
      }
    }

    if (!atLeastOnePosInside) {
      return false;
    }

    var container = r.container;
    var target = e.target;
    var tParent = target.parentNode;
    var containerIsTarget = false;

    while (tParent) {
      if (tParent === container) {
        containerIsTarget = true;
        break;
      }

      tParent = tParent.parentNode;
    }

    if (!containerIsTarget) {
      return false;
    } // if target is outisde cy container, then this event is not for us


    return true;
  }; // Primary key


  r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {
    if (!eventInContainer(e)) {
      return;
    }

    e.preventDefault();
    blurActiveDomElement();
    r.hoverData.capture = true;
    r.hoverData.which = e.which;
    var cy = r.cy;
    var gpos = [e.clientX, e.clientY];
    var pos = r.projectIntoViewport(gpos[0], gpos[1]);
    var select = r.selection;
    var nears = r.findNearestElements(pos[0], pos[1], true, false);
    var near = nears[0];
    var draggedElements = r.dragData.possibleDragElements;
    r.hoverData.mdownPos = pos;
    r.hoverData.mdownGPos = gpos;

    var checkForTaphold = function checkForTaphold() {
      r.hoverData.tapholdCancelled = false;
      clearTimeout(r.hoverData.tapholdTimeout);
      r.hoverData.tapholdTimeout = setTimeout(function () {
        if (r.hoverData.tapholdCancelled) {
          return;
        } else {
          var ele = r.hoverData.down;

          if (ele) {
            ele.emit({
              originalEvent: e,
              type: 'taphold',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          } else {
            cy.emit({
              originalEvent: e,
              type: 'taphold',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          }
        }
      }, r.tapholdDuration);
    }; // Right click button


    if (e.which == 3) {
      r.hoverData.cxtStarted = true;
      var cxtEvt = {
        originalEvent: e,
        type: 'cxttapstart',
        position: {
          x: pos[0],
          y: pos[1]
        }
      };

      if (near) {
        near.activate();
        near.emit(cxtEvt);
        r.hoverData.down = near;
      } else {
        cy.emit(cxtEvt);
      }

      r.hoverData.downTime = new Date().getTime();
      r.hoverData.cxtDragged = false; // Primary button
    } else if (e.which == 1) {
      if (near) {
        near.activate();
      } // Element dragging


      {
        // If something is under the cursor and it is draggable, prepare to grab it
        if (near != null) {
          if (r.nodeIsGrabbable(near)) {
            var makeEvent = function makeEvent(type) {
              return {
                originalEvent: e,
                type: type,
                position: {
                  x: pos[0],
                  y: pos[1]
                }
              };
            };

            var triggerGrab = function triggerGrab(ele) {
              ele.emit(makeEvent('grab'));
            };

            setGrabTarget(near);

            if (!near.selected()) {
              draggedElements = r.dragData.possibleDragElements = cy.collection();
              addNodeToDrag(near, {
                addToList: draggedElements
              });
              near.emit(makeEvent('grabon')).emit(makeEvent('grab'));
            } else {
              draggedElements = r.dragData.possibleDragElements = cy.collection();
              var selectedNodes = cy.$(function (ele) {
                return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);
              });
              addNodesToDrag(selectedNodes, {
                addToList: draggedElements
              });
              near.emit(makeEvent('grabon'));
              selectedNodes.forEach(triggerGrab);
            }

            r.redrawHint('eles', true);
            r.redrawHint('drag', true);
          }
        }

        r.hoverData.down = near;
        r.hoverData.downs = nears;
        r.hoverData.downTime = new Date().getTime();
      }
      triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {
        x: pos[0],
        y: pos[1]
      });

      if (near == null) {
        select[4] = 1;
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };
        r.redrawHint('select', true);
        r.redraw();
      } else if (near.pannable()) {
        select[4] = 1; // for future pan
      }

      checkForTaphold();
    } // Initialize selection box coordinates


    select[0] = select[2] = pos[0];
    select[1] = select[3] = pos[1];
  }, false);
  r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.hoverData.capture;

    if (!capture && !eventInContainer(e)) {
      return;
    }

    var preventDefault = false;
    var cy = r.cy;
    var zoom = cy.zoom();
    var gpos = [e.clientX, e.clientY];
    var pos = r.projectIntoViewport(gpos[0], gpos[1]);
    var mdownPos = r.hoverData.mdownPos;
    var mdownGPos = r.hoverData.mdownGPos;
    var select = r.selection;
    var near = null;

    if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {
      near = r.findNearestElement(pos[0], pos[1], true, false);
    }

    var last = r.hoverData.last;
    var down = r.hoverData.down;
    var disp = [pos[0] - select[2], pos[1] - select[3]];
    var draggedElements = r.dragData.possibleDragElements;
    var isOverThresholdDrag;

    if (mdownGPos) {
      var dx = gpos[0] - mdownGPos[0];
      var dx2 = dx * dx;
      var dy = gpos[1] - mdownGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;
    }

    var multSelKeyDown = isMultSelKeyDown(e);

    if (isOverThresholdDrag) {
      r.hoverData.tapholdCancelled = true;
    }

    var updateDragDelta = function updateDragDelta() {
      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

      if (dragDelta.length === 0) {
        dragDelta.push(disp[0]);
        dragDelta.push(disp[1]);
      } else {
        dragDelta[0] += disp[0];
        dragDelta[1] += disp[1];
      }
    };

    preventDefault = true;
    triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {
      x: pos[0],
      y: pos[1]
    });

    var goIntoBoxMode = function goIntoBoxMode() {
      r.data.bgActivePosistion = undefined;

      if (!r.hoverData.selecting) {
        cy.emit({
          originalEvent: e,
          type: 'boxstart',
          position: {
            x: pos[0],
            y: pos[1]
          }
        });
      }

      select[4] = 1;
      r.hoverData.selecting = true;
      r.redrawHint('select', true);
      r.redraw();
    }; // trigger context drag if rmouse down


    if (r.hoverData.which === 3) {
      // but only if over threshold
      if (isOverThresholdDrag) {
        var cxtEvt = {
          originalEvent: e,
          type: 'cxtdrag',
          position: {
            x: pos[0],
            y: pos[1]
          }
        };

        if (down) {
          down.emit(cxtEvt);
        } else {
          cy.emit(cxtEvt);
        }

        r.hoverData.cxtDragged = true;

        if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {
          if (r.hoverData.cxtOver) {
            r.hoverData.cxtOver.emit({
              originalEvent: e,
              type: 'cxtdragout',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          }

          r.hoverData.cxtOver = near;

          if (near) {
            near.emit({
              originalEvent: e,
              type: 'cxtdragover',
              position: {
                x: pos[0],
                y: pos[1]
              }
            });
          }
        }
      } // Check if we are drag panning the entire graph

    } else if (r.hoverData.dragging) {
      preventDefault = true;

      if (cy.panningEnabled() && cy.userPanningEnabled()) {
        var deltaP;

        if (r.hoverData.justStartedPan) {
          var mdPos = r.hoverData.mdownPos;
          deltaP = {
            x: (pos[0] - mdPos[0]) * zoom,
            y: (pos[1] - mdPos[1]) * zoom
          };
          r.hoverData.justStartedPan = false;
        } else {
          deltaP = {
            x: disp[0] * zoom,
            y: disp[1] * zoom
          };
        }

        cy.panBy(deltaP);
        r.hoverData.dragged = true;
      } // Needs reproject due to pan changing viewport


      pos = r.projectIntoViewport(e.clientX, e.clientY); // Checks primary button down & out of time & mouse not moved much
    } else if (select[4] == 1 && (down == null || down.pannable())) {
      if (isOverThresholdDrag) {
        if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {
          goIntoBoxMode();
        } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {
          var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);

          if (allowPassthrough) {
            r.hoverData.dragging = true;
            r.hoverData.justStartedPan = true;
            select[4] = 0;
            r.data.bgActivePosistion = array2point(mdownPos);
            r.redrawHint('select', true);
            r.redraw();
          }
        }

        if (down && down.pannable() && down.active()) {
          down.unactivate();
        }
      }
    } else {
      if (down && down.pannable() && down.active()) {
        down.unactivate();
      }

      if ((!down || !down.grabbed()) && near != last) {
        if (last) {
          triggerEvents(last, ['mouseout', 'tapdragout'], e, {
            x: pos[0],
            y: pos[1]
          });
        }

        if (near) {
          triggerEvents(near, ['mouseover', 'tapdragover'], e, {
            x: pos[0],
            y: pos[1]
          });
        }

        r.hoverData.last = near;
      }

      if (down) {
        if (isOverThresholdDrag) {
          // then we can take action
          if (cy.boxSelectionEnabled() && multSelKeyDown) {
            // then selection overrides
            if (down && down.grabbed()) {
              freeDraggedElements(draggedElements);
              down.emit('freeon');
              draggedElements.emit('free');

              if (r.dragData.didDrag) {
                down.emit('dragfreeon');
                draggedElements.emit('dragfree');
              }
            }

            goIntoBoxMode();
          } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {
            // drag node
            var justStartedDrag = !r.dragData.didDrag;

            if (justStartedDrag) {
              r.redrawHint('eles', true);
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = cy.collection(); // now, add the elements to the drag layer if not done already

            if (!r.hoverData.draggingEles) {
              addNodesToDrag(draggedElements, {
                inDragLayer: true
              });
            }

            var totalShift = {
              x: 0,
              y: 0
            };

            if (number(disp[0]) && number(disp[1])) {
              totalShift.x += disp[0];
              totalShift.y += disp[1];

              if (justStartedDrag) {
                var dragDelta = r.hoverData.dragDelta;

                if (dragDelta && number(dragDelta[0]) && number(dragDelta[1])) {
                  totalShift.x += dragDelta[0];
                  totalShift.y += dragDelta[1];
                }
              }
            }

            for (var i = 0; i < draggedElements.length; i++) {
              var dEle = draggedElements[i];

              if (r.nodeIsDraggable(dEle) && dEle.grabbed()) {
                toTrigger.merge(dEle);
              }
            }

            r.hoverData.draggingEles = true;
            toTrigger.silentShift(totalShift).emit('position drag');
            r.redrawHint('drag', true);
            r.redraw();
          }
        } else {
          // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
          updateDragDelta();
        }
      } // prevent the dragging from triggering text selection on the page


      preventDefault = true;
    }

    select[2] = pos[0];
    select[3] = pos[1];

    if (preventDefault) {
      if (e.stopPropagation) e.stopPropagation();
      if (e.preventDefault) e.preventDefault();
      return false;
    }
  }, false);
  r.registerBinding(window, 'mouseup', function mouseupHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.hoverData.capture;

    if (!capture) {
      return;
    }

    r.hoverData.capture = false;
    var cy = r.cy;
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var select = r.selection;
    var near = r.findNearestElement(pos[0], pos[1], true, false);
    var draggedElements = r.dragData.possibleDragElements;
    var down = r.hoverData.down;
    var multSelKeyDown = isMultSelKeyDown(e);

    if (r.data.bgActivePosistion) {
      r.redrawHint('select', true);
      r.redraw();
    }

    r.hoverData.tapholdCancelled = true;
    r.data.bgActivePosistion = undefined; // not active bg now

    if (down) {
      down.unactivate();
    }

    if (r.hoverData.which === 3) {
      var cxtEvt = {
        originalEvent: e,
        type: 'cxttapend',
        position: {
          x: pos[0],
          y: pos[1]
        }
      };

      if (down) {
        down.emit(cxtEvt);
      } else {
        cy.emit(cxtEvt);
      }

      if (!r.hoverData.cxtDragged) {
        var cxtTap = {
          originalEvent: e,
          type: 'cxttap',
          position: {
            x: pos[0],
            y: pos[1]
          }
        };

        if (down) {
          down.emit(cxtTap);
        } else {
          cy.emit(cxtTap);
        }
      }

      r.hoverData.cxtDragged = false;
      r.hoverData.which = null;
    } else if (r.hoverData.which === 1) {
      triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {
        x: pos[0],
        y: pos[1]
      });

      if (!r.dragData.didDrag // didn't move a node around
      && !r.hoverData.dragged // didn't pan
      && !r.hoverData.selecting // not box selection
      && !r.hoverData.isOverThresholdDrag // didn't move too much
      ) {
          triggerEvents(down, ['click', 'tap', 'vclick'], e, {
            x: pos[0],
            y: pos[1]
          });
        } // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something


      if (down == null && // not mousedown on node
      !r.dragData.didDrag // didn't move the node around
      && !r.hoverData.selecting // not box selection
      && !r.hoverData.dragged // didn't pan
      && !isMultSelKeyDown(e)) {
        cy.$(isSelected).unselect(['tapunselect']);

        if (draggedElements.length > 0) {
          r.redrawHint('eles', true);
        }

        r.dragData.possibleDragElements = draggedElements = cy.collection();
      } // Single selection


      if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {
        if (near != null && near._private.selectable) {
          if (r.hoverData.dragging) ; else if (cy.selectionType() === 'additive' || multSelKeyDown) {
            if (near.selected()) {
              near.unselect(['tapunselect']);
            } else {
              near.select(['tapselect']);
            }
          } else {
            if (!multSelKeyDown) {
              cy.$(isSelected).unmerge(near).unselect(['tapunselect']);
              near.select(['tapselect']);
            }
          }

          r.redrawHint('eles', true);
        }
      }

      if (r.hoverData.selecting) {
        var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));
        r.redrawHint('select', true);

        if (box.length > 0) {
          r.redrawHint('eles', true);
        }

        cy.emit({
          type: 'boxend',
          originalEvent: e,
          position: {
            x: pos[0],
            y: pos[1]
          }
        });

        var eleWouldBeSelected = function eleWouldBeSelected(ele) {
          return ele.selectable() && !ele.selected();
        };

        if (cy.selectionType() === 'additive') {
          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
        } else {
          if (!multSelKeyDown) {
            cy.$(isSelected).unmerge(box).unselect();
          }

          box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');
        } // always need redraw in case eles unselectable


        r.redraw();
      } // Cancel drag pan


      if (r.hoverData.dragging) {
        r.hoverData.dragging = false;
        r.redrawHint('select', true);
        r.redrawHint('eles', true);
        r.redraw();
      }

      if (!select[4]) {
        r.redrawHint('drag', true);
        r.redrawHint('eles', true);
        var downWasGrabbed = down && down.grabbed();
        freeDraggedElements(draggedElements);

        if (downWasGrabbed) {
          down.emit('freeon');
          draggedElements.emit('free');

          if (r.dragData.didDrag) {
            down.emit('dragfreeon');
            draggedElements.emit('dragfree');
          }
        }
      }
    } // else not right mouse


    select[4] = 0;
    r.hoverData.down = null;
    r.hoverData.cxtStarted = false;
    r.hoverData.draggingEles = false;
    r.hoverData.selecting = false;
    r.hoverData.isOverThresholdDrag = false;
    r.dragData.didDrag = false;
    r.hoverData.dragged = false;
    r.hoverData.dragDelta = [];
    r.hoverData.mdownPos = null;
    r.hoverData.mdownGPos = null;
  }, false);

  var wheelHandler = function wheelHandler(e) {
    if (r.scrollingPage) {
      return;
    } // while scrolling, ignore wheel-to-zoom


    var cy = r.cy;
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var rpos = [pos[0] * cy.zoom() + cy.pan().x, pos[1] * cy.zoom() + cy.pan().y];

    if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {
      // if pan dragging or cxt dragging, wheel movements make no zoom
      e.preventDefault();
      return;
    }

    if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {
      e.preventDefault();
      r.data.wheelZooming = true;
      clearTimeout(r.data.wheelTimeout);
      r.data.wheelTimeout = setTimeout(function () {
        r.data.wheelZooming = false;
        r.redrawHint('eles', true);
        r.redraw();
      }, 150);
      var diff;

      if (e.deltaY != null) {
        diff = e.deltaY / -250;
      } else if (e.wheelDeltaY != null) {
        diff = e.wheelDeltaY / 1000;
      } else {
        diff = e.wheelDelta / 1000;
      }

      diff = diff * r.wheelSensitivity;
      var needsWheelFix = e.deltaMode === 1;

      if (needsWheelFix) {
        // fixes slow wheel events on ff/linux and ff/windows
        diff *= 33;
      }

      cy.zoom({
        level: cy.zoom() * Math.pow(10, diff),
        renderedPosition: {
          x: rpos[0],
          y: rpos[1]
        }
      });
    }
  }; // Functions to help with whether mouse wheel should trigger zooming
  // --


  r.registerBinding(r.container, 'wheel', wheelHandler, true); // disable nonstandard wheel events
  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

  r.registerBinding(window, 'scroll', function scrollHandler(e) {
    // eslint-disable-line no-unused-vars
    r.scrollingPage = true;
    clearTimeout(r.scrollingPageTimeout);
    r.scrollingPageTimeout = setTimeout(function () {
      r.scrollingPage = false;
    }, 250);
  }, true); // Functions to help with handling mouseout/mouseover on the Cytoscape container
  // Handle mouseout on Cytoscape container

  r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    r.cy.emit({
      originalEvent: e,
      type: 'mouseout',
      position: {
        x: pos[0],
        y: pos[1]
      }
    });
  }, false);
  r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    r.cy.emit({
      originalEvent: e,
      type: 'mouseover',
      position: {
        x: pos[0],
        y: pos[1]
      }
    });
  }, false);
  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom

  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom

  var center1, modelCenter1; // center point on start pinch to zoom

  var offsetLeft, offsetTop;
  var containerWidth, containerHeight;
  var twoFingersStartInside;

  var distance = function distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  };

  var distanceSq = function distanceSq(x1, y1, x2, y2) {
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
  };

  var touchstartHandler;
  r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {
    if (!eventInContainer(e)) {
      return;
    }

    blurActiveDomElement();
    r.touchData.capture = true;
    r.data.bgActivePosistion = undefined;
    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
      now[0] = pos[0];
      now[1] = pos[1];
    }

    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
      now[2] = pos[0];
      now[3] = pos[1];
    }

    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
      now[4] = pos[0];
      now[5] = pos[1];
    } // record starting points for pinch-to-zoom


    if (e.touches[1]) {
      r.touchData.singleTouchMoved = true;
      freeDraggedElements(r.dragData.touchDragEles);
      var offsets = r.findContainerClientCoords();
      offsetLeft = offsets[0];
      offsetTop = offsets[1];
      containerWidth = offsets[2];
      containerHeight = offsets[3];
      f1x1 = e.touches[0].clientX - offsetLeft;
      f1y1 = e.touches[0].clientY - offsetTop;
      f2x1 = e.touches[1].clientX - offsetLeft;
      f2y1 = e.touches[1].clientY - offsetTop;
      twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;
      var pan = cy.pan();
      var zoom = cy.zoom();
      distance1 = distance(f1x1, f1y1, f2x1, f2y1);
      distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);
      center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];
      modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom]; // consider context tap

      var cxtDistThreshold = 200;
      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;

      if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {
        var near1 = r.findNearestElement(now[0], now[1], true, true);
        var near2 = r.findNearestElement(now[2], now[3], true, true);

        if (near1 && near1.isNode()) {
          near1.activate().emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: {
              x: now[0],
              y: now[1]
            }
          });
          r.touchData.start = near1;
        } else if (near2 && near2.isNode()) {
          near2.activate().emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: {
              x: now[0],
              y: now[1]
            }
          });
          r.touchData.start = near2;
        } else {
          cy.emit({
            originalEvent: e,
            type: 'cxttapstart',
            position: {
              x: now[0],
              y: now[1]
            }
          });
        }

        if (r.touchData.start) {
          r.touchData.start._private.grabbed = false;
        }

        r.touchData.cxt = true;
        r.touchData.cxtDragged = false;
        r.data.bgActivePosistion = undefined;
        r.redraw();
        return;
      }
    }

    if (e.touches[2]) {
      // ignore
      // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)
      if (cy.boxSelectionEnabled()) {
        e.preventDefault();
      }
    } else if (e.touches[1]) ; else if (e.touches[0]) {
      var nears = r.findNearestElements(now[0], now[1], true, true);
      var near = nears[0];

      if (near != null) {
        near.activate();
        r.touchData.start = near;
        r.touchData.starts = nears;

        if (r.nodeIsGrabbable(near)) {
          var draggedEles = r.dragData.touchDragEles = cy.collection();
          var selectedNodes = null;
          r.redrawHint('eles', true);
          r.redrawHint('drag', true);

          if (near.selected()) {
            // reset drag elements, since near will be added again
            selectedNodes = cy.$(function (ele) {
              return ele.selected() && r.nodeIsGrabbable(ele);
            });
            addNodesToDrag(selectedNodes, {
              addToList: draggedEles
            });
          } else {
            addNodeToDrag(near, {
              addToList: draggedEles
            });
          }

          setGrabTarget(near);

          var makeEvent = function makeEvent(type) {
            return {
              originalEvent: e,
              type: type,
              position: {
                x: now[0],
                y: now[1]
              }
            };
          };

          near.emit(makeEvent('grabon'));

          if (selectedNodes) {
            selectedNodes.forEach(function (n) {
              n.emit(makeEvent('grab'));
            });
          } else {
            near.emit(makeEvent('grab'));
          }
        }
      }

      triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {
        x: now[0],
        y: now[1]
      });

      if (near == null) {
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };
        r.redrawHint('select', true);
        r.redraw();
      } // Tap, taphold
      // -----


      r.touchData.singleTouchMoved = false;
      r.touchData.singleTouchStartTime = +new Date();
      clearTimeout(r.touchData.tapholdTimeout);
      r.touchData.tapholdTimeout = setTimeout(function () {
        if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect
        && !r.touchData.selecting // box selection shouldn't allow taphold through
        ) {
            triggerEvents(r.touchData.start, ['taphold'], e, {
              x: now[0],
              y: now[1]
            });
          }
      }, r.tapholdDuration);
    }

    if (e.touches.length >= 1) {
      var sPos = r.touchData.startPosition = [];

      for (var i = 0; i < now.length; i++) {
        sPos[i] = earlier[i] = now[i];
      }

      var touch0 = e.touches[0];
      r.touchData.startGPosition = [touch0.clientX, touch0.clientY];
    }
  }, false);
  var touchmoveHandler;
  r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {
    // eslint-disable-line no-undef
    var capture = r.touchData.capture;

    if (!capture && !eventInContainer(e)) {
      return;
    }

    var select = r.selection;
    var cy = r.cy;
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;
    var zoom = cy.zoom();

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
      now[0] = pos[0];
      now[1] = pos[1];
    }

    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
      now[2] = pos[0];
      now[3] = pos[1];
    }

    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
      now[4] = pos[0];
      now[5] = pos[1];
    }

    var startGPos = r.touchData.startGPosition;
    var isOverThresholdDrag;

    if (capture && e.touches[0] && startGPos) {
      var disp = [];

      for (var j = 0; j < now.length; j++) {
        disp[j] = now[j] - earlier[j];
      }

      var dx = e.touches[0].clientX - startGPos[0];
      var dx2 = dx * dx;
      var dy = e.touches[0].clientY - startGPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      isOverThresholdDrag = dist2 >= r.touchTapThreshold2;
    } // context swipe cancelling


    if (capture && r.touchData.cxt) {
      e.preventDefault();
      var f1x2 = e.touches[0].clientX - offsetLeft,
          f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft,
          f2y2 = e.touches[1].clientY - offsetTop; // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );

      var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);
      var factorSq = distance2Sq / distance1Sq;
      var distThreshold = 150;
      var distThresholdSq = distThreshold * distThreshold;
      var factorThreshold = 1.5;
      var factorThresholdSq = factorThreshold * factorThreshold; // cancel ctx gestures if the distance b/t the fingers increases

      if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {
        r.touchData.cxt = false;
        r.data.bgActivePosistion = undefined;
        r.redrawHint('select', true);
        var cxtEvt = {
          originalEvent: e,
          type: 'cxttapend',
          position: {
            x: now[0],
            y: now[1]
          }
        };

        if (r.touchData.start) {
          r.touchData.start.unactivate().emit(cxtEvt);
          r.touchData.start = null;
        } else {
          cy.emit(cxtEvt);
        }
      }
    } // context swipe


    if (capture && r.touchData.cxt) {
      var cxtEvt = {
        originalEvent: e,
        type: 'cxtdrag',
        position: {
          x: now[0],
          y: now[1]
        }
      };
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      if (r.touchData.start) {
        r.touchData.start.emit(cxtEvt);
      } else {
        cy.emit(cxtEvt);
      }

      if (r.touchData.start) {
        r.touchData.start._private.grabbed = false;
      }

      r.touchData.cxtDragged = true;
      var near = r.findNearestElement(now[0], now[1], true, true);

      if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {
        if (r.touchData.cxtOver) {
          r.touchData.cxtOver.emit({
            originalEvent: e,
            type: 'cxtdragout',
            position: {
              x: now[0],
              y: now[1]
            }
          });
        }

        r.touchData.cxtOver = near;

        if (near) {
          near.emit({
            originalEvent: e,
            type: 'cxtdragover',
            position: {
              x: now[0],
              y: now[1]
            }
          });
        }
      } // box selection

    } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {
      e.preventDefault();
      r.data.bgActivePosistion = undefined;
      this.lastThreeTouch = +new Date();

      if (!r.touchData.selecting) {
        cy.emit({
          originalEvent: e,
          type: 'boxstart',
          position: {
            x: now[0],
            y: now[1]
          }
        });
      }

      r.touchData.selecting = true;
      r.touchData.didSelect = true;
      select[4] = 1;

      if (!select || select.length === 0 || select[0] === undefined) {
        select[0] = (now[0] + now[2] + now[4]) / 3;
        select[1] = (now[1] + now[3] + now[5]) / 3;
        select[2] = (now[0] + now[2] + now[4]) / 3 + 1;
        select[3] = (now[1] + now[3] + now[5]) / 3 + 1;
      } else {
        select[2] = (now[0] + now[2] + now[4]) / 3;
        select[3] = (now[1] + now[3] + now[5]) / 3;
      }

      r.redrawHint('select', true);
      r.redraw(); // pinch to zoom
    } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom
    && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {
      // two fingers => pinch to zoom
      e.preventDefault();
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
      var draggedEles = r.dragData.touchDragEles;

      if (draggedEles) {
        r.redrawHint('drag', true);

        for (var i = 0; i < draggedEles.length; i++) {
          var de_p = draggedEles[i]._private;
          de_p.grabbed = false;
          de_p.rscratch.inDragLayer = false;
        }
      }

      var _start = r.touchData.start; // (x2, y2) for fingers 1 and 2

      var f1x2 = e.touches[0].clientX - offsetLeft,
          f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft,
          f2y2 = e.touches[1].clientY - offsetTop;
      var distance2 = distance(f1x2, f1y2, f2x2, f2y2); // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );

      var factor = distance2 / distance1;

      if (twoFingersStartInside) {
        // delta finger1
        var df1x = f1x2 - f1x1;
        var df1y = f1y2 - f1y1; // delta finger 2

        var df2x = f2x2 - f2x1;
        var df2y = f2y2 - f2y1; // translation is the normalised vector of the two fingers movement
        // i.e. so pinching cancels out and moving together pans

        var tx = (df1x + df2x) / 2;
        var ty = (df1y + df2y) / 2; // now calculate the zoom

        var zoom1 = cy.zoom();
        var zoom2 = zoom1 * factor;
        var pan1 = cy.pan(); // the model center point converted to the current rendered pos

        var ctrx = modelCenter1[0] * zoom1 + pan1.x;
        var ctry = modelCenter1[1] * zoom1 + pan1.y;
        var pan2 = {
          x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,
          y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry
        }; // remove dragged eles

        if (_start && _start.active()) {
          var draggedEles = r.dragData.touchDragEles;
          freeDraggedElements(draggedEles);
          r.redrawHint('drag', true);
          r.redrawHint('eles', true);

          _start.unactivate().emit('freeon');

          draggedEles.emit('free');

          if (r.dragData.didDrag) {
            _start.emit('dragfreeon');

            draggedEles.emit('dragfree');
          }
        }

        cy.viewport({
          zoom: zoom2,
          pan: pan2,
          cancelOnFailedZoom: true
        });
        distance1 = distance2;
        f1x1 = f1x2;
        f1y1 = f1y2;
        f2x1 = f2x2;
        f2y1 = f2y2;
        r.pinching = true;
      } // Re-project


      if (e.touches[0]) {
        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
        now[0] = pos[0];
        now[1] = pos[1];
      }

      if (e.touches[1]) {
        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
        now[2] = pos[0];
        now[3] = pos[1];
      }

      if (e.touches[2]) {
        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
        now[4] = pos[0];
        now[5] = pos[1];
      }
    } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning
    ) {
        var start = r.touchData.start;
        var last = r.touchData.last;
        var near;

        if (!r.hoverData.draggingEles && !r.swipePanning) {
          near = r.findNearestElement(now[0], now[1], true, true);
        }

        if (capture && start != null) {
          e.preventDefault();
        } // dragging nodes


        if (capture && start != null && r.nodeIsDraggable(start)) {
          if (isOverThresholdDrag) {
            // then dragging can happen
            var draggedEles = r.dragData.touchDragEles;
            var justStartedDrag = !r.dragData.didDrag;

            if (justStartedDrag) {
              addNodesToDrag(draggedEles, {
                inDragLayer: true
              });
            }

            r.dragData.didDrag = true;
            var totalShift = {
              x: 0,
              y: 0
            };

            if (number(disp[0]) && number(disp[1])) {
              totalShift.x += disp[0];
              totalShift.y += disp[1];

              if (justStartedDrag) {
                r.redrawHint('eles', true);
                var dragDelta = r.touchData.dragDelta;

                if (dragDelta && number(dragDelta[0]) && number(dragDelta[1])) {
                  totalShift.x += dragDelta[0];
                  totalShift.y += dragDelta[1];
                }
              }
            }

            r.hoverData.draggingEles = true;
            draggedEles.silentShift(totalShift).emit('position drag');
            r.redrawHint('drag', true);

            if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {
              r.redrawHint('eles', true);
            }

            r.redraw();
          } else {
            // otherise keep track of drag delta for later
            var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

            if (dragDelta.length === 0) {
              dragDelta.push(disp[0]);
              dragDelta.push(disp[1]);
            } else {
              dragDelta[0] += disp[0];
              dragDelta[1] += disp[1];
            }
          }
        } // touchmove


        {
          triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {
            x: now[0],
            y: now[1]
          });

          if ((!start || !start.grabbed()) && near != last) {
            if (last) {
              last.emit({
                originalEvent: e,
                type: 'tapdragout',
                position: {
                  x: now[0],
                  y: now[1]
                }
              });
            }

            if (near) {
              near.emit({
                originalEvent: e,
                type: 'tapdragover',
                position: {
                  x: now[0],
                  y: now[1]
                }
              });
            }
          }

          r.touchData.last = near;
        } // check to cancel taphold

        if (capture) {
          for (var i = 0; i < now.length; i++) {
            if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {
              r.touchData.singleTouchMoved = true;
            }
          }
        } // panning


        if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {
          var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);

          if (allowPassthrough) {
            e.preventDefault();

            if (!r.data.bgActivePosistion) {
              r.data.bgActivePosistion = array2point(r.touchData.startPosition);
            }

            if (r.swipePanning) {
              cy.panBy({
                x: disp[0] * zoom,
                y: disp[1] * zoom
              });
            } else if (isOverThresholdDrag) {
              r.swipePanning = true;
              cy.panBy({
                x: dx * zoom,
                y: dy * zoom
              });

              if (start) {
                start.unactivate();
                r.redrawHint('select', true);
                r.touchData.start = null;
              }
            }
          } // Re-project


          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
          now[0] = pos[0];
          now[1] = pos[1];
        }
      }

    for (var j = 0; j < now.length; j++) {
      earlier[j] = now[j];
    } // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning


    if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
      r.redraw();
    }
  }, false);
  var touchcancelHandler;
  r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {
    // eslint-disable-line no-unused-vars
    var start = r.touchData.start;
    r.touchData.capture = false;

    if (start) {
      start.unactivate();
    }
  });
  var touchendHandler;
  r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {
    // eslint-disable-line no-unused-vars
    var start = r.touchData.start;
    var capture = r.touchData.capture;

    if (capture) {
      if (e.touches.length === 0) {
        r.touchData.capture = false;
      }

      e.preventDefault();
    } else {
      return;
    }

    var select = r.selection;
    r.swipePanning = false;
    r.hoverData.draggingEles = false;
    var cy = r.cy;
    var zoom = cy.zoom();
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) {
      var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
      now[0] = pos[0];
      now[1] = pos[1];
    }

    if (e.touches[1]) {
      var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
      now[2] = pos[0];
      now[3] = pos[1];
    }

    if (e.touches[2]) {
      var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
      now[4] = pos[0];
      now[5] = pos[1];
    }

    if (start) {
      start.unactivate();
    }

    var ctxTapend;

    if (r.touchData.cxt) {
      ctxTapend = {
        originalEvent: e,
        type: 'cxttapend',
        position: {
          x: now[0],
          y: now[1]
        }
      };

      if (start) {
        start.emit(ctxTapend);
      } else {
        cy.emit(ctxTapend);
      }

      if (!r.touchData.cxtDragged) {
        var ctxTap = {
          originalEvent: e,
          type: 'cxttap',
          position: {
            x: now[0],
            y: now[1]
          }
        };

        if (start) {
          start.emit(ctxTap);
        } else {
          cy.emit(ctxTap);
        }
      }

      if (r.touchData.start) {
        r.touchData.start._private.grabbed = false;
      }

      r.touchData.cxt = false;
      r.touchData.start = null;
      r.redraw();
      return;
    } // no more box selection if we don't have three fingers


    if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {
      r.touchData.selecting = false;
      var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));
      select[0] = undefined;
      select[1] = undefined;
      select[2] = undefined;
      select[3] = undefined;
      select[4] = 0;
      r.redrawHint('select', true);
      cy.emit({
        type: 'boxend',
        originalEvent: e,
        position: {
          x: now[0],
          y: now[1]
        }
      });

      var eleWouldBeSelected = function eleWouldBeSelected(ele) {
        return ele.selectable() && !ele.selected();
      };

      box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');

      if (box.nonempty()) {
        r.redrawHint('eles', true);
      }

      r.redraw();
    }

    if (start != null) {
      start.unactivate();
    }

    if (e.touches[2]) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
    } else if (e.touches[1]) ; else if (e.touches[0]) ; else if (!e.touches[0]) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
      var draggedEles = r.dragData.touchDragEles;

      if (start != null) {
        var startWasGrabbed = start._private.grabbed;
        freeDraggedElements(draggedEles);
        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        if (startWasGrabbed) {
          start.emit('freeon');
          draggedEles.emit('free');

          if (r.dragData.didDrag) {
            start.emit('dragfreeon');
            draggedEles.emit('dragfree');
          }
        }

        triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
          x: now[0],
          y: now[1]
        });
        start.unactivate();
        r.touchData.start = null;
      } else {
        var near = r.findNearestElement(now[0], now[1], true, true);
        triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {
          x: now[0],
          y: now[1]
        });
      }

      var dx = r.touchData.startPosition[0] - now[0];
      var dx2 = dx * dx;
      var dy = r.touchData.startPosition[1] - now[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom; // Tap event, roughly same as mouse click event for touch

      if (!r.touchData.singleTouchMoved) {
        if (!start) {
          cy.$(':selected').unselect(['tapunselect']);
        }

        triggerEvents(start, ['tap', 'vclick'], e, {
          x: now[0],
          y: now[1]
        });
      } // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance


      if (start != null && !r.dragData.didDrag // didn't drag nodes around
      && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection
      ) {
          if (cy.selectionType() === 'single') {
            cy.$(isSelected).unmerge(start).unselect(['tapunselect']);
            start.select(['tapselect']);
          } else {
            if (start.selected()) {
              start.unselect(['tapunselect']);
            } else {
              start.select(['tapselect']);
            }
          }

          r.redrawHint('eles', true);
        }

      r.touchData.singleTouchMoved = true;
    }

    for (var j = 0; j < now.length; j++) {
      earlier[j] = now[j];
    }

    r.dragData.didDrag = false; // reset for next touchstart

    if (e.touches.length === 0) {
      r.touchData.dragDelta = [];
      r.touchData.startPosition = null;
      r.touchData.startGPosition = null;
      r.touchData.didSelect = false;
    }

    if (e.touches.length < 2) {
      if (e.touches.length === 1) {
        // the old start global pos'n may not be the same finger that remains
        r.touchData.startGPosition = [e.touches[0].clientX, e.touches[0].clientY];
      }

      r.pinching = false;
      r.redrawHint('eles', true);
      r.redraw();
    } //r.redraw();

  }, false); // fallback compatibility layer for ms pointer events

  if (typeof TouchEvent === 'undefined') {
    var pointers = [];

    var makeTouch = function makeTouch(e) {
      return {
        clientX: e.clientX,
        clientY: e.clientY,
        force: 1,
        identifier: e.pointerId,
        pageX: e.pageX,
        pageY: e.pageY,
        radiusX: e.width / 2,
        radiusY: e.height / 2,
        screenX: e.screenX,
        screenY: e.screenY,
        target: e.target
      };
    };

    var makePointer = function makePointer(e) {
      return {
        event: e,
        touch: makeTouch(e)
      };
    };

    var addPointer = function addPointer(e) {
      pointers.push(makePointer(e));
    };

    var removePointer = function removePointer(e) {
      for (var i = 0; i < pointers.length; i++) {
        var p = pointers[i];

        if (p.event.pointerId === e.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    };

    var updatePointer = function updatePointer(e) {
      var p = pointers.filter(function (p) {
        return p.event.pointerId === e.pointerId;
      })[0];
      p.event = e;
      p.touch = makeTouch(e);
    };

    var addTouchesToEvent = function addTouchesToEvent(e) {
      e.touches = pointers.map(function (p) {
        return p.touch;
      });
    };

    var pointerIsMouse = function pointerIsMouse(e) {
      return e.pointerType === 'mouse' || e.pointerType === 4;
    };

    r.registerBinding(r.container, 'pointerdown', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled


      e.preventDefault();
      addPointer(e);
      addTouchesToEvent(e);
      touchstartHandler(e);
    });
    r.registerBinding(r.container, 'pointerup', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled


      removePointer(e);
      addTouchesToEvent(e);
      touchendHandler(e);
    });
    r.registerBinding(r.container, 'pointercancel', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled


      removePointer(e);
      addTouchesToEvent(e);
      touchcancelHandler(e);
    });
    r.registerBinding(r.container, 'pointermove', function (e) {
      if (pointerIsMouse(e)) {
        return;
      } // mouse already handled


      e.preventDefault();
      updatePointer(e);
      addTouchesToEvent(e);
      touchmoveHandler(e);
    });
  }
};

var BRp$d = {};

BRp$d.generatePolygon = function (name, points) {
  return this.nodeShapes[name] = {
    renderer: this,
    name: name,
    points: points,
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);
    }
  };
};

BRp$d.generateEllipse = function () {
  return this.nodeShapes['ellipse'] = {
    renderer: this,
    name: 'ellipse',
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return checkInEllipse(x, y, width, height, centerX, centerY, padding);
    }
  };
};

BRp$d.generateRoundPolygon = function (name, points) {
  // Pre-compute control points
  // Since these points depend on the radius length (which in turns depend on the width/height of the node) we will only pre-compute
  // the unit vectors.
  // For simplicity the layout will be:
  // [ p0, UnitVectorP0P1, p1, UniVectorP1P2, ..., pn, UnitVectorPnP0 ]
  var allPoints = new Array(points.length * 2);

  for (var i = 0; i < points.length / 2; i++) {
    var sourceIndex = i * 2;
    var destIndex = void 0;

    if (i < points.length / 2 - 1) {
      destIndex = (i + 1) * 2;
    } else {
      destIndex = 0;
    }

    allPoints[i * 4] = points[sourceIndex];
    allPoints[i * 4 + 1] = points[sourceIndex + 1];
    var xDest = points[destIndex] - points[sourceIndex];
    var yDest = points[destIndex + 1] - points[sourceIndex + 1];
    var norm = Math.sqrt(xDest * xDest + yDest * yDest);
    allPoints[i * 4 + 2] = xDest / norm;
    allPoints[i * 4 + 3] = yDest / norm;
  }

  return this.nodeShapes[name] = {
    renderer: this,
    name: name,
    points: allPoints,
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl('round-polygon', context, centerX, centerY, width, height, this.points);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height);
    }
  };
};

BRp$d.generateRoundRectangle = function () {
  return this.nodeShapes['round-rectangle'] = this.nodeShapes['roundrectangle'] = {
    renderer: this,
    name: 'round-rectangle',
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      var cornerRadius = getRoundRectangleRadius(width, height);
      var diam = cornerRadius * 2; // Check hBox

      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
        return true;
      } // Check vBox


      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
        return true;
      } // Check top left quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {
        return true;
      } // Check top right quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {
        return true;
      } // Check bottom right quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
        return true;
      } // Check bottom left quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
        return true;
      }

      return false;
    }
  };
};

BRp$d.generateCutRectangle = function () {
  return this.nodeShapes['cut-rectangle'] = this.nodeShapes['cutrectangle'] = {
    renderer: this,
    name: 'cut-rectangle',
    cornerLength: getCutRectangleCornerLength(),
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {
      var cl = this.cornerLength;
      var hh = height / 2;
      var hw = width / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh; // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]

      return {
        topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],
        topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],
        bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],
        bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]
      };
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);
      var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);
      return polygonIntersectLine(x, y, pts, nodeX, nodeY);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      // Check hBox
      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {
        return true;
      } // Check vBox


      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {
        return true;
      }

      var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);
      return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);
    }
  };
};

BRp$d.generateBarrel = function () {
  return this.nodeShapes['barrel'] = {
    renderer: this,
    name: 'barrel',
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      // use two fixed t values for the bezier curve approximation
      var t0 = 0.15;
      var t1 = 0.5;
      var t2 = 0.85;
      var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);

      var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {
        // approximate curve pts based on the two t values
        var m0 = qbezierPtAt({
          x: pts[0],
          y: pts[1]
        }, {
          x: pts[2],
          y: pts[3]
        }, {
          x: pts[4],
          y: pts[5]
        }, t0);
        var m1 = qbezierPtAt({
          x: pts[0],
          y: pts[1]
        }, {
          x: pts[2],
          y: pts[3]
        }, {
          x: pts[4],
          y: pts[5]
        }, t1);
        var m2 = qbezierPtAt({
          x: pts[0],
          y: pts[1]
        }, {
          x: pts[2],
          y: pts[3]
        }, {
          x: pts[4],
          y: pts[5]
        }, t2);
        return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];
      };

      var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));
      return polygonIntersectLine(x, y, pts, nodeX, nodeY);
    },
    generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {
      var hh = height / 2;
      var hw = width / 2;
      var xBegin = centerX - hw;
      var xEnd = centerX + hw;
      var yBegin = centerY - hh;
      var yEnd = centerY + hh;
      var curveConstants = getBarrelCurveConstants(width, height);
      var hOffset = curveConstants.heightOffset;
      var wOffset = curveConstants.widthOffset;
      var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width; // points are in clockwise order, inner (imaginary) control pt on [4, 5]

      var pts = {
        topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],
        topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],
        bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],
        bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]
      };
      pts.topLeft.isTop = true;
      pts.topRight.isTop = true;
      pts.bottomLeft.isBottom = true;
      pts.bottomRight.isBottom = true;
      return pts;
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      var curveConstants = getBarrelCurveConstants(width, height);
      var hOffset = curveConstants.heightOffset;
      var wOffset = curveConstants.widthOffset; // Check hBox

      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {
        return true;
      } // Check vBox


      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {
        return true;
      }

      var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);

      var getCurveT = function getCurveT(x, y, curvePts) {
        var x0 = curvePts[4];
        var x1 = curvePts[2];
        var x2 = curvePts[0];
        var y0 = curvePts[5]; // var y1 = curvePts[ 3 ];

        var y2 = curvePts[1];
        var xMin = Math.min(x0, x2);
        var xMax = Math.max(x0, x2);
        var yMin = Math.min(y0, y2);
        var yMax = Math.max(y0, y2);

        if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {
          var coeff = bezierPtsToQuadCoeff(x0, x1, x2);
          var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);
          var validRoots = roots.filter(function (r) {
            return 0 <= r && r <= 1;
          });

          if (validRoots.length > 0) {
            return validRoots[0];
          }
        }

        return null;
      };

      var curveRegions = Object.keys(barrelCurvePts);

      for (var i = 0; i < curveRegions.length; i++) {
        var corner = curveRegions[i];
        var cornerPts = barrelCurvePts[corner];
        var t = getCurveT(x, y, cornerPts);

        if (t == null) {
          continue;
        }

        var y0 = cornerPts[5];
        var y1 = cornerPts[3];
        var y2 = cornerPts[1];
        var bezY = qbezierAt(y0, y1, y2, t);

        if (cornerPts.isTop && bezY <= y) {
          return true;
        }

        if (cornerPts.isBottom && y <= bezY) {
          return true;
        }
      }

      return false;
    }
  };
};

BRp$d.generateBottomRoundrectangle = function () {
  return this.nodeShapes['bottom-round-rectangle'] = this.nodeShapes['bottomroundrectangle'] = {
    renderer: this,
    name: 'bottom-round-rectangle',
    points: generateUnitNgonPointsFitToSquare(4, 0),
    draw: function draw(context, centerX, centerY, width, height) {
      this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);
    },
    intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {
      var topStartX = nodeX - (width / 2 + padding);
      var topStartY = nodeY - (height / 2 + padding);
      var topEndY = topStartY;
      var topEndX = nodeX + (width / 2 + padding);
      var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

      if (topIntersections.length > 0) {
        return topIntersections;
      }

      return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);
    },
    checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {
      var cornerRadius = getRoundRectangleRadius(width, height);
      var diam = 2 * cornerRadius; // Check hBox

      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {
        return true;
      } // Check vBox


      if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {
        return true;
      } // check non-rounded top side


      var outerWidth = width / 2 + 2 * padding;
      var outerHeight = height / 2 + 2 * padding;
      var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];

      if (pointInsidePolygonPoints(x, y, points)) {
        return true;
      } // Check bottom right quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
        return true;
      } // Check bottom left quarter circle


      if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {
        return true;
      }

      return false;
    }
  };
};

BRp$d.registerNodeShapes = function () {
  var nodeShapes = this.nodeShapes = {};
  var renderer = this;
  this.generateEllipse();
  this.generatePolygon('triangle', generateUnitNgonPointsFitToSquare(3, 0));
  this.generateRoundPolygon('round-triangle', generateUnitNgonPointsFitToSquare(3, 0));
  this.generatePolygon('rectangle', generateUnitNgonPointsFitToSquare(4, 0));
  nodeShapes['square'] = nodeShapes['rectangle'];
  this.generateRoundRectangle();
  this.generateCutRectangle();
  this.generateBarrel();
  this.generateBottomRoundrectangle();
  {
    var diamondPoints = [0, 1, 1, 0, 0, -1, -1, 0];
    this.generatePolygon('diamond', diamondPoints);
    this.generateRoundPolygon('round-diamond', diamondPoints);
  }
  this.generatePolygon('pentagon', generateUnitNgonPointsFitToSquare(5, 0));
  this.generateRoundPolygon('round-pentagon', generateUnitNgonPointsFitToSquare(5, 0));
  this.generatePolygon('hexagon', generateUnitNgonPointsFitToSquare(6, 0));
  this.generateRoundPolygon('round-hexagon', generateUnitNgonPointsFitToSquare(6, 0));
  this.generatePolygon('heptagon', generateUnitNgonPointsFitToSquare(7, 0));
  this.generateRoundPolygon('round-heptagon', generateUnitNgonPointsFitToSquare(7, 0));
  this.generatePolygon('octagon', generateUnitNgonPointsFitToSquare(8, 0));
  this.generateRoundPolygon('round-octagon', generateUnitNgonPointsFitToSquare(8, 0));
  var star5Points = new Array(20);
  {
    var outerPoints = generateUnitNgonPoints(5, 0);
    var innerPoints = generateUnitNgonPoints(5, Math.PI / 5); // Outer radius is 1; inner radius of star is smaller

    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;

    for (var i = 0; i < innerPoints.length / 2; i++) {
      innerPoints[i * 2] *= innerRadius;
      innerPoints[i * 2 + 1] *= innerRadius;
    }

    for (var i = 0; i < 20 / 4; i++) {
      star5Points[i * 4] = outerPoints[i * 2];
      star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];
      star5Points[i * 4 + 2] = innerPoints[i * 2];
      star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];
    }
  }
  star5Points = fitPolygonToSquare(star5Points);
  this.generatePolygon('star', star5Points);
  this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);
  this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);
  this.nodeShapes['concavehexagon'] = this.generatePolygon('concave-hexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);
  {
    var tagPoints = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];
    this.generatePolygon('tag', tagPoints);
    this.generateRoundPolygon('round-tag', tagPoints);
  }

  nodeShapes.makePolygon = function (points) {
    // use caching on user-specified polygons so they are as fast as native shapes
    var key = points.join('$');
    var name = 'polygon-' + key;
    var shape;

    if (shape = this[name]) {
      // got cached shape
      return shape;
    } // create and cache new shape


    return renderer.generatePolygon(name, points);
  };
};

var BRp$e = {};

BRp$e.timeToRender = function () {
  return this.redrawTotalTime / this.redrawCount;
};

BRp$e.redraw = function (options) {
  options = options || staticEmptyObject();
  var r = this;

  if (r.averageRedrawTime === undefined) {
    r.averageRedrawTime = 0;
  }

  if (r.lastRedrawTime === undefined) {
    r.lastRedrawTime = 0;
  }

  if (r.lastDrawTime === undefined) {
    r.lastDrawTime = 0;
  }

  r.requestedFrame = true;
  r.renderOptions = options;
};

BRp$e.beforeRender = function (fn, priority) {
  // the renderer can't add tick callbacks when destroyed
  if (this.destroyed) {
    return;
  }

  if (priority == null) {
    error('Priority is not optional for beforeRender');
  }

  var cbs = this.beforeRenderCallbacks;
  cbs.push({
    fn: fn,
    priority: priority
  }); // higher priority callbacks executed first

  cbs.sort(function (a, b) {
    return b.priority - a.priority;
  });
};

var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {
  var cbs = r.beforeRenderCallbacks;

  for (var i = 0; i < cbs.length; i++) {
    cbs[i].fn(willDraw, startTime);
  }
};

BRp$e.startRenderLoop = function () {
  var r = this;
  var cy = r.cy;

  if (r.renderLoopStarted) {
    return;
  } else {
    r.renderLoopStarted = true;
  }

  var renderFn = function renderFn(requestTime) {
    if (r.destroyed) {
      return;
    }

    if (cy.batching()) ; else if (r.requestedFrame && !r.skipFrame) {
      beforeRenderCallbacks(r, true, requestTime);
      var startTime = performanceNow();
      r.render(r.renderOptions);
      var endTime = r.lastDrawTime = performanceNow();

      if (r.averageRedrawTime === undefined) {
        r.averageRedrawTime = endTime - startTime;
      }

      if (r.redrawCount === undefined) {
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if (r.redrawTotalTime === undefined) {
        r.redrawTotalTime = 0;
      }

      var duration = endTime - startTime;
      r.redrawTotalTime += duration;
      r.lastRedrawTime = duration; // use a weighted average with a bias from the previous average so we don't spike so easily

      r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;
      r.requestedFrame = false;
    } else {
      beforeRenderCallbacks(r, false, requestTime);
    }

    r.skipFrame = false;
    requestAnimationFrame(renderFn);
  };

  requestAnimationFrame(renderFn);
};

var BaseRenderer = function BaseRenderer(options) {
  this.init(options);
};

var BR = BaseRenderer;
var BRp$f = BR.prototype;
BRp$f.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];

BRp$f.init = function (options) {
  var r = this;
  r.options = options;
  r.cy = options.cy;
  var ctr = r.container = options.cy.container(); // prepend a stylesheet in the head such that

  if (window$1) {
    var document = window$1.document;
    var head = document.head;
    var stylesheetId = '__________cytoscape_stylesheet';
    var className = '__________cytoscape_container';
    var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;

    if (ctr.className.indexOf(className) < 0) {
      ctr.className = (ctr.className || '') + ' ' + className;
    }

    if (!stylesheetAlreadyExists) {
      var stylesheet = document.createElement('style');
      stylesheet.id = stylesheetId;
      stylesheet.innerHTML = '.' + className + ' { position: relative; }';
      head.insertBefore(stylesheet, head.children[0]); // first so lowest priority
    }

    var computedStyle = window$1.getComputedStyle(ctr);
    var position = computedStyle.getPropertyValue('position');

    if (position === 'static') {
      warn('A Cytoscape container has style position:static and so can not use UI extensions properly');
    }
  }

  r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

  r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95]; //--Pointer-related data

  r.hoverData = {
    down: null,
    last: null,
    downTime: null,
    triggerMode: null,
    dragging: false,
    initialPan: [null, null],
    capture: false
  };
  r.dragData = {
    possibleDragElements: []
  };
  r.touchData = {
    start: null,
    capture: false,
    // These 3 fields related to tap, taphold events
    startPosition: [null, null, null, null, null, null],
    singleTouchStartTime: null,
    singleTouchMoved: true,
    now: [null, null, null, null, null, null],
    earlier: [null, null, null, null, null, null]
  };
  r.redraws = 0;
  r.showFps = options.showFps;
  r.debug = options.debug;
  r.hideEdgesOnViewport = options.hideEdgesOnViewport;
  r.textureOnViewport = options.textureOnViewport;
  r.wheelSensitivity = options.wheelSensitivity;
  r.motionBlurEnabled = options.motionBlur; // on by default

  r.forcedPixelRatio = number(options.pixelRatio) ? options.pixelRatio : null;
  r.motionBlur = options.motionBlur; // for initial kick off

  r.motionBlurOpacity = options.motionBlurOpacity;
  r.motionBlurTransparency = 1 - r.motionBlurOpacity;
  r.motionBlurPxRatio = 1;
  r.mbPxRBlurry = 1; //0.8;

  r.minMbLowQualFrames = 4;
  r.fullQualityMb = false;
  r.clearedForMotionBlur = [];
  r.desktopTapThreshold = options.desktopTapThreshold;
  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
  r.touchTapThreshold = options.touchTapThreshold;
  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
  r.tapholdDuration = 500;
  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.beforeRenderPriorities = {
    // higher priority execs before lower one
    animations: 400,
    eleCalcs: 300,
    eleTxrDeq: 200,
    lyrTxrDeq: 150,
    lyrTxrSkip: 100
  };
  r.registerNodeShapes();
  r.registerArrowShapes();
  r.registerCalculationListeners();
};

BRp$f.notify = function (eventName, eles) {
  var r = this;
  var cy = r.cy; // the renderer can't be notified after it's destroyed

  if (this.destroyed) {
    return;
  }

  if (eventName === 'init') {
    r.load();
    return;
  }

  if (eventName === 'destroy') {
    r.destroy();
    return;
  }

  if (eventName === 'add' || eventName === 'remove' || eventName === 'move' && cy.hasCompoundNodes() || eventName === 'load' || eventName === 'zorder' || eventName === 'mount') {
    r.invalidateCachedZSortedEles();
  }

  if (eventName === 'viewport') {
    r.redrawHint('select', true);
  }

  if (eventName === 'load' || eventName === 'resize' || eventName === 'mount') {
    r.invalidateContainerClientCoordsCache();
    r.matchCanvasSize(r.container);
  }

  r.redrawHint('eles', true);
  r.redrawHint('drag', true);
  this.startRenderLoop();
  this.redraw();
};

BRp$f.destroy = function () {
  var r = this;
  r.destroyed = true;
  r.cy.stopAnimationLoop();

  for (var i = 0; i < r.bindings.length; i++) {
    var binding = r.bindings[i];
    var b = binding;
    var tgt = b.target;
    (tgt.off || tgt.removeEventListener).apply(tgt, b.args);
  }

  r.bindings = [];
  r.beforeRenderCallbacks = [];
  r.onUpdateEleCalcsFns = [];

  if (r.removeObserver) {
    r.removeObserver.disconnect();
  }

  if (r.styleObserver) {
    r.styleObserver.disconnect();
  }

  if (r.resizeObserver) {
    r.resizeObserver.disconnect();
  }

  if (r.labelCalcDiv) {
    try {
      document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef
    } catch (e) {// ie10 issue #1014
    }
  }
};

BRp$f.isHeadless = function () {
  return false;
};

[BRp, BRp$a, BRp$b, BRp$c, BRp$d, BRp$e].forEach(function (props) {
  extend(BRp$f, props);
});

var fullFpsTime = 1000 / 60; // assume 60 frames per second

var defs = {
  setupDequeueing: function setupDequeueing(opts) {
    return function setupDequeueingImpl() {
      var self = this;
      var r = this.renderer;

      if (self.dequeueingSetup) {
        return;
      } else {
        self.dequeueingSetup = true;
      }

      var queueRedraw = util(function () {
        r.redrawHint('eles', true);
        r.redrawHint('drag', true);
        r.redraw();
      }, opts.deqRedrawThreshold);

      var dequeue = function dequeue(willDraw, frameStartTime) {
        var startTime = performanceNow();
        var avgRenderTime = r.averageRedrawTime;
        var renderTime = r.lastRedrawTime;
        var deqd = [];
        var extent = r.cy.extent();
        var pixelRatio = r.getPixelRatio(); // if we aren't in a tick that causes a draw, then the rendered style
        // queue won't automatically be flushed before dequeueing starts

        if (!willDraw) {
          r.flushRenderedStyleQueue();
        }

        while (true) {
          // eslint-disable-line no-constant-condition
          var now = performanceNow();
          var duration = now - startTime;
          var frameDuration = now - frameStartTime;

          if (renderTime < fullFpsTime) {
            // if we're rendering faster than the ideal fps, then do dequeueing
            // during all of the remaining frame time
            var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);

            if (frameDuration >= opts.deqFastCost * timeAvailable) {
              break;
            }
          } else {
            if (willDraw) {
              if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {
                break;
              }
            } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {
              break;
            }
          }

          var thisDeqd = opts.deq(self, pixelRatio, extent);

          if (thisDeqd.length > 0) {
            for (var i = 0; i < thisDeqd.length; i++) {
              deqd.push(thisDeqd[i]);
            }
          } else {
            break;
          }
        } // callbacks on dequeue


        if (deqd.length > 0) {
          opts.onDeqd(self, deqd);

          if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {
            queueRedraw();
          }
        }
      };

      var priority = opts.priority || noop;
      r.beforeRender(dequeue, priority(self));
    };
  }
};

// Uses keys so elements may share the same cache.

var ElementTextureCacheLookup =
/*#__PURE__*/
function () {
  function ElementTextureCacheLookup(getKey) {
    var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;

    _classCallCheck(this, ElementTextureCacheLookup);

    this.idsByKey = new Map$1();
    this.keyForId = new Map$1();
    this.cachesByLvl = new Map$1();
    this.lvls = [];
    this.getKey = getKey;
    this.doesEleInvalidateKey = doesEleInvalidateKey;
  }

  _createClass(ElementTextureCacheLookup, [{
    key: "getIdsFor",
    value: function getIdsFor(key) {
      if (key == null) {
        error("Can not get id list for null key");
      }

      var idsByKey = this.idsByKey;
      var ids = this.idsByKey.get(key);

      if (!ids) {
        ids = new Set$1();
        idsByKey.set(key, ids);
      }

      return ids;
    }
  }, {
    key: "addIdForKey",
    value: function addIdForKey(key, id) {
      if (key != null) {
        this.getIdsFor(key).add(id);
      }
    }
  }, {
    key: "deleteIdForKey",
    value: function deleteIdForKey(key, id) {
      if (key != null) {
        this.getIdsFor(key)["delete"](id);
      }
    }
  }, {
    key: "getNumberOfIdsForKey",
    value: function getNumberOfIdsForKey(key) {
      if (key == null) {
        return 0;
      } else {
        return this.getIdsFor(key).size;
      }
    }
  }, {
    key: "updateKeyMappingFor",
    value: function updateKeyMappingFor(ele) {
      var id = ele.id();
      var prevKey = this.keyForId.get(id);
      var currKey = this.getKey(ele);
      this.deleteIdForKey(prevKey, id);
      this.addIdForKey(currKey, id);
      this.keyForId.set(id, currKey);
    }
  }, {
    key: "deleteKeyMappingFor",
    value: function deleteKeyMappingFor(ele) {
      var id = ele.id();
      var prevKey = this.keyForId.get(id);
      this.deleteIdForKey(prevKey, id);
      this.keyForId["delete"](id);
    }
  }, {
    key: "keyHasChangedFor",
    value: function keyHasChangedFor(ele) {
      var id = ele.id();
      var prevKey = this.keyForId.get(id);
      var newKey = this.getKey(ele);
      return prevKey !== newKey;
    }
  }, {
    key: "isInvalid",
    value: function isInvalid(ele) {
      return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);
    }
  }, {
    key: "getCachesAt",
    value: function getCachesAt(lvl) {
      var cachesByLvl = this.cachesByLvl,
          lvls = this.lvls;
      var caches = cachesByLvl.get(lvl);

      if (!caches) {
        caches = new Map$1();
        cachesByLvl.set(lvl, caches);
        lvls.push(lvl);
      }

      return caches;
    }
  }, {
    key: "getCache",
    value: function getCache(key, lvl) {
      return this.getCachesAt(lvl).get(key);
    }
  }, {
    key: "get",
    value: function get(ele, lvl) {
      var key = this.getKey(ele);
      var cache = this.getCache(key, lvl); // getting for an element may need to add to the id list b/c eles can share keys

      if (cache != null) {
        this.updateKeyMappingFor(ele);
      }

      return cache;
    }
  }, {
    key: "getForCachedKey",
    value: function getForCachedKey(ele, lvl) {
      var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key

      var cache = this.getCache(key, lvl);
      return cache;
    }
  }, {
    key: "hasCache",
    value: function hasCache(key, lvl) {
      return this.getCachesAt(lvl).has(key);
    }
  }, {
    key: "has",
    value: function has(ele, lvl) {
      var key = this.getKey(ele);
      return this.hasCache(key, lvl);
    }
  }, {
    key: "setCache",
    value: function setCache(key, lvl, cache) {
      cache.key = key;
      this.getCachesAt(lvl).set(key, cache);
    }
  }, {
    key: "set",
    value: function set(ele, lvl, cache) {
      var key = this.getKey(ele);
      this.setCache(key, lvl, cache);
      this.updateKeyMappingFor(ele);
    }
  }, {
    key: "deleteCache",
    value: function deleteCache(key, lvl) {
      this.getCachesAt(lvl)["delete"](key);
    }
  }, {
    key: "delete",
    value: function _delete(ele, lvl) {
      var key = this.getKey(ele);
      this.deleteCache(key, lvl);
    }
  }, {
    key: "invalidateKey",
    value: function invalidateKey(key) {
      var _this = this;

      this.lvls.forEach(function (lvl) {
        return _this.deleteCache(key, lvl);
      });
    } // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)

  }, {
    key: "invalidate",
    value: function invalidate(ele) {
      var id = ele.id();
      var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)

      this.deleteKeyMappingFor(ele);
      var entireKeyInvalidated = this.doesEleInvalidateKey(ele);

      if (entireKeyInvalidated) {
        // clear mapping for current key
        this.invalidateKey(key);
      }

      return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;
    }
  }]);

  return ElementTextureCacheLookup;
}();

var minTxrH = 25; // the size of the texture cache for small height eles (special case)

var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up

var minLvl = -4; // when scaling smaller than that we don't need to re-render

var maxLvl = 3; // when larger than this scale just render directly (caching is not helpful)

var maxZoom = 7.99; // beyond this zoom level, layered textures are not used

var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps

var defTxrWidth = 1024; // default/minimum texture width

var maxTxrW = 1024; // the maximum width of a texture

var maxTxrH = 1024; // the maximum height of a texture

var minUtility = 0.2; // if usage of texture is less than this, it is retired

var maxFullness = 0.8; // fullness of texture after which queue removal is checked

var maxFullnessChecks = 10; // dequeued after this many checks

var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame

var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time

var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing

var deqFastCost = 0.9; // % of frame time to be used when >60fps

var deqRedrawThreshold = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile

var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch

var getTxrReasons = {
  dequeue: 'dequeue',
  downscale: 'downscale',
  highQuality: 'highQuality'
};
var initDefaults = defaults({
  getKey: null,
  doesEleInvalidateKey: falsify,
  drawElement: null,
  getBoundingBox: null,
  getRotationPoint: null,
  getRotationOffset: null,
  isVisible: trueify,
  allowEdgeTxrCaching: true,
  allowParentTxrCaching: true
});

var ElementTextureCache = function ElementTextureCache(renderer, initOptions) {
  var self = this;
  self.renderer = renderer;
  self.onDequeues = [];
  var opts = initDefaults(initOptions);
  extend(self, opts);
  self.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);
  self.setupDequeueing();
};

var ETCp = ElementTextureCache.prototype;
ETCp.reasons = getTxrReasons; // the list of textures in which new subtextures for elements can be placed

ETCp.getTextureQueue = function (txrH) {
  var self = this;
  self.eleImgCaches = self.eleImgCaches || {};
  return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];
}; // the list of usused textures which can be recycled (in use in texture queue)


ETCp.getRetiredTextureQueue = function (txrH) {
  var self = this;
  var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};
  var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];
  return rtxtrQ;
}; // queue of element draw requests at different scale levels


ETCp.getElementQueue = function () {
  var self = this;
  var q = self.eleCacheQueue = self.eleCacheQueue || new Heap(function (a, b) {
    return b.reqs - a.reqs;
  });
  return q;
}; // queue of element draw requests at different scale levels (element id lookup)


ETCp.getElementKeyToQueue = function () {
  var self = this;
  var k2q = self.eleKeyToCacheQueue = self.eleKeyToCacheQueue || {};
  return k2q;
};

ETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {
  var self = this;
  var r = this.renderer;
  var zoom = r.cy.zoom();
  var lookup = this.lookup;

  if (bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible()) {
    return null;
  }

  if (!self.allowEdgeTxrCaching && ele.isEdge() || !self.allowParentTxrCaching && ele.isParent()) {
    return null;
  }

  if (lvl == null) {
    lvl = Math.ceil(log2(zoom * pxRatio));
  }

  if (lvl < minLvl) {
    lvl = minLvl;
  } else if (zoom >= maxZoom || lvl > maxLvl) {
    return null;
  }

  var scale = Math.pow(2, lvl);
  var eleScaledH = bb.h * scale;
  var eleScaledW = bb.w * scale;
  var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);

  if (!this.isVisible(ele, scaledLabelShown)) {
    return null;
  }

  var eleCache = lookup.get(ele, lvl); // if this get was on an unused/invalidated cache, then restore the texture usage metric

  if (eleCache && eleCache.invalidated) {
    eleCache.invalidated = false;
    eleCache.texture.invalidatedWidth -= eleCache.width;
  }

  if (eleCache) {
    return eleCache;
  }

  var txrH; // which texture height this ele belongs to

  if (eleScaledH <= minTxrH) {
    txrH = minTxrH;
  } else if (eleScaledH <= txrStepH) {
    txrH = txrStepH;
  } else {
    txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;
  }

  if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {
    return null; // caching large elements is not efficient
  }

  var txrQ = self.getTextureQueue(txrH); // first try the second last one in case it has space at the end

  var txr = txrQ[txrQ.length - 2];

  var addNewTxr = function addNewTxr() {
    return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);
  }; // try the last one if there is no second last one


  if (!txr) {
    txr = txrQ[txrQ.length - 1];
  } // if the last one doesn't exist, we need a first one


  if (!txr) {
    txr = addNewTxr();
  } // if there's no room in the current texture, we need a new one


  if (txr.width - txr.usedWidth < eleScaledW) {
    txr = addNewTxr();
  }

  var scalableFrom = function scalableFrom(otherCache) {
    return otherCache && otherCache.scaledLabelShown === scaledLabelShown;
  };

  var deqing = reason && reason === getTxrReasons.dequeue;
  var highQualityReq = reason && reason === getTxrReasons.highQuality;
  var downscaleReq = reason && reason === getTxrReasons.downscale;
  var higherCache; // the nearest cache with a higher level

  for (var l = lvl + 1; l <= maxLvl; l++) {
    var c = lookup.get(ele, l);

    if (c) {
      higherCache = c;
      break;
    }
  }

  var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;

  var downscale = function downscale() {
    txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);
  }; // reset ele area in texture


  txr.context.setTransform(1, 0, 0, 1, 0, 0);
  txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);

  if (scalableFrom(oneUpCache)) {
    // then we can relatively cheaply rescale the existing image w/o rerendering
    downscale();
  } else if (scalableFrom(higherCache)) {
    // then use the higher cache for now and queue the next level down
    // to cheaply scale towards the smaller level
    if (highQualityReq) {
      for (var _l = higherCache.level; _l > lvl; _l--) {
        oneUpCache = self.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);
      }

      downscale();
    } else {
      self.queueElement(ele, higherCache.level - 1);
      return higherCache;
    }
  } else {
    var lowerCache; // the nearest cache with a lower level

    if (!deqing && !highQualityReq && !downscaleReq) {
      for (var _l2 = lvl - 1; _l2 >= minLvl; _l2--) {
        var _c = lookup.get(ele, _l2);

        if (_c) {
          lowerCache = _c;
          break;
        }
      }
    }

    if (scalableFrom(lowerCache)) {
      // then use the lower quality cache for now and queue the better one for later
      self.queueElement(ele, lvl);
      return lowerCache;
    }

    txr.context.translate(txr.usedWidth, 0);
    txr.context.scale(scale, scale);
    this.drawElement(txr.context, ele, bb, scaledLabelShown, false);
    txr.context.scale(1 / scale, 1 / scale);
    txr.context.translate(-txr.usedWidth, 0);
  }

  eleCache = {
    x: txr.usedWidth,
    texture: txr,
    level: lvl,
    scale: scale,
    width: eleScaledW,
    height: eleScaledH,
    scaledLabelShown: scaledLabelShown
  };
  txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);
  txr.eleCaches.push(eleCache);
  lookup.set(ele, lvl, eleCache);
  self.checkTextureFullness(txr);
  return eleCache;
};

ETCp.invalidateElements = function (eles) {
  for (var i = 0; i < eles.length; i++) {
    this.invalidateElement(eles[i]);
  }
};

ETCp.invalidateElement = function (ele) {
  var self = this;
  var lookup = self.lookup;
  var caches = [];
  var invalid = lookup.isInvalid(ele);

  if (!invalid) {
    return; // override the invalidation request if the element key has not changed
  }

  for (var lvl = minLvl; lvl <= maxLvl; lvl++) {
    var cache = lookup.getForCachedKey(ele, lvl);

    if (cache) {
      caches.push(cache);
    }
  }

  var noOtherElesUseCache = lookup.invalidate(ele);

  if (noOtherElesUseCache) {
    for (var i = 0; i < caches.length; i++) {
      var _cache = caches[i];
      var txr = _cache.texture; // remove space from the texture it belongs to

      txr.invalidatedWidth += _cache.width; // mark the cache as invalidated

      _cache.invalidated = true; // retire the texture if its utility is low

      self.checkTextureUtility(txr);
    }
  } // remove from queue since the old req was for the old state


  self.removeFromQueue(ele);
};

ETCp.checkTextureUtility = function (txr) {
  // invalidate all entries in the cache if the cache size is small
  if (txr.invalidatedWidth >= minUtility * txr.width) {
    this.retireTexture(txr);
  }
};

ETCp.checkTextureFullness = function (txr) {
  // if texture has been mostly filled and passed over several times, remove
  // it from the queue so we don't need to waste time looking at it to put new things
  var self = this;
  var txrQ = self.getTextureQueue(txr.height);

  if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {
    removeFromArray(txrQ, txr);
  } else {
    txr.fullnessChecks++;
  }
};

ETCp.retireTexture = function (txr) {
  var self = this;
  var txrH = txr.height;
  var txrQ = self.getTextureQueue(txrH);
  var lookup = this.lookup; // retire the texture from the active / searchable queue:

  removeFromArray(txrQ, txr);
  txr.retired = true; // remove the refs from the eles to the caches:

  var eleCaches = txr.eleCaches;

  for (var i = 0; i < eleCaches.length; i++) {
    var eleCache = eleCaches[i];
    lookup.deleteCache(eleCache.key, eleCache.level);
  }

  clearArray(eleCaches); // add the texture to a retired queue so it can be recycled in future:

  var rtxtrQ = self.getRetiredTextureQueue(txrH);
  rtxtrQ.push(txr);
};

ETCp.addTexture = function (txrH, minW) {
  var self = this;
  var txrQ = self.getTextureQueue(txrH);
  var txr = {};
  txrQ.push(txr);
  txr.eleCaches = [];
  txr.height = txrH;
  txr.width = Math.max(defTxrWidth, minW);
  txr.usedWidth = 0;
  txr.invalidatedWidth = 0;
  txr.fullnessChecks = 0;
  txr.canvas = self.renderer.makeOffscreenCanvas(txr.width, txr.height);
  txr.context = txr.canvas.getContext('2d');
  return txr;
};

ETCp.recycleTexture = function (txrH, minW) {
  var self = this;
  var txrQ = self.getTextureQueue(txrH);
  var rtxtrQ = self.getRetiredTextureQueue(txrH);

  for (var i = 0; i < rtxtrQ.length; i++) {
    var txr = rtxtrQ[i];

    if (txr.width >= minW) {
      txr.retired = false;
      txr.usedWidth = 0;
      txr.invalidatedWidth = 0;
      txr.fullnessChecks = 0;
      clearArray(txr.eleCaches);
      txr.context.setTransform(1, 0, 0, 1, 0, 0);
      txr.context.clearRect(0, 0, txr.width, txr.height);
      removeFromArray(rtxtrQ, txr);
      txrQ.push(txr);
      return txr;
    }
  }
};

ETCp.queueElement = function (ele, lvl) {
  var self = this;
  var q = self.getElementQueue();
  var k2q = self.getElementKeyToQueue();
  var key = this.getKey(ele);
  var existingReq = k2q[key];

  if (existingReq) {
    // use the max lvl b/c in between lvls are cheap to make
    existingReq.level = Math.max(existingReq.level, lvl);
    existingReq.eles.merge(ele);
    existingReq.reqs++;
    q.updateItem(existingReq);
  } else {
    var req = {
      eles: ele.spawn().merge(ele),
      level: lvl,
      reqs: 1,
      key: key
    };
    q.push(req);
    k2q[key] = req;
  }
};

ETCp.dequeue = function (pxRatio
/*, extent*/
) {
  var self = this;
  var q = self.getElementQueue();
  var k2q = self.getElementKeyToQueue();
  var dequeued = [];
  var lookup = self.lookup;

  for (var i = 0; i < maxDeqSize; i++) {
    if (q.size() > 0) {
      var req = q.pop();
      var key = req.key;
      var ele = req.eles[0]; // all eles have the same key

      var cacheExists = lookup.hasCache(ele, req.level); // clear out the key to req lookup

      k2q[key] = null; // dequeueing isn't necessary with an existing cache

      if (cacheExists) {
        continue;
      }

      dequeued.push(req);
      var bb = self.getBoundingBox(ele);
      self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);
    } else {
      break;
    }
  }

  return dequeued;
};

ETCp.removeFromQueue = function (ele) {
  var self = this;
  var q = self.getElementQueue();
  var k2q = self.getElementKeyToQueue();
  var key = this.getKey(ele);
  var req = k2q[key];

  if (req != null) {
    if (req.eles.length === 1) {
      // remove if last ele in the req
      // bring to front of queue
      req.reqs = MAX_INT;
      q.updateItem(req);
      q.pop(); // remove from queue

      k2q[key] = null; // remove from lookup map
    } else {
      // otherwise just remove ele from req
      req.eles.unmerge(ele);
    }
  }
};

ETCp.onDequeue = function (fn) {
  this.onDequeues.push(fn);
};

ETCp.offDequeue = function (fn) {
  removeFromArray(this.onDequeues, fn);
};

ETCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold,
  deqCost: deqCost,
  deqAvgCost: deqAvgCost,
  deqNoDrawCost: deqNoDrawCost,
  deqFastCost: deqFastCost,
  deq: function deq(self, pxRatio, extent) {
    return self.dequeue(pxRatio, extent);
  },
  onDeqd: function onDeqd(self, deqd) {
    for (var i = 0; i < self.onDequeues.length; i++) {
      var fn = self.onDequeues[i];
      fn(deqd);
    }
  },
  shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {
    for (var i = 0; i < deqd.length; i++) {
      var eles = deqd[i].eles;

      for (var j = 0; j < eles.length; j++) {
        var bb = eles[j].boundingBox();

        if (boundingBoxesIntersect(bb, extent)) {
          return true;
        }
      }
    }

    return false;
  },
  priority: function priority(self) {
    return self.renderer.beforeRenderPriorities.eleTxrDeq;
  }
});

var defNumLayers = 1; // default number of layers to use

var minLvl$1 = -4; // when scaling smaller than that we don't need to re-render

var maxLvl$1 = 2; // when larger than this scale just render directly (caching is not helpful)

var maxZoom$1 = 3.99; // beyond this zoom level, layered textures are not used

var deqRedrawThreshold$1 = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile

var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates

var deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame

var deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time

var deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing

var deqFastCost$1 = 0.9; // % of frame time to be used when >60fps

var maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch

var invalidThreshold = 250; // time threshold for disabling b/c of invalidations

var maxLayerArea = 4000 * 4000; // layers can't be bigger than this

var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)
// var log = function(){ console.log.apply( console, arguments ); };

var LayeredTextureCache = function LayeredTextureCache(renderer) {
  var self = this;
  var r = self.renderer = renderer;
  var cy = r.cy;
  self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]

  self.firstGet = true;
  self.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;
  self.skipping = false;
  self.eleTxrDeqs = cy.collection();
  self.scheduleElementRefinement = util(function () {
    self.refineElementTextures(self.eleTxrDeqs);
    self.eleTxrDeqs.unmerge(self.eleTxrDeqs);
  }, refineEleDebounceTime);
  r.beforeRender(function (willDraw, now) {
    if (now - self.lastInvalidationTime <= invalidThreshold) {
      self.skipping = true;
    } else {
      self.skipping = false;
    }
  }, r.beforeRenderPriorities.lyrTxrSkip);

  var qSort = function qSort(a, b) {
    return b.reqs - a.reqs;
  };

  self.layersQueue = new Heap(qSort);
  self.setupDequeueing();
};

var LTCp = LayeredTextureCache.prototype;
var layerIdPool = 0;
var MAX_INT$1 = Math.pow(2, 53) - 1;

LTCp.makeLayer = function (bb, lvl) {
  var scale = Math.pow(2, lvl);
  var w = Math.ceil(bb.w * scale);
  var h = Math.ceil(bb.h * scale);
  var canvas = this.renderer.makeOffscreenCanvas(w, h);
  var layer = {
    id: layerIdPool = ++layerIdPool % MAX_INT$1,
    bb: bb,
    level: lvl,
    width: w,
    height: h,
    canvas: canvas,
    context: canvas.getContext('2d'),
    eles: [],
    elesQueue: [],
    reqs: 0
  }; // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);

  var cxt = layer.context;
  var dx = -layer.bb.x1;
  var dy = -layer.bb.y1; // do the transform on creation to save cycles (it's the same for all eles)

  cxt.scale(scale, scale);
  cxt.translate(dx, dy);
  return layer;
};

LTCp.getLayers = function (eles, pxRatio, lvl) {
  var self = this;
  var r = self.renderer;
  var cy = r.cy;
  var zoom = cy.zoom();
  var firstGet = self.firstGet;
  self.firstGet = false; // log('--\nget layers with %s eles', eles.length);
  //log eles.map(function(ele){ return ele.id() }) );

  if (lvl == null) {
    lvl = Math.ceil(log2(zoom * pxRatio));

    if (lvl < minLvl$1) {
      lvl = minLvl$1;
    } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {
      return null;
    }
  }

  self.validateLayersElesOrdering(lvl, eles);
  var layersByLvl = self.layersByLevel;
  var scale = Math.pow(2, lvl);
  var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];
  var bb;
  var lvlComplete = self.levelIsComplete(lvl, eles);
  var tmpLayers;

  var checkTempLevels = function checkTempLevels() {
    var canUseAsTmpLvl = function canUseAsTmpLvl(l) {
      self.validateLayersElesOrdering(l, eles);

      if (self.levelIsComplete(l, eles)) {
        tmpLayers = layersByLvl[l];
        return true;
      }
    };

    var checkLvls = function checkLvls(dir) {
      if (tmpLayers) {
        return;
      }

      for (var l = lvl + dir; minLvl$1 <= l && l <= maxLvl$1; l += dir) {
        if (canUseAsTmpLvl(l)) {
          break;
        }
      }
    };

    checkLvls(+1);
    checkLvls(-1); // remove the invalid layers; they will be replaced as needed later in this function

    for (var i = layers.length - 1; i >= 0; i--) {
      var layer = layers[i];

      if (layer.invalid) {
        removeFromArray(layers, layer);
      }
    }
  };

  if (!lvlComplete) {
    // if the current level is incomplete, then use the closest, best quality layerset temporarily
    // and later queue the current layerset so we can get the proper quality level soon
    checkTempLevels();
  } else {
    // log('level complete, using existing layers\n--');
    return layers;
  }

  var getBb = function getBb() {
    if (!bb) {
      bb = makeBoundingBox();

      for (var i = 0; i < eles.length; i++) {
        updateBoundingBox(bb, eles[i].boundingBox());
      }
    }

    return bb;
  };

  var makeLayer = function makeLayer(opts) {
    opts = opts || {};
    var after = opts.after;
    getBb();
    var area = bb.w * scale * (bb.h * scale);

    if (area > maxLayerArea) {
      return null;
    }

    var layer = self.makeLayer(bb, lvl);

    if (after != null) {
      var index = layers.indexOf(after) + 1;
      layers.splice(index, 0, layer);
    } else if (opts.insert === undefined || opts.insert) {
      // no after specified => first layer made so put at start
      layers.unshift(layer);
    } // if( tmpLayers ){
    //self.queueLayer( layer );
    // }


    return layer;
  };

  if (self.skipping && !firstGet) {
    // log('skip layers');
    return null;
  } // log('do layers');


  var layer = null;
  var maxElesPerLayer = eles.length / defNumLayers;
  var allowLazyQueueing =  !firstGet;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {}; // log('look at ele', ele.id());

    var existingLayer = caches[lvl];

    if (existingLayer) {
      // reuse layer for later eles
      // log('reuse layer for', ele.id());
      layer = existingLayer;
      continue;
    }

    if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {
      // log('make new layer for ele %s', ele.id());
      layer = makeLayer({
        insert: true,
        after: layer
      }); // if now layer can be built then we can't use layers at this level

      if (!layer) {
        return null;
      } // log('new layer with id %s', layer.id);

    }

    if (tmpLayers || allowLazyQueueing) {
      // log('queue ele %s in layer %s', ele.id(), layer.id);
      self.queueLayer(layer, ele);
    } else {
      // log('draw ele %s in layer %s', ele.id(), layer.id);
      self.drawEleInLayer(layer, ele, lvl, pxRatio);
    }

    layer.eles.push(ele);
    caches[lvl] = layer;
  } // log('--');


  if (tmpLayers) {
    // then we only queued the current layerset and can't draw it yet
    return tmpLayers;
  }

  if (allowLazyQueueing) {
    // log('lazy queue level', lvl);
    return null;
  }

  return layers;
}; // a layer may want to use an ele cache of a higher level to avoid blurriness
// so the layer level might not equal the ele level


LTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {
  return lvl;
};

LTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {
  var self = this;
  var r = this.renderer;
  var context = layer.context;
  var bb = ele.boundingBox();

  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
    return;
  }

  lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);

  {
    r.setImgSmoothing(context, false);
  }

  {
    r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);
  }

  {
    r.setImgSmoothing(context, true);
  }
};

LTCp.levelIsComplete = function (lvl, eles) {
  var self = this;
  var layers = self.layersByLevel[lvl];

  if (!layers || layers.length === 0) {
    return false;
  }

  var numElesInLayers = 0;

  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i]; // if there are any eles needed to be drawn yet, the level is not complete

    if (layer.reqs > 0) {
      return false;
    } // if the layer is invalid, the level is not complete


    if (layer.invalid) {
      return false;
    }

    numElesInLayers += layer.eles.length;
  } // we should have exactly the number of eles passed in to be complete


  if (numElesInLayers !== eles.length) {
    return false;
  }

  return true;
};

LTCp.validateLayersElesOrdering = function (lvl, eles) {
  var layers = this.layersByLevel[lvl];

  if (!layers) {
    return;
  } // if in a layer the eles are not in the same order, then the layer is invalid
  // (i.e. there is an ele in between the eles in the layer)


  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i];
    var offset = -1; // find the offset

    for (var j = 0; j < eles.length; j++) {
      if (layer.eles[0] === eles[j]) {
        offset = j;
        break;
      }
    }

    if (offset < 0) {
      // then the layer has nonexistant elements and is invalid
      this.invalidateLayer(layer);
      continue;
    } // the eles in the layer must be in the same continuous order, else the layer is invalid


    var o = offset;

    for (var j = 0; j < layer.eles.length; j++) {
      if (layer.eles[j] !== eles[o + j]) {
        // log('invalidate based on ordering', layer.id);
        this.invalidateLayer(layer);
        break;
      }
    }
  }
};

LTCp.updateElementsInLayers = function (eles, update) {
  var self = this;
  var isEles = element(eles[0]); // collect udpated elements (cascaded from the layers) and update each
  // layer itself along the way

  for (var i = 0; i < eles.length; i++) {
    var req = isEles ? null : eles[i];
    var ele = isEles ? eles[i] : eles[i].ele;
    var rs = ele._private.rscratch;
    var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};

    for (var l = minLvl$1; l <= maxLvl$1; l++) {
      var layer = caches[l];

      if (!layer) {
        continue;
      } // if update is a request from the ele cache, then it affects only
      // the matching level


      if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {
        continue;
      }

      update(layer, ele, req);
    }
  }
};

LTCp.haveLayers = function () {
  var self = this;
  var haveLayers = false;

  for (var l = minLvl$1; l <= maxLvl$1; l++) {
    var layers = self.layersByLevel[l];

    if (layers && layers.length > 0) {
      haveLayers = true;
      break;
    }
  }

  return haveLayers;
};

LTCp.invalidateElements = function (eles) {
  var self = this;

  if (eles.length === 0) {
    return;
  }

  self.lastInvalidationTime = performanceNow(); // log('update invalidate layer time from eles');

  if (eles.length === 0 || !self.haveLayers()) {
    return;
  }

  self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {
    self.invalidateLayer(layer);
  });
};

LTCp.invalidateLayer = function (layer) {
  // log('update invalidate layer time');
  this.lastInvalidationTime = performanceNow();

  if (layer.invalid) {
    return;
  } // save cycles


  var lvl = layer.level;
  var eles = layer.eles;
  var layers = this.layersByLevel[lvl]; // log('invalidate layer', layer.id );

  removeFromArray(layers, layer); // layer.eles = [];

  layer.elesQueue = [];
  layer.invalid = true;

  if (layer.replacement) {
    layer.replacement.invalid = true;
  }

  for (var i = 0; i < eles.length; i++) {
    var caches = eles[i]._private.rscratch.imgLayerCaches;

    if (caches) {
      caches[lvl] = null;
    }
  }
};

LTCp.refineElementTextures = function (eles) {
  var self = this; // log('refine', eles.length);

  self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {
    var rLyr = layer.replacement;

    if (!rLyr) {
      rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);
      rLyr.replaces = layer;
      rLyr.eles = layer.eles; // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);
    }

    if (!rLyr.reqs) {
      for (var i = 0; i < rLyr.eles.length; i++) {
        self.queueLayer(rLyr, rLyr.eles[i]);
      } // log('queue replacement layer refinement', rLyr.id);

    }
  });
};

LTCp.enqueueElementRefinement = function (ele) {

  this.eleTxrDeqs.merge(ele);
  this.scheduleElementRefinement();
};

LTCp.queueLayer = function (layer, ele) {
  var self = this;
  var q = self.layersQueue;
  var elesQ = layer.elesQueue;
  var hasId = elesQ.hasId = elesQ.hasId || {}; // if a layer is going to be replaced, queuing is a waste of time

  if (layer.replacement) {
    return;
  }

  if (ele) {
    if (hasId[ele.id()]) {
      return;
    }

    elesQ.push(ele);
    hasId[ele.id()] = true;
  }

  if (layer.reqs) {
    layer.reqs++;
    q.updateItem(layer);
  } else {
    layer.reqs = 1;
    q.push(layer);
  }
};

LTCp.dequeue = function (pxRatio) {
  var self = this;
  var q = self.layersQueue;
  var deqd = [];
  var eleDeqs = 0;

  while (eleDeqs < maxDeqSize$1) {
    if (q.size() === 0) {
      break;
    }

    var layer = q.peek(); // if a layer has been or will be replaced, then don't waste time with it

    if (layer.replacement) {
      // log('layer %s in queue skipped b/c it already has a replacement', layer.id);
      q.pop();
      continue;
    } // if this is a replacement layer that has been superceded, then forget it


    if (layer.replaces && layer !== layer.replaces.replacement) {
      // log('layer is no longer the most uptodate replacement; dequeued', layer.id)
      q.pop();
      continue;
    }

    if (layer.invalid) {
      // log('replacement layer %s is invalid; dequeued', layer.id);
      q.pop();
      continue;
    }

    var ele = layer.elesQueue.shift();

    if (ele) {
      // log('dequeue layer %s', layer.id);
      self.drawEleInLayer(layer, ele, layer.level, pxRatio);
      eleDeqs++;
    }

    if (deqd.length === 0) {
      // we need only one entry in deqd to queue redrawing etc
      deqd.push(true);
    } // if the layer has all its eles done, then remove from the queue


    if (layer.elesQueue.length === 0) {
      q.pop();
      layer.reqs = 0; // log('dequeue of layer %s complete', layer.id);
      // when a replacement layer is dequeued, it replaces the old layer in the level

      if (layer.replaces) {
        self.applyLayerReplacement(layer);
      }

      self.requestRedraw();
    }
  }

  return deqd;
};

LTCp.applyLayerReplacement = function (layer) {
  var self = this;
  var layersInLevel = self.layersByLevel[layer.level];
  var replaced = layer.replaces;
  var index = layersInLevel.indexOf(replaced); // if the replaced layer is not in the active list for the level, then replacing
  // refs would be a mistake (i.e. overwriting the true active layer)

  if (index < 0 || replaced.invalid) {
    // log('replacement layer would have no effect', layer.id);
    return;
  }

  layersInLevel[index] = layer; // replace level ref
  // replace refs in eles

  for (var i = 0; i < layer.eles.length; i++) {
    var _p = layer.eles[i]._private;
    var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};

    if (cache) {
      cache[layer.level] = layer;
    }
  } // log('apply replacement layer %s over %s', layer.id, replaced.id);


  self.requestRedraw();
};

LTCp.requestRedraw = util(function () {
  var r = this.renderer;
  r.redrawHint('eles', true);
  r.redrawHint('drag', true);
  r.redraw();
}, 100);
LTCp.setupDequeueing = defs.setupDequeueing({
  deqRedrawThreshold: deqRedrawThreshold$1,
  deqCost: deqCost$1,
  deqAvgCost: deqAvgCost$1,
  deqNoDrawCost: deqNoDrawCost$1,
  deqFastCost: deqFastCost$1,
  deq: function deq(self, pxRatio) {
    return self.dequeue(pxRatio);
  },
  onDeqd: noop,
  shouldRedraw: trueify,
  priority: function priority(self) {
    return self.renderer.beforeRenderPriorities.lyrTxrDeq;
  }
});

var CRp = {};
var impl;

function polygon(context, points) {
  for (var i = 0; i < points.length; i++) {
    var pt = points[i];
    context.lineTo(pt.x, pt.y);
  }
}

function triangleBackcurve(context, points, controlPoint) {
  var firstPt;

  for (var i = 0; i < points.length; i++) {
    var pt = points[i];

    if (i === 0) {
      firstPt = pt;
    }

    context.lineTo(pt.x, pt.y);
  }

  context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);
}

function triangleTee(context, trianglePoints, teePoints) {
  if (context.beginPath) {
    context.beginPath();
  }

  var triPts = trianglePoints;

  for (var i = 0; i < triPts.length; i++) {
    var pt = triPts[i];
    context.lineTo(pt.x, pt.y);
  }

  var teePts = teePoints;
  var firstTeePt = teePoints[0];
  context.moveTo(firstTeePt.x, firstTeePt.y);

  for (var i = 1; i < teePts.length; i++) {
    var pt = teePts[i];
    context.lineTo(pt.x, pt.y);
  }

  if (context.closePath) {
    context.closePath();
  }
}

function circle(context, rx, ry, r) {
  context.arc(rx, ry, r, 0, Math.PI * 2, false);
}

CRp.arrowShapeImpl = function (name) {
  return (impl || (impl = {
    'polygon': polygon,
    'triangle-backcurve': triangleBackcurve,
    'triangle-tee': triangleTee,
    'triangle-cross': triangleTee,
    'circle': circle
  }))[name];
};

var CRp$1 = {};

CRp$1.drawElement = function (context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {
  var r = this;

  if (ele.isNode()) {
    r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
  } else {
    r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);
  }
};

CRp$1.drawElementOverlay = function (context, ele) {
  var r = this;

  if (ele.isNode()) {
    r.drawNodeOverlay(context, ele);
  } else {
    r.drawEdgeOverlay(context, ele);
  }
};

CRp$1.drawCachedElementPortion = function (context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {
  var r = this;
  var bb = eleTxrCache.getBoundingBox(ele);

  if (bb.w === 0 || bb.h === 0) {
    return;
  } // ignore zero size case


  var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);

  if (eleCache != null) {
    var opacity = getOpacity(r, ele);

    if (opacity === 0) {
      return;
    }

    var theta = getRotation(r, ele);
    var x1 = bb.x1,
        y1 = bb.y1,
        w = bb.w,
        h = bb.h;
    var x, y, sx, sy, smooth;

    if (theta !== 0) {
      var rotPt = eleTxrCache.getRotationPoint(ele);
      sx = rotPt.x;
      sy = rotPt.y;
      context.translate(sx, sy);
      context.rotate(theta);
      smooth = r.getImgSmoothing(context);

      if (!smooth) {
        r.setImgSmoothing(context, true);
      }

      var off = eleTxrCache.getRotationOffset(ele);
      x = off.x;
      y = off.y;
    } else {
      x = x1;
      y = y1;
    }

    var oldGlobalAlpha;

    if (opacity !== 1) {
      oldGlobalAlpha = context.globalAlpha;
      context.globalAlpha = oldGlobalAlpha * opacity;
    }

    context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);

    if (opacity !== 1) {
      context.globalAlpha = oldGlobalAlpha;
    }

    if (theta !== 0) {
      context.rotate(-theta);
      context.translate(-sx, -sy);

      if (!smooth) {
        r.setImgSmoothing(context, false);
      }
    }
  } else {
    eleTxrCache.drawElement(context, ele); // direct draw fallback
  }
};

var getZeroRotation = function getZeroRotation() {
  return 0;
};

var getLabelRotation = function getLabelRotation(r, ele) {
  return r.getTextAngle(ele, null);
};

var getSourceLabelRotation = function getSourceLabelRotation(r, ele) {
  return r.getTextAngle(ele, 'source');
};

var getTargetLabelRotation = function getTargetLabelRotation(r, ele) {
  return r.getTextAngle(ele, 'target');
};

var getOpacity = function getOpacity(r, ele) {
  return ele.effectiveOpacity();
};

var getTextOpacity = function getTextOpacity(e, ele) {
  return ele.pstyle('text-opacity').pfValue * ele.effectiveOpacity();
};

CRp$1.drawCachedElement = function (context, ele, pxRatio, extent, lvl, requestHighQuality) {
  var r = this;
  var _r$data = r.data,
      eleTxrCache = _r$data.eleTxrCache,
      lblTxrCache = _r$data.lblTxrCache,
      slbTxrCache = _r$data.slbTxrCache,
      tlbTxrCache = _r$data.tlbTxrCache;
  var bb = ele.boundingBox();
  var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;

  if (bb.w === 0 || bb.h === 0 || !ele.visible()) {
    return;
  }

  if (!extent || boundingBoxesIntersect(bb, extent)) {
    var isEdge = ele.isEdge();

    var badLine = ele.element()._private.rscratch.badLine;

    r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);

    if (!isEdge || !badLine) {
      r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);
    }

    if (isEdge && !badLine) {
      r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);
      r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);
    }

    r.drawElementOverlay(context, ele);
  }
};

CRp$1.drawElements = function (context, eles) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    r.drawElement(context, ele);
  }
};

CRp$1.drawCachedElements = function (context, eles, pxRatio, extent) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];
    r.drawCachedElement(context, ele, pxRatio, extent);
  }
};

CRp$1.drawCachedNodes = function (context, eles, pxRatio, extent) {
  var r = this;

  for (var i = 0; i < eles.length; i++) {
    var ele = eles[i];

    if (!ele.isNode()) {
      continue;
    }

    r.drawCachedElement(context, ele, pxRatio, extent);
  }
};

CRp$1.drawLayeredElements = function (context, eles, pxRatio, extent) {
  var r = this;
  var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);

  if (layers) {
    for (var i = 0; i < layers.length; i++) {
      var layer = layers[i];
      var bb = layer.bb;

      if (bb.w === 0 || bb.h === 0) {
        continue;
      }

      context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);
    }
  } else {
    // fall back on plain caching if no layers
    r.drawCachedElements(context, eles, pxRatio, extent);
  }
};

/* global Path2D */
var CRp$2 = {};

CRp$2.drawEdge = function (context, edge, shiftToOriginWithBb) {
  var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  var r = this;
  var rs = edge._private.rscratch;

  if (shouldDrawOpacity && !edge.visible()) {
    return;
  } // if bezier ctrl pts can not be calculated, then die


  if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {
    // isNaN in case edge is impossible and browser bugs (e.g. safari)
    return;
  }

  var bb;

  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;
    context.translate(-bb.x1, -bb.y1);
  }

  var opacity = shouldDrawOpacity ? edge.pstyle('opacity').value : 1;
  var lineStyle = edge.pstyle('line-style').value;
  var edgeWidth = edge.pstyle('width').pfValue;
  var lineCap = edge.pstyle('line-cap').value;

  var drawLine = function drawLine() {
    var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;
    context.lineWidth = edgeWidth;
    context.lineCap = lineCap;
    r.eleStrokeStyle(context, edge, strokeOpacity);
    r.drawEdgePath(edge, context, rs.allpts, lineStyle);
    context.lineCap = 'butt'; // reset for other drawing functions
  };

  var drawOverlay = function drawOverlay() {
    if (!shouldDrawOverlay) {
      return;
    }

    r.drawEdgeOverlay(context, edge);
  };

  var drawArrows = function drawArrows() {
    var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : opacity;
    r.drawArrowheads(context, edge, arrowOpacity);
  };

  var drawText = function drawText() {
    r.drawElementText(context, edge, null, drawLabel);
  };

  context.lineJoin = 'round';
  var ghost = edge.pstyle('ghost').value === 'yes';

  if (ghost) {
    var gx = edge.pstyle('ghost-offset-x').pfValue;
    var gy = edge.pstyle('ghost-offset-y').pfValue;
    var ghostOpacity = edge.pstyle('ghost-opacity').value;
    var effectiveGhostOpacity = opacity * ghostOpacity;
    context.translate(gx, gy);
    drawLine(effectiveGhostOpacity);
    drawArrows(effectiveGhostOpacity);
    context.translate(-gx, -gy);
  }

  drawLine();
  drawArrows();
  drawOverlay();
  drawText();

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

CRp$2.drawEdgeOverlay = function (context, edge) {
  if (!edge.visible()) {
    return;
  }

  var overlayOpacity = edge.pstyle('overlay-opacity').value;

  if (overlayOpacity === 0) {
    return;
  }

  var r = this;
  var usePaths = r.usePaths();
  var rs = edge._private.rscratch;
  var overlayPadding = edge.pstyle('overlay-padding').pfValue;
  var overlayWidth = 2 * overlayPadding;
  var overlayColor = edge.pstyle('overlay-color').value;
  context.lineWidth = overlayWidth;

  if (rs.edgeType === 'self' && !usePaths) {
    context.lineCap = 'butt';
  } else {
    context.lineCap = 'round';
  }

  r.colorStrokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
  r.drawEdgePath(edge, context, rs.allpts, 'solid');
};

CRp$2.drawEdgePath = function (edge, context, pts, type) {
  var rs = edge._private.rscratch;
  var canvasCxt = context;
  var path;
  var pathCacheHit = false;
  var usePaths = this.usePaths();
  var lineDashPattern = edge.pstyle('line-dash-pattern').pfValue;
  var lineDashOffset = edge.pstyle('line-dash-offset').pfValue;

  if (usePaths) {
    var pathCacheKey = pts.join('$');
    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

    if (keyMatches) {
      path = context = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = context = new Path2D();
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if (canvasCxt.setLineDash) {
    // for very outofdate browsers
    switch (type) {
      case 'dotted':
        canvasCxt.setLineDash([1, 1]);
        break;

      case 'dashed':
        canvasCxt.setLineDash(lineDashPattern);
        canvasCxt.lineDashOffset = lineDashOffset;
        break;

      case 'solid':
        canvasCxt.setLineDash([]);
        break;
    }
  }

  if (!pathCacheHit && !rs.badLine) {
    if (context.beginPath) {
      context.beginPath();
    }

    context.moveTo(pts[0], pts[1]);

    switch (rs.edgeType) {
      case 'bezier':
      case 'self':
      case 'compound':
      case 'multibezier':
        for (var i = 2; i + 3 < pts.length; i += 4) {
          context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);
        }

        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        for (var _i = 2; _i + 1 < pts.length; _i += 2) {
          context.lineTo(pts[_i], pts[_i + 1]);
        }

        break;
    }
  }

  context = canvasCxt;

  if (usePaths) {
    context.stroke(path);
  } else {
    context.stroke();
  } // reset any line dashes


  if (context.setLineDash) {
    // for very outofdate browsers
    context.setLineDash([]);
  }
};

CRp$2.drawArrowheads = function (context, edge, opacity) {
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';

  if (!isHaystack) {
    this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);
  }

  this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);
  this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);

  if (!isHaystack) {
    this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);
  }
};

CRp$2.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {
  if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {
    return;
  }

  var self = this;
  var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;

  if (arrowShape === 'none') {
    return;
  }

  var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';
  var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;
  var edgeWidth = edge.pstyle('width').pfValue;
  var edgeOpacity = edge.pstyle('opacity').value;

  if (opacity === undefined) {
    opacity = edgeOpacity;
  }

  var gco = context.globalCompositeOperation;

  if (opacity !== 1 || arrowFill === 'hollow') {
    // then extra clear is needed
    context.globalCompositeOperation = 'destination-out';
    self.colorFillStyle(context, 255, 255, 255, 1);
    self.colorStrokeStyle(context, 255, 255, 255, 1);
    self.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);
    context.globalCompositeOperation = gco;
  } // otherwise, the opaque arrow clears it for free :)


  var color = edge.pstyle(prefix + '-arrow-color').value;
  self.colorFillStyle(context, color[0], color[1], color[2], opacity);
  self.colorStrokeStyle(context, color[0], color[1], color[2], opacity);
  self.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, x, y, angle);
};

CRp$2.drawArrowShape = function (edge, context, fill, edgeWidth, shape, x, y, angle) {
  var r = this;
  var usePaths = this.usePaths() && shape !== 'triangle-cross';
  var pathCacheHit = false;
  var path;
  var canvasContext = context;
  var translation = {
    x: x,
    y: y
  };
  var scale = edge.pstyle('arrow-scale').value;
  var size = this.getArrowWidth(edgeWidth, scale);
  var shapeImpl = r.arrowShapes[shape];

  if (usePaths) {
    var cache = r.arrowPathCache = r.arrowPathCache || [];
    var key = hashString(shape);
    var cachedPath = cache[key];

    if (cachedPath != null) {
      path = context = cachedPath;
      pathCacheHit = true;
    } else {
      path = context = new Path2D();
      cache[key] = path;
    }
  }

  if (context.beginPath) {
    context.beginPath();
  }

  if (!pathCacheHit) {
    if (usePaths) {
      // store in the path cache with values easily manipulated later
      shapeImpl.draw(context, 1, 0, {
        x: 0,
        y: 0
      }, 1);
    } else {
      shapeImpl.draw(context, size, angle, translation, edgeWidth);
    }
  }

  if (context.closePath) {
    context.closePath();
  }

  context = canvasContext;

  if (usePaths) {
    // set transform to arrow position/orientation
    context.translate(x, y);
    context.rotate(angle);
    context.scale(size, size);
  }

  if (fill === 'filled' || fill === 'both') {
    if (usePaths) {
      context.fill(path);
    } else {
      context.fill();
    }
  }

  if (fill === 'hollow' || fill === 'both') {
    context.lineWidth = (shapeImpl.matchEdgeWidth ? edgeWidth : 1) / (usePaths ? size : 1);
    context.lineJoin = 'miter';

    if (usePaths) {
      context.stroke(path);
    } else {
      context.stroke();
    }
  }

  if (usePaths) {
    // reset transform by applying inverse
    context.scale(1 / size, 1 / size);
    context.rotate(-angle);
    context.translate(-x, -y);
  }
};

var CRp$3 = {};

CRp$3.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {
  // detect problematic cases for old browsers with bad images (cheaper than try-catch)
  if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {
    return;
  }

  context.drawImage(img, ix, iy, iw, ih, x, y, w, h);
};

CRp$3.drawInscribedImage = function (context, img, node, index, nodeOpacity) {
  var r = this;
  var pos = node.position();
  var nodeX = pos.x;
  var nodeY = pos.y;
  var styleObj = node.cy().style();
  var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);
  var fit = getIndexedStyle(node, 'background-fit', 'value', index);
  var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);
  var nodeW = node.width();
  var nodeH = node.height();
  var paddingX2 = node.padding() * 2;
  var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
  var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);
  var rs = node._private.rscratch;
  var clip = getIndexedStyle(node, 'background-clip', 'value', index);
  var shouldClip = clip === 'node';
  var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;
  var imgW = img.width || img.cachedW;
  var imgH = img.height || img.cachedH; // workaround for broken browsers like ie

  if (null == imgW || null == imgH) {
    document.body.appendChild(img); // eslint-disable-line no-undef

    imgW = img.cachedW = img.width || img.offsetWidth;
    imgH = img.cachedH = img.height || img.offsetHeight;
    document.body.removeChild(img); // eslint-disable-line no-undef
  }

  var w = imgW;
  var h = imgH;

  if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {
    if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {
      w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;
    } else {
      w = getIndexedStyle(node, 'background-width', 'pfValue', index);
    }
  }

  if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {
    if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {
      h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;
    } else {
      h = getIndexedStyle(node, 'background-height', 'pfValue', index);
    }
  }

  if (w === 0 || h === 0) {
    return; // no point in drawing empty image (and chrome is broken in this case)
  }

  if (fit === 'contain') {
    var scale = Math.min(nodeTW / w, nodeTH / h);
    w *= scale;
    h *= scale;
  } else if (fit === 'cover') {
    var scale = Math.max(nodeTW / w, nodeTH / h);
    w *= scale;
    h *= scale;
  }

  var x = nodeX - nodeTW / 2; // left

  var posXUnits = getIndexedStyle(node, 'background-position-x', 'units', index);
  var posXPfVal = getIndexedStyle(node, 'background-position-x', 'pfValue', index);

  if (posXUnits === '%') {
    x += (nodeTW - w) * posXPfVal;
  } else {
    x += posXPfVal;
  }

  var offXUnits = getIndexedStyle(node, 'background-offset-x', 'units', index);
  var offXPfVal = getIndexedStyle(node, 'background-offset-x', 'pfValue', index);

  if (offXUnits === '%') {
    x += (nodeTW - w) * offXPfVal;
  } else {
    x += offXPfVal;
  }

  var y = nodeY - nodeTH / 2; // top

  var posYUnits = getIndexedStyle(node, 'background-position-y', 'units', index);
  var posYPfVal = getIndexedStyle(node, 'background-position-y', 'pfValue', index);

  if (posYUnits === '%') {
    y += (nodeTH - h) * posYPfVal;
  } else {
    y += posYPfVal;
  }

  var offYUnits = getIndexedStyle(node, 'background-offset-y', 'units', index);
  var offYPfVal = getIndexedStyle(node, 'background-offset-y', 'pfValue', index);

  if (offYUnits === '%') {
    y += (nodeTH - h) * offYPfVal;
  } else {
    y += offYPfVal;
  }

  if (rs.pathCache) {
    x -= nodeX;
    y -= nodeY;
    nodeX = 0;
    nodeY = 0;
  }

  var gAlpha = context.globalAlpha;
  context.globalAlpha = imgOpacity;

  if (repeat === 'no-repeat') {
    if (shouldClip) {
      context.save();

      if (rs.pathCache) {
        context.clip(rs.pathCache);
      } else {
        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);
        context.clip();
      }
    }

    r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);

    if (shouldClip) {
      context.restore();
    }
  } else {
    var pattern = context.createPattern(img, repeat);
    context.fillStyle = pattern;
    r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);
    context.translate(x, y);
    context.fill();
    context.translate(-x, -y);
  }

  context.globalAlpha = gAlpha;
};

var CRp$4 = {};

CRp$4.eleTextBiggerThanMin = function (ele, scale) {
  if (!scale) {
    var zoom = ele.cy().zoom();
    var pxRatio = this.getPixelRatio();
    var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level

    scale = Math.pow(2, lvl);
  }

  var computedSize = ele.pstyle('font-size').pfValue * scale;
  var minSize = ele.pstyle('min-zoomed-font-size').pfValue;

  if (computedSize < minSize) {
    return false;
  }

  return true;
};

CRp$4.drawElementText = function (context, ele, shiftToOriginWithBb, force, prefix) {
  var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  var r = this;

  if (force == null) {
    if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {
      return;
    }
  } else if (force === false) {
    return;
  }

  if (ele.isNode()) {
    var label = ele.pstyle('label');

    if (!label || !label.value) {
      return;
    }

    var justification = r.getLabelJustification(ele);
    context.textAlign = justification;
    context.textBaseline = 'bottom';
  } else {
    var badLine = ele.element()._private.rscratch.badLine;

    var _label = ele.pstyle('label');

    var srcLabel = ele.pstyle('source-label');
    var tgtLabel = ele.pstyle('target-label');

    if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {
      return;
    }

    context.textAlign = 'center';
    context.textBaseline = 'bottom';
  }

  var applyRotation = !shiftToOriginWithBb;
  var bb;

  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;
    context.translate(-bb.x1, -bb.y1);
  }

  if (prefix == null) {
    r.drawText(context, ele, null, applyRotation, useEleOpacity);

    if (ele.isEdge()) {
      r.drawText(context, ele, 'source', applyRotation, useEleOpacity);
      r.drawText(context, ele, 'target', applyRotation, useEleOpacity);
    }
  } else {
    r.drawText(context, ele, prefix, applyRotation, useEleOpacity);
  }

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

CRp$4.getFontCache = function (context) {
  var cache;
  this.fontCaches = this.fontCaches || [];

  for (var i = 0; i < this.fontCaches.length; i++) {
    cache = this.fontCaches[i];

    if (cache.context === context) {
      return cache;
    }
  }

  cache = {
    context: context
  };
  this.fontCaches.push(cache);
  return cache;
}; // set up canvas context with font
// returns transformed text string


CRp$4.setupTextStyle = function (context, ele) {
  var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  // Font style
  var labelStyle = ele.pstyle('font-style').strValue;
  var labelSize = ele.pstyle('font-size').pfValue + 'px';
  var labelFamily = ele.pstyle('font-family').strValue;
  var labelWeight = ele.pstyle('font-weight').strValue;
  var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle('text-opacity').value : 1;
  var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;
  var color = ele.pstyle('color').value;
  var outlineColor = ele.pstyle('text-outline-color').value;
  context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;
  context.lineJoin = 'round'; // so text outlines aren't jagged

  this.colorFillStyle(context, color[0], color[1], color[2], opacity);
  this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);
}; // TODO ensure re-used


function roundRect(ctx, x, y, width, height) {
  var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  ctx.fill();
}

CRp$4.getTextAngle = function (ele, prefix) {
  var theta;
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var pdash = prefix ? prefix + '-' : '';
  var rotation = ele.pstyle(pdash + 'text-rotation');
  var textAngle = getPrefixedProperty(rscratch, 'labelAngle', prefix);

  if (rotation.strValue === 'autorotate') {
    theta = ele.isEdge() ? textAngle : 0;
  } else if (rotation.strValue === 'none') {
    theta = 0;
  } else {
    theta = rotation.pfValue;
  }

  return theta;
};

CRp$4.drawText = function (context, ele, prefix) {
  var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var _p = ele._private;
  var rscratch = _p.rscratch;
  var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;

  if (useEleOpacity && (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0)) {
    return;
  } // use 'main' as an alias for the main label (i.e. null prefix)


  if (prefix === 'main') {
    prefix = null;
  }

  var textX = getPrefixedProperty(rscratch, 'labelX', prefix);
  var textY = getPrefixedProperty(rscratch, 'labelY', prefix);
  var orgTextX, orgTextY; // used for rotation

  var text = this.getLabelText(ele, prefix);

  if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {
    this.setupTextStyle(context, ele, useEleOpacity);
    var pdash = prefix ? prefix + '-' : '';
    var textW = getPrefixedProperty(rscratch, 'labelWidth', prefix);
    var textH = getPrefixedProperty(rscratch, 'labelHeight', prefix);
    var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;
    var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;
    var isEdge = ele.isEdge();
    var halign = ele.pstyle('text-halign').value;
    var valign = ele.pstyle('text-valign').value;

    if (isEdge) {
      halign = 'center';
      valign = 'center';
    }

    textX += marginX;
    textY += marginY;
    var theta;

    if (!applyRotation) {
      theta = 0;
    } else {
      theta = this.getTextAngle(ele, prefix);
    }

    if (theta !== 0) {
      orgTextX = textX;
      orgTextY = textY;
      context.translate(orgTextX, orgTextY);
      context.rotate(theta);
      textX = 0;
      textY = 0;
    }

    switch (valign) {
      case 'top':
        break;

      case 'center':
        textY += textH / 2;
        break;

      case 'bottom':
        textY += textH;
        break;
    }

    var backgroundOpacity = ele.pstyle('text-background-opacity').value;
    var borderOpacity = ele.pstyle('text-border-opacity').value;
    var textBorderWidth = ele.pstyle('text-border-width').pfValue;
    var backgroundPadding = ele.pstyle('text-background-padding').pfValue;

    if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {
      var bgX = textX - backgroundPadding;

      switch (halign) {
        case 'left':
          bgX -= textW;
          break;

        case 'center':
          bgX -= textW / 2;
          break;

        case 'right':
          break;
      }

      var bgY = textY - textH - backgroundPadding;
      var bgW = textW + 2 * backgroundPadding;
      var bgH = textH + 2 * backgroundPadding;

      if (backgroundOpacity > 0) {
        var textFill = context.fillStyle;
        var textBackgroundColor = ele.pstyle('text-background-color').value;
        context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
        var styleShape = ele.pstyle('text-background-shape').strValue;

        if (styleShape.indexOf('round') === 0) {
          roundRect(context, bgX, bgY, bgW, bgH, 2);
        } else {
          context.fillRect(bgX, bgY, bgW, bgH);
        }

        context.fillStyle = textFill;
      }

      if (textBorderWidth > 0 && borderOpacity > 0) {
        var textStroke = context.strokeStyle;
        var textLineWidth = context.lineWidth;
        var textBorderColor = ele.pstyle('text-border-color').value;
        var textBorderStyle = ele.pstyle('text-border-style').value;
        context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
        context.lineWidth = textBorderWidth;

        if (context.setLineDash) {
          // for very outofdate browsers
          switch (textBorderStyle) {
            case 'dotted':
              context.setLineDash([1, 1]);
              break;

            case 'dashed':
              context.setLineDash([4, 2]);
              break;

            case 'double':
              context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders

              context.setLineDash([]);
              break;

            case 'solid':
              context.setLineDash([]);
              break;
          }
        }

        context.strokeRect(bgX, bgY, bgW, bgH);

        if (textBorderStyle === 'double') {
          var whiteWidth = textBorderWidth / 2;
          context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);
        }

        if (context.setLineDash) {
          // for very outofdate browsers
          context.setLineDash([]);
        }

        context.lineWidth = textLineWidth;
        context.strokeStyle = textStroke;
      }
    }

    var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle

    if (lineWidth > 0) {
      context.lineWidth = lineWidth;
    }

    if (ele.pstyle('text-wrap').value === 'wrap') {
      var lines = getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);
      var lineHeight = getPrefixedProperty(rscratch, 'labelLineHeight', prefix);
      var halfTextW = textW / 2;
      var justification = this.getLabelJustification(ele);

      if (justification === 'auto') ; else if (halign === 'left') {
        // auto justification : right
        if (justification === 'left') {
          textX += -textW;
        } else if (justification === 'center') {
          textX += -halfTextW;
        } // else same as auto

      } else if (halign === 'center') {
        // auto justfication : center
        if (justification === 'left') {
          textX += -halfTextW;
        } else if (justification === 'right') {
          textX += halfTextW;
        } // else same as auto

      } else if (halign === 'right') {
        // auto justification : left
        if (justification === 'center') {
          textX += halfTextW;
        } else if (justification === 'right') {
          textX += textW;
        } // else same as auto

      }

      switch (valign) {
        case 'top':
          textY -= (lines.length - 1) * lineHeight;
          break;

        case 'center':
        case 'bottom':
          textY -= (lines.length - 1) * lineHeight;
          break;
      }

      for (var l = 0; l < lines.length; l++) {
        if (lineWidth > 0) {
          context.strokeText(lines[l], textX, textY);
        }

        context.fillText(lines[l], textX, textY);
        textY += lineHeight;
      }
    } else {
      if (lineWidth > 0) {
        context.strokeText(text, textX, textY);
      }

      context.fillText(text, textX, textY);
    }

    if (theta !== 0) {
      context.rotate(-theta);
      context.translate(-orgTextX, -orgTextY);
    }
  }
};

/* global Path2D */
var CRp$5 = {};

CRp$5.drawNode = function (context, node, shiftToOriginWithBb) {
  var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  var r = this;
  var nodeWidth, nodeHeight;
  var _p = node._private;
  var rs = _p.rscratch;
  var pos = node.position();

  if (!number(pos.x) || !number(pos.y)) {
    return; // can't draw node with undefined position
  }

  if (shouldDrawOpacity && !node.visible()) {
    return;
  }

  var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;
  var usePaths = r.usePaths();
  var path;
  var pathCacheHit = false;
  var padding = node.padding();
  nodeWidth = node.width() + 2 * padding;
  nodeHeight = node.height() + 2 * padding; //
  // setup shift

  var bb;

  if (shiftToOriginWithBb) {
    bb = shiftToOriginWithBb;
    context.translate(-bb.x1, -bb.y1);
  } //
  // load bg image


  var bgImgProp = node.pstyle('background-image');
  var urls = bgImgProp.value;
  var urlDefined = new Array(urls.length);
  var image = new Array(urls.length);
  var numImages = 0;

  for (var i = 0; i < urls.length; i++) {
    var url = urls[i];
    var defd = urlDefined[i] = url != null && url !== 'none';

    if (defd) {
      var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);
      numImages++; // get image, and if not loaded then ask to redraw when later loaded

      image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {
        _p.backgroundTimestamp = Date.now();
        node.emitAndNotify('background');
      });
    }
  } //
  // setup styles


  var darkness = node.pstyle('background-blacken').value;
  var borderWidth = node.pstyle('border-width').pfValue;
  var bgOpacity = node.pstyle('background-opacity').value * eleOpacity;
  var borderColor = node.pstyle('border-color').value;
  var borderStyle = node.pstyle('border-style').value;
  var borderOpacity = node.pstyle('border-opacity').value * eleOpacity;
  context.lineJoin = 'miter'; // so borders are square with the node shape

  var setupShapeColor = function setupShapeColor() {
    var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;
    r.eleFillStyle(context, node, bgOpy);
  };

  var setupBorderColor = function setupBorderColor() {
    var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;
    r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);
  }; //
  // setup shape


  var styleShape = node.pstyle('shape').strValue;
  var shapePts = node.pstyle('shape-polygon-points').pfValue;

  if (usePaths) {
    context.translate(pos.x, pos.y);
    var pathCache = r.nodePathCache = r.nodePathCache || [];
    var key = hashStrings(styleShape === 'polygon' ? styleShape + ',' + shapePts.join(',') : styleShape, '' + nodeHeight, '' + nodeWidth);
    var cachedPath = pathCache[key];

    if (cachedPath != null) {
      path = cachedPath;
      pathCacheHit = true;
      rs.pathCache = path;
    } else {
      path = new Path2D();
      pathCache[key] = rs.pathCache = path;
    }
  }

  var drawShape = function drawShape() {
    if (!pathCacheHit) {
      var npos = pos;

      if (usePaths) {
        npos = {
          x: 0,
          y: 0
        };
      }

      r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);
    }

    if (usePaths) {
      context.fill(path);
    } else {
      context.fill();
    }
  };

  var drawImages = function drawImages() {
    var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;
    var prevBging = _p.backgrounding;
    var totalCompleted = 0;

    for (var _i = 0; _i < image.length; _i++) {
      if (urlDefined[_i] && image[_i].complete && !image[_i].error) {
        totalCompleted++;
        r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);
      }
    }

    _p.backgrounding = !(totalCompleted === numImages);

    if (prevBging !== _p.backgrounding) {
      // update style b/c :backgrounding state changed
      node.updateStyle(false);
    }
  };

  var drawPie = function drawPie() {
    var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;

    if (r.hasPie(node)) {
      r.drawPie(context, node, pieOpacity); // redraw/restore path if steps after pie need it

      if (redrawShape) {
        if (!usePaths) {
          r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);
        }
      }
    }
  };

  var darken = function darken() {
    var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;
    var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;
    var c = darkness > 0 ? 0 : 255;

    if (darkness !== 0) {
      r.colorFillStyle(context, c, c, c, opacity);

      if (usePaths) {
        context.fill(path);
      } else {
        context.fill();
      }
    }
  };

  var drawBorder = function drawBorder() {
    if (borderWidth > 0) {
      context.lineWidth = borderWidth;
      context.lineCap = 'butt';

      if (context.setLineDash) {
        // for very outofdate browsers
        switch (borderStyle) {
          case 'dotted':
            context.setLineDash([1, 1]);
            break;

          case 'dashed':
            context.setLineDash([4, 2]);
            break;

          case 'solid':
          case 'double':
            context.setLineDash([]);
            break;
        }
      }

      if (usePaths) {
        context.stroke(path);
      } else {
        context.stroke();
      }

      if (borderStyle === 'double') {
        context.lineWidth = borderWidth / 3;
        var gco = context.globalCompositeOperation;
        context.globalCompositeOperation = 'destination-out';

        if (usePaths) {
          context.stroke(path);
        } else {
          context.stroke();
        }

        context.globalCompositeOperation = gco;
      } // reset in case we changed the border style


      if (context.setLineDash) {
        // for very outofdate browsers
        context.setLineDash([]);
      }
    }
  };

  var drawOverlay = function drawOverlay() {
    if (shouldDrawOverlay) {
      r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);
    }
  };

  var drawText = function drawText() {
    r.drawElementText(context, node, null, drawLabel);
  };

  var ghost = node.pstyle('ghost').value === 'yes';

  if (ghost) {
    var gx = node.pstyle('ghost-offset-x').pfValue;
    var gy = node.pstyle('ghost-offset-y').pfValue;
    var ghostOpacity = node.pstyle('ghost-opacity').value;
    var effGhostOpacity = ghostOpacity * eleOpacity;
    context.translate(gx, gy);
    setupShapeColor(ghostOpacity * bgOpacity);
    drawShape();
    drawImages(effGhostOpacity);
    drawPie(darkness !== 0 || borderWidth !== 0);
    darken(effGhostOpacity);
    setupBorderColor(ghostOpacity * borderOpacity);
    drawBorder();
    context.translate(-gx, -gy);
  }

  setupShapeColor();
  drawShape();
  drawImages();
  drawPie(darkness !== 0 || borderWidth !== 0);
  darken();
  setupBorderColor();
  drawBorder();

  if (usePaths) {
    context.translate(-pos.x, -pos.y);
  }

  drawText();
  drawOverlay(); //
  // clean up shift

  if (shiftToOriginWithBb) {
    context.translate(bb.x1, bb.y1);
  }
};

CRp$5.drawNodeOverlay = function (context, node, pos, nodeWidth, nodeHeight) {
  var r = this;

  if (!node.visible()) {
    return;
  }

  var overlayPadding = node.pstyle('overlay-padding').pfValue;
  var overlayOpacity = node.pstyle('overlay-opacity').value;
  var overlayColor = node.pstyle('overlay-color').value;

  if (overlayOpacity > 0) {
    pos = pos || node.position();

    if (nodeWidth == null || nodeHeight == null) {
      var padding = node.padding();
      nodeWidth = node.width() + 2 * padding;
      nodeHeight = node.height() + 2 * padding;
    }

    r.colorFillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
    r.nodeShapes['roundrectangle'].draw(context, pos.x, pos.y, nodeWidth + overlayPadding * 2, nodeHeight + overlayPadding * 2);
    context.fill();
  }
}; // does the node have at least one pie piece?


CRp$5.hasPie = function (node) {
  node = node[0]; // ensure ele ref

  return node._private.hasPie;
};

CRp$5.drawPie = function (context, node, nodeOpacity, pos) {
  node = node[0]; // ensure ele ref

  pos = pos || node.position();
  var cyStyle = node.cy().style();
  var pieSize = node.pstyle('pie-size');
  var x = pos.x;
  var y = pos.y;
  var nodeW = node.width();
  var nodeH = node.height();
  var radius = Math.min(nodeW, nodeH) / 2; // must fit in node

  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]

  var usePaths = this.usePaths();

  if (usePaths) {
    x = 0;
    y = 0;
  }

  if (pieSize.units === '%') {
    radius = radius * pieSize.pfValue;
  } else if (pieSize.pfValue !== undefined) {
    radius = pieSize.pfValue / 2;
  }

  for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {
    // 1..N
    var size = node.pstyle('pie-' + i + '-background-size').value;
    var color = node.pstyle('pie-' + i + '-background-color').value;
    var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;
    var percent = size / 100; // map integer range [0, 100] to [0, 1]
    // percent can't push beyond 1

    if (percent + lastPercent > 1) {
      percent = 1 - lastPercent;
    }

    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise

    var angleDelta = 2 * Math.PI * percent;
    var angleEnd = angleStart + angleDelta; // ignore if
    // - zero size
    // - we're already beyond the full circle
    // - adding the current slice would go beyond the full circle

    if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {
      continue;
    }

    context.beginPath();
    context.moveTo(x, y);
    context.arc(x, y, radius, angleStart, angleEnd);
    context.closePath();
    this.colorFillStyle(context, color[0], color[1], color[2], opacity);
    context.fill();
    lastPercent += percent;
  }
};

var CRp$6 = {};
var motionBlurDelay = 100; // var isFirefox = typeof InstallTrigger !== 'undefined';

CRp$6.getPixelRatio = function () {
  var context = this.data.contexts[0];

  if (this.forcedPixelRatio != null) {
    return this.forcedPixelRatio;
  }

  var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
  return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef
};

CRp$6.paintCache = function (context) {
  var caches = this.paintCaches = this.paintCaches || [];
  var needToCreateCache = true;
  var cache;

  for (var i = 0; i < caches.length; i++) {
    cache = caches[i];

    if (cache.context === context) {
      needToCreateCache = false;
      break;
    }
  }

  if (needToCreateCache) {
    cache = {
      context: context
    };
    caches.push(cache);
  }

  return cache;
};

CRp$6.createGradientStyleFor = function (context, shapeStyleName, ele, fill, opacity) {
  var gradientStyle;
  var usePaths = this.usePaths();
  var colors = ele.pstyle(shapeStyleName + '-gradient-stop-colors').value,
      positions = ele.pstyle(shapeStyleName + '-gradient-stop-positions').pfValue;

  if (fill === 'radial-gradient') {
    if (ele.isEdge()) {
      var start = ele.sourceEndpoint(),
          end = ele.targetEndpoint(),
          mid = ele.midpoint();
      var d1 = dist(start, mid);
      var d2 = dist(end, mid);
      gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));
    } else {
      var pos = usePaths ? {
        x: 0,
        y: 0
      } : ele.position(),
          width = ele.paddedWidth(),
          height = ele.paddedHeight();
      gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));
    }
  } else {
    if (ele.isEdge()) {
      var _start = ele.sourceEndpoint(),
          _end = ele.targetEndpoint();

      gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);
    } else {
      var _pos = usePaths ? {
        x: 0,
        y: 0
      } : ele.position(),
          _width = ele.paddedWidth(),
          _height = ele.paddedHeight(),
          halfWidth = _width / 2,
          halfHeight = _height / 2;

      var direction = ele.pstyle('background-gradient-direction').value;

      switch (direction) {
        case 'to-bottom':
          gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);
          break;

        case 'to-top':
          gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);
          break;

        case 'to-left':
          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);
          break;

        case 'to-right':
          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);
          break;

        case 'to-bottom-right':
        case 'to-right-bottom':
          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);
          break;

        case 'to-top-right':
        case 'to-right-top':
          gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);
          break;

        case 'to-bottom-left':
        case 'to-left-bottom':
          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);
          break;

        case 'to-top-left':
        case 'to-left-top':
          gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);
          break;
      }
    }
  }

  if (!gradientStyle) return null; // invalid gradient style

  var hasPositions = positions.length === colors.length;
  var length = colors.length;

  for (var i = 0; i < length; i++) {
    gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ',' + opacity + ')');
  }

  return gradientStyle;
};

CRp$6.gradientFillStyle = function (context, ele, fill, opacity) {
  var gradientStyle = this.createGradientStyleFor(context, 'background', ele, fill, opacity);
  if (!gradientStyle) return null; // error

  context.fillStyle = gradientStyle;
};

CRp$6.colorFillStyle = function (context, r, g, b, a) {
  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching
  // var cache = this.paintCache(context);
  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  // if( cache.fillStyle !== fillStyle ){
  //   context.fillStyle = cache.fillStyle = fillStyle;
  // }
};

CRp$6.eleFillStyle = function (context, ele, opacity) {
  var backgroundFill = ele.pstyle('background-fill').value;

  if (backgroundFill === 'linear-gradient' || backgroundFill === 'radial-gradient') {
    this.gradientFillStyle(context, ele, backgroundFill, opacity);
  } else {
    var backgroundColor = ele.pstyle('background-color').value;
    this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);
  }
};

CRp$6.gradientStrokeStyle = function (context, ele, fill, opacity) {
  var gradientStyle = this.createGradientStyleFor(context, 'line', ele, fill, opacity);
  if (!gradientStyle) return null; // error

  context.strokeStyle = gradientStyle;
};

CRp$6.colorStrokeStyle = function (context, r, g, b, a) {
  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching
  // var cache = this.paintCache(context);
  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  // if( cache.strokeStyle !== strokeStyle ){
  //   context.strokeStyle = cache.strokeStyle = strokeStyle;
  // }
};

CRp$6.eleStrokeStyle = function (context, ele, opacity) {
  var lineFill = ele.pstyle('line-fill').value;

  if (lineFill === 'linear-gradient' || lineFill === 'radial-gradient') {
    this.gradientStrokeStyle(context, ele, lineFill, opacity);
  } else {
    var lineColor = ele.pstyle('line-color').value;
    this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);
  }
}; // Resize canvas


CRp$6.matchCanvasSize = function (container) {
  var r = this;
  var data = r.data;
  var bb = r.findContainerClientCoords();
  var width = bb[2];
  var height = bb[3];
  var pixelRatio = r.getPixelRatio();
  var mbPxRatio = r.motionBlurPxRatio;

  if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {
    pixelRatio = mbPxRatio;
  }

  var canvasWidth = width * pixelRatio;
  var canvasHeight = height * pixelRatio;
  var canvas;

  if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {
    return; // save cycles if same
  }

  r.fontCaches = null; // resizing resets the style

  var canvasContainer = data.canvasContainer;
  canvasContainer.style.width = width + 'px';
  canvasContainer.style.height = height + 'px';

  for (var i = 0; i < r.CANVAS_LAYERS; i++) {
    canvas = data.canvases[i];
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  for (var i = 0; i < r.BUFFER_COUNT; i++) {
    canvas = data.bufferCanvases[i];
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  r.textureMult = 1;

  if (pixelRatio <= 1) {
    canvas = data.bufferCanvases[r.TEXTURE_BUFFER];
    r.textureMult = 2;
    canvas.width = canvasWidth * r.textureMult;
    canvas.height = canvasHeight * r.textureMult;
  }

  r.canvasWidth = canvasWidth;
  r.canvasHeight = canvasHeight;
};

CRp$6.renderTo = function (cxt, zoom, pan, pxRatio) {
  this.render({
    forcedContext: cxt,
    forcedZoom: zoom,
    forcedPan: pan,
    drawAllLayers: true,
    forcedPxRatio: pxRatio
  });
};

CRp$6.render = function (options) {
  options = options || staticEmptyObject();
  var forcedContext = options.forcedContext;
  var drawAllLayers = options.drawAllLayers;
  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
  var forcedZoom = options.forcedZoom;
  var forcedPan = options.forcedPan;
  var r = this;
  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
  var cy = r.cy;
  var data = r.data;
  var needDraw = data.canvasNeedsRedraw;
  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
  var mbPxRatio = r.motionBlurPxRatio;
  var hasCompoundNodes = cy.hasCompoundNodes();
  var inNodeDragGesture = r.hoverData.draggingEles;
  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
  var motionBlurFadeEffect = motionBlur;

  if (!forcedContext) {
    if (r.prevPxRatio !== pixelRatio) {
      r.invalidateContainerClientCoordsCache();
      r.matchCanvasSize(r.container);
      r.redrawHint('eles', true);
      r.redrawHint('drag', true);
    }

    r.prevPxRatio = pixelRatio;
  }

  if (!forcedContext && r.motionBlurTimeout) {
    clearTimeout(r.motionBlurTimeout);
  }

  if (motionBlur) {
    if (r.mbFrames == null) {
      r.mbFrames = 0;
    }

    r.mbFrames++;

    if (r.mbFrames < 3) {
      // need several frames before even high quality motionblur
      motionBlurFadeEffect = false;
    } // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)


    if (r.mbFrames > r.minMbLowQualFrames) {
      //r.fullQualityMb = false;
      r.motionBlurPxRatio = r.mbPxRBlurry;
    }
  }

  if (r.clearingMotionBlur) {
    r.motionBlurPxRatio = 1;
  } // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
  // because a rogue async texture frame would clear needDraw


  if (r.textureDrawLastFrame && !textureDraw) {
    needDraw[r.NODE] = true;
    needDraw[r.SELECT_BOX] = true;
  }

  var style = cy.style();
  var zoom = cy.zoom();
  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
  var pan = cy.pan();
  var effectivePan = {
    x: pan.x,
    y: pan.y
  };
  var vp = {
    zoom: zoom,
    pan: {
      x: pan.x,
      y: pan.y
    }
  };
  var prevVp = r.prevViewport;
  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y; // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)

  if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {
    r.motionBlurPxRatio = 1;
  }

  if (forcedPan) {
    effectivePan = forcedPan;
  } // apply pixel ratio


  effectiveZoom *= pixelRatio;
  effectivePan.x *= pixelRatio;
  effectivePan.y *= pixelRatio;
  var eles = r.getCachedZSortedEles();

  function mbclear(context, x, y, w, h) {
    var gco = context.globalCompositeOperation;
    context.globalCompositeOperation = 'destination-out';
    r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);
    context.fillRect(x, y, w, h);
    context.globalCompositeOperation = gco;
  }

  function setContextTransform(context, clear) {
    var ePan, eZoom, w, h;

    if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {
      ePan = {
        x: pan.x * mbPxRatio,
        y: pan.y * mbPxRatio
      };
      eZoom = zoom * mbPxRatio;
      w = r.canvasWidth * mbPxRatio;
      h = r.canvasHeight * mbPxRatio;
    } else {
      ePan = effectivePan;
      eZoom = effectiveZoom;
      w = r.canvasWidth;
      h = r.canvasHeight;
    }

    context.setTransform(1, 0, 0, 1, 0, 0);

    if (clear === 'motionBlur') {
      mbclear(context, 0, 0, w, h);
    } else if (!forcedContext && (clear === undefined || clear)) {
      context.clearRect(0, 0, w, h);
    }

    if (!drawAllLayers) {
      context.translate(ePan.x, ePan.y);
      context.scale(eZoom, eZoom);
    }

    if (forcedPan) {
      context.translate(forcedPan.x, forcedPan.y);
    }

    if (forcedZoom) {
      context.scale(forcedZoom, forcedZoom);
    }
  }

  if (!textureDraw) {
    r.textureDrawLastFrame = false;
  }

  if (textureDraw) {
    r.textureDrawLastFrame = true;

    if (!r.textureCache) {
      r.textureCache = {};
      r.textureCache.bb = cy.mutableElements().boundingBox();
      r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];
      var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];
      cxt.setTransform(1, 0, 0, 1, 0, 0);
      cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);
      r.render({
        forcedContext: cxt,
        drawOnlyNodeLayer: true,
        forcedPxRatio: pixelRatio * r.textureMult
      });
      var vp = r.textureCache.viewport = {
        zoom: cy.zoom(),
        pan: cy.pan(),
        width: r.canvasWidth,
        height: r.canvasHeight
      };
      vp.mpan = {
        x: (0 - vp.pan.x) / vp.zoom,
        y: (0 - vp.pan.y) / vp.zoom
      };
    }

    needDraw[r.DRAG] = false;
    needDraw[r.NODE] = false;
    var context = data.contexts[r.NODE];
    var texture = r.textureCache.texture;
    var vp = r.textureCache.viewport;
    context.setTransform(1, 0, 0, 1, 0, 0);

    if (motionBlur) {
      mbclear(context, 0, 0, vp.width, vp.height);
    } else {
      context.clearRect(0, 0, vp.width, vp.height);
    }

    var outsideBgColor = style.core('outside-texture-bg-color').value;
    var outsideBgOpacity = style.core('outside-texture-bg-opacity').value;
    r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);
    context.fillRect(0, 0, vp.width, vp.height);
    var zoom = cy.zoom();
    setContextTransform(context, false);
    context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
    context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);
  } else if (r.textureOnViewport && !forcedContext) {
    // clear the cache since we don't need it
    r.textureCache = null;
  }

  var extent = cy.extent();
  var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();
  var hideEdges = r.hideEdgesOnViewport && vpManip;
  var needMbClear = [];
  needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;

  if (needMbClear[r.NODE]) {
    r.clearedForMotionBlur[r.NODE] = true;
  }

  needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;

  if (needMbClear[r.DRAG]) {
    r.clearedForMotionBlur[r.DRAG] = true;
  }

  if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {
    var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);
    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;
    setContextTransform(context, clear);

    if (hideEdges) {
      r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);
    } else {
      r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);
    }

    if (r.debug) {
      r.drawDebugPoints(context, eles.nondrag);
    }

    if (!drawAllLayers && !motionBlur) {
      needDraw[r.NODE] = false;
    }
  }

  if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {
    var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
    var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);
    setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);

    if (hideEdges) {
      r.drawCachedNodes(context, eles.drag, pixelRatio, extent);
    } else {
      r.drawCachedElements(context, eles.drag, pixelRatio, extent);
    }

    if (r.debug) {
      r.drawDebugPoints(context, eles.drag);
    }

    if (!drawAllLayers && !motionBlur) {
      needDraw[r.DRAG] = false;
    }
  }

  if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {
    var context = forcedContext || data.contexts[r.SELECT_BOX];
    setContextTransform(context);

    if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {
      var zoom = r.cy.zoom();
      var borderWidth = style.core('selection-box-border-width').value / zoom;
      context.lineWidth = borderWidth;
      context.fillStyle = 'rgba(' + style.core('selection-box-color').value[0] + ',' + style.core('selection-box-color').value[1] + ',' + style.core('selection-box-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';
      context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);

      if (borderWidth > 0) {
        context.strokeStyle = 'rgba(' + style.core('selection-box-border-color').value[0] + ',' + style.core('selection-box-border-color').value[1] + ',' + style.core('selection-box-border-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';
        context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);
      }
    }

    if (data.bgActivePosistion && !r.hoverData.selecting) {
      var zoom = r.cy.zoom();
      var pos = data.bgActivePosistion;
      context.fillStyle = 'rgba(' + style.core('active-bg-color').value[0] + ',' + style.core('active-bg-color').value[1] + ',' + style.core('active-bg-color').value[2] + ',' + style.core('active-bg-opacity').value + ')';
      context.beginPath();
      context.arc(pos.x, pos.y, style.core('active-bg-size').pfValue / zoom, 0, 2 * Math.PI);
      context.fill();
    }

    var timeToRender = r.lastRedrawTime;

    if (r.showFps && timeToRender) {
      timeToRender = Math.round(timeToRender);
      var fps = Math.round(1000 / timeToRender);
      context.setTransform(1, 0, 0, 1, 0, 0);
      context.fillStyle = 'rgba(255, 0, 0, 0.75)';
      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
      context.lineWidth = 1;
      context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);
      var maxFps = 60;
      context.strokeRect(0, 30, 250, 20);
      context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);
    }

    if (!drawAllLayers) {
      needDraw[r.SELECT_BOX] = false;
    }
  } // motionblur: blit rendered blurry frames


  if (motionBlur && mbPxRatio !== 1) {
    var cxtNode = data.contexts[r.NODE];
    var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];
    var cxtDrag = data.contexts[r.DRAG];
    var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];

    var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {
      cxt.setTransform(1, 0, 0, 1, 0, 0);

      if (needClear || !motionBlurFadeEffect) {
        cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);
      } else {
        mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);
      }

      var pxr = mbPxRatio;
      cxt.drawImage(txt, // img
      0, 0, // sx, sy
      r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
      0, 0, // x, y
      r.canvasWidth, r.canvasHeight // w, h
      );
    };

    if (needDraw[r.NODE] || needMbClear[r.NODE]) {
      drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);
      needDraw[r.NODE] = false;
    }

    if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {
      drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);
      needDraw[r.DRAG] = false;
    }
  }

  r.prevViewport = vp;

  if (r.clearingMotionBlur) {
    r.clearingMotionBlur = false;
    r.motionBlurCleared = true;
    r.motionBlur = true;
  }

  if (motionBlur) {
    r.motionBlurTimeout = setTimeout(function () {
      r.motionBlurTimeout = null;
      r.clearedForMotionBlur[r.NODE] = false;
      r.clearedForMotionBlur[r.DRAG] = false;
      r.motionBlur = false;
      r.clearingMotionBlur = !textureDraw;
      r.mbFrames = 0;
      needDraw[r.NODE] = true;
      needDraw[r.DRAG] = true;
      r.redraw();
    }, motionBlurDelay);
  }

  if (!forcedContext) {
    cy.emit('render');
  }
};

var CRp$7 = {}; // @O Polygon drawing

CRp$7.drawPolygonPath = function (context, x, y, width, height, points) {
  var halfW = width / 2;
  var halfH = height / 2;

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(x + halfW * points[0], y + halfH * points[1]);

  for (var i = 1; i < points.length / 2; i++) {
    context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);
  }

  context.closePath();
};

CRp$7.drawRoundPolygonPath = function (context, x, y, width, height, points) {
  var halfW = width / 2;
  var halfH = height / 2;
  var cornerRadius = getRoundPolygonRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  }

  for (var _i = 0; _i < points.length / 4; _i++) {
    var sourceUv = void 0,
        destUv = void 0;

    if (_i === 0) {
      sourceUv = points.length - 2;
    } else {
      sourceUv = _i * 4 - 2;
    }

    destUv = _i * 4 + 2;
    var px = x + halfW * points[_i * 4];
    var py = y + halfH * points[_i * 4 + 1];
    var cosTheta = -points[sourceUv] * points[destUv] - points[sourceUv + 1] * points[destUv + 1];
    var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);
    var cp0x = px - offset * points[sourceUv];
    var cp0y = py - offset * points[sourceUv + 1];
    var cp1x = px + offset * points[destUv];
    var cp1y = py + offset * points[destUv + 1];

    if (_i === 0) {
      context.moveTo(cp0x, cp0y);
    } else {
      context.lineTo(cp0x, cp0y);
    }

    context.arcTo(px, py, cp1x, cp1y, cornerRadius);
  }

  context.closePath();
}; // Round rectangle drawing


CRp$7.drawRoundRectanglePath = function (context, x, y, width, height) {
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = getRoundRectangleRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  } // Start at top middle


  context.moveTo(x, y - halfHeight); // Arc from middle top to right side

  context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius); // Arc from right side to bottom

  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius); // Arc from bottom to left side

  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius); // Arc from left side to topBorder

  context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius); // Join line

  context.lineTo(x, y - halfHeight);
  context.closePath();
};

CRp$7.drawBottomRoundRectanglePath = function (context, x, y, width, height) {
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerRadius = getRoundRectangleRadius(width, height);

  if (context.beginPath) {
    context.beginPath();
  } // Start at top middle


  context.moveTo(x, y - halfHeight);
  context.lineTo(x + halfWidth, y - halfHeight);
  context.lineTo(x + halfWidth, y);
  context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
  context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
  context.lineTo(x - halfWidth, y - halfHeight);
  context.lineTo(x, y - halfHeight);
  context.closePath();
};

CRp$7.drawCutRectanglePath = function (context, x, y, width, height) {
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var cornerLength = getCutRectangleCornerLength();

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(x - halfWidth + cornerLength, y - halfHeight);
  context.lineTo(x + halfWidth - cornerLength, y - halfHeight);
  context.lineTo(x + halfWidth, y - halfHeight + cornerLength);
  context.lineTo(x + halfWidth, y + halfHeight - cornerLength);
  context.lineTo(x + halfWidth - cornerLength, y + halfHeight);
  context.lineTo(x - halfWidth + cornerLength, y + halfHeight);
  context.lineTo(x - halfWidth, y + halfHeight - cornerLength);
  context.lineTo(x - halfWidth, y - halfHeight + cornerLength);
  context.closePath();
};

CRp$7.drawBarrelPath = function (context, x, y, width, height) {
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var xBegin = x - halfWidth;
  var xEnd = x + halfWidth;
  var yBegin = y - halfHeight;
  var yEnd = y + halfHeight;
  var barrelCurveConstants = getBarrelCurveConstants(width, height);
  var wOffset = barrelCurveConstants.widthOffset;
  var hOffset = barrelCurveConstants.heightOffset;
  var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;

  if (context.beginPath) {
    context.beginPath();
  }

  context.moveTo(xBegin, yBegin + hOffset);
  context.lineTo(xBegin, yEnd - hOffset);
  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);
  context.lineTo(xEnd - wOffset, yEnd);
  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);
  context.lineTo(xEnd, yBegin + hOffset);
  context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);
  context.lineTo(xBegin + wOffset, yBegin);
  context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);
  context.closePath();
};

var sin0 = Math.sin(0);
var cos0 = Math.cos(0);
var sin = {};
var cos = {};
var ellipseStepSize = Math.PI / 40;

for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
  sin[i] = Math.sin(i);
  cos[i] = Math.cos(i);
}

CRp$7.drawEllipsePath = function (context, centerX, centerY, width, height) {
  if (context.beginPath) {
    context.beginPath();
  }

  if (context.ellipse) {
    context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);
  } else {
    var xPos, yPos;
    var rw = width / 2;
    var rh = height / 2;

    for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {
      xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;
      yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;

      if (i === 0) {
        context.moveTo(xPos, yPos);
      } else {
        context.lineTo(xPos, yPos);
      }
    }
  }

  context.closePath();
};

/* global atob, ArrayBuffer, Uint8Array, Blob */
var CRp$8 = {};

CRp$8.createBuffer = function (w, h) {
  var buffer = document.createElement('canvas'); // eslint-disable-line no-undef

  buffer.width = w;
  buffer.height = h;
  return [buffer, buffer.getContext('2d')];
};

CRp$8.bufferCanvasImage = function (options) {
  var cy = this.cy;
  var eles = cy.mutableElements();
  var bb = eles.boundingBox();
  var ctrRect = this.findContainerClientCoords();
  var width = options.full ? Math.ceil(bb.w) : ctrRect[2];
  var height = options.full ? Math.ceil(bb.h) : ctrRect[3];
  var specdMaxDims = number(options.maxWidth) || number(options.maxHeight);
  var pxRatio = this.getPixelRatio();
  var scale = 1;

  if (options.scale !== undefined) {
    width *= options.scale;
    height *= options.scale;
    scale = options.scale;
  } else if (specdMaxDims) {
    var maxScaleW = Infinity;
    var maxScaleH = Infinity;

    if (number(options.maxWidth)) {
      maxScaleW = scale * options.maxWidth / width;
    }

    if (number(options.maxHeight)) {
      maxScaleH = scale * options.maxHeight / height;
    }

    scale = Math.min(maxScaleW, maxScaleH);
    width *= scale;
    height *= scale;
  }

  if (!specdMaxDims) {
    width *= pxRatio;
    height *= pxRatio;
    scale *= pxRatio;
  }

  var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef

  buffCanvas.width = width;
  buffCanvas.height = height;
  buffCanvas.style.width = width + 'px';
  buffCanvas.style.height = height + 'px';
  var buffCxt = buffCanvas.getContext('2d'); // Rasterize the layers, but only if container has nonzero size

  if (width > 0 && height > 0) {
    buffCxt.clearRect(0, 0, width, height);
    buffCxt.globalCompositeOperation = 'source-over';
    var zsortedEles = this.getCachedZSortedEles();

    if (options.full) {
      // draw the full bounds of the graph
      buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);
      buffCxt.scale(scale, scale);
      this.drawElements(buffCxt, zsortedEles);
      buffCxt.scale(1 / scale, 1 / scale);
      buffCxt.translate(bb.x1 * scale, bb.y1 * scale);
    } else {
      // draw the current view
      var pan = cy.pan();
      var translation = {
        x: pan.x * scale,
        y: pan.y * scale
      };
      scale *= cy.zoom();
      buffCxt.translate(translation.x, translation.y);
      buffCxt.scale(scale, scale);
      this.drawElements(buffCxt, zsortedEles);
      buffCxt.scale(1 / scale, 1 / scale);
      buffCxt.translate(-translation.x, -translation.y);
    } // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs


    if (options.bg) {
      buffCxt.globalCompositeOperation = 'destination-over';
      buffCxt.fillStyle = options.bg;
      buffCxt.rect(0, 0, width, height);
      buffCxt.fill();
    }
  }

  return buffCanvas;
};

function b64ToBlob(b64, mimeType) {
  var bytes = atob(b64);
  var buff = new ArrayBuffer(bytes.length);
  var buffUint8 = new Uint8Array(buff);

  for (var i = 0; i < bytes.length; i++) {
    buffUint8[i] = bytes.charCodeAt(i);
  }

  return new Blob([buff], {
    type: mimeType
  });
}

function b64UriToB64(b64uri) {
  var i = b64uri.indexOf(',');
  return b64uri.substr(i + 1);
}

function output(options, canvas, mimeType) {
  var getB64Uri = function getB64Uri() {
    return canvas.toDataURL(mimeType, options.quality);
  };

  switch (options.output) {
    case 'blob-promise':
      return new Promise$1(function (resolve, reject) {
        try {
          canvas.toBlob(function (blob) {
            if (blob != null) {
              resolve(blob);
            } else {
              reject(new Error('`canvas.toBlob()` sent a null value in its callback'));
            }
          }, mimeType, options.quality);
        } catch (err) {
          reject(err);
        }
      });

    case 'blob':
      return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);

    case 'base64':
      return b64UriToB64(getB64Uri());

    case 'base64uri':
    default:
      return getB64Uri();
  }
}

CRp$8.png = function (options) {
  return output(options, this.bufferCanvasImage(options), 'image/png');
};

CRp$8.jpg = function (options) {
  return output(options, this.bufferCanvasImage(options), 'image/jpeg');
};

var CRp$9 = {};

CRp$9.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {
  switch (name) {
    case 'ellipse':
      return this.drawEllipsePath(context, centerX, centerY, width, height);

    case 'polygon':
      return this.drawPolygonPath(context, centerX, centerY, width, height, points);

    case 'round-polygon':
      return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points);

    case 'roundrectangle':
    case 'round-rectangle':
      return this.drawRoundRectanglePath(context, centerX, centerY, width, height);

    case 'cutrectangle':
    case 'cut-rectangle':
      return this.drawCutRectanglePath(context, centerX, centerY, width, height);

    case 'bottomroundrectangle':
    case 'bottom-round-rectangle':
      return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);

    case 'barrel':
      return this.drawBarrelPath(context, centerX, centerY, width, height);
  }
};

var CR = CanvasRenderer;
var CRp$a = CanvasRenderer.prototype;
CRp$a.CANVAS_LAYERS = 3; //

CRp$a.SELECT_BOX = 0;
CRp$a.DRAG = 1;
CRp$a.NODE = 2;
CRp$a.BUFFER_COUNT = 3; //

CRp$a.TEXTURE_BUFFER = 0;
CRp$a.MOTIONBLUR_BUFFER_NODE = 1;
CRp$a.MOTIONBLUR_BUFFER_DRAG = 2;

function CanvasRenderer(options) {
  var r = this;
  r.data = {
    canvases: new Array(CRp$a.CANVAS_LAYERS),
    contexts: new Array(CRp$a.CANVAS_LAYERS),
    canvasNeedsRedraw: new Array(CRp$a.CANVAS_LAYERS),
    bufferCanvases: new Array(CRp$a.BUFFER_COUNT),
    bufferContexts: new Array(CRp$a.CANVAS_LAYERS)
  };
  var tapHlOffAttr = '-webkit-tap-highlight-color';
  var tapHlOffStyle = 'rgba(0,0,0,0)';
  r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef

  var containerStyle = r.data.canvasContainer.style;
  r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;
  containerStyle.position = 'relative';
  containerStyle.zIndex = '0';
  containerStyle.overflow = 'hidden';
  var container = options.cy.container();
  container.appendChild(r.data.canvasContainer);
  container.style[tapHlOffAttr] = tapHlOffStyle;
  var styleMap = {
    '-webkit-user-select': 'none',
    '-moz-user-select': '-moz-none',
    'user-select': 'none',
    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',
    'outline-style': 'none'
  };

  if (ms()) {
    styleMap['-ms-touch-action'] = 'none';
    styleMap['touch-action'] = 'none';
  }

  for (var i = 0; i < CRp$a.CANVAS_LAYERS; i++) {
    var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef

    r.data.contexts[i] = canvas.getContext('2d');
    Object.keys(styleMap).forEach(function (k) {
      canvas.style[k] = styleMap[k];
    });
    canvas.style.position = 'absolute';
    canvas.setAttribute('data-id', 'layer' + i);
    canvas.style.zIndex = String(CRp$a.CANVAS_LAYERS - i);
    r.data.canvasContainer.appendChild(canvas);
    r.data.canvasNeedsRedraw[i] = false;
  }

  r.data.topCanvas = r.data.canvases[0];
  r.data.canvases[CRp$a.NODE].setAttribute('data-id', 'layer' + CRp$a.NODE + '-node');
  r.data.canvases[CRp$a.SELECT_BOX].setAttribute('data-id', 'layer' + CRp$a.SELECT_BOX + '-selectbox');
  r.data.canvases[CRp$a.DRAG].setAttribute('data-id', 'layer' + CRp$a.DRAG + '-drag');

  for (var i = 0; i < CRp$a.BUFFER_COUNT; i++) {
    r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef

    r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');
    r.data.bufferCanvases[i].style.position = 'absolute';
    r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
    r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
    r.data.bufferCanvases[i].style.visibility = 'hidden'; //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
  }

  r.pathsEnabled = true;
  var emptyBb = makeBoundingBox();

  var getBoxCenter = function getBoxCenter(bb) {
    return {
      x: (bb.x1 + bb.x2) / 2,
      y: (bb.y1 + bb.y2) / 2
    };
  };

  var getCenterOffset = function getCenterOffset(bb) {
    return {
      x: -bb.w / 2,
      y: -bb.h / 2
    };
  };

  var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {
    var _p = ele[0]._private;
    var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;
    return !same;
  };

  var getStyleKey = function getStyleKey(ele) {
    return ele[0]._private.nodeKey;
  };

  var getLabelKey = function getLabelKey(ele) {
    return ele[0]._private.labelStyleKey;
  };

  var getSourceLabelKey = function getSourceLabelKey(ele) {
    return ele[0]._private.sourceLabelStyleKey;
  };

  var getTargetLabelKey = function getTargetLabelKey(ele) {
    return ele[0]._private.targetLabelStyleKey;
  };

  var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r.drawElement(context, ele, bb, false, false, useEleOpacity);
  };

  var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r.drawElementText(context, ele, bb, scaledLabelShown, 'main', useEleOpacity);
  };

  var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r.drawElementText(context, ele, bb, scaledLabelShown, 'source', useEleOpacity);
  };

  var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {
    return r.drawElementText(context, ele, bb, scaledLabelShown, 'target', useEleOpacity);
  };

  var getElementBox = function getElementBox(ele) {
    ele.boundingBox();
    return ele[0]._private.bodyBounds;
  };

  var getLabelBox = function getLabelBox(ele) {
    ele.boundingBox();
    return ele[0]._private.labelBounds.main || emptyBb;
  };

  var getSourceLabelBox = function getSourceLabelBox(ele) {
    ele.boundingBox();
    return ele[0]._private.labelBounds.source || emptyBb;
  };

  var getTargetLabelBox = function getTargetLabelBox(ele) {
    ele.boundingBox();
    return ele[0]._private.labelBounds.target || emptyBb;
  };

  var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {
    return scaledLabelShown;
  };

  var getElementRotationPoint = function getElementRotationPoint(ele) {
    return getBoxCenter(getElementBox(ele));
  };

  var addTextMargin = function addTextMargin(prefix, pt, ele) {
    var pre = prefix ? prefix + '-' : '';
    return {
      x: pt.x + ele.pstyle(pre + 'text-margin-x').pfValue,
      y: pt.y + ele.pstyle(pre + 'text-margin-y').pfValue
    };
  };

  var getRsPt = function getRsPt(ele, x, y) {
    var rs = ele[0]._private.rscratch;
    return {
      x: rs[x],
      y: rs[y]
    };
  };

  var getLabelRotationPoint = function getLabelRotationPoint(ele) {
    return addTextMargin('', getRsPt(ele, 'labelX', 'labelY'), ele);
  };

  var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {
    return addTextMargin('source', getRsPt(ele, 'sourceLabelX', 'sourceLabelY'), ele);
  };

  var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {
    return addTextMargin('target', getRsPt(ele, 'targetLabelX', 'targetLabelY'), ele);
  };

  var getElementRotationOffset = function getElementRotationOffset(ele) {
    return getCenterOffset(getElementBox(ele));
  };

  var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {
    return getCenterOffset(getSourceLabelBox(ele));
  };

  var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {
    return getCenterOffset(getTargetLabelBox(ele));
  };

  var getLabelRotationOffset = function getLabelRotationOffset(ele) {
    var bb = getLabelBox(ele);
    var p = getCenterOffset(getLabelBox(ele));

    if (ele.isNode()) {
      switch (ele.pstyle('text-halign').value) {
        case 'left':
          p.x = -bb.w;
          break;

        case 'right':
          p.x = 0;
          break;
      }

      switch (ele.pstyle('text-valign').value) {
        case 'top':
          p.y = -bb.h;
          break;

        case 'bottom':
          p.y = 0;
          break;
      }
    }

    return p;
  };

  var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {
    getKey: getStyleKey,
    doesEleInvalidateKey: backgroundTimestampHasChanged,
    drawElement: drawElement,
    getBoundingBox: getElementBox,
    getRotationPoint: getElementRotationPoint,
    getRotationOffset: getElementRotationOffset,
    allowEdgeTxrCaching: false,
    allowParentTxrCaching: false
  });
  var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {
    getKey: getLabelKey,
    drawElement: drawLabel,
    getBoundingBox: getLabelBox,
    getRotationPoint: getLabelRotationPoint,
    getRotationOffset: getLabelRotationOffset,
    isVisible: isLabelVisibleAtScale
  });
  var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {
    getKey: getSourceLabelKey,
    drawElement: drawSourceLabel,
    getBoundingBox: getSourceLabelBox,
    getRotationPoint: getSourceLabelRotationPoint,
    getRotationOffset: getSourceLabelRotationOffset,
    isVisible: isLabelVisibleAtScale
  });
  var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {
    getKey: getTargetLabelKey,
    drawElement: drawTargetLabel,
    getBoundingBox: getTargetLabelBox,
    getRotationPoint: getTargetLabelRotationPoint,
    getRotationOffset: getTargetLabelRotationOffset,
    isVisible: isLabelVisibleAtScale
  });
  var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);
  r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {
    // each cache should check for sub-key diff to see that the update affects that cache particularly
    eleTxrCache.invalidateElements(eles);
    lblTxrCache.invalidateElements(eles);
    slbTxrCache.invalidateElements(eles);
    tlbTxrCache.invalidateElements(eles); // any change invalidates the layers

    lyrTxrCache.invalidateElements(eles); // update the old bg timestamp so diffs can be done in the ele txr caches

    for (var _i = 0; _i < eles.length; _i++) {
      var _p = eles[_i]._private;
      _p.oldBackgroundTimestamp = _p.backgroundTimestamp;
    }
  });

  var refineInLayers = function refineInLayers(reqs) {
    for (var i = 0; i < reqs.length; i++) {
      lyrTxrCache.enqueueElementRefinement(reqs[i].ele);
    }
  };

  eleTxrCache.onDequeue(refineInLayers);
  lblTxrCache.onDequeue(refineInLayers);
  slbTxrCache.onDequeue(refineInLayers);
  tlbTxrCache.onDequeue(refineInLayers);
}

CRp$a.redrawHint = function (group, bool) {
  var r = this;

  switch (group) {
    case 'eles':
      r.data.canvasNeedsRedraw[CRp$a.NODE] = bool;
      break;

    case 'drag':
      r.data.canvasNeedsRedraw[CRp$a.DRAG] = bool;
      break;

    case 'select':
      r.data.canvasNeedsRedraw[CRp$a.SELECT_BOX] = bool;
      break;
  }
}; // whether to use Path2D caching for drawing


var pathsImpld = typeof Path2D !== 'undefined';

CRp$a.path2dEnabled = function (on) {
  if (on === undefined) {
    return this.pathsEnabled;
  }

  this.pathsEnabled = on ? true : false;
};

CRp$a.usePaths = function () {
  return pathsImpld && this.pathsEnabled;
};

CRp$a.setImgSmoothing = function (context, bool) {
  if (context.imageSmoothingEnabled != null) {
    context.imageSmoothingEnabled = bool;
  } else {
    context.webkitImageSmoothingEnabled = bool;
    context.mozImageSmoothingEnabled = bool;
    context.msImageSmoothingEnabled = bool;
  }
};

CRp$a.getImgSmoothing = function (context) {
  if (context.imageSmoothingEnabled != null) {
    return context.imageSmoothingEnabled;
  } else {
    return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;
  }
};

CRp$a.makeOffscreenCanvas = function (width, height) {
  var canvas;

  if ((typeof OffscreenCanvas === "undefined" ? "undefined" : _typeof(OffscreenCanvas)) !== ( "undefined" )) {
    canvas = new OffscreenCanvas(width, height);
  } else {
    canvas = document.createElement('canvas'); // eslint-disable-line no-undef

    canvas.width = width;
    canvas.height = height;
  }

  return canvas;
};

[CRp, CRp$1, CRp$2, CRp$3, CRp$4, CRp$5, CRp$6, CRp$7, CRp$8, CRp$9].forEach(function (props) {
  extend(CRp$a, props);
});

var renderer = [{
  name: 'null',
  impl: NullRenderer
}, {
  name: 'base',
  impl: BR
}, {
  name: 'canvas',
  impl: CR
}];

var incExts = [{
  type: 'layout',
  extensions: layout
}, {
  type: 'renderer',
  extensions: renderer
}];

var extensions = {}; // registered modules for extensions, indexed by name

var modules = {};

function setExtension(type, name, registrant) {
  var ext = registrant;

  var overrideErr = function overrideErr(field) {
    error('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');
  };

  if (type === 'core') {
    if (Core.prototype[name]) {
      return overrideErr(name);
    } else {
      Core.prototype[name] = registrant;
    }
  } else if (type === 'collection') {
    if (Collection.prototype[name]) {
      return overrideErr(name);
    } else {
      Collection.prototype[name] = registrant;
    }
  } else if (type === 'layout') {
    // fill in missing layout functions in the prototype
    var Layout = function Layout(options) {
      this.options = options;
      registrant.call(this, options); // make sure layout has _private for use w/ std apis like .on()

      if (!plainObject(this._private)) {
        this._private = {};
      }

      this._private.cy = options.cy;
      this._private.listeners = [];
      this.createEmitter();
    };

    var layoutProto = Layout.prototype = Object.create(registrant.prototype);
    var optLayoutFns = [];

    for (var i = 0; i < optLayoutFns.length; i++) {
      var fnName = optLayoutFns[i];

      layoutProto[fnName] = layoutProto[fnName] || function () {
        return this;
      };
    } // either .start() or .run() is defined, so autogen the other


    if (layoutProto.start && !layoutProto.run) {
      layoutProto.run = function () {
        this.start();
        return this;
      };
    } else if (!layoutProto.start && layoutProto.run) {
      layoutProto.start = function () {
        this.run();
        return this;
      };
    }

    var regStop = registrant.prototype.stop;

    layoutProto.stop = function () {
      var opts = this.options;

      if (opts && opts.animate) {
        var anis = this.animations;

        if (anis) {
          for (var _i = 0; _i < anis.length; _i++) {
            anis[_i].stop();
          }
        }
      }

      if (regStop) {
        regStop.call(this);
      } else {
        this.emit('layoutstop');
      }

      return this;
    };

    if (!layoutProto.destroy) {
      layoutProto.destroy = function () {
        return this;
      };
    }

    layoutProto.cy = function () {
      return this._private.cy;
    };

    var getCy = function getCy(layout) {
      return layout._private.cy;
    };

    var emitterOpts = {
      addEventFields: function addEventFields(layout, evt) {
        evt.layout = layout;
        evt.cy = getCy(layout);
        evt.target = layout;
      },
      bubble: function bubble() {
        return true;
      },
      parent: function parent(layout) {
        return getCy(layout);
      }
    };
    extend(layoutProto, {
      createEmitter: function createEmitter() {
        this._private.emitter = new Emitter(emitterOpts, this);
        return this;
      },
      emitter: function emitter() {
        return this._private.emitter;
      },
      on: function on(evt, cb) {
        this.emitter().on(evt, cb);
        return this;
      },
      one: function one(evt, cb) {
        this.emitter().one(evt, cb);
        return this;
      },
      once: function once(evt, cb) {
        this.emitter().one(evt, cb);
        return this;
      },
      removeListener: function removeListener(evt, cb) {
        this.emitter().removeListener(evt, cb);
        return this;
      },
      removeAllListeners: function removeAllListeners() {
        this.emitter().removeAllListeners();
        return this;
      },
      emit: function emit(evt, params) {
        this.emitter().emit(evt, params);
        return this;
      }
    });
    define$3.eventAliasesOn(layoutProto);
    ext = Layout; // replace with our wrapped layout
  } else if (type === 'renderer' && name !== 'null' && name !== 'base') {
    // user registered renderers inherit from base
    var BaseRenderer = getExtension('renderer', 'base');
    var bProto = BaseRenderer.prototype;
    var RegistrantRenderer = registrant;
    var rProto = registrant.prototype;

    var Renderer = function Renderer() {
      BaseRenderer.apply(this, arguments);
      RegistrantRenderer.apply(this, arguments);
    };

    var proto = Renderer.prototype;

    for (var pName in bProto) {
      var pVal = bProto[pName];
      var existsInR = rProto[pName] != null;

      if (existsInR) {
        return overrideErr(pName);
      }

      proto[pName] = pVal; // take impl from base
    }

    for (var _pName in rProto) {
      proto[_pName] = rProto[_pName]; // take impl from registrant
    }

    bProto.clientFunctions.forEach(function (name) {
      proto[name] = proto[name] || function () {
        error('Renderer does not implement `renderer.' + name + '()` on its prototype');
      };
    });
    ext = Renderer;
  }

  return setMap({
    map: extensions,
    keys: [type, name],
    value: ext
  });
}

function getExtension(type, name) {
  return getMap({
    map: extensions,
    keys: [type, name]
  });
}

function setModule(type, name, moduleType, moduleName, registrant) {
  return setMap({
    map: modules,
    keys: [type, name, moduleType, moduleName],
    value: registrant
  });
}

function getModule(type, name, moduleType, moduleName) {
  return getMap({
    map: modules,
    keys: [type, name, moduleType, moduleName]
  });
}

var extension = function extension() {
  // e.g. extension('renderer', 'svg')
  if (arguments.length === 2) {
    return getExtension.apply(null, arguments);
  } // e.g. extension('renderer', 'svg', { ... })
  else if (arguments.length === 3) {
      return setExtension.apply(null, arguments);
    } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
    else if (arguments.length === 4) {
        return getModule.apply(null, arguments);
      } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
      else if (arguments.length === 5) {
          return setModule.apply(null, arguments);
        } else {
          error('Invalid extension access syntax');
        }
}; // allows a core instance to access extensions internally


Core.prototype.extension = extension; // included extensions

incExts.forEach(function (group) {
  group.extensions.forEach(function (ext) {
    setExtension(group.type, ext.name, ext.impl);
  });
});

// (useful for init)

var Stylesheet = function Stylesheet() {
  if (!(this instanceof Stylesheet)) {
    return new Stylesheet();
  }

  this.length = 0;
};

var sheetfn = Stylesheet.prototype;

sheetfn.instanceString = function () {
  return 'stylesheet';
}; // just store the selector to be parsed later


sheetfn.selector = function (selector) {
  var i = this.length++;
  this[i] = {
    selector: selector,
    properties: []
  };
  return this; // chaining
}; // just store the property to be parsed later


sheetfn.css = function (name, value) {
  var i = this.length - 1;

  if (string(name)) {
    this[i].properties.push({
      name: name,
      value: value
    });
  } else if (plainObject(name)) {
    var map = name;
    var propNames = Object.keys(map);

    for (var j = 0; j < propNames.length; j++) {
      var key = propNames[j];
      var mapVal = map[key];

      if (mapVal == null) {
        continue;
      }

      var prop = Style.properties[key] || Style.properties[dash2camel(key)];

      if (prop == null) {
        continue;
      }

      var _name = prop.name;
      var _value = mapVal;
      this[i].properties.push({
        name: _name,
        value: _value
      });
    }
  }

  return this; // chaining
};

sheetfn.style = sheetfn.css; // generate a real style object from the dummy stylesheet

sheetfn.generateStyle = function (cy) {
  var style = new Style(cy);
  return this.appendToStyle(style);
}; // append a dummy stylesheet object on a real style object


sheetfn.appendToStyle = function (style) {
  for (var i = 0; i < this.length; i++) {
    var context = this[i];
    var selector = context.selector;
    var props = context.properties;
    style.selector(selector); // apply selector

    for (var j = 0; j < props.length; j++) {
      var prop = props[j];
      style.css(prop.name, prop.value); // apply property
    }
  }

  return style;
};

var version = "3.12.1";

var cytoscape = function cytoscape(options) {
  // if no options specified, use default
  if (options === undefined) {
    options = {};
  } // create instance


  if (plainObject(options)) {
    return new Core(options);
  } // allow for registration of extensions
  else if (string(options)) {
      return extension.apply(extension, arguments);
    }
}; // e.g. cytoscape.use( require('cytoscape-foo'), bar )


cytoscape.use = function (ext) {
  var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext

  args.unshift(cytoscape); // cytoscape is first arg to ext

  ext.apply(null, args);
  return this;
};

cytoscape.warnings = function (bool) {
  return warnings(bool);
}; // replaced by build system


cytoscape.version = version; // expose public apis (mostly for extensions)

cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;

module.exports = cytoscape;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),

/***/ "./node_modules/heap/index.js":
/*!************************************!*\
  !*** ./node_modules/heap/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/heap */ "./node_modules/heap/lib/heap.js");


/***/ }),

/***/ "./node_modules/heap/lib/heap.js":
/*!***************************************!*\
  !*** ./node_modules/heap/lib/heap.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    if (true) {
      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  })(this, function() {
    return Heap;
  });

}).call(this);


/***/ }),

/***/ "./node_modules/lodash.debounce/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.debounce/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash.memoize/index.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash.memoize/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = memoize;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/*! exports provided: render, hydrate, createElement, h, Fragment, createRef, isValidElement, Component, cloneElement, createContext, toChildArray, _unmount, options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return E; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return H; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return I; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return L; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toChildArray", function() { return b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_unmount", function() { return A; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "options", function() { return n; });
var n,l,u,t,i,o,r,f={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function a(n){var l=n.parentNode;l&&l.removeChild(n)}function h(n,l,u){var t,i,o,r,f=arguments;if(l=s({},l),arguments.length>3)for(u=[u],t=3;t<arguments.length;t++)u.push(f[t]);if(null!=u&&(l.children=u),null!=n&&null!=n.defaultProps)for(i in n.defaultProps)void 0===l[i]&&(l[i]=n.defaultProps[i]);return r=l.key,null!=(o=l.ref)&&delete l.ref,null!=r&&delete l.key,v(n,l,r,o)}function v(l,u,t,i){var o={type:l,props:u,key:t,ref:i,__k:null,__:null,__b:0,__e:null,__d:null,__c:null,constructor:void 0};return n.vnode&&n.vnode(o),o}function p(){return{}}function d(n){return n.children}function y(n,l){this.props=n,this.context=l}function m(n,l){if(null==l)return n.__?m(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?m(n):null}function w(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return w(n)}}function g(l){(!l.__d&&(l.__d=!0)&&1===u.push(l)||i!==n.debounceRendering)&&((i=n.debounceRendering)||t)(k)}function k(){var n,l,t,i,o,r,f;for(u.sort(function(n,l){return l.__v.__b-n.__v.__b});n=u.pop();)n.__d&&(t=void 0,i=void 0,r=(o=(l=n).__v).__e,(f=l.__P)&&(t=[],i=T(f,o,s({},o),l.__n,void 0!==f.ownerSVGElement,null,t,null==r?m(o):r),$(t,o),i!=r&&w(o)))}function _(n,l,u,t,i,o,r,c,s){var h,v,p,d,y,w,g,k=u&&u.__k||e,_=k.length;if(c==f&&(c=null!=o?o[0]:_?m(u,0):null),h=0,l.__k=b(l.__k,function(u){if(null!=u){if(u.__=l,u.__b=l.__b+1,null===(p=k[h])||p&&u.key==p.key&&u.type===p.type)k[h]=void 0;else for(v=0;v<_;v++){if((p=k[v])&&u.key==p.key&&u.type===p.type){k[v]=void 0;break}p=null}if(d=T(n,u,p=p||f,t,i,o,r,c,s),(v=u.ref)&&p.ref!=v&&(g||(g=[]),p.ref&&g.push(p.ref,null,u),g.push(v,u.__c||d,u)),null!=d){if(null==w&&(w=d),null!=u.__d)d=u.__d,u.__d=null;else if(o==p||d!=c||null==d.parentNode){n:if(null==c||c.parentNode!==n)n.appendChild(d);else{for(y=c,v=0;(y=y.nextSibling)&&v<_;v+=2)if(y==d)break n;n.insertBefore(d,c)}"option"==l.type&&(n.value="")}c=d.nextSibling,"function"==typeof l.type&&(l.__d=d)}}return h++,u}),l.__e=w,null!=o&&"function"!=typeof l.type)for(h=o.length;h--;)null!=o[h]&&a(o[h]);for(h=_;h--;)null!=k[h]&&A(k[h],k[h]);if(g)for(h=0;h<g.length;h++)z(g[h],g[++h],g[++h])}function b(n,l,u){if(null==u&&(u=[]),null==n||"boolean"==typeof n)l&&u.push(l(null));else if(Array.isArray(n))for(var t=0;t<n.length;t++)b(n[t],l,u);else u.push(l?l("string"==typeof n||"number"==typeof n?v(null,n,null,null):null!=n.__e||null!=n.__c?v(n.type,n.props,n.key,null):n):n);return u}function x(n,l,u,t,i){var o;for(o in u)o in l||P(n,o,null,u[o],t);for(o in l)i&&"function"!=typeof l[o]||"value"===o||"checked"===o||u[o]===l[o]||P(n,o,l[o],u[o],t)}function C(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]="number"==typeof u&&!1===c.test(l)?u+"px":null==u?"":u}function P(n,l,u,t,i){var o,r,f,e,c;if(i?"className"===l&&(l="class"):"class"===l&&(l="className"),"key"===l||"children"===l);else if("style"===l)if(o=n.style,"string"==typeof u)o.cssText=u;else{if("string"==typeof t&&(o.cssText="",t=null),t)for(r in t)u&&r in u||C(o,r,"");if(u)for(f in u)t&&u[f]===t[f]||C(o,f,u[f])}else"o"===l[0]&&"n"===l[1]?(e=l!==(l=l.replace(/Capture$/,"")),c=l.toLowerCase(),l=(c in n?c:l).slice(2),u?(t||n.addEventListener(l,N,e),(n.l||(n.l={}))[l]=u):n.removeEventListener(l,N,e)):"list"!==l&&"tagName"!==l&&"form"!==l&&!i&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/^xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u?n.removeAttribute(l):n.setAttribute(l,u))}function N(l){this.l[l.type](n.event?n.event(l):l)}function T(l,u,t,i,o,r,f,e,c){var a,h,v,p,m,w,g,k,x,C,P=u.type;if(void 0!==u.constructor)return null;(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(k=u.props,x=(a=P.contextType)&&i[a.__c],C=a?x?x.props.value:a.__:i,t.__c?g=(h=u.__c=t.__c).__=h.__E:("prototype"in P&&P.prototype.render?u.__c=h=new P(k,C):(u.__c=h=new y(k,C),h.constructor=P,h.render=D),x&&x.sub(h),h.props=k,h.state||(h.state={}),h.context=C,h.__n=i,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=s({},h.__s)),s(h.__s,P.getDerivedStateFromProps(k,h.__s))),p=h.props,m=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==P.getDerivedStateFromProps&&null==h.__e&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(k,C),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(k,h.__s,C)){for(h.props=k,h.state=h.__s,h.__d=!1,h.__v=u,u.__e=t.__e,u.__k=t.__k,h.__h.length&&f.push(h),a=0;a<u.__k.length;a++)u.__k[a]&&(u.__k[a].__=u);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(k,h.__s,C),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(p,m,w)})}h.context=C,h.props=k,h.state=h.__s,(a=n.__r)&&a(u),h.__d=!1,h.__v=u,h.__P=l,a=h.render(h.props,h.state,h.context),u.__k=b(null!=a&&a.type==d&&null==a.key?a.props.children:a),null!=h.getChildContext&&(i=s(s({},i),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(w=h.getSnapshotBeforeUpdate(p,m)),_(l,u,t,i,o,r,f,e,c),h.base=u.__e,h.__h.length&&f.push(h),g&&(h.__E=h.__=null),h.__e=null}else u.__e=j(t.__e,u,t,i,o,r,f,c);(a=n.diffed)&&a(u)}catch(l){n.__e(l,u,t)}return u.__e}function $(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function j(n,l,u,t,i,o,r,c){var s,a,h,v,p,d=u.props,y=l.props;if(i="svg"===l.type||i,null==n&&null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&(null===l.type?3===a.nodeType:a.localName===l.type)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(y);n=i?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type),o=null}if(null===l.type)null!=o&&(o[o.indexOf(n)]=null),d!==y&&(n.data=y);else if(l!==u){if(null!=o&&(o=e.slice.call(n.childNodes)),h=(d=u.props||f).dangerouslySetInnerHTML,v=y.dangerouslySetInnerHTML,!c){if(d===f)for(d={},p=0;p<n.attributes.length;p++)d[n.attributes[p].name]=n.attributes[p].value;(v||h)&&(v&&h&&v.__html==h.__html||(n.innerHTML=v&&v.__html||""))}x(n,y,d,i,c),l.__k=l.props.children,v||_(n,l,u,t,"foreignObject"!==l.type&&i,o,r,f,c),c||("value"in y&&void 0!==y.value&&y.value!==n.value&&(n.value=null==y.value?"":y.value),"checked"in y&&void 0!==y.checked&&y.checked!==n.checked&&(n.checked=y.checked))}return n}function z(l,u,t){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,t)}}function A(l,u,t){var i,o,r;if(n.unmount&&n.unmount(l),(i=l.ref)&&z(i,null,u),t||"function"==typeof l.type||(t=null!=(o=l.__e)),l.__e=l.__d=null,null!=(i=l.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(l){n.__e(l,u)}i.base=i.__P=null}if(i=l.__k)for(r=0;r<i.length;r++)i[r]&&A(i[r],u,t);null!=o&&a(o)}function D(n,l,u){return this.constructor(n,u)}function E(l,u,t){var i,r,c;n.__&&n.__(l,u),r=(i=t===o)?null:t&&t.__k||u.__k,l=h(d,null,[l]),c=[],T(u,(i?u:t||u).__k=l,r||f,f,void 0!==u.ownerSVGElement,t&&!i?[t]:r?null:e.slice.call(u.childNodes),c,t||f,i),$(c,l)}function H(n,l){E(n,l,o)}function I(n,l){return l=s(s({},n.props),l),arguments.length>2&&(l.children=e.slice.call(arguments,2)),v(n.type,l,l.key||n.key,l.ref||n.ref)}function L(n){var l={},u={__c:"__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var t,i=this;return this.getChildContext||(t=[],this.getChildContext=function(){return l[u.__c]=i,l},this.shouldComponentUpdate=function(l){n.value!==l.value&&t.some(function(n){n.context=l.value,g(n)})},this.sub=function(n){t.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){t.splice(t.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Consumer.contextType=u,u}n={__e:function(n,l){for(var u;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError)u.setState(u.constructor.getDerivedStateFromError(n));else{if(null==u.componentDidCatch)continue;u.componentDidCatch(n)}return g(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},y.prototype.setState=function(n,l){var u;u=this.__s!==this.state?this.__s:this.__s=s({},this.state),"function"==typeof n&&(n=n(u,this.props)),n&&s(u,n),null!=n&&this.__v&&(this.__e=!1,l&&this.__h.push(l),g(this))},y.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),g(this))},y.prototype.render=d,u=[],t="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,o=f,r=0;
//# sourceMappingURL=preact.module.js.map


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/client/components/app.js":
/*!**************************************!*\
  !*** ./src/client/components/app.js ***!
  \**************************************/
/*! exports provided: default, AppComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppComponent", function() { return AppComponent; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../controller */ "./src/client/controller.js");
/* harmony import */ var cytoscape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cytoscape */ "./node_modules/cytoscape/dist/cytoscape.cjs.js");
/* harmony import */ var cytoscape__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(cytoscape__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _cy_conf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cy-conf */ "./src/client/cy-conf/index.js");
/* harmony import */ var _cytoscape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cytoscape */ "./src/client/components/cytoscape.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../env */ "./src/client/env.js");
/* harmony import */ var _node_info__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node-info */ "./src/client/components/node-info.js");
/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./menu */ "./src/client/components/menu.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }










var AppComponent =
/*#__PURE__*/
function (_Component) {
  _inherits(AppComponent, _Component);

  function AppComponent(props) {
    var _this;

    _classCallCheck(this, AppComponent);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(AppComponent).call(this, props));
    var cy = new cytoscape__WEBPACK_IMPORTED_MODULE_2___default.a({
      elements: _cy_conf__WEBPACK_IMPORTED_MODULE_3__["elements"],
      style: _cy_conf__WEBPACK_IMPORTED_MODULE_3__["style"],
      layout: {
        name: 'preset'
      },
      selectionType: 'single',
      boxSelectionEnabled: false
    });
    cy.nodes().panify().ungrabify();
    var controller = new _controller__WEBPACK_IMPORTED_MODULE_1__["Controller"]({
      cy: cy
    });
    var bus = controller.bus;

    if (_env__WEBPACK_IMPORTED_MODULE_5__["isDev"]) {
      window.cy = cy;
      window.controller = controller;
    }

    _this.state = {
      controller: controller,
      cy: cy
    };
    bus.on('showInfo', _this.onShowInfo = function (node) {
      _this.setState({
        infoNode: node
      });
    });
    bus.on('hideInfo', _this.onHideInfo = function () {
      _this.setState({
        infoNode: null
      });
    });
    return _this;
  }

  _createClass(AppComponent, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var bus = this.state.controller.bus;
      bus.removeListener('showInfo', this.onShowInfo);
      bus.removeListener('hideInfo', this.onHideInfo);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state = this.state,
          cy = _this$state.cy,
          controller = _this$state.controller,
          infoNode = _this$state.infoNode;
      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'app'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_cytoscape__WEBPACK_IMPORTED_MODULE_4__["default"], {
        cy: cy,
        controller: controller
      }), infoNode ? Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'app-node-info'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_node_info__WEBPACK_IMPORTED_MODULE_6__["NodeInfo"], {
        node: infoNode
      })]) : null, Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_menu__WEBPACK_IMPORTED_MODULE_7__["Menu"], {
        controller: controller
      })]);
    }
  }]);

  return AppComponent;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (AppComponent);


/***/ }),

/***/ "./src/client/components/cytoscape.js":
/*!********************************************!*\
  !*** ./src/client/components/cytoscape.js ***!
  \********************************************/
/*! exports provided: default, CytoscapeComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CytoscapeComponent", function() { return CytoscapeComponent; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var CytoscapeComponent =
/*#__PURE__*/
function (_Component) {
  _inherits(CytoscapeComponent, _Component);

  function CytoscapeComponent(props) {
    _classCallCheck(this, CytoscapeComponent);

    return _possibleConstructorReturn(this, _getPrototypeOf(CytoscapeComponent).call(this, props));
  }

  _createClass(CytoscapeComponent, [{
    key: "render",
    value: function render() {
      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        id: 'cy'
      });
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props = this.props,
          cy = _this$props.cy,
          controller = _this$props.controller;
      var container = document.getElementById('cy');
      cy.mount(container);
      cy.fit(10);
      cy.on('tap', this.onTap = function (e) {
        if (e.target === cy) {
          controller.unhighlight();
          controller.hideInfo();
          controller.closeMenu();
        } else {
          controller.highlight(e.target);
          controller.showInfo(e.target);
          controller.closeMenu();
        }
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var cy = this.props.cy;
      cy.removeListener('tap', this.onTap);
    }
  }]);

  return CytoscapeComponent;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (CytoscapeComponent);


/***/ }),

/***/ "./src/client/components/menu.js":
/*!***************************************!*\
  !*** ./src/client/components/menu.js ***!
  \***************************************/
/*! exports provided: default, Menu */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Menu", function() { return Menu; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! classnames */ "./node_modules/classnames/index.js");
/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node-info */ "./src/client/components/node-info.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }






var Menu =
/*#__PURE__*/
function (_Component) {
  _inherits(Menu, _Component);

  function Menu(props) {
    var _this;

    _classCallCheck(this, Menu);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Menu).call(this, props));
    var controller = props.controller;
    var bus = controller.bus;
    _this.state = {
      open: controller.isMenuOpen()
    };
    bus.on('openMenu', _this.onOpenMenu = function () {
      _this.setState({
        open: true
      });

      _this.focusTextBox();
    });
    bus.on('closeMenu', _this.onOpenMenu = function () {
      _this.setState({
        open: false
      });
    });
    bus.on('updateSearch', _this.onUpdateSearch = function (searchMatchNodes) {
      _this.setState({
        searchMatchNodes: searchMatchNodes
      });
    });
    _this.debouncedUpdateSearch = lodash_debounce__WEBPACK_IMPORTED_MODULE_2___default()(function () {
      return _this.updateSearch();
    }, 250);
    return _this;
  }

  _createClass(Menu, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var bus = this.props.controller.bus;
      bus.removeListener('openMenu', this.onOpenMenu);
      bus.removeListener('closeMenu', this.onCloseMenu);
      bus.removeListener('updateSearch', this.onUpdateSearch);
    }
  }, {
    key: "open",
    value: function open() {
      var controller = this.props.controller;
      controller.openMenu();
    }
  }, {
    key: "updateSearch",
    value: function updateSearch() {
      var controller = this.props.controller;
      var input = document.getElementById('menu-search');
      var results = document.getElementById('menu-search-results');
      var queryString = input.value;
      results.scrollTo(0, 0);
      controller.updateSearch(queryString);
    }
  }, {
    key: "focusTextBox",
    value: function focusTextBox() {
      var input = document.getElementById('menu-search');

      if (input) {
        input.focus();
      }
    }
  }, {
    key: "selectNode",
    value: function selectNode(node) {
      var controller = this.props.controller;
      controller.closeMenu();
      controller.highlight(node);
      controller.showInfo(node);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var controller = this.props.controller;
      var _this$state = this.state,
          open = _this$state.open,
          searchMatchNodes = _this$state.searchMatchNodes;
      var closed = !open;
      var searchResults = [];

      if (searchMatchNodes) {
        searchResults = searchMatchNodes.map(function (node) {
          return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div.menu-node-info', {
            onClick: function onClick() {
              return _this2.selectNode(node);
            }
          }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])(_node_info__WEBPACK_IMPORTED_MODULE_3__["NodeInfo"], {
            node: node
          })]);
        });
      }

      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'menu-parent'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'menu-toggle': true,
          'menu-open': open
        }),
        onClick: function onClick() {
          return controller.toggleMenu();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": classnames__WEBPACK_IMPORTED_MODULE_1___default()({
          'menu': true,
          'menu-closed': closed
        })
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('input', {
        type: 'text',
        "class": 'menu-search',
        placeholder: 'Search',
        id: 'menu-search',
        onClick: function onClick() {
          return _this2.open();
        },
        onKeyDown: function onKeyDown() {
          return _this2.debouncedUpdateSearch();
        }
      }), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'menu-search-results',
        id: 'menu-search-results'
      }, searchResults)])]);
    }
  }]);

  return Menu;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (Menu);


/***/ }),

/***/ "./src/client/components/node-info.js":
/*!********************************************!*\
  !*** ./src/client/components/node-info.js ***!
  \********************************************/
/*! exports provided: default, NodeInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NodeInfo", function() { return NodeInfo; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }



var NodeInfo =
/*#__PURE__*/
function (_Component) {
  _inherits(NodeInfo, _Component);

  function NodeInfo(props) {
    _classCallCheck(this, NodeInfo);

    return _possibleConstructorReturn(this, _getPrototypeOf(NodeInfo).call(this, props));
  }

  _createClass(NodeInfo, [{
    key: "render",
    value: function render() {
      var node = this.props.node;
      var data = node.data();
      var name = data.name;
      var type = data.NodeTypeFormatted + (data.Type ? " (".concat(data.Type, ")") : '');
      var milk = data.Milk;
      var isMilk = milk != null;
      var country = data.Country;
      var hasCountry = country != null;
      var q = encodeURIComponent(data.NodeType === 'Cheese' ? "".concat(name, " cheese") : name);
      var edges = node.connectedEdges().map(function (edge) {
        return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('li', {
          "class": 'node-info-more-detail'
        }, edge.data().orig_sent);
      }); // console.log(node.data());

      return Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info'
      }, [Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-name'
      }, name), Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-type'
      }, type), isMilk ? Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-milk'
      }, milk) : null, hasCountry ? Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-country'
      }, country) : null, Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('div', {
        "class": 'node-info-more'
      }, Object(preact__WEBPACK_IMPORTED_MODULE_0__["h"])('ul', {}, edges))]);
    }
  }]);

  return NodeInfo;
}(preact__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (NodeInfo);


/***/ }),

/***/ "./src/client/controller.js":
/*!**********************************!*\
  !*** ./src/client/controller.js ***!
  \**********************************/
/*! exports provided: default, Controller */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Controller", function() { return Controller; });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.memoize */ "./node_modules/lodash.memoize/index.js");
/* harmony import */ var lodash_memoize__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_memoize__WEBPACK_IMPORTED_MODULE_1__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var layoutPadding = 10;
var animationDuration = 500;
var easing = 'ease'; // search parameters

var minMetricValue = 0.25; // filter out nodes from search results if they have total scores lower than this

var minSimilarityValue = 0; // only include in total metric if the individual sim val is on [0.5, 1]

var delayPromise = function delayPromise(duration) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, duration);
  });
};

var getOrgPos = function getOrgPos(n) {
  return Object.assign({}, n.data('orgPos'));
};

var Controller =
/*#__PURE__*/
function () {
  function Controller(_ref) {
    var cy = _ref.cy;

    _classCallCheck(this, Controller);

    this.cy = cy;
    this.bus = new eventemitter3__WEBPACK_IMPORTED_MODULE_0___default.a();
    this.menu = false;
    this.nodes = cy.nodes();
    this.searchMatchNodes = cy.collection();
  }

  _createClass(Controller, [{
    key: "isMenuOpen",
    value: function isMenuOpen() {
      return this.menu;
    }
  }, {
    key: "openMenu",
    value: function openMenu() {
      this.menu = true;
      this.bus.emit('openMenu');
      this.bus.emit('toggleMenu', true);
    }
  }, {
    key: "closeMenu",
    value: function closeMenu() {
      this.menu = false;
      this.bus.emit('closeMenu');
      this.bus.emit('toggleMenu', false);
    }
  }, {
    key: "toggleMenu",
    value: function toggleMenu() {
      if (this.isMenuOpen()) {
        this.closeMenu();
      } else {
        this.openMenu();
      }
    }
  }, {
    key: "isInfoShown",
    value: function isInfoShown() {
      return this.infoNode != null;
    }
  }, {
    key: "showInfo",
    value: function showInfo(node) {
      this.infoNode = node;
      this.bus.emit('showInfo', node);
    }
  }, {
    key: "hideInfo",
    value: function hideInfo() {
      this.bus.emit('hideInfo', this.infoNode);
      this.infoNode = null;
    }
  }, {
    key: "hasHighlight",
    value: function hasHighlight() {
      return this.lastHighlighted != null;
    }
  }, {
    key: "highlight",
    value: function highlight(node) {
      var _this = this;

      var cy = this.cy;

      if (this.highlightInProgress) {
        return Promise.resolve();
      }

      this.highlightInProgress = true;
      var allEles = cy.elements();
      var nhood = this.lastHighlighted = node.closedNeighborhood();
      var others = this.lastUnhighlighted = allEles.not(nhood);

      var showOverview = function showOverview() {
        cy.batch(function () {
          allEles.removeClass('faded highlighted hidden');
          nhood.addClass('highlighted');
          others.addClass('hidden');
          others.positions(getOrgPos);
        });
        var layout = nhood.layout({
          name: 'preset',
          positions: getOrgPos,
          fit: true,
          animate: true,
          animationDuration: animationDuration,
          animationEasing: easing,
          padding: layoutPadding
        });
        layout.run();
        return layout.promiseOn('layoutstop');
      };

      var runLayout = function runLayout() {
        var p = getOrgPos(node);
        var layout = nhood.layout({
          name: 'concentric',
          fit: true,
          animate: true,
          animationDuration: animationDuration,
          animationEasing: easing,
          minNodeSpacing: 50,
          boundingBox: {
            x1: p.x - 1,
            x2: p.x + 1,
            y1: p.y - 1,
            y2: p.y + 1
          },
          avoidOverlap: true,
          concentric: function concentric(ele) {
            if (ele.same(node)) {
              return 2;
            } else {
              return 1;
            }
          },
          levelWidth: function levelWidth() {
            return 1;
          },
          padding: layoutPadding
        });
        var promise = layout.promiseOn('layoutstop');
        layout.run();
        return promise;
      };

      var showOthersFaded = function showOthersFaded() {
        cy.batch(function () {
          others.removeClass('hidden').addClass('faded');
        });
      };

      this.bus.emit('highlight', node);
      return Promise.resolve().then(showOverview).then(function () {
        return delayPromise(animationDuration);
      }).then(runLayout).then(showOthersFaded).then(function () {
        _this.highlightInProgress = false;

        _this.bus.emit('highlightend', node);
      });
    }
  }, {
    key: "unhighlight",
    value: function unhighlight() {
      if (!this.hasHighlight()) {
        return Promise.resolve();
      }

      var cy = this.cy;
      var allEles = cy.elements();
      var allNodes = cy.nodes();
      cy.stop();
      allNodes.stop();
      var nhood = this.lastHighlighted;
      var others = this.lastUnhighlighted;
      this.lastHighlighted = this.lastUnhighlighted = null;

      var hideOthers = function hideOthers() {
        others.addClass('hidden');
        return Promise.resolve();
      };

      var resetClasses = function resetClasses() {
        cy.batch(function () {
          allEles.removeClass('hidden').removeClass('faded').removeClass('highlighted');
        });
        return Promise.resolve();
      };

      var animateToOrgPos = function animateToOrgPos(nhood) {
        return Promise.all(nhood.nodes().map(function (n) {
          return n.animation({
            position: getOrgPos(n),
            duration: animationDuration,
            easing: easing
          }).play().promise();
        }));
      };

      var restorePositions = function restorePositions() {
        cy.batch(function () {
          others.nodes().positions(getOrgPos);
        });
        return animateToOrgPos(nhood.nodes());
      };

      this.bus.emit('unhighlight');
      return Promise.resolve().then(hideOthers).then(restorePositions).then(resetClasses);
    }
  }, {
    key: "updateSearch",
    value: function updateSearch(queryString) {
      var _this2 = this;

      var normalize = function normalize(str) {
        return str.toLowerCase();
      };

      var getWords = function getWords(str) {
        return str.split(/\s+/);
      };

      var queryWords = getWords(normalize(queryString));

      var addWords = function addWords(wordList, wordsStr) {
        if (wordsStr) {
          wordList.push.apply(wordList, _toConsumableArray(getWords(normalize(wordsStr))));
        }
      };

      var cacheNodeWords = function cacheNodeWords(node) {
        var data = node.data();
        var wordList = [];
        addWords(wordList, data.name);
        addWords(wordList, data.Synonym);
        addWords(wordList, data.NodeTypeFormatted);
        addWords(wordList, data.Milk);
        addWords(wordList, data.Type);
        addWords(wordList, data.Country);
        node.data('words', wordList);
      };

      var getStringSimilarity = function getStringSimilarity(queryWord, nodeWord) {
        var index = nodeWord.indexOf(queryWord);

        if (index === 0) {
          var diff = Math.abs(nodeWord.length - queryWord.length);
          var maxLength = Math.max(nodeWord.length, queryWord.length);
          return 1 - diff / maxLength;
        } else {
          return 0;
        }
      };

      var getMetric = function getMetric(node, queryWords) {
        var nodeWords = node.data('words');
        var score = 0;

        for (var i = 0; i < nodeWords.length; i++) {
          var nodeWord = nodeWords[i];

          for (var j = 0; j < queryWords.length; j++) {
            var queryWord = queryWords[j];
            var similarity = getStringSimilarity(queryWord, nodeWord);

            if (similarity > minSimilarityValue) {
              score += similarity;
            }
          }
        }

        return score;
      };

      var getNodeMetric = lodash_memoize__WEBPACK_IMPORTED_MODULE_1___default()(function (node) {
        return getMetric(node, queryWords);
      }, function (node) {
        return node.id();
      });

      if (!this.cachedNodeWords) {
        this.cy.batch(function () {
          _this2.nodes.forEach(cacheNodeWords);
        });
        this.cachedNodeWords = true;
      }

      this.searchMatchNodes = this.nodes.filter(function (node) {
        return getNodeMetric(node) > minMetricValue;
      }).sort(function (nodeA, nodeB) {
        return getNodeMetric(nodeB) - getNodeMetric(nodeA);
      });
      this.bus.emit('updateSearch', this.searchMatchNodes);
      return this.searchMatchNodes;
    }
  }, {
    key: "getSearchMatchNodes",
    value: function getSearchMatchNodes() {
      return this.searchMatchNodes;
    }
  }]);

  return Controller;
}();

/* harmony default export */ __webpack_exports__["default"] = (Controller);


/***/ }),

/***/ "./src/client/cy-conf/elements.js":
/*!****************************************!*\
  !*** ./src/client/cy-conf/elements.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var elements = {
  "nodes": [{
    "data": {
      "id": "8895104",
      "name": "G805R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106971601",
      "name": "melanoma",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "831004",
      "name": "R120Q",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "208404",
      "name": "H723R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106970701",
      "name": "aura",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12873604",
      "name": "p.Q548X",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "10241104",
      "name": "p.P152R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106936601",
      "name": "sporadic colorectal cancer",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12697404",
      "name": "rs258415",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "257045501",
      "name": "demyelination",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "16155804",
      "name": "rs11543198",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1067604",
      "name": "Glu82Lys",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "9624404",
      "name": "G1418D",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "7861604",
      "name": "N440K",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "266704101",
      "name": "autosomal dominant FD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "236204",
      "name": "R14del",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "267378201",
      "name": "skeletal myopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3288104",
      "name": "E421K",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "2720904",
      "name": "R212C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107284601",
      "name": "familial hypertrophic cardiomyopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "13772704",
      "name": "p.Glu410GlyfsX43",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "257154601",
      "name": "systemic inflammation",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106989701",
      "name": "MD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "13508204",
      "name": "rs1092913",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107271801",
      "name": "CTX",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "347904",
      "name": "rs9277535",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107423601",
      "name": "Apert syndrome",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106978601",
      "name": "amyloidosis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "1932601",
      "name": "diastrophic dysplasia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "19190204",
      "name": "rs2294693",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "19319804",
      "name": "rs12970291",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "254631501",
      "name": "Hypomyelination",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "4428504",
      "name": "P394L",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "11159804",
      "name": "A57G",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "11950504",
      "name": "rs3849942",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107550601",
      "name": "TSD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "9464804",
      "name": "rs10498345",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "120426101",
      "name": "limb-girdle type 2B",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106918201",
      "name": "mild hyperphenylalaninemia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12498504",
      "name": "rs10754833",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "20028004",
      "name": "rs75444904",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "6573004",
      "name": "Q292K",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "258259601",
      "name": "chorea",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3854504",
      "name": "p.N29I",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "12373904",
      "name": "rs505922",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "6257804",
      "name": "p.R240X",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1464904",
      "name": "Tyr82Cys",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "258682501",
      "name": "pulmonary disease",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107507101",
      "name": "DCM",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106918201",
      "name": "MHP",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "256642501",
      "name": "hypoketotic hypoglycaemia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "257165801",
      "name": "myopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107430601",
      "name": "MLD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "5510704",
      "name": "R563Q",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107386401",
      "name": "urinary tract cancers",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "4233204",
      "name": "Leu849His",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "263401901",
      "name": "DHFR deficiency",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "255445901",
      "name": "obstetric",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "921004",
      "name": "Lys206Gln",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "259268901",
      "name": "pancreatitis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "4952304",
      "name": "V62M",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "510604",
      "name": "R167W",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "263007401",
      "name": "PTS-deficient",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "265010001",
      "name": "gait disturbance",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "6077904",
      "name": "p. P361L",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "16058004",
      "name": "p.C1733F",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "15138504",
      "name": "p.W746*",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106987201",
      "name": "ALS",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "256915301",
      "name": "complex I deficiency",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "258765001",
      "name": "atrial fibrillation",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107540401",
      "name": "pachyonychia congenita type I",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "4034504",
      "name": "p.E139D",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "13073504",
      "name": "rs704853",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107547401",
      "name": "MEN 2A",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "256343701",
      "name": "lymphoid hyperplasia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106904101",
      "name": "FMF",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "486604",
      "name": "R117H",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "15816404",
      "name": "rs4845625",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107293601",
      "name": "Lynch syndrome",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "1160704",
      "name": "Arg237Gln",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "254200001",
      "name": "OCA",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107292001",
      "name": "Amsterdam II",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "362504",
      "name": "p.R241C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107507101",
      "name": "dilated cardiomyopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "263007401",
      "name": "PTS deficient",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "5324104",
      "name": "R122C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3012204",
      "name": "T67M",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107368101",
      "name": "end-stage renal disease",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12826004",
      "name": "rs2916733",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "13145204",
      "name": "K108E",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "509204",
      "name": "Arg170Trp",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "17866204",
      "name": "rs17530068",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106932701",
      "name": "oral ulcers",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107292001",
      "name": "glycogen storage disease type 1b",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "6208804",
      "name": "Tyr69His",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107452501",
      "name": "FL",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106913701",
      "name": "thymoma",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "16728704",
      "name": "c.549_550delGT",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106906101",
      "name": "T2D",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106909101",
      "name": "diabetes complications",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "259493901",
      "name": "dyskinesia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "31904",
      "name": "1100delC",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "8099504",
      "name": "A172G",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106920001",
      "name": "myeloid malignancies",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "561604",
      "name": "E101K",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "284004",
      "name": "R222Q",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1352204",
      "name": "E161K",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "19189904",
      "name": "Rs9829896",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1465504",
      "name": "N34S",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "266633501",
      "name": "autosomal dominant lateral temporal lobe epilepsy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "258719501",
      "name": "hemolysis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3811604",
      "name": "Gly80Arg",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "260418101",
      "name": "Bipolar disorder",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106971401",
      "name": "kidney disease",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106971701",
      "name": "pediatric asthma",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106925201",
      "name": "haemochromatosis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "257429101",
      "name": "macrocephaly",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107376501",
      "name": "migraine",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "20255604",
      "name": "rs9260151",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "260955401",
      "name": "ataxic episodes",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "7879304",
      "name": "D458V",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "2874404",
      "name": "Arg151Cys",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "10232804",
      "name": "p.L424V",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "13737004",
      "name": "Rs738409",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106983801",
      "name": "AIP",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "29404",
      "name": "delta F508",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "19666104",
      "name": "p.M1029K",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "260566401",
      "name": "PK deficiency",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3771404",
      "name": "A559T",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "259528501",
      "name": "Usher syndrome",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106980801",
      "name": "NAFLD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "20255704",
      "name": "rs3135002",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107368101",
      "name": "end stage renal disease",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "808301",
      "name": "HP",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "267370401",
      "name": "genetic lesion",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3202104",
      "name": "S891A",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "4752904",
      "name": "K257T",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "264444101",
      "name": "sudden death",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "14032704",
      "name": "rs9275517",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "255472201",
      "name": "Byelorussian breast cancer",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107450201",
      "name": "Canavan disease",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "259268901",
      "name": "juvenile pancreatitis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "13577104",
      "name": "R820W",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "254472701",
      "name": "ventricular ectopy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "13820404",
      "name": "p.Arg182Gly",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1322904",
      "name": "p.A307S",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106966501",
      "name": "stroke",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106918201",
      "name": "PKU",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "260321101",
      "name": "microcytic hypochromic anemia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12983204",
      "name": "p.Arg201del",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107481501",
      "name": "mitochondrial encephalomyopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107425401",
      "name": "FVII deficiency",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "83904",
      "name": "E255K",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1584501",
      "name": "GSD type 1a",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "257227401",
      "name": "hearing impairment",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "1687904",
      "name": "R67C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "16058404",
      "name": "p.C1733Y",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1743504",
      "name": "p.R870H",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "260101301",
      "name": "autosomal",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "846504",
      "name": "p.R96H",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107486501",
      "name": "BS",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "2799204",
      "name": "Ser252Phe",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "13772704",
      "name": "c.1227_1228dup",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "16728604",
      "name": "c.1114delG",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107465501",
      "name": "CeD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "8539404",
      "name": "V456A",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106922101",
      "name": "MM",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "4977704",
      "name": "L266V",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3305604",
      "name": "T80A",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "6530504",
      "name": "W258X",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107503801",
      "name": "bladder cancer",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "9700004",
      "name": "T322M",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "264739201",
      "name": "ISs",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107354501",
      "name": "dystonia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "7681404",
      "name": "p.Leu149del",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3204",
      "name": "p.V600E",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "12094204",
      "name": "rs17580",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106936601",
      "name": "colorectal tumors",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "4262404",
      "name": "D513G",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3284704",
      "name": "p.P86L",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107495601",
      "name": "type 1 diabetes",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "2526904",
      "name": "G188R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "678604",
      "name": "C73R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "13036704",
      "name": "c.4034delA",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107362301",
      "name": "MADD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106907601",
      "name": "narcolepsy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "494404",
      "name": "p.R408Q",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106986001",
      "name": "CD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "267282001",
      "name": "cardiac involvement",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107500701",
      "name": "hypertrophic cardiomyopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "254443101",
      "name": "FH",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "258542001",
      "name": "polyposis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "120637201",
      "name": "PED",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107438201",
      "name": "myoclonus epilepsy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "319804",
      "name": "G380R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "262426801",
      "name": "CAVD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107467801",
      "name": "HypoPP",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106992001",
      "name": "leukopenia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "262993401",
      "name": "dysferlinopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "2273901",
      "name": "long QT syndrome type 1",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "75304",
      "name": "R702W",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1153304",
      "name": "R39C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "263356201",
      "name": "Tau",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "6159404",
      "name": "V59G",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "2187504",
      "name": "p.Gly207Arg",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "6611004",
      "name": "R863X",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106971001",
      "name": "Parkinson's disease",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "2504704",
      "name": "32 deltaT",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "256588001",
      "name": "apical hypertrophic cardiomyopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12002404",
      "name": "Y658C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "260617201",
      "name": "idiopathic bronchiectasis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "4869304",
      "name": "R377H",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107402101",
      "name": "NSCLC",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107393501",
      "name": "sialidosis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "4723304",
      "name": "I157T",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3038104",
      "name": "D1152H",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "903304",
      "name": "P81L",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "4789904",
      "name": "Arg723Gly",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1105001",
      "name": "gout",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "265713201",
      "name": "ulcerative colitis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "70604",
      "name": "rs7025486",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "264592201",
      "name": "HBV infection",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "256225101",
      "name": "Tumor",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "262558501",
      "name": "autosomal recessive persistent hyperplastic primary vitreous",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "267385301",
      "name": "type II collagenopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "261146201",
      "name": "EC",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "267380601",
      "name": "Pendred syndrome",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3587804",
      "name": "E1317Q",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107428001",
      "name": "SD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "6536904",
      "name": "R769Q",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107386001",
      "name": "Crouzon and Pfeiffer",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "6077004",
      "name": "Q163X",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1433804",
      "name": "G1306A",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "258174001",
      "name": "autistic",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12140504",
      "name": "rs13333226",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "12889204",
      "name": "R865G",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "13668604",
      "name": "N46H",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106925201",
      "name": "Hereditary hemochromatosis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "254383901",
      "name": "mental retardation",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107532701",
      "name": "TAs",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106916201",
      "name": "migraine without aura",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "264818801",
      "name": "desmin",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107550601",
      "name": "Tay-Sachs disease",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "7858304",
      "name": "p.G192R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3282201",
      "name": "calpainopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "1788404",
      "name": "T704M",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107550501",
      "name": "AD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "33404",
      "name": "35delG",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107451301",
      "name": "IC",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "267343301",
      "name": "cardiac malformations",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "261093201",
      "name": "X-linked dominant Parkinson's disease",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "268304",
      "name": "p.Arg192His",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "260996301",
      "name": "myokymia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "18834004",
      "name": "rs9815663",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "260737701",
      "name": "primary intractable epilepsy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "10241004",
      "name": "p.P152A",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "6160304",
      "name": "p.Asp153Val",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "262758701",
      "name": "myotonia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107500701",
      "name": "Hypertrophic cardiomyopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12679504",
      "name": "p.Gly603Arg",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "8499504",
      "name": "T295M",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3019304",
      "name": "R133C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "989204",
      "name": "P30L",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "18560504",
      "name": "rs7533564",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "7686004",
      "name": "R1905X",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "259766001",
      "name": "epilepsy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106966601",
      "name": "hypertension",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "261099801",
      "name": "cardiomyopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "261733101",
      "name": "EPS",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "8684204",
      "name": "W1191X",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "5908204",
      "name": "p.Asn107Ser",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "18289104",
      "name": "c.359del",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "18934104",
      "name": "rs1422673",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1847204",
      "name": "Arg145Gly",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "15461904",
      "name": "p.Leu474Pro",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "11887804",
      "name": "rs1805007",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "17740804",
      "name": "rs2042329",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "267367901",
      "name": "hypotonia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "4536304",
      "name": "C136R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "8066704",
      "name": "p.D169G",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "258452101",
      "name": "cerebral X-ALD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "2685204",
      "name": "A244V",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1797001",
      "name": "OS",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107256901",
      "name": "ER-negative breast cancer",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107393701",
      "name": "WD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "256225101",
      "name": "tumor",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "15344904",
      "name": "rs11655081",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "811204",
      "name": "D18N",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "4814304",
      "name": "R38X",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "7150104",
      "name": "R420W",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "120597501",
      "name": "Jackson-Weiss syndrome",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "263938501",
      "name": "MCM",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "261602501",
      "name": "JLNS",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "257108101",
      "name": "PGL",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12282404",
      "name": "rs2569512",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107483801",
      "name": "arrhythmogenic right ventricular cardiomyopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3605804",
      "name": "C240F",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3274004",
      "name": "T106M",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3149004",
      "name": "Gly364 to Asp",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107539201",
      "name": "MR",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "258530501",
      "name": "neuronal loss",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12874304",
      "name": "rs987870",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "4244804",
      "name": "G389R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "256372401",
      "name": "uniparental disomy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "260998301",
      "name": "left ventricular non-compaction",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "10112904",
      "name": "rs5770917",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "259499001",
      "name": "pancreatic sufficiency",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "5754004",
      "name": "C46R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "14044204",
      "name": "p.S248Afs*65",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "267312601",
      "name": "AO-GLD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "5739404",
      "name": "S465R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "578704",
      "name": "Arg3500Gln",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "263852501",
      "name": "MCOPCB",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "2727304",
      "name": "p.Asp215Asn",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "12282304",
      "name": "rs6929846",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "19804",
      "name": "T790M",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "258886601",
      "name": "myocyte enlargement",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "6364404",
      "name": "P199P",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "5811104",
      "name": "Q79R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106936601",
      "name": "CRC",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107385101",
      "name": "type IIIa",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "262381401",
      "name": "painful muscle cramps",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "262778001",
      "name": "upper limb malformations",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107276101",
      "name": "CJD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "6847304",
      "name": "I462S",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107503301",
      "name": "DS",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "20299004",
      "name": "rs2284378",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106926201",
      "name": "Charcot-Marie-Tooth",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "260914201",
      "name": "ischemic stroke",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "2785904",
      "name": "F310L",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106986301",
      "name": "cystic fibrosis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106908001",
      "name": "gingivitis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3455804",
      "name": "D444H",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106924901",
      "name": "duodenal ulcer",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "5917704",
      "name": "p.Arg137Gln",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "2793304",
      "name": "I179S",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107387701",
      "name": "gastric non-cardia cancer",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "513604",
      "name": "glycine250--> aspartate",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1494904",
      "name": "L206W",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107519601",
      "name": "CAH",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "161204",
      "name": "H63D",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "17393504",
      "name": "F82V",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "18102104",
      "name": "rs163177",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107435301",
      "name": "familial hypercholesterolemia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "4175304",
      "name": "L345P",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "267139201",
      "name": "CFEOM",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12004004",
      "name": "p.C118Y",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "11777404",
      "name": "P799L",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3511004",
      "name": "R761H",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "259378801",
      "name": "skeletal abnormalities",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "256366601",
      "name": "fibrosis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3811704",
      "name": "Arg237Trp",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "260992301",
      "name": "microcephaly",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "2757904",
      "name": "R279W",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3407404",
      "name": "P86R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "258682501",
      "name": "lung disease",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "54404",
      "name": "G2019S",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107254501",
      "name": "ventricular septal defects",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "17662504",
      "name": "rs755249",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1631504",
      "name": "P253R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107001201",
      "name": "CRD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107483801",
      "name": "septal hypertrophy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "259964101",
      "name": "oculoleptomeningeal amyloidosis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "16058204",
      "name": "p.C1748F",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3072804",
      "name": "I66M",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106906301",
      "name": "GD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106948501",
      "name": "VHL",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "256018601",
      "name": "otitis media",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "18102004",
      "name": "rs10761745",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "2679704",
      "name": "N188S",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "2669604",
      "name": "Pro252Arg",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107505801",
      "name": "ADAMTS13 deficiencies",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107477201",
      "name": "GS",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "10234304",
      "name": "rs10492972",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106986301",
      "name": "CF",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "254308601",
      "name": "conduction defect",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106918201",
      "name": "phenylketonuria",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "259285501",
      "name": "giant",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "261382501",
      "name": "neuropathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "260399801",
      "name": "Pendred's syndrome",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106987301",
      "name": "vasculitis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "14304304",
      "name": "rs2645424",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "248804",
      "name": "I172N",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "6250904",
      "name": "p.D249N",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107368101",
      "name": "ESRD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "6059404",
      "name": "E103D",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107483801",
      "name": "ARVC",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "1545604",
      "name": "R83C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1631404",
      "name": "S252W",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "6732704",
      "name": "c.1932delC",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "671404",
      "name": "P664L",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3861804",
      "name": "R176X",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1534404",
      "name": "R98C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "13246104",
      "name": "rs2727943",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3049604",
      "name": "V804L",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "258004301",
      "name": "malignancy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "258966801",
      "name": "hematologic disorders",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "8280904",
      "name": "E292V",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106970401",
      "name": "MS",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106913501",
      "name": "tauopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12915104",
      "name": "p.G304K",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106971801",
      "name": "MI",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "16936204",
      "name": "rs9896052",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "259371601",
      "name": "sight-threatening diabetic retinopathy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "257967001",
      "name": "cardiac",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "257729201",
      "name": "hypertrophy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "510804",
      "name": "P533R",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107451501",
      "name": "Bernard-Soulier syndrome",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "265404101",
      "name": "neural defects",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "5877404",
      "name": "p.Arg1210Cys",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "6306204",
      "name": "p.R287Q",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107362501",
      "name": "partial epilepsy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "1707404",
      "name": "V180I",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "6992104",
      "name": "R90H",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "262012001",
      "name": "deficiency of mitochondrial 3-hydroxy-3-methylglutaryl-CoA synthase",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107500701",
      "name": "HCM",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "12094104",
      "name": "rs28929474",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107549401",
      "name": "biotinidase deficiency",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3204",
      "name": "V600E",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "255048701",
      "name": "PAD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "1924904",
      "name": "W283X",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "256960301",
      "name": "bone lesions",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "256146201",
      "name": "hyperglycemia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "13382104",
      "name": "rs11986414",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "255521001",
      "name": "congenital muscular dystrophy",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107465501",
      "name": "ALP",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "528704",
      "name": "R231C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "222404",
      "name": "C282Y",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107271801",
      "name": "cerebrotendinous xanthomatosis",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "11767004",
      "name": "rs4784227",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "352801",
      "name": "FMTC",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "4048904",
      "name": "F229L",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "6557404",
      "name": "Y288 C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "256849801",
      "name": "medullary thyroid cancer",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "267292901",
      "name": "pupal lethality",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107422801",
      "name": "CML",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106906301",
      "name": "GD1",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107547401",
      "name": "multiple endocrine neoplasia type 2 syndrome",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "4723204",
      "name": "R145W",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "258765001",
      "name": "AF",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3320504",
      "name": "Arg58Gln",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107423601",
      "name": "Apert",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3477804",
      "name": "Ser78Leu",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "263872401",
      "name": "Muenke syndrome",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107293601",
      "name": "colorectal adenomas",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "689301",
      "name": "familial atrial fibrillation",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "20439004",
      "name": "rs2041570",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "8685304",
      "name": "E1978X",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106936901",
      "name": "Noonan syndrome",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "1435504",
      "name": "p.Arg258Gly",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107465201",
      "name": "HT",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107435301",
      "name": "LDL receptor deficient",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "2945204",
      "name": "phenylalanine-55 to serine",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "261004401",
      "name": "unilateral postaxial polydactyly",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "13864304",
      "name": "rs3850370",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "5467504",
      "name": "P316S",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "16309204",
      "name": "rs7537605",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "4205904",
      "name": "V57del",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "5751904",
      "name": "S140T",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "620504",
      "name": "G480C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107457501",
      "name": "GSDII",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "18213004",
      "name": "rs515071",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "7500104",
      "name": "Q510E",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "476204",
      "name": "Glu22Lys",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106926301",
      "name": "APC",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "6116504",
      "name": "Arg820Gln",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3111004",
      "name": "G13513A",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107354501",
      "name": "focal or segmental dystonia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "19239704",
      "name": "rs903603",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "651304",
      "name": "G13V",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "4019701",
      "name": "Aland island eye disease",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "671404",
      "name": "proline664-leucine",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "263648901",
      "name": "Glut1-deficiency",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106999001",
      "name": "frontotemporal dementia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107393501",
      "name": "type 2",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106971801",
      "name": "myocardial infarction",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106917801",
      "name": "dementing condition",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "2113304",
      "name": "Arg510 to Gln",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "261079401",
      "name": "congenital stationary night blindness phenotypes",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107423601",
      "name": "Pfeiffer syndrome",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "5260404",
      "name": "R702C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "1689901",
      "name": "neurovisceral phenotype",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107523501",
      "name": "Leigh syndrome",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "494404",
      "name": "R408Q",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "16155904",
      "name": "rs8041357",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "8606304",
      "name": "p. P266S",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "5260604",
      "name": "R702H",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "8476504",
      "name": "C229Y",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "5030704",
      "name": "V138F",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "256192501",
      "name": "hypercholesterolemia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107376801",
      "name": "COPD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "1645804",
      "name": "R528H",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "259814101",
      "name": "axonal loss",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "255792701",
      "name": "low-renin, low-aldosterone hypertension",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "267415101",
      "name": "thyroid tumors",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "256225101",
      "name": "tumors",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "260955401",
      "name": "cerebellar ataxia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "9603204",
      "name": "Ser358Leu",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "206004",
      "name": "M694V",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "3985701",
      "name": "dHMN",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "3502704",
      "name": "A337P",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107480901",
      "name": "breast cancer",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "7955204",
      "name": "Thr574Ala",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "106971701",
      "name": "asthma",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "259811301",
      "name": "developmental delay",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "267309701",
      "name": "UPD",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "5381304",
      "name": "I125T",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "254768101",
      "name": "conduction block",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "14055604",
      "name": "R3277C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107480601",
      "name": "coronary spasm",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "397804",
      "name": "Arg104Gln",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "4683804",
      "name": "G724C",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107490301",
      "name": "Achondroplasia",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107527101",
      "name": "myotonic discharges",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "16819504",
      "name": "Thr298Ala",
      "type": "variant"
    }
  }, {
    "data": {
      "id": "107549901",
      "name": "craniosynostotic syndromes",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "267256201",
      "name": "cardiac abnormalities",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "255210801",
      "name": "drug abuse",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "267394401",
      "name": "immunodeficiency",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "106906101",
      "name": "type 2 diabetes",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "260342001",
      "name": "CFTR-related disorders",
      "type": "disease"
    }
  }, {
    "data": {
      "id": "107549901",
      "name": "syndromic form of craniosynostosis",
      "type": "disease"
    }
  }],
  "edges": [{
    "data": {
      "source": "11777404",
      "target": "106989701",
      "name": "identified In",
      "orig_sent": "In MD, a recurrent P799L mutation was identified in nine subjects, as well as 10 novel mutations including F471del, the first deletion mutation of TRPV4."
    }
  }, {
    "data": {
      "source": "18102004",
      "target": "106906101",
      "name": "associated with",
      "orig_sent": "Among them, rs10761745 (JMJD1C) and rs163177 (KCNQ1) were prospectively associated with T2D."
    }
  }, {
    "data": {
      "source": "16936204",
      "target": "259371601",
      "name": "associated with",
      "orig_sent": "Only rs9896052 (p = 6.55 x 10 (-5)) was associated with sight-threatening diabetic retinopathy in both the type 2 (p = 0.035) and the type 1 (p = 0.041) replication cohorts, as well as in the Indian cohort (p = 0.016)."
    }
  }, {
    "data": {
      "source": "264818801",
      "target": "257165801",
      "name": "causes",
      "orig_sent": "We conclude that the L345P desmin missense mutation causes myopathy by interfering in a dominant-negative manner with the dimerization-polymerization process of intermediate filament assembly."
    }
  }, {
    "data": {
      "source": "3811704",
      "target": "267256201",
      "name": "caused",
      "orig_sent": "In contrast, missense mutations produced distinct phenotypes: Gly80Arg caused significant cardiac malformations but only minor skeletal abnormalities; and Arg237Gln and Arg237Trp caused extensive upper limb malformations but less significant cardiac abnormalities."
    }
  }, {
    "data": {
      "source": "16728604",
      "target": "254200001",
      "name": "associated with",
      "orig_sent": "It is the first time, to the best of our knowledge, to report that c.549_550delGT and c.1114delG mutations in the TYR gene were associated with OCA."
    }
  }, {
    "data": {
      "source": "75304",
      "target": "265713201",
      "name": "associated with",
      "orig_sent": "R702W, G908R, and 3020insC were strongly associated with CD but not with ulcerative colitis."
    }
  }, {
    "data": {
      "source": "3477804",
      "target": "1464904",
      "name": "found with",
      "orig_sent": "In the P0 gene a Ser78Leu mutation was found in one family with severe CMT1 and a de novo Tyr82Cys mutation was found in one DSS patient."
    }
  }, {
    "data": {
      "source": "17393504",
      "target": "106920001",
      "name": "identified in",
      "orig_sent": "All five mutations are associated with NS, whereas two (A57G and F82V) have also been identified in urinary tract cancers and myeloid malignancies."
    }
  }, {
    "data": {
      "source": "107271801",
      "target": "5917704",
      "name": "caused by",
      "orig_sent": "Whole-exome sequencing assuming recessive inheritance determined his genetic diagnosis to be cerebrotendinous xanthomatosis caused by homozygous mutations (c.410G> A or p.Arg137Gln) in the cytochrome P450 subfamily 27 A1 (CYP27A1) gene."
    }
  }, {
    "data": {
      "source": "12373904",
      "target": "260914201",
      "name": "associated with",
      "orig_sent": "SNP rs505922 was nominally associated with ischemic stroke (odds ratio = 0.94, 95% confidence interval = 0.88-0.99, p = 0.023)."
    }
  }, {
    "data": {
      "source": "259811301",
      "target": "1322904",
      "name": "carry",
      "orig_sent": "Clinical features are severe developmental delay, microcephaly and dyskinesia."
    }
  }, {
    "data": {
      "source": "8685304",
      "target": "107480901",
      "name": "observed in",
      "orig_sent": "In a third case-control study from Poland, E1978X was observed in 7/3,910 Polish breast cancer cases (0.2%) compared with 1/2,010 cancer-free population controls (OR: 3.6; 95% CI: 0.4-29.3, P = 0.4)."
    }
  }, {
    "data": {
      "source": "17740804",
      "target": "107503801",
      "name": "associated with",
      "orig_sent": "However, rs2042329 was not associated with bladder cancer risk in patients of European descent."
    }
  }, {
    "data": {
      "source": "254631501",
      "target": "6250904",
      "name": "associated with",
      "orig_sent": "Hypomyelination with atrophy of the basal ganglia and cerebellum (H-ABC) has recently been associated with a single heterozygous p.D249N mutation in TUBB4A."
    }
  }, {
    "data": {
      "source": "259285501",
      "target": "1433804",
      "name": "found in",
      "orig_sent": "No giant myotonic discharges or painful muscle cramps were found in the other G1306A families."
    }
  }, {
    "data": {
      "source": "6557404",
      "target": "259811301",
      "name": "described with",
      "orig_sent": "The Y288 C variant was previously described in a child with macrocephaly, mild developmental delay, increased signal intensity in the basal ganglia, partial cortical blindness and retinitis pigmentosa, and slightly elevated N-acetylaspartate in the urine."
    }
  }, {
    "data": {
      "source": "1847204",
      "target": "107500701",
      "name": "linked to",
      "orig_sent": "Family studies showed that an Arg145Gly mutation was linked to HCM and a Lys206Gln mutation had occurred de novo, thus strongly suggesting that cTnI is the seventh HCM gene."
    }
  }, {
    "data": {
      "source": "3111004",
      "target": "107523501",
      "name": "found with",
      "orig_sent": "Since the G13513A mutation was found in 21% of our patients with Leigh syndrome and complex I deficiency (3/14), it appears that this mutation represents a frequent cause of Leigh-like syndrome, which should be systematically tested for molecular diagnosis in affected children and for genetic counselling in their maternal relatives."
    }
  }, {
    "data": {
      "source": "9624404",
      "target": "120426101",
      "name": "causes",
      "orig_sent": "Dysferlin homozygous mutation G1418D causes limb-girdle type 2B in a Mexican family."
    }
  }, {
    "data": {
      "source": "4034504",
      "target": "267309701",
      "name": "found due",
      "orig_sent": "Molecular genetic analysis of lymphoblastic blasts at the time of the ALL diagnosis revealed the germline mutation in a heterozygous state, while in the myelomonocytic blasts occurring with JMML diagnosis, the mutation p.E139D was found in a homozygous state due to a uniparental disomy (UPD)."
    }
  }, {
    "data": {
      "source": "262426801",
      "target": "486604",
      "name": "compound for",
      "orig_sent": "Twenty-one German CAVD patients were compound heterozygous for delta F508 and R117H, which was the most frequent CAVD genotype in our study group."
    }
  }, {
    "data": {
      "source": "107547401",
      "target": "352801",
      "name": "subclassified into",
      "orig_sent": "Therefore, we suggest that MEN 2A families should not be subclassified into MEN 2A and FMTC, but rather according to their specific mutation in the RET protein (i.e., for this family MEN 2A RET C618S)."
    }
  }, {
    "data": {
      "source": "8606304",
      "target": "107457501",
      "name": "associated with",
      "orig_sent": "However, p. P266S, p. P361L and p.R437C might be associated with late-onset GSDII."
    }
  }, {
    "data": {
      "source": "1924904",
      "target": "106983801",
      "name": "found in",
      "orig_sent": "The W283X lesion was found in another unrelated AIP family."
    }
  }, {
    "data": {
      "source": "260418101",
      "target": "13246104",
      "name": "associated with",
      "orig_sent": "Bipolar disorder with alcohol dependence and other co-morbidities was associated with SNP rs2727943 (p = 3.3x10-) on chromosome 3p26.3 located between the genes contactin-4 precursor (BIG-2) and contactin 6 (CNTN6)."
    }
  }, {
    "data": {
      "source": "120637201",
      "target": "259811301",
      "name": "combined with",
      "orig_sent": "We screened 4 additional families, in which PED is combined with epilepsy, developmental delay, or migraine, but not with hemolysis or echinocytosis, and identified 2 additional GLUT1 mutations (A275T, G314S) that decreased glucose transport but did not affect cation permeability."
    }
  }, {
    "data": {
      "source": "17866204",
      "target": "107480901",
      "name": "associated with",
      "orig_sent": "Similarly, rs17530068 at 6q14 was associated with breast cancer (OR = 1.12; P = 1.1 x 10 (-9)), and with both ER-positive (OR = 1.09; P = 1.5 x 10 (-5)) and ER-negative (OR = 1.16, P = 2.5 x 10 (-7)) disease."
    }
  }, {
    "data": {
      "source": "1707404",
      "target": "107276101",
      "name": "caused",
      "orig_sent": "Our results indicate that the V180I mutation caused CJD at an older age, with a slower progression and a lower possibility of developing myoclonus, cerebellar, pyramidal signs and visual disturbance compared with classical sporadic CJD with methionine homozygosity at codon 129 of PRNP."
    }
  }, {
    "data": {
      "source": "83904",
      "target": "107422801",
      "name": "detected in",
      "orig_sent": "Polyfunctional E255K-specific CD8+ T cells were detected in two imatinib-resistant HLA-A3+ CML patients concurrent with an effective anti-CML response to further therapy."
    }
  }, {
    "data": {
      "source": "107425401",
      "target": "2685204",
      "name": "caused by",
      "orig_sent": "FVII deficiency in both populations is caused by a founder A244V mutation in the F7 gene and DJS is caused by two founder mutations, I1173F and R1150H in the MRP2 gene that are specific for Iranian and Moroccan Jewish patients, respectively."
    }
  }, {
    "data": {
      "source": "12498504",
      "target": "106971601",
      "name": "associated with",
      "orig_sent": "We further determined that the rs10754833 [T] was associated with a decreased melanoma risk in 2368 melanoma cases and 7432 controls [for CT genotype: odds ratio (OR)"
    }
  }, {
    "data": {
      "source": "8099504",
      "target": "106936901",
      "name": "convey",
      "orig_sent": "Does the rare A172G mutation of PTPN11 gene convey a mild Noonan syndrome phenotype?"
    }
  }, {
    "data": {
      "source": "256642501",
      "target": "262012001",
      "name": "caused by",
      "orig_sent": "We report two additional patients in whom hypoketotic hypoglycaemia was caused by a deficiency of mitochondrial 3-hydroxy-3-methylglutaryl-CoA synthase (HMCM); two novel mutations were identified (V54M and Y167C), one of which directly involves the catalytic site of the enzyme."
    }
  }, {
    "data": {
      "source": "13577104",
      "target": "107500701",
      "name": "causes",
      "orig_sent": "The R820W mutation in the MYBPC3 gene, associated with hypertrophic cardiomyopathy in cats, causes hypertrophic cardiomyopathy and left ventricular non-compaction in humans."
    }
  }, {
    "data": {
      "source": "258452101",
      "target": "265010001",
      "name": "diagnosed upon",
      "orig_sent": "In a 50 year-old Caucasian male, cerebral X-ALD was diagnosed upon progressive gait disturbance, intellectual decline, elevated very-long chain fatty acids in the serum or leucocytes, cerebral MRI, showing extensive, symmetric, homogenous demyelination in the parieto-occipital areas, the splenium corporis callosum, the thalamus, the crura cerebri, the brain stem, and the pedunculi cerebelli, and the deletion c.1415-1416delAG in the ABCD1-gene."
    }
  }, {
    "data": {
      "source": "2187504",
      "target": "267385301",
      "name": "causes",
      "orig_sent": "We suggest that the p.Gly207Arg variant causes a distinct type II collagenopathy with features of PPRD and SED, Stanescu type."
    }
  }, {
    "data": {
      "source": "106980801",
      "target": "14304304",
      "name": "associated with",
      "orig_sent": "In multivariate models adjusted for age, body mass index, diabetes, waist/hip ratios, and levels of glycated hemoglobin, the NAFLD activity score was associated with the SNP rs2645424 on chromosome 8 in farnesyl diphosphate farnesyl transferase 1 (FDFT1) (P = 6.8 x 10 (-7))."
    }
  }, {
    "data": {
      "source": "3502704",
      "target": "267282001",
      "name": "identified with",
      "orig_sent": "A heterozygous A337P mutation was identified in a family with an adult-onset skeletal myopathy and mild cardiac involvement."
    }
  }, {
    "data": {
      "source": "4752904",
      "target": "106917801",
      "name": "cause",
      "orig_sent": "Taken together, the present findings indicate that the K257T mutation in Tau can cause a dementing condition similar to Pick's disease."
    }
  }, {
    "data": {
      "source": "10232804",
      "target": "258542001",
      "name": "identified in",
      "orig_sent": "POLE p.L424V was identified in a 28-year-old polyposis and CRC patient, as a de novo mutation."
    }
  }, {
    "data": {
      "source": "4789904",
      "target": "258004301",
      "name": "linked to",
      "orig_sent": "The results showed that: Val606Met is an intermediate malignancy mutation; Arg694Leu is a novel mutation with a benign phenotype; and the Arg723Gly mutation is linked to malignancy - it can lead not only to HCM but also to dilated cardiomyopathy at various ages."
    }
  }, {
    "data": {
      "source": "263356201",
      "target": "106913501",
      "name": "causes",
      "orig_sent": "Tau gene mutation G389R causes a tauopathy with abundant pick body-like inclusions and axonal deposits."
    }
  }, {
    "data": {
      "source": "107490301",
      "target": "319804",
      "name": "defined by",
      "orig_sent": "Achondroplasia is defined by recurrent G380R mutations of FGFR3."
    }
  }, {
    "data": {
      "source": "107500701",
      "target": "257967001",
      "name": "associated with",
      "orig_sent": "Hypertrophic cardiomyopathy caused by a novel alpha-tropomyosin mutation (V95A) is associated with mild cardiac phenotype, abnormal calcium binding to troponin, abnormal myosin cycling, and poor prognosis."
    }
  }, {
    "data": {
      "source": "4683804",
      "target": "260955401",
      "name": "exhibit",
      "orig_sent": "(KCNA1 G724C)"
    }
  }, {
    "data": {
      "source": "106925201",
      "target": "222404",
      "name": "associated with",
      "orig_sent": "Hereditary hemochromatosis is associated with C282Y homozygosity."
    }
  }, {
    "data": {
      "source": "10234304",
      "target": "106970401",
      "name": "associated with",
      "orig_sent": "An rs10492972 [C] variant located in the KIF1B gene was associated with MS with an odds ratio of 1.35 (P = 2.5 x 10 (-10))."
    }
  }, {
    "data": {
      "source": "5751904",
      "target": "106926201",
      "name": "associated with",
      "orig_sent": "The S140T mutation in myelin P0 can be associated with conduction block and Charcot-Marie-Tooth should be part of the differential diagnosis of that phenomenon."
    }
  }, {
    "data": {
      "source": "1687904",
      "target": "259268901",
      "name": "found in",
      "orig_sent": "The N34S mutation was found in six familial pancreatitis patients (three families) and in one juvenile pancreatitis patient, and the R67C mutation was found in one familial pancreatitis patient and one juvenile pancreatitis patient."
    }
  }, {
    "data": {
      "source": "831004",
      "target": "259814101",
      "name": "cause",
      "orig_sent": "Both the Q163X and the R120Q mutation cause demyelination and axonal loss."
    }
  }, {
    "data": {
      "source": "4428504",
      "target": "256960301",
      "name": "developed",
      "orig_sent": "The P394L mutant mice developed focal bone lesions with increasing age and by 12 months, 14/18 (77%) heterozygotes and 20/21 (95%) homozygotes had lesions, compared with 0/18 (0%) wild-type littermates (P <0.001)."
    }
  }, {
    "data": {
      "source": "20255604",
      "target": "107495601",
      "name": "associated with",
      "orig_sent": "rs9260151 and rs3135002 have been associated with type 1 diabetes, whereas rs559047 and rs61211515 have not been associated with a risk of developing type 1 diabetes."
    }
  }, {
    "data": {
      "source": "120637201",
      "target": "258719501",
      "name": "combined with",
      "orig_sent": "We screened 4 additional families, in which PED is combined with epilepsy, developmental delay, or migraine, but not with hemolysis or echinocytosis, and identified 2 additional GLUT1 mutations (A275T, G314S) that decreased glucose transport but did not affect cation permeability."
    }
  }, {
    "data": {
      "source": "6573004",
      "target": "1689901",
      "name": "associated with",
      "orig_sent": "The Q292K mutation (homoallelic, heteroallelic) was strongly associated with a protracted neurovisceral phenotype (10 of 12 cases)."
    }
  }, {
    "data": {
      "source": "1067604",
      "target": "254308601",
      "name": "associated with",
      "orig_sent": "Mutation Glu82Lys in lamin A/C gene is associated with cardiomyopathy and conduction defect."
    }
  }, {
    "data": {
      "source": "4814304",
      "target": "903304",
      "name": "reported in",
      "orig_sent": "P81L and R38X mutations have previously been reported in other PGL families and P81L was suggested as a founder mutation."
    }
  }, {
    "data": {
      "source": "9464804",
      "target": "107480601",
      "name": "associated with",
      "orig_sent": "SNP rs10498345 was strongly associated with coronary spasm in Japanese women utilizing genome-wide SNP analysis."
    }
  }, {
    "data": {
      "source": "811204",
      "target": "257154601",
      "name": "exhibit",
      "orig_sent": "The TREX1 D18N mice exhibit systemic inflammation, lymphoid hyperplasia, vasculitis, and kidney disease."
    }
  }, {
    "data": {
      "source": "811204",
      "target": "256343701",
      "name": "exhibit",
      "orig_sent": "The TREX1 D18N mice exhibit systemic inflammation, lymphoid hyperplasia, vasculitis, and kidney disease."
    }
  }, {
    "data": {
      "source": "11159804",
      "target": "107386401",
      "name": "identified in",
      "orig_sent": "All five mutations are associated with NS, whereas two (A57G and F82V) have also been identified in urinary tract cancers and myeloid malignancies."
    }
  }, {
    "data": {
      "source": "347904",
      "target": "264592201",
      "name": "associated with",
      "orig_sent": "We found that rs9277535 (HLA-DPB1, P = 4.87x10 (-14)),"
    }
  }, {
    "data": {
      "source": "16155804",
      "target": "107503801",
      "name": "associated with",
      "orig_sent": "SNP rs11543198 was associated with bladder cancer risk with odds ratio (OR) of 1.41 and P-value of 4.03 x 10 (-9)."
    }
  }, {
    "data": {
      "source": "3811604",
      "target": "259378801",
      "name": "caused",
      "orig_sent": "In contrast, missense mutations produced distinct phenotypes: Gly80Arg caused significant cardiac malformations but only minor skeletal abnormalities; and Arg237Gln and Arg237Trp caused extensive upper limb malformations but less significant cardiac abnormalities."
    }
  }, {
    "data": {
      "source": "16728704",
      "target": "254200001",
      "name": "associated with",
      "orig_sent": "It is the first time, to the best of our knowledge, to report that c.549_550delGT and c.1114delG mutations in the TYR gene were associated with OCA."
    }
  }, {
    "data": {
      "source": "8539404",
      "target": "258682501",
      "name": "cause",
      "orig_sent": "The objective of this study is to provide clinical evidence that V456A, a novel mutation in South Asian Cystic Fibrosis patients, can cause significant lung disease."
    }
  }, {
    "data": {
      "source": "106908001",
      "target": "256018601",
      "name": "associated with",
      "orig_sent": "In the indigenous population, both gingivitis and A2ML1 variants including the known duplication variant and the novel splice variant c.4061+1G> C were independently associated with otitis media."
    }
  }, {
    "data": {
      "source": "5260604",
      "target": "261733101",
      "name": "associated with",
      "orig_sent": "R702C and R702H mutations were only associated with FTNS, EPS, or APSM, thus defining a region of MYHIIA critical in the combined pathogenesis of macrothrombocytopenia, nephritis, and deafness."
    }
  }, {
    "data": {
      "source": "6257804",
      "target": "106970701",
      "name": "found without",
      "orig_sent": "Previously reported p.R240X was found in one patient with PKD with migraine without aura."
    }
  }, {
    "data": {
      "source": "1534404",
      "target": "261382501",
      "name": "develop",
      "orig_sent": "R98C mice, an authentic model of early onset Charcot-Marie-Tooth disease type 1B, develop neuropathy in part because the misfolded mutant myelin protein zero is retained in the endoplasmic reticulum where it activates the unfolded protein response."
    }
  }, {
    "data": {
      "source": "11767004",
      "target": "107480901",
      "name": "associated with",
      "orig_sent": "SNP rs4784227 was consistently associated with breast cancer risk across all studies with adjusted odds ratios (95% confidence intervals) of 1.25 (1.20-1.31) per allele (P = 3.2 x 10 (-25)) in the pooled analysis of samples from all Asian samples."
    }
  }, {
    "data": {
      "source": "1847204",
      "target": "921004",
      "name": "linked to",
      "orig_sent": "Family studies showed that an Arg145Gly mutation was linked to HCM and a Lys206Gln mutation had occurred de novo, thus strongly suggesting that cTnI is the seventh HCM gene."
    }
  }, {
    "data": {
      "source": "106913701",
      "target": "651304",
      "name": "had",
      "orig_sent": "One thymoma and one thymic carcinoma harbored KRAS mutations (G12A and G12V, respectively), and one thymoma had a G13V HRAS mutation."
    }
  }, {
    "data": {
      "source": "265404101",
      "target": "107362301",
      "name": "underdiagnosed with",
      "orig_sent": "Neurite shortening caused by the c.250G> A mutation in ETFDH suggests that neural defects could be underdiagnosed in human patients with MADD."
    }
  }, {
    "data": {
      "source": "528704",
      "target": "689301",
      "name": "causes",
      "orig_sent": "R231C mutation in KCNQ1 causes long QT syndrome type 1 and familial atrial fibrillation."
    }
  }, {
    "data": {
      "source": "2945204",
      "target": "107451501",
      "name": "associated with",
      "orig_sent": "A phenylalanine-55 to serine amino-acid substitution in the human glycoprotein IX leucine-rich repeat is associated with Bernard-Soulier syndrome."
    }
  }, {
    "data": {
      "source": "4205904",
      "target": "263007401",
      "name": "found in",
      "orig_sent": "The T67M and V57del mutations have been found in Caucasian PTS deficient patients, while the L76F, IVS3+1G> A, and K38X mutations are novel."
    }
  }, {
    "data": {
      "source": "1067604",
      "target": "261099801",
      "name": "associated with",
      "orig_sent": "Mutation Glu82Lys in lamin A/C gene is associated with cardiomyopathy and conduction defect."
    }
  }, {
    "data": {
      "source": "3861804",
      "target": "106918201",
      "name": "presented",
      "orig_sent": "Individuals with R111X/A165D and R176X/A165D genotypes, on the other hand, respectively presented moderate and classic PKU phenotypes."
    }
  }, {
    "data": {
      "source": "120597501",
      "target": "107386001",
      "name": "observed in",
      "orig_sent": "In addition, the Jackson-Weiss syndrome mutation, C342R, in exon IIIc was observed previously in other craniosynostotic syndromes, Crouzon and Pfeiffer."
    }
  }, {
    "data": {
      "source": "397804",
      "target": "107271801",
      "name": "identified in",
      "orig_sent": "To our knowledge, this is the first report in which the Arg104Gln mutation is identified in CTX patients."
    }
  }, {
    "data": {
      "source": "19666104",
      "target": "107354501",
      "name": "causes",
      "orig_sent": "In one family, a p.M1029K mutation in the C2 domain causes severe dystonia, hypotonia, and chorea."
    }
  }, {
    "data": {
      "source": "20439004",
      "target": "107465501",
      "name": "associated with",
      "orig_sent": "After replication, SNP rs2041570 on chromosome 7 was significantly associated with progression to RCDII (P=2.37x10, odds ratio=2.36) but not with CeD susceptibility."
    }
  }, {
    "data": {
      "source": "16058204",
      "target": "107550501",
      "name": "associated with",
      "orig_sent": "Clinically, p.C1733Y was associated with GD, as reported previously, as well as the novel p.N1730I, whereas p.C1733F"
    }
  }, {
    "data": {
      "source": "2799204",
      "target": "107423601",
      "name": "causes",
      "orig_sent": "The observation that the Ser252Phe mutation causes Apert syndrome, whereas the other single or double substitutions are associated with milder or normal phenotypes, highlights the exquisitely specific molecular pathogenesis of the limb and craniofacial abnormalities associated with Apert syndrome."
    }
  }, {
    "data": {
      "source": "10112904",
      "target": "106907601",
      "name": "associated with",
      "orig_sent": "rs5770917, a SNP located between CPT1B and CHKB, was associated with narcolepsy in Japanese (rs5770917 [C], odds ratio (OR) = 1.79, combined P = 4.4 x 10 (-7)) and other ancestry groups (OR = 1.40, P = 0.02)."
    }
  }, {
    "data": {
      "source": "107480901",
      "target": "6159404",
      "name": "had",
      "orig_sent": "Another patient, with a melanoma diagnosed at 77 years, a breast cancer diagnosed at 66 and a family history of melanoma, had the V59G mutation."
    }
  }, {
    "data": {
      "source": "3274004",
      "target": "263007401",
      "name": "identified in",
      "orig_sent": "Seven mutations - namely R25G, N52S, V56M, V70D, P87S, D96N, and T106M - had been identified in Chinese PTS-deficient patients previously."
    }
  }, {
    "data": {
      "source": "1105001",
      "target": "6530504",
      "name": "genotyped with",
      "orig_sent": "Here, 1,993 primary gout patients and 4,902 health examination participants (3,305 males and 1,597 females) were genotyped with R90H and W258X."
    }
  }, {
    "data": {
      "source": "578704",
      "target": "256192501",
      "name": "causes",
      "orig_sent": "The Arg3500Gln mutation in the apolipoprotein B gene, which is responsible for familial defective apolipoprotein B-100 and is present in approximately 1 in 1000 persons in Denmark, causes severe hypercholesterolemia and increases the risk of ischemic heart disease."
    }
  }, {
    "data": {
      "source": "12874304",
      "target": "106971701",
      "name": "associated with",
      "orig_sent": "SNP rs987870, located between HLA-DPA1 and HLA-DPB1, was consistently associated with pediatric asthma in 3 independent populations (P (combined) ="
    }
  }, {
    "data": {
      "source": "494404",
      "target": "106918201",
      "name": "classified as",
      "orig_sent": "Both p.R241C and p.R408Q are classified as mild phenylketonuria (PKU) or mild hyperphenylalaninemia (MHP) mutation, which may explain the fact that classical PKU is very rare in Taiwan (n=4, or one in 413,035)."
    }
  }, {
    "data": {
      "source": "13820404",
      "target": "107293601",
      "name": "causes",
      "orig_sent": "Clinical, histological, immunohistochemical and molecular evidence from these families and other independent clinical and scientific evidence indicates that the MLH1 p.Arg182Gly (c.544A> G) change causes Lynch syndrome and supports reclassification of the variant as pathogenic."
    }
  }, {
    "data": {
      "source": "811204",
      "target": "106971401",
      "name": "exhibit",
      "orig_sent": "The TREX1 D18N mice exhibit systemic inflammation, lymphoid hyperplasia, vasculitis, and kidney disease."
    }
  }, {
    "data": {
      "source": "107423601",
      "target": "1631404",
      "name": "had",
      "orig_sent": "Except for one, all the Apert patients had either S252W (n = 16) or P253R (n = 10) mutations."
    }
  }, {
    "data": {
      "source": "1435504",
      "target": "260342001",
      "name": "associated with",
      "orig_sent": "The p.Arg258Gly mutation in intracellular loop 2 of CFTR is associated with CFTR-related disorders."
    }
  }, {
    "data": {
      "source": "5510704",
      "target": "255792701",
      "name": "associated with",
      "orig_sent": "R563Q, a new variant of the beta epithelial sodium channel, is associated with low-renin, low-aldosterone hypertension, in South African black and mixed-ancestry patients."
    }
  }, {
    "data": {
      "source": "903304",
      "target": "257108101",
      "name": "reported in",
      "orig_sent": "P81L and R38X mutations have previously been reported in other PGL families and P81L was suggested as a founder mutation."
    }
  }, {
    "data": {
      "source": "1545604",
      "target": "1584501",
      "name": "demonstrated in",
      "orig_sent": "The R83C mutation was also demonstrated in one homozygous and five heterogenous GSD type 1a patients, indicating that type 1aSP is a misclassification of GSD type 1a."
    }
  }, {
    "data": {
      "source": "31904",
      "target": "256225101",
      "name": "associated in",
      "orig_sent": "Both 1100delC and R145W germ-line mutations in CHK2 are associated with loss of the wild-type allele in the corresponding tumor specimens, and neither tumor harbors a somatic TP53 mutation."
    }
  }, {
    "data": {
      "source": "4262404",
      "target": "106986301",
      "name": "found in",
      "orig_sent": "The novel D513G mutation has not been found in more than 200 non-CF chromosomes and in a sample of 300 CF chromosomes from French classical CF patients."
    }
  }, {
    "data": {
      "source": "1160704",
      "target": "267256201",
      "name": "caused",
      "orig_sent": "In contrast, missense mutations produced distinct phenotypes: Gly80Arg caused significant cardiac malformations but only minor skeletal abnormalities; and Arg237Gln and Arg237Trp caused extensive upper limb malformations but less significant cardiac abnormalities."
    }
  }, {
    "data": {
      "source": "33404",
      "target": "257227401",
      "name": "have",
      "orig_sent": "We found that 35delG homozygotes have significantly more hearing impairment, compared with 35delG/non-35delG compound heterozygotes."
    }
  }, {
    "data": {
      "source": "12826004",
      "target": "106992001",
      "name": "associated with",
      "orig_sent": "The combined analysis indicated that rs2916733 in microcephalin 1 [combined PFisher min=2.27x10, odds ratio (OR) =2.74 with 95% confidence interval (CI) =1.96-3.83; the nonrisk genotype as reference] was significantly associated with epirubicin-induced leukopenia/neutropenia."
    }
  }, {
    "data": {
      "source": "12282304",
      "target": "106971801",
      "name": "associated with",
      "orig_sent": "The rs6929846 SNP of BTN2A1, but not rs2569512 of ILF3, was also significantly associated with MI in Japanese subject panel C."
    }
  }, {
    "data": {
      "source": "7955204",
      "target": "106971601",
      "name": "identified in",
      "orig_sent": "A novel Thr574Ala (c.1720A> G) KIT mutation, which has not been reported in melanoma or other tumor types, was identified in one genital melanoma case."
    }
  }, {
    "data": {
      "source": "8499504",
      "target": "263648901",
      "name": "constitute",
      "orig_sent": "Disease-associated Glut1 single amino acid substitute mutations S66F, R126C, and T295M constitute Glut1-deficiency states in vitro."
    }
  }, {
    "data": {
      "source": "12873604",
      "target": "107480901",
      "name": "associated with",
      "orig_sent": "In a combined analysis of our four case-control series, the p.Q548X mutation was significantly associated with breast cancer (Mantel-Haenszel OR 5.1, 95% CI 1.2; 21.9, p = 0.03)."
    }
  }, {
    "data": {
      "source": "3854504",
      "target": "808301",
      "name": "found Among",
      "orig_sent": "Among HP patients, no p.N29I mutations were found and the p.A16V mutation was more frequent than previously reported, 45 and 32% had exocrine and endocrine insufficiency, respectively, and among tIP patients 9 and 12%, respectively."
    }
  }, {
    "data": {
      "source": "2526904",
      "target": "107292001",
      "name": "confers",
      "orig_sent": "Glucose-6-phosphatase mutation G188R confers an atypical glycogen storage disease type 1b phenotype."
    }
  }, {
    "data": {
      "source": "14044204",
      "target": "107451301",
      "name": "identified in",
      "orig_sent": "The novel frameshift p.S248Afs*65 was identified in a PKD/IC family member with IC and migraine with aura."
    }
  }, {
    "data": {
      "source": "5739404",
      "target": "106906101",
      "name": "found with",
      "orig_sent": "The S465R mutation was found in 0.5% of our patients with common type 2 diabetes and thus may be a rare genetic risk factor contributing to the development of type 2 diabetes rather than MODY5."
    }
  }, {
    "data": {
      "source": "6116504",
      "target": "107500701",
      "name": "associated with",
      "orig_sent": "In conclusion, the c.2067+1G--> A mutation is associated with HCM with substantial hypertrophy and moderate incidence of sudden death, whereas the Arg820Gln mutation is associated with end-stage HCM."
    }
  }, {
    "data": {
      "source": "8895104",
      "target": "107435301",
      "name": "causes",
      "orig_sent": "Mutation G805R in the transmembrane domain of the LDL receptor gene causes familial hypercholesterolemia by inducing ectodomain cleavage of the LDL receptor in the endoplasmic reticulum."
    }
  }, {
    "data": {
      "source": "17393504",
      "target": "107386401",
      "name": "identified in",
      "orig_sent": "All five mutations are associated with NS, whereas two (A57G and F82V) have also been identified in urinary tract cancers and myeloid malignancies."
    }
  }, {
    "data": {
      "source": "12140504",
      "target": "106966601",
      "name": "associated with",
      "orig_sent": "In a subset of 13,446 individuals with estimated glomerular filtration rate (eGFR) measurements, we show that rs13333226 is independently associated with hypertension (unadjusted for eGFR: 0.89 [0.83-0.96], p = 0.004; after eGFR adjustment: 0.89 [0.83-0.96], p = 0.003)."
    }
  }, {
    "data": {
      "source": "4952304",
      "target": "256146201",
      "name": "cause",
      "orig_sent": "We conclude that V62M may cause hyperglycemia by a complex defect of GCK regulation involving instability in combination with loss of control by a putative endogenous activator and/or GKRP."
    }
  }, {
    "data": {
      "source": "1743504",
      "target": "107284601",
      "name": "causes",
      "orig_sent": "A p.R870H mutation in the beta-cardiac myosin heavy chain 7 gene causes familial hypertrophic cardiomyopathy in several members of an Indian family."
    }
  }, {
    "data": {
      "source": "75304",
      "target": "106986001",
      "name": "associated with",
      "orig_sent": "R702W, G908R, and 3020insC were strongly associated with CD but not with ulcerative colitis."
    }
  }, {
    "data": {
      "source": "11887804",
      "target": "2874404",
      "name": "encoding",
      "orig_sent": "A non-synonymous SNP in the MC1R gene (rs1805007 encoding Arg151Cys substitution), a previously well-documented pigmentation gene, showed the strongest association with BCC risk in the discovery set (rs1805007"
    }
  }, {
    "data": {
      "source": "5381304",
      "target": "260617201",
      "name": "associated with",
      "orig_sent": "Furthermore, the I125T mutation was significantly associated with the idiopathic bronchiectasis sub-group (P <0.05)."
    }
  }, {
    "data": {
      "source": "13036704",
      "target": "107480901",
      "name": "associated among",
      "orig_sent": "In addition, among the breast cancer cases the c.4034delA mutation has been associated with a later age of onset and worse clinical outcomes in comparison with the c.5266dupC mutation."
    }
  }, {
    "data": {
      "source": "15816404",
      "target": "258765001",
      "name": "associated with",
      "orig_sent": "SNP rs4845625 in the IL6R gene was associated with AF (relative risk [RR] C allele, 0.90; 95% confidence interval [CI], 0.85-0.95; P=0.0005) in whites but did not reach statistical significance in African Americans (RR, 0.86; 95% CI, 0.72-1.03; P=0.09)."
    }
  }, {
    "data": {
      "source": "1352204",
      "target": "4869304",
      "name": "identified with",
      "orig_sent": "A new missense (E161K) mutation was identified in a family with early atrial fibrillation and a previously described (R377H) mutation in another family with a quadriceps myopathy associated with DCM."
    }
  }, {
    "data": {
      "source": "12002404",
      "target": "107505801",
      "name": "detected with",
      "orig_sent": "Homozygous and heterozygous Y658C (c.1973A> G) alleles were detected in the patient and her child with severe and mild ADAMTS13 deficiencies, respectively."
    }
  }, {
    "data": {
      "source": "6306204",
      "target": "255521001",
      "name": "associated with",
      "orig_sent": "We observe that c.79G> C (p.D27H) is associated with a mild limb-girdle muscular dystrophy phenotype, whereas c.860G> A (p.R287Q) is associated with a relatively severe congenital muscular dystrophy typically involving brain development."
    }
  }, {
    "data": {
      "source": "8066704",
      "target": "258530501",
      "name": "rescued",
      "orig_sent": "Although p.D169G rescued organismal pupal lethality and neuronal loss to a similar extent as wild-type TARDBP, p.A90V, p.G287S, and p.A315T were less efficient."
    }
  }, {
    "data": {
      "source": "19666104",
      "target": "267367901",
      "name": "causes",
      "orig_sent": "In one family, a p.M1029K mutation in the C2 domain causes severe dystonia, hypotonia, and chorea."
    }
  }, {
    "data": {
      "source": "3511004",
      "target": "106904101",
      "name": "found in",
      "orig_sent": "M694I and A744S seem specific to Arab populations, and R761H is frequently found in Lebanese FMF patients."
    }
  }, {
    "data": {
      "source": "18934104",
      "target": "106971701",
      "name": "associated with",
      "orig_sent": "rs1422673 was also associated with asthma in the published GABRIEL (P = .018) and EVE (P = 1.31 x 10 (-5)) studies."
    }
  }, {
    "data": {
      "source": "107527101",
      "target": "1433804",
      "name": "found in",
      "orig_sent": "No giant myotonic discharges or painful muscle cramps were found in the other G1306A families."
    }
  }, {
    "data": {
      "source": "2504704",
      "target": "107450201",
      "name": "identified with",
      "orig_sent": "The homozygous 32 deltaT deletion was identified in the only known patient of African-American origin with Canavan disease."
    }
  }, {
    "data": {
      "source": "3587804",
      "target": "107293601",
      "name": "associated with",
      "orig_sent": "E1317Q is significantly associated with multiple colorectal adenomas (OR = 11."
    }
  }, {
    "data": {
      "source": "261602501",
      "target": "9700004",
      "name": "carried",
      "orig_sent": "The two JLNS patients in the family carried the homozygous T322M mutation."
    }
  }, {
    "data": {
      "source": "3149004",
      "target": "260566401",
      "name": "cause",
      "orig_sent": "In this way the Gly364 to Asp and Arg510 to Gln substitutions may cause PK deficiency by influencing the allosteric properties of the enzyme."
    }
  }, {
    "data": {
      "source": "20028004",
      "target": "107368101",
      "name": "associated In",
      "orig_sent": "In an additional validation-cohort of EA (410 end-stage renal disease (ESRD) cases and 1308 controls), rs75444904 was associated with ESRD (OR = 1.22, P = 0.036)."
    }
  }, {
    "data": {
      "source": "18289104",
      "target": "260955401",
      "name": "associated with",
      "orig_sent": "Homozygous c.359del variant in MGME1 is associated with early onset cerebellar ataxia."
    }
  }, {
    "data": {
      "source": "260992301",
      "target": "1322904",
      "name": "carry",
      "orig_sent": "Clinical features are severe developmental delay, microcephaly and dyskinesia."
    }
  }, {
    "data": {
      "source": "3288104",
      "target": "267139201",
      "name": "cause",
      "orig_sent": "These observations led us to ask whether axon dysinnervation is a primary phenotype, and why the E421K, but not other, TUBB2B substitutions cause CFEOM."
    }
  }, {
    "data": {
      "source": "18102104",
      "target": "106906101",
      "name": "associated with",
      "orig_sent": "Among them, rs10761745 (JMJD1C) and rs163177 (KCNQ1) were prospectively associated with T2D."
    }
  }, {
    "data": {
      "source": "7500104",
      "target": "107500701",
      "name": "causes",
      "orig_sent": "The PTPN11 loss-of-function mutation Q510E-Shp2 causes hypertrophic cardiomyopathy by dysregulating mTOR signaling."
    }
  }, {
    "data": {
      "source": "8066704",
      "target": "267292901",
      "name": "rescued",
      "orig_sent": "Although p.D169G rescued organismal pupal lethality and neuronal loss to a similar extent as wild-type TARDBP, p.A90V, p.G287S, and p.A315T were less efficient."
    }
  }, {
    "data": {
      "source": "15461904",
      "target": "107292001",
      "name": "identified in",
      "orig_sent": "("
    }
  }, {
    "data": {
      "source": "4244804",
      "target": "106913501",
      "name": "causes",
      "orig_sent": "Tau gene mutation G389R causes a tauopathy with abundant pick body-like inclusions and axonal deposits."
    }
  }, {
    "data": {
      "source": "8280904",
      "target": "258682501",
      "name": "found without",
      "orig_sent": "The E292V mutation was not found on 200 control alleles from adults without lung disease, but seven additional patients of the remaining study patients had the E292V mutation on one allele."
    }
  }, {
    "data": {
      "source": "4175304",
      "target": "257165801",
      "name": "causes",
      "orig_sent": "We conclude that the L345P desmin missense mutation causes myopathy by interfering in a dominant-negative manner with the dimerization-polymerization process of intermediate filament assembly."
    }
  }, {
    "data": {
      "source": "5030704",
      "target": "260399801",
      "name": "found with",
      "orig_sent": "Because V138F was found in the German patients with Pendred's syndrome on at least one allele, we genotyped five microsatellite markers located in the PDS region."
    }
  }, {
    "data": {
      "source": "254443101",
      "target": "671404",
      "name": "divided into",
      "orig_sent": "Based on the genetic mutation, the FH subjects were divided into 2 groups, K790X, (n=20) and P664L, (n=5), and their LDLR activities was measured by this method, which was found to be 55.3+/-8.9% and 63.9+/-13.8%, respectively, of that of the control group (n=15)."
    }
  }, {
    "data": {
      "source": "2679704",
      "target": "107438201",
      "name": "associated with",
      "orig_sent": "The N188S mutation in Gaucher disease is associated with myoclonus epilepsy."
    }
  }, {
    "data": {
      "source": "4977704",
      "target": "106999001",
      "name": "causes",
      "orig_sent": "A novel L266V mutation of the tau gene causes frontotemporal dementia with a unique tau pathology."
    }
  }, {
    "data": {
      "source": "3202104",
      "target": "256849801",
      "name": "caused",
      "orig_sent": "S891A mutation caused medullary thyroid cancer (MTC) in 69.4%, pheochromocytoma in 2.8%, and parathyroid hyperplasia in 8.3% of the 36 patients of this case series and in 63.5, 4.1, and 4.1%, respectively, for the entire groups of 74 patients."
    }
  }, {
    "data": {
      "source": "12282404",
      "target": "106971801",
      "name": "associated with",
      "orig_sent": "The rs6929846 SNP of BTN2A1, but not rs2569512 of ILF3, was also significantly associated with MI in Japanese subject panel C."
    }
  }, {
    "data": {
      "source": "284004",
      "target": "107507101",
      "name": "associated with",
      "orig_sent": "R222Q SCN5A mutation is associated with reversible ventricular ectopy and dilated cardiomyopathy."
    }
  }, {
    "data": {
      "source": "3605804",
      "target": "107435301",
      "name": "expressed in",
      "orig_sent": "The C240F mutant was expressed in LDL receptor deficient CHOMldlA7 cells."
    }
  }, {
    "data": {
      "source": "75304",
      "target": "106986001",
      "name": "associated to",
      "orig_sent": "R702W is not associated with susceptibility to CD in Ashkenazi Jews."
    }
  }, {
    "data": {
      "source": "13577104",
      "target": "260998301",
      "name": "causes",
      "orig_sent": "The R820W mutation in the MYBPC3 gene, associated with hypertrophic cardiomyopathy in cats, causes hypertrophic cardiomyopathy and left ventricular non-compaction in humans."
    }
  }, {
    "data": {
      "source": "846504",
      "target": "3985701",
      "name": "associated with",
      "orig_sent": "The p.R96H mutation is associated with dHMN."
    }
  }, {
    "data": {
      "source": "561604",
      "target": "256588001",
      "name": "associated with",
      "orig_sent": "The E101K mutation in the alpha-cardiac actin gene (ACTC) has been associated with apical hypertrophic cardiomyopathy (HCM)."
    }
  }, {
    "data": {
      "source": "1645804",
      "target": "107467801",
      "name": "had",
      "orig_sent": "The Ca (V) 1.1 R528H mice had a HypoPP phenotype for which low K+ challenge produced a paradoxical depolarization of the resting potential, loss of muscle excitability, and weakness."
    }
  }, {
    "data": {
      "source": "54404",
      "target": "106971001",
      "name": "associated with",
      "orig_sent": "The G2019S mutation was associated with the classical Parkinson's disease phenotype and a broad range of onset age (34 to 73 years)."
    }
  }, {
    "data": {
      "source": "107549401",
      "target": "3455804",
      "name": "attributed to",
      "orig_sent": "Partial biotinidase deficiency is almost universally attributed to the D444H mutation."
    }
  }, {
    "data": {
      "source": "2720904",
      "target": "107001201",
      "name": "found in",
      "orig_sent": "In the Spanish collection, R212C was found in a CRD patient, indicating that it may be a rather severe change."
    }
  }, {
    "data": {
      "source": "10232804",
      "target": "106936601",
      "name": "identified in",
      "orig_sent": "POLE p.L424V was identified in a 28-year-old polyposis and CRC patient, as a de novo mutation."
    }
  }, {
    "data": {
      "source": "6077904",
      "target": "107457501",
      "name": "detected in",
      "orig_sent": "p. P361L"
    }
  }, {
    "data": {
      "source": "107500701",
      "target": "268304",
      "name": "had",
      "orig_sent": "One HCM proband with a maximal left ventricular wall thickness of 17 mm had p."
    }
  }, {
    "data": {
      "source": "3407404",
      "target": "106948501",
      "name": "alters",
      "orig_sent": "P25L alters only the upstream protein, whereas P86R alters both VHL proteins."
    }
  }, {
    "data": {
      "source": "3320504",
      "target": "107483801",
      "name": "showed",
      "orig_sent": "The mutation Arg58Gln showed also moderate septal hypertrophy, but, in contrast, it was associated with an early onset of clinical manifestation and premature sudden cardiac death."
    }
  }, {
    "data": {
      "source": "1105001",
      "target": "6992104",
      "name": "genotyped with",
      "orig_sent": "Here, 1,993 primary gout patients and 4,902 health examination participants (3,305 males and 1,597 females) were genotyped with R90H and W258X."
    }
  }, {
    "data": {
      "source": "13145204",
      "target": "260101301",
      "name": "associated with",
      "orig_sent": "The K108E variant was associated with an autosomal recessive severe immunodeficiency with a complete lack of circulating monocytes and dendritic cells."
    }
  }, {
    "data": {
      "source": "13864304",
      "target": "107402101",
      "name": "associated with",
      "orig_sent": "The minor allele of three SNPs (rs7629386 at 3p22.1, rs969088 at 5p14.1, and rs3850370 at 14q24.3) were associated with worse NSCLC survival while 2 (rs41997 at 7q31.31 and rs12000445 at 9p21.3) were associated with better NSCLC survival."
    }
  }, {
    "data": {
      "source": "5260404",
      "target": "261733101",
      "name": "associated with",
      "orig_sent": "R702C and R702H mutations were only associated with FTNS, EPS, or APSM, thus defining a region of MYHIIA critical in the combined pathogenesis of macrothrombocytopenia, nephritis, and deafness."
    }
  }, {
    "data": {
      "source": "3771404",
      "target": "106986301",
      "name": "found in",
      "orig_sent": "An interesting fact is that A559T was so far found mostly in CF patients of African-American origin."
    }
  }, {
    "data": {
      "source": "620504",
      "target": "106986301",
      "name": "found on",
      "orig_sent": "G480C was found on one additional CF chromosome and on none of 220 normal chromosomes, including 160 chromosomes from normal African-American individuals."
    }
  }, {
    "data": {
      "source": "107500701",
      "target": "257729201",
      "name": "have",
      "orig_sent": "Hypertrophic cardiomyopathy patients with the malignant Arg719Trp mutation have more extensive hypertrophy than those with the benign Leu606Val mutation."
    }
  }, {
    "data": {
      "source": "2727304",
      "target": "107385101",
      "name": "related with",
      "orig_sent": "The c.643G> A, p.Asp215Asn mutation is related with type IIIa, as this mutation was found homozygously in two type IIIa patients."
    }
  }, {
    "data": {
      "source": "107001201",
      "target": "261004401",
      "name": "showed",
      "orig_sent": "The two CRD siblings with the c.156-2A> G mutation also showed unilateral postaxial polydactyly."
    }
  }, {
    "data": {
      "source": "206004",
      "target": "106978601",
      "name": "associated with",
      "orig_sent": "Our findings confirmed that homozygous M694V is associated with amyloidosis in the Turkish population as well similar to Armenia, Israel, and Arabian countries."
    }
  }, {
    "data": {
      "source": "8684204",
      "target": "107486501",
      "name": "associated with",
      "orig_sent": "The W1191X mutation is associated with BS and resulted in the loss of function of the cardiac sodium channel."
    }
  }, {
    "data": {
      "source": "3019304",
      "target": "258174001",
      "name": "has",
      "orig_sent": "The R133C genotype has a predominantly autistic presentation while the R306C genotype is associated with a slower disease progression."
    }
  }, {
    "data": {
      "source": "6847304",
      "target": "107540401",
      "name": "associated with",
      "orig_sent": "[A de nono I462S mutation in the KRT6A gene is associated with pachyonychia congenita type I]."
    }
  }, {
    "data": {
      "source": "107451301",
      "target": "106916201",
      "name": "having",
      "orig_sent": "PRRT2 mutations were also found in PKD/IC with migraine: p."
    }
  }, {
    "data": {
      "source": "6732704",
      "target": "107477201",
      "name": "reported in",
      "orig_sent": "A (Leu849His) and c.1932delC] have been reported in Japanese patients, but not in GS patients from other ethnic groups."
    }
  }, {
    "data": {
      "source": "206004",
      "target": "106978601",
      "name": "associated with",
      "orig_sent": "M694V homozygosity is associated with phenotype II and amyloidosis compared to other common genotypes in patients with FMF."
    }
  }, {
    "data": {
      "source": "236204",
      "target": "107507101",
      "name": "identified in",
      "orig_sent": "PLN mutation R14del was identified in 12 (12%) ARVC patients and in 39 (15%) DCM patients."
    }
  }, {
    "data": {
      "source": "15138504",
      "target": "107457501",
      "name": "detected in",
      "orig_sent": "p. P361L"
    }
  }, {
    "data": {
      "source": "16058404",
      "target": "106906301",
      "name": "associated with",
      "orig_sent": "Clinically, p.C1733Y was associated with GD, as reported previously, as well as the novel p.N1730I, whereas p.C1733F"
    }
  }, {
    "data": {
      "source": "2669604",
      "target": "107423601",
      "name": "causes",
      "orig_sent": "These studies provide direct genetic evidence that the Pro252Arg mutation in FGFR1 causes human Pfeiffer syndrome and uncovers a molecular mechanism in which Fgf/Fgfr1 signals regulate intramembraneous bone formation by modulating Cbfa1 expression."
    }
  }, {
    "data": {
      "source": "811204",
      "target": "106987301",
      "name": "exhibit",
      "orig_sent": "The TREX1 D18N mice exhibit systemic inflammation, lymphoid hyperplasia, vasculitis, and kidney disease."
    }
  }, {
    "data": {
      "source": "16058004",
      "target": "107550501",
      "name": "associated with",
      "orig_sent": "Clinically, p.C1733Y was associated with GD, as reported previously, as well as the novel p.N1730I, whereas p.C1733F"
    }
  }, {
    "data": {
      "source": "5754004",
      "target": "266633501",
      "name": "associated with",
      "orig_sent": "The C46R mutation is associated with autosomal dominant lateral temporal lobe epilepsy in a large Norwegian family showing unusual clinical features like short-lasting sensory aphasia and auditory symptoms."
    }
  }, {
    "data": {
      "source": "3502704",
      "target": "267378201",
      "name": "identified with",
      "orig_sent": "A heterozygous A337P mutation was identified in a family with an adult-onset skeletal myopathy and mild cardiac involvement."
    }
  }, {
    "data": {
      "source": "3305604",
      "target": "267394401",
      "name": "associated with",
      "orig_sent": "The T80A variant was associated with an autosomal dominant, milder immunodeficiency and a selective depletion of CD11c+CD1c+ circulating dendritic cells."
    }
  }, {
    "data": {
      "source": "20028004",
      "target": "107368101",
      "name": "associated with",
      "orig_sent": "In an additional validation-cohort of EA (410 end-stage renal disease (ESRD) cases and 1308 controls), rs75444904 was associated with ESRD (OR = 1.22, P = 0.036)."
    }
  }, {
    "data": {
      "source": "107423601",
      "target": "1631504",
      "name": "had",
      "orig_sent": "Except for one, all the Apert patients had either S252W (n = 16) or P253R (n = 10) mutations."
    }
  }, {
    "data": {
      "source": "1465504",
      "target": "259268901",
      "name": "found in",
      "orig_sent": "The N34S mutation was found in six familial pancreatitis patients (three families) and in one juvenile pancreatitis patient, and the R67C mutation was found in one familial pancreatitis patient and one juvenile pancreatitis patient."
    }
  }, {
    "data": {
      "source": "13737004",
      "target": "106980801",
      "name": "associated with",
      "orig_sent": "Rs738409 in the PNPLA3 gene was most strongly associated with NAFLD after adjustment (P = 6.8 x 10 (-14), OR = 2.05)."
    }
  }, {
    "data": {
      "source": "509204",
      "target": "107550601",
      "name": "detected in",
      "orig_sent": "The Arg170Trp mutation was also detected in a third unrelated TSD patient."
    }
  }, {
    "data": {
      "source": "1160704",
      "target": "262778001",
      "name": "caused",
      "orig_sent": "In contrast, missense mutations produced distinct phenotypes: Gly80Arg caused significant cardiac malformations but only minor skeletal abnormalities; and Arg237Gln and Arg237Trp caused extensive upper limb malformations but less significant cardiac abnormalities."
    }
  }, {
    "data": {
      "source": "12373904",
      "target": "106924901",
      "name": "associated with",
      "orig_sent": "rs505922 at ABO was also associated with duodenal ulcer in a recessive model (OR = 1.32; P = 1.15 x 10 (-10))."
    }
  }, {
    "data": {
      "source": "6557404",
      "target": "257429101",
      "name": "described with",
      "orig_sent": "The Y288 C variant was previously described in a child with macrocephaly, mild developmental delay, increased signal intensity in the basal ganglia, partial cortical blindness and retinitis pigmentosa, and slightly elevated N-acetylaspartate in the urine."
    }
  }, {
    "data": {
      "source": "262381401",
      "target": "1433804",
      "name": "found in",
      "orig_sent": "No giant myotonic discharges or painful muscle cramps were found in the other G1306A families."
    }
  }, {
    "data": {
      "source": "107500701",
      "target": "4789904",
      "name": "had",
      "orig_sent": "In this pedigree, 13 out of 25 family members were diagnosed as HCM, 5 died of heart failure, all HCM patients in this pedigree had Arg723Gly mutation and 3 of them had NYHA III and 2 of them were diagnosed as HCM before the age of 20."
    }
  }, {
    "data": {
      "source": "3012204",
      "target": "263007401",
      "name": "found in",
      "orig_sent": "The T67M and V57del mutations have been found in Caucasian PTS deficient patients, while the L76F, IVS3+1G> A, and K38X mutations are novel."
    }
  }, {
    "data": {
      "source": "8539404",
      "target": "258682501",
      "name": "cause",
      "orig_sent": "We provide evidence that V456A can cause significant pulmonary disease in South Asian Cystic Fibrosis patients."
    }
  }, {
    "data": {
      "source": "4536304",
      "target": "106986001",
      "name": "reported in",
      "orig_sent": "To the best of our knowledge, the C136R mutation has not previously been reported in CD patients."
    }
  }, {
    "data": {
      "source": "4683804",
      "target": "260996301",
      "name": "exhibit",
      "orig_sent": "(KCNA1 G724C)"
    }
  }, {
    "data": {
      "source": "362504",
      "target": "106918201",
      "name": "classified as",
      "orig_sent": "Both p.R241C and p.R408Q are classified as mild phenylketonuria (PKU) or mild hyperphenylalaninemia (MHP) mutation, which may explain the fact that classical PKU is very rare in Taiwan (n=4, or one in 413,035)."
    }
  }, {
    "data": {
      "source": "3038104",
      "target": "258682501",
      "name": "causes",
      "orig_sent": "When present in trans with a CF-causing mutation, D1152H causes significant pulmonary disease, but all subjects had prolonged survival."
    }
  }, {
    "data": {
      "source": "13508204",
      "target": "107480901",
      "name": "associated with",
      "orig_sent": "(rs1092913), 5q12/"
    }
  }, {
    "data": {
      "source": "5467504",
      "target": "107393501",
      "name": "identified in",
      "orig_sent": "and P316S) in the coding region were identified in two Japanese sialidosis patients."
    }
  }, {
    "data": {
      "source": "513604",
      "target": "107550601",
      "name": "causes",
      "orig_sent": "A glycine250--> aspartate substitution in the alpha-subunit of hexosaminidase A causes juvenile-onset Tay-Sachs disease in a Lebanese-Canadian family."
    }
  }, {
    "data": {
      "source": "208404",
      "target": "267380601",
      "name": "associated with",
      "orig_sent": "The H723R mutation in the PDS/SLC26A4 gene is associated with typical Pendred syndrome in Korean patients."
    }
  }, {
    "data": {
      "source": "4723304",
      "target": "107480901",
      "name": "associated with",
      "orig_sent": "The I157T variant may be associated with breast cancer risk, but the risk is lower than for 1100delC."
    }
  }, {
    "data": {
      "source": "256225101",
      "target": "3204",
      "name": "carried",
      "orig_sent": "In the dose-escalation cohort, among the 16 patients with melanoma whose tumors carried the V600E BRAF mutation and who were receiving 240 mg or more of PLX4032 twice daily, 10 had a partial response and 1 had a complete response."
    }
  }, {
    "data": {
      "source": "3204",
      "target": "267415101",
      "name": "detected in",
      "orig_sent": "Additionally, somatic p.V600E"
    }
  }, {
    "data": {
      "source": "16155904",
      "target": "107503801",
      "name": "associated with",
      "orig_sent": "SNP rs8041357, which is in complete linkage disequilibrium (r (2) = 1) with rs11543198, was also associated with bladder cancer risk in Europeans (P = 0.045 for an additive and P = 0.025 for a recessive model), despite much lower minor allele frequency in Europeans (3.7%) compared with the Japanese (22.2%)."
    }
  }, {
    "data": {
      "source": "11950504",
      "target": "106987201",
      "name": "associated with",
      "orig_sent": "rs3849942 and rs903603 were strongly associated with ALS when all samples were included (rs3849942, p ="
    }
  }, {
    "data": {
      "source": "5751904",
      "target": "254768101",
      "name": "associated with",
      "orig_sent": "The S140T mutation in myelin P0 can be associated with conduction block and Charcot-Marie-Tooth should be part of the differential diagnosis of that phenomenon."
    }
  }, {
    "data": {
      "source": "678604",
      "target": "260321101",
      "name": "had",
      "orig_sent": "C73R/C73R mice that survived fetal life to weaning age (~12%) had a severe microcytic hypochromic anemia (hemoglobin 7.9 g/dL, mean cellular volume 26.6 fL, mean cellular hemoglobin content 27.4 g/dL, red cell distribution width 37.7%, reticulocytes 19%) and massively accumulated isomer I porphyrins (95, 183 and 44"
    }
  }, {
    "data": {
      "source": "11159804",
      "target": "106920001",
      "name": "identified in",
      "orig_sent": "All five mutations are associated with NS, whereas two (A57G and F82V) have also been identified in urinary tract cancers and myeloid malignancies."
    }
  }, {
    "data": {
      "source": "284004",
      "target": "254472701",
      "name": "associated with",
      "orig_sent": "R222Q SCN5A mutation is associated with reversible ventricular ectopy and dilated cardiomyopathy."
    }
  }, {
    "data": {
      "source": "12983204",
      "target": "107481501",
      "name": "associated with",
      "orig_sent": "Another AIFM1 mutation that predicts p.Arg201del has recently been associated with severe mitochondrial encephalomyopathy in two infants by impairing oxidative phosphorylation."
    }
  }, {
    "data": {
      "source": "561604",
      "target": "107500701",
      "name": "associated with",
      "orig_sent": "The E101K mutation in the alpha-cardiac actin gene (ACTC) has been associated with apical hypertrophic cardiomyopathy (HCM)."
    }
  }, {
    "data": {
      "source": "106966601",
      "target": "106966501",
      "name": "associated with",
      "orig_sent": "The 15q21.3 locus linked with lipid levels and hypertension was associated with total stroke (rs4471613; P=3.9x10 (-8)) in African Americans."
    }
  }, {
    "data": {
      "source": "4752904",
      "target": "106913501",
      "name": "causes",
      "orig_sent": "Tau gene mutation K257T causes a tauopathy similar to Pick's disease."
    }
  }, {
    "data": {
      "source": "3284704",
      "target": "263938501",
      "name": "yield",
      "orig_sent": "The observed homozygous p.P86L mutation in the N-terminal extended segment may yield reduced MCM activity and is refractory to hydroxocobalamin supplementation, while not inducing a metabolically unstable phenotype."
    }
  }, {
    "data": {
      "source": "248804",
      "target": "107519601",
      "name": "yielded",
      "orig_sent": "In particular, contrary to what is generally reported in the literature, we found that certain mutations, for example, the P30L, I2G, and I172N mutations, yielded different CAH phenotypes."
    }
  }, {
    "data": {
      "source": "494404",
      "target": "106918201",
      "name": "exhibited",
      "orig_sent": "The patient homozygous for F299C manifested severe PKU, whereas the R408Q homozygote exhibited a mild PKU variant."
    }
  }, {
    "data": {
      "source": "120637201",
      "target": "259766001",
      "name": "combined with",
      "orig_sent": "We screened 4 additional families, in which PED is combined with epilepsy, developmental delay, or migraine, but not with hemolysis or echinocytosis, and identified 2 additional GLUT1 mutations (A275T, G314S) that decreased glucose transport but did not affect cation permeability."
    }
  }, {
    "data": {
      "source": "2113304",
      "target": "260566401",
      "name": "cause",
      "orig_sent": "In this way the Gly364 to Asp and Arg510 to Gln substitutions may cause PK deficiency by influencing the allosteric properties of the enzyme."
    }
  }, {
    "data": {
      "source": "262558501",
      "target": "13668604",
      "name": "caused by",
      "orig_sent": "Our results strongly suggest that autosomal recessive persistent hyperplastic primary vitreous is caused by N46H and is etiologically related to nonsyndromic congenital retinal nonattachment."
    }
  }, {
    "data": {
      "source": "19239704",
      "target": "106987201",
      "name": "associated with",
      "orig_sent": "rs3849942 and rs903603 were strongly associated with ALS when all samples were included (rs3849942, p ="
    }
  }, {
    "data": {
      "source": "262426801",
      "target": "29404",
      "name": "compound for",
      "orig_sent": "Twenty-one German CAVD patients were compound heterozygous for delta F508 and R117H, which was the most frequent CAVD genotype in our study group."
    }
  }, {
    "data": {
      "source": "12094204",
      "target": "107376801",
      "name": "associated with",
      "orig_sent": "This study sought to identify whether genetic polymorphisms rs28929474 and rs17580 are associated with COPD susceptibility and lung function values in a Mexican mestizo population."
    }
  }, {
    "data": {
      "source": "4814304",
      "target": "257108101",
      "name": "reported in",
      "orig_sent": "P81L and R38X mutations have previously been reported in other PGL families and P81L was suggested as a founder mutation."
    }
  }, {
    "data": {
      "source": "5877404",
      "target": "106986001",
      "name": "identified in",
      "orig_sent": "The p.Arg1210Cys variant was identified in two CD cases but was not identified in our Dutch-German non-CD-type AMD case-control cohort."
    }
  }, {
    "data": {
      "source": "7861604",
      "target": "262758701",
      "name": "causes",
      "orig_sent": "A novel N440K sodium channel mutation causes myotonia with exercise-induced weakness--exclusion of CLCN1 exon deletion/duplication by MLPA."
    }
  }, {
    "data": {
      "source": "1153304",
      "target": "107428001",
      "name": "found with",
      "orig_sent": "The same R39C mutation was also found both in most of the Swedish patients with SD and in a heterozygous form in five patients from central Europe who presented with an unusually severe (intermediate) SD phenotype."
    }
  }, {
    "data": {
      "source": "9603204",
      "target": "107483801",
      "name": "implicated in",
      "orig_sent": "The Ser358Leu mutation in TMEM43, encoding an inner nuclear membrane protein, has been implicated in arrhythmogenic right ventricular cardiomyopathy (ARVC)."
    }
  }, {
    "data": {
      "source": "3811704",
      "target": "262778001",
      "name": "caused",
      "orig_sent": "In contrast, missense mutations produced distinct phenotypes: Gly80Arg caused significant cardiac malformations but only minor skeletal abnormalities; and Arg237Gln and Arg237Trp caused extensive upper limb malformations but less significant cardiac abnormalities."
    }
  }, {
    "data": {
      "source": "4048904",
      "target": "260737701",
      "name": "associated with",
      "orig_sent": "Heterozygous mutations in Myoclonin1/EFHC1 cause juvenile myoclonic epilepsy (JME), the most common form of genetic generalized epilepsies, while homozygous F229L mutation is associated with primary intractable epilepsy in infancy."
    }
  }, {
    "data": {
      "source": "10241004",
      "target": "10241104",
      "name": "compared with",
      "orig_sent": "We show that a gradient of impairment is present when the p.P152A mutation is compared with an allelic p.P152R mutation, which causes classic Rett syndrome and another Rett syndrome-causing mutation, such that protein-heterochromatin binding observed by immunofluorescence and immunoblotting is wild-type> P152A> P152R> T158 M, consistent with the severity of the observed phenotype."
    }
  }, {
    "data": {
      "source": "8476504",
      "target": "254200001",
      "name": "added with",
      "orig_sent": "Three mutational alleles, R278X and R52I of the TYR gene and C229Y of the SLC45A2 gene, are added to the mutational spectra of Korean patients with OCA, and we report the first Korean case of OCA2 with the OCA2 gene mutations."
    }
  }, {
    "data": {
      "source": "3111004",
      "target": "256915301",
      "name": "found with",
      "orig_sent": "Since the G13513A mutation was found in 21% of our patients with Leigh syndrome and complex I deficiency (3/14), it appears that this mutation represents a frequent cause of Leigh-like syndrome, which should be systematically tested for molecular diagnosis in affected children and for genetic counselling in their maternal relatives."
    }
  }, {
    "data": {
      "source": "16309204",
      "target": "107465201",
      "name": "associated with",
      "orig_sent": "An association analysis using healthy controls showed that rs7537605 is significantly associated with HT (P = 1.24 x 10 (-5); odds ratio = 1.60; 95% confidence interval = 1.30-1.97) but not with GD (P = .50), suggesting that the variant specifically affects susceptibility to HT."
    }
  }, {
    "data": {
      "source": "5324104",
      "target": "259268901",
      "name": "represents",
      "orig_sent": "In addition, the newly found R122C variant represents a likely pancreatitis-predisposing mutation."
    }
  }, {
    "data": {
      "source": "13772704",
      "target": "106936601",
      "name": "identified in",
      "orig_sent": "Moreover, in sporadic colorectal cancer, the c.1227_1228dup (p.Glu410GlyfsX43) mutation was identified in 13% of patients compared to the p.G396D and p.Y179C found in 1.2 and 2.12% respectively."
    }
  }, {
    "data": {
      "source": "6611004",
      "target": "259766001",
      "name": "involved in",
      "orig_sent": "R863X alteration in HERG channel may be involved in both prolonged QTc interval and epilepsy."
    }
  }, {
    "data": {
      "source": "671404",
      "target": "254443101",
      "name": "detected in",
      "orig_sent": "The proline664-leucine low density lipoprotein (LDL) -receptor mutation was detected in four apparently unrelated Indian FH families in South Africa."
    }
  }, {
    "data": {
      "source": "528704",
      "target": "2273901",
      "name": "causes",
      "orig_sent": "R231C mutation in KCNQ1 causes long QT syndrome type 1 and familial atrial fibrillation."
    }
  }, {
    "data": {
      "source": "13382104",
      "target": "106906301",
      "name": "associated with",
      "orig_sent": "Several SNPs in linkage disequilibrium within the CLN8 gene locus were associated with the GD1 severity: SNP rs11986414 was associated with GD1 severity at P value 1.26 x 10 (-6)."
    }
  }, {
    "data": {
      "source": "4723204",
      "target": "256225101",
      "name": "associated in",
      "orig_sent": "Both 1100delC and R145W germ-line mutations in CHK2 are associated with loss of the wild-type allele in the corresponding tumor specimens, and neither tumor harbors a somatic TP53 mutation."
    }
  }, {
    "data": {
      "source": "106904101",
      "target": "106978601",
      "name": "developing",
      "orig_sent": "Four-hundred patients had amyloidosis and homozygous M694V was detected in 189 (47%) of the 400 amyloidotic patients which was significantly higher than that in the FMF patients not developing amyloidosis (p <0.0001)."
    }
  }, {
    "data": {
      "source": "120597501",
      "target": "107549901",
      "name": "observed in",
      "orig_sent": "In addition, the Jackson-Weiss syndrome mutation, C342R, in exon IIIc was observed previously in other craniosynostotic syndromes, Crouzon and Pfeiffer."
    }
  }, {
    "data": {
      "source": "257967001",
      "target": "258886601",
      "name": "include",
      "orig_sent": "Although the cardiac pathology caused by PRKAG2 mutations Arg302Gln, Thr400Asn, and Asn488Ile include myocyte enlargement and minimal interstitial fibrosis, these mutations were not associated with myocyte and myofibrillar disarray, the pathognomonic features of hypertrophic cardiomyopathy caused by sarcomere protein mutations."
    }
  }, {
    "data": {
      "source": "510804",
      "target": "267370401",
      "name": "constitutes",
      "orig_sent": "These results suggest that the P533R mutation constitutes the genetic lesion which results in MPS I in people of Moroccan descent and provides yet more evidence for the uneven geographical distribution of mutations in MPS I."
    }
  }, {
    "data": {
      "source": "263872401",
      "target": "107549901",
      "name": "constitutes",
      "orig_sent": "Muenke syndrome constitutes the most common syndromic form of craniosynostosis, with an incidence of 1 in 30,000 births and is defined by the presence of the p.Pro250Arg mutation in FGFR3."
    }
  }, {
    "data": {
      "source": "106926301",
      "target": "106936601",
      "name": "associated with",
      "orig_sent": "The APC variants I1307K and E1317Q are associated with colorectal tumors, but not always with a family history."
    }
  }, {
    "data": {
      "source": "20255704",
      "target": "107495601",
      "name": "associated with",
      "orig_sent": "rs9260151 and rs3135002 have been associated with type 1 diabetes, whereas rs559047 and rs61211515 have not been associated with a risk of developing type 1 diabetes."
    }
  }, {
    "data": {
      "source": "19319804",
      "target": "261146201",
      "name": "associated with",
      "orig_sent": "Another polymorphism, rs12970291 near gene TSHZ1, was associated with both CRC and EC (OR = 1.26, P = 4.82 x 10 (-8)), with the alleles showing opposite effects on the risks of the two cancers."
    }
  }, {
    "data": {
      "source": "989204",
      "target": "107519601",
      "name": "yielded",
      "orig_sent": "In particular, contrary to what is generally reported in the literature, we found that certain mutations, for example, the P30L, I2G, and I172N mutations, yielded different CAH phenotypes."
    }
  }, {
    "data": {
      "source": "5811104",
      "target": "107254501",
      "name": "showed",
      "orig_sent": "Q79R SHP2 embryonic hearts showed altered cardiomyocyte cell cycling, ventricular noncompaction, and ventricular septal defects, while, in the postnatal cardiomyocyte, Q79R SHP2 expression was completely benign."
    }
  }, {
    "data": {
      "source": "12697404",
      "target": "255445901",
      "name": "had",
      "orig_sent": "In pregnancy-associated cardiomyopathy cases, rs258415 had a similar effect versus local2 control subjects (P=0.06; OR, 1.79), younger control subjects (P=0.14; OR, 1.65), and obstetric control subjects (P=0.038; OR, 1.99)."
    }
  }, {
    "data": {
      "source": "12679504",
      "target": "261079401",
      "name": "causes",
      "orig_sent": "A novel p.Gly603Arg mutation in CACNA1F causes Aland island eye disease and incomplete congenital stationary night blindness phenotypes in a family."
    }
  }, {
    "data": {
      "source": "1494904",
      "target": "259499001",
      "name": "associated with",
      "orig_sent": "On the basis of the clinical features presented by the four patients, we postulate that the L206W might be associated with pancreatic sufficiency and residual transmembrane transport of chloride in lung."
    }
  }, {
    "data": {
      "source": "6160304",
      "target": "263401901",
      "name": "causes",
      "orig_sent": "In conclusion, the homozygous DHFR mutation"
    }
  }, {
    "data": {
      "source": "17740804",
      "target": "107503801",
      "name": "related in",
      "orig_sent": "The rs2042329 risk allele was also related to significantly increased expression levels of CWC27 mRNA and protein in bladder cancer tissues from Chinese patients."
    }
  }, {
    "data": {
      "source": "107532701",
      "target": "1788404",
      "name": "associated with",
      "orig_sent": "These observations confirmed that TAs were associated with T704M mutations of SCN4A in paralysis periodica paramyotonica."
    }
  }, {
    "data": {
      "source": "20299004",
      "target": "107256901",
      "name": "associated with",
      "orig_sent": "SNP rs2284378 at 20q11 was associated with ER-negative breast cancer (combined two-stage OR = 1.16; P = 1.1 x 10 (-8)) but showed a weaker association with overall breast cancer (OR = 1.08, P = 1.3 x 10 (-6)) based on 17 869 cases and 43 745 controls and no association with ER-positive disease (OR = 1.01, P = 0.67) based on 9965 cases and 22 902 controls."
    }
  }, {
    "data": {
      "source": "18834004",
      "target": "106971701",
      "name": "associated with",
      "orig_sent": "Of these 2 SNPs, rs9815663 was also significantly associated with earlier asthma onset in an analysis including only the replication cohorts."
    }
  }, {
    "data": {
      "source": "13577104",
      "target": "107500701",
      "name": "causes",
      "orig_sent": "The R820W mutation in the MYBPC3 gene, previously associated with HCM in rag-doll cats, causes both HCM and LVNC in homozygous human carriers, with mild or null clinical expression in heterozygous carriers."
    }
  }, {
    "data": {
      "source": "13737004",
      "target": "256366601",
      "name": "associated with",
      "orig_sent": "Rs738409, rs2896019, rs738491, rs6006473, rs5764455, and rs6006611 were associated with fibrosis."
    }
  }, {
    "data": {
      "source": "2793304",
      "target": "107430601",
      "name": "observed in",
      "orig_sent": "The two common alleles, 459+1G> A and P426L, together accounted for 42% of all 50 unrelated MLD alleles investigated; I179S was observed in 6 of 50 MLD alleles (12%)."
    }
  }, {
    "data": {
      "source": "19319804",
      "target": "106936601",
      "name": "associated with",
      "orig_sent": "Another polymorphism, rs12970291 near gene TSHZ1, was associated with both CRC and EC (OR = 1.26, P = 4.82 x 10 (-8)), with the alleles showing opposite effects on the risks of the two cancers."
    }
  }, {
    "data": {
      "source": "6059404",
      "target": "6364404",
      "name": "found whereas",
      "orig_sent": "Among them, only E103D, H486R, V148V, and IVS13+21C--> G were found exclusively in patients with POAG, whereas P199P, T202T, and IVS8+20G-->"
    }
  }, {
    "data": {
      "source": "6077004",
      "target": "257045501",
      "name": "cause",
      "orig_sent": "Both the Q163X and the R120Q mutation cause demyelination and axonal loss."
    }
  }, {
    "data": {
      "source": "19190204",
      "target": "107387701",
      "name": "associated with",
      "orig_sent": "At 6p21.1, rs2294693 near UNC5CL was significantly associated with gastric non-cardia cancer risk (p=2.50x10 (-8)), with OR (95% CI) of 1.18 (1.12 to 1.26), but there was only a nominal association for cardia cancer (p=1.47x10 (-2))."
    }
  }, {
    "data": {
      "source": "256225101",
      "target": "19804",
      "name": "contained",
      "orig_sent": "Tumor cells from a sixth patient with a drug-sensitive EGFR mutation whose tumor progressed on adjuvant gefitinib after complete resection also contained the T790M mutation."
    }
  }, {
    "data": {
      "source": "13073504",
      "target": "106932701",
      "name": "linked to",
      "orig_sent": "Patient-only analysis suggested that rs704853 is also linked to oral ulcers, hematologic disorders and anti-double-stranded DNA (dsDNA) antibody production."
    }
  }, {
    "data": {
      "source": "161204",
      "target": "106925201",
      "name": "recognised as",
      "orig_sent": "First considered as a polymorphism of the HFE gene, the H63D mutation is now widely recognised as a haemochromatosis associated allele."
    }
  }, {
    "data": {
      "source": "19189904",
      "target": "255210801",
      "name": "associated with",
      "orig_sent": "Rs9829896-C was not associated with drug abuse across the EA cohorts: frequency = 36% and meta-analysis P = 0.12."
    }
  }, {
    "data": {
      "source": "6208804",
      "target": "259964101",
      "name": "associated with",
      "orig_sent": "The ATTR Tyr69His mutation is associated with oculoleptomeningeal amyloidosis."
    }
  }, {
    "data": {
      "source": "7686004",
      "target": "262993401",
      "name": "produced",
      "orig_sent": "The new R1905X DYSF founder mutation produced the 3 possible dysferlinopathy phenotypes without intrafamilial heterogeneity."
    }
  }, {
    "data": {
      "source": "4233204",
      "target": "107477201",
      "name": "reported in",
      "orig_sent": "A (Leu849His) and c.1932delC] have been reported in Japanese patients, but not in GS patients from other ethnic groups."
    }
  }, {
    "data": {
      "source": "2785904",
      "target": "107465501",
      "name": "exhibited",
      "orig_sent": "Interestingly, the reconstructive experiments demonstrated that the F310L mutant exhibited an ALP activity level 65% of the normal level, whereas the mutant G439R had no activity."
    }
  }, {
    "data": {
      "source": "476204",
      "target": "107483801",
      "name": "associated with",
      "orig_sent": "The mutation Glu22Lys was associated with moderate septal hypertrophy, a late onset of clinical manifestation, and benign disease course and prognosis."
    }
  }, {
    "data": {
      "source": "70604",
      "target": "106971801",
      "name": "associated with",
      "orig_sent": "In tests for association with other vascular diseases, we found that rs7025486"
    }
  }, {
    "data": {
      "source": "19666104",
      "target": "258259601",
      "name": "causes",
      "orig_sent": "In one family, a p.M1029K mutation in the C2 domain causes severe dystonia, hypotonia, and chorea."
    }
  }, {
    "data": {
      "source": "15344904",
      "target": "107393701",
      "name": "associated with",
      "orig_sent": "rs11655081 was also associated with WD (P = 2.78 x 10 (-2)) but not with any other focal or segmental dystonia."
    }
  }, {
    "data": {
      "source": "6536904",
      "target": "3282201",
      "name": "confirmed",
      "orig_sent": "A homozygous R769Q mutation in the calpain-3 gene and absence of muscle calpain-3 protein confirmed a calpainopathy."
    }
  }, {
    "data": {
      "source": "7858304",
      "target": "261093201",
      "name": "causes",
      "orig_sent": "The RAB39B p.G192R mutation causes X-linked dominant Parkinson's disease."
    }
  }, {
    "data": {
      "source": "18213004",
      "target": "106906101",
      "name": "associated with",
      "orig_sent": "Combined meta-analysis using directly genotyped data for stages 1 and 2 revealed that rs515071 in ANK1 and rs7656416 near MGC21675 were associated with type 2 diabetes in the Japanese population at the genome-wide significant level (P <5 x 10 (-8))."
    }
  }, {
    "data": {
      "source": "4683804",
      "target": "107362501",
      "name": "exhibit",
      "orig_sent": "(KCNA1 G724C)"
    }
  }, {
    "data": {
      "source": "14055604",
      "target": "107368101",
      "name": "developed",
      "orig_sent": "In one family, two siblings homozygous for R3277C developed end stage renal disease at ages 75 and 62 years, while six heterozygotes had few cysts."
    }
  }, {
    "data": {
      "source": "106922101",
      "target": "16819504",
      "name": "harbours",
      "orig_sent": "We find that the MM risk allele harbours a Thr298Ala missense variant in an ELL2 domain required for transcription elongation."
    }
  }, {
    "data": {
      "source": "6077004",
      "target": "259814101",
      "name": "cause",
      "orig_sent": "Both the Q163X and the R120Q mutation cause demyelination and axonal loss."
    }
  }, {
    "data": {
      "source": "17662504",
      "target": "255048701",
      "name": "associated with",
      "orig_sent": "The rs755249-traffic exposure interaction was associated with PAD at a genome-wide significant level (P = 2.29x10-8) in European-Americans."
    }
  }, {
    "data": {
      "source": "14032704",
      "target": "107452501",
      "name": "associated with",
      "orig_sent": "rs9275517, which is in high linkage disequilibrium with rs2647012 (r2 = 0.9), was no longer associated with FL after conditioning on rs2647012."
    }
  }, {
    "data": {
      "source": "12679504",
      "target": "4019701",
      "name": "causes",
      "orig_sent": "A novel p.Gly603Arg mutation in CACNA1F causes Aland island eye disease and incomplete congenital stationary night blindness phenotypes in a family."
    }
  }, {
    "data": {
      "source": "1797001",
      "target": "12004004",
      "name": "harbored",
      "orig_sent": "The OS baby harbored a homozygous p.C118Y mutation in IL7R."
    }
  }, {
    "data": {
      "source": "1352204",
      "target": "258765001",
      "name": "identified with",
      "orig_sent": "A new missense (E161K) mutation was identified in a family with early atrial fibrillation and a previously described (R377H) mutation in another family with a quadriceps myopathy associated with DCM."
    }
  }, {
    "data": {
      "source": "106986301",
      "target": "620504",
      "name": "expresses",
      "orig_sent": "As expected, the G480C cystic fibrosis mouse model expresses the G480C mutant transcript at a level comparable to that of wild-type CFTR:"
    }
  }, {
    "data": {
      "source": "4034504",
      "target": "256372401",
      "name": "found due",
      "orig_sent": "Molecular genetic analysis of lymphoblastic blasts at the time of the ALL diagnosis revealed the germline mutation in a heterozygous state, while in the myelomonocytic blasts occurring with JMML diagnosis, the mutation p.E139D was found in a homozygous state due to a uniparental disomy (UPD)."
    }
  }, {
    "data": {
      "source": "510604",
      "target": "254383901",
      "name": "identified in",
      "orig_sent": "The first mutation, an E137G, was identified in the MRX16 family, and the second, R167W, was identified in a new mental retardation (MR) family shown to be linked to Xq28."
    }
  }, {
    "data": {
      "source": "2757904",
      "target": "1932601",
      "name": "found in",
      "orig_sent": "A homozygous R279W mutation was recently found in the diastrophic dysplasia sulfate transporter gene, DTDST, in a patient with MED who had a club foot and double-layered patella."
    }
  }, {
    "data": {
      "source": "4244804",
      "target": "106917801",
      "name": "cause",
      "orig_sent": "Taken together, the present findings indicate that the G389R mutation in Tau can cause a dementing condition that closely resembles Pick's disease."
    }
  }, {
    "data": {
      "source": "16936204",
      "target": "107393501",
      "name": "associated in",
      "orig_sent": "Only rs9896052 (p = 6.55 x 10 (-5)) was associated with sight-threatening diabetic retinopathy in both the type 2 (p = 0.035) and the type 1 (p = 0.041) replication cohorts, as well as in the Indian cohort (p = 0.016)."
    }
  }, {
    "data": {
      "source": "12915104",
      "target": "263852501",
      "name": "detected in",
      "orig_sent": "The STRA6 p.G304"
    }
  }, {
    "data": {
      "source": "7681404",
      "target": "266704101",
      "name": "induce",
      "orig_sent": "APOE R136S and p.Leu149del induce autosomal dominant FD and a phenotype indistinguishable from FCHL, respectively."
    }
  }, {
    "data": {
      "source": "120637201",
      "target": "107376501",
      "name": "combined with",
      "orig_sent": "We screened 4 additional families, in which PED is combined with epilepsy, developmental delay, or migraine, but not with hemolysis or echinocytosis, and identified 2 additional GLUT1 mutations (A275T, G314S) that decreased glucose transport but did not affect cation permeability."
    }
  }, {
    "data": {
      "source": "8685304",
      "target": "255472201",
      "name": "identified in",
      "orig_sent": "In a case-control study from Belarus, the E1978X mutation was identified in 10/1,891 Byelorussian breast cancer cases (0.5%) compared with 1/1,019 population controls [odds ratio (OR): 5.4; 95% confidence interval (95% CI), 0.7-42.4, P = 0.1]."
    }
  }, {
    "data": {
      "source": "15344904",
      "target": "107354501",
      "name": "associated with",
      "orig_sent": "rs11655081 was also associated with WD (P = 2.78 x 10 (-2)) but not with any other focal or segmental dystonia."
    }
  }, {
    "data": {
      "source": "12889204",
      "target": "107503301",
      "name": "cause",
      "orig_sent": "Interestingly, while loss of Na (v) 1.1 function is common in DS, the R865G mutation may cause DS by overall gain-of-function defects."
    }
  }, {
    "data": {
      "source": "12094104",
      "target": "107376801",
      "name": "associated with",
      "orig_sent": "This study sought to identify whether genetic polymorphisms rs28929474 and rs17580 are associated with COPD susceptibility and lung function values in a Mexican mestizo population."
    }
  }, {
    "data": {
      "source": "831004",
      "target": "257045501",
      "name": "cause",
      "orig_sent": "Both the Q163X and the R120Q mutation cause demyelination and axonal loss."
    }
  }, {
    "data": {
      "source": "267312601",
      "target": "3072804",
      "name": "located in",
      "orig_sent": "AO-GLD mutations, including those found here, are located in the N-terminus (I66M, G270D, 535-573del) or C-terminus (L618S) of the GALC enzyme, whereas the reported mutations in the infantile form (IF-GLD) are in the central domain."
    }
  }, {
    "data": {
      "source": "510604",
      "target": "107539201",
      "name": "identified in",
      "orig_sent": "The first mutation, an E137G, was identified in the MRX16 family, and the second, R167W, was identified in a new mental retardation (MR) family shown to be linked to Xq28."
    }
  }, {
    "data": {
      "source": "7150104",
      "target": "264444101",
      "name": "found in",
      "orig_sent": "The N-terminal R420W mutation has already been found in juvenile sudden death cadavers of unrelated families."
    }
  }, {
    "data": {
      "source": "3811604",
      "target": "267343301",
      "name": "caused",
      "orig_sent": "In contrast, missense mutations produced distinct phenotypes: Gly80Arg caused significant cardiac malformations but only minor skeletal abnormalities; and Arg237Gln and Arg237Trp caused extensive upper limb malformations but less significant cardiac abnormalities."
    }
  }, {
    "data": {
      "source": "18560504",
      "target": "106909101",
      "name": "associated with",
      "orig_sent": "rs7533564 was not associated with diabetes complications in DCCT/EDIC or with SF in subjects without diabetes (nondiabetic [ND])"
    }
  }, {
    "data": {
      "source": "6257804",
      "target": "107376501",
      "name": "found with",
      "orig_sent": "Previously reported p.R240X was found in one patient with PKD with migraine without aura."
    }
  }, {
    "data": {
      "source": "3049604",
      "target": "107547401",
      "name": "causes",
      "orig_sent": "Some studies have suggested that the V804L mutation causes the low penetrance multiple endocrine neoplasia type 2 syndrome, with late onset and relatively indolent course, whereas others have reported that V804L and V804M have an aggressive potential."
    }
  }, {
    "data": {
      "source": "259493901",
      "target": "1322904",
      "name": "carry",
      "orig_sent": "Clinical features are severe developmental delay, microcephaly and dyskinesia."
    }
  }, {
    "data": {
      "source": "5908204",
      "target": "264739201",
      "name": "reported with",
      "orig_sent": "The p.Asn107Ser missense mutation of ALG13 had been previously reported in four females with ISs."
    }
  }, {
    "data": {
      "source": "13073504",
      "target": "258966801",
      "name": "linked to",
      "orig_sent": "Patient-only analysis suggested that rs704853 is also linked to oral ulcers, hematologic disorders and anti-double-stranded DNA (dsDNA) antibody production."
    }
  }, {
    "data": {
      "source": "7879304",
      "target": "259528501",
      "name": "causes",
      "orig_sent": "A novel D458V mutation in the SANS PDZ binding motif causes atypical Usher syndrome."
    }
  }]
}; // process data

elements.nodes.forEach(function (n) {
  var data = n.data;
  data.NodeTypeFormatted = data.type; // the source data for types isn't formatted well for reading

  if (data.NodeTypeFormatted === 'disease') {
    data.NodeTypeFormatted = 'Disease';
    data.NodeType = 'RedWine';
  } else if (data.NodeTypeFormatted === 'variant') {
    data.NodeTypeFormatted = 'Variant';
    data.NodeType = 'WhiteWine';
  } else if (data.NodeTypeFormatted === 'CheeseType') {
    data.NodeTypeFormatted = 'Cheese Type';
  } // save original position for use in animated layouts


  n.data.orgPos = {
    x: Math.random() * 3000,
    y: Math.random() * 2000
  };
  n.position = {
    x: Math.random() * 3000,
    y: Math.random() * 2000
  }; // zero width space after dashes to allow for line breaking

  data.name = data.name.replace(/[-]/g, "-\u200B");
});
/* harmony default export */ __webpack_exports__["default"] = (elements);

/***/ }),

/***/ "./src/client/cy-conf/index.js":
/*!*************************************!*\
  !*** ./src/client/cy-conf/index.js ***!
  \*************************************/
/*! exports provided: style, elements, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style */ "./src/client/cy-conf/style.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "style", function() { return _style__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _elements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elements */ "./src/client/cy-conf/elements.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "elements", function() { return _elements__WEBPACK_IMPORTED_MODULE_1__["default"]; });




/* harmony default export */ __webpack_exports__["default"] = ({
  style: _style__WEBPACK_IMPORTED_MODULE_0__["default"],
  elements: _elements__WEBPACK_IMPORTED_MODULE_1__["default"]
});

/***/ }),

/***/ "./src/client/cy-conf/style.js":
/*!*************************************!*\
  !*** ./src/client/cy-conf/style.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\ncore {\n\tactive-bg-color: #fff;\n\tactive-bg-opacity: 0.333;\n}\n\nedge {\n\tcurve-style: bezier;\n\topacity: 0.4;\n\twidth: 2;\n\tz-index: 0;\n\toverlay-opacity: 0;\n    events: no;\n    content: data(name);\n    target-arrow-shape: triangle;\n    font-size: 6;\n}\n\nnode {\n\twidth: 40;\n\theight: 40;\n\tfont-size: 9;\n\tfont-weight: bold;\n\tmin-zoomed-font-size: 4;\n\tlabel: data(name);\n\ttext-wrap: wrap;\n\ttext-max-width: 50;\n\ttext-valign: center;\n\ttext-halign: center;\n\ttext-events: yes;\n\tcolor: #000;\n\ttext-outline-width: 1;\n\ttext-outline-color: #fff;\n\ttext-outline-opacity: 1;\n\toverlay-color: #fff;\n}\n\nedge[interaction = \"cc\"] {\n\tline-color: #FACD37;\n\topacity: 0.666;\n\tz-index: 9;\n\twidth: 4;\n}\n\nnode[NodeType = \"Cheese\"],\nnode[NodeType = \"CheeseType\"] {\n\tbackground-color: #FACD37;\n\ttext-outline-color: #FACD37;\n}\n\nnode[NodeType = \"Cheese\"][Quality],\nnode[NodeType = \"CheeseType\"][Quality] {\n\twidth: mapData(Quality, 70, 100, 20, 50);\n\theight: mapData(Quality, 70, 100, 20, 50);\n}\n\nnode[NodeType = \"WhiteWine\"] {\n\tbackground-color: #EEAAAA;\n}\n\nedge[interaction = \"cw\"] {\n\tline-color: white;\n}\n\nnode[NodeType = \"RedWine\"] {\n\tbackground-color: #AAEEAA;\n}\n\nedge[interaction = \"cr\"] {\n\tline-color: #DE3128;\n}\n\nnode[NodeType = \"Cider\"] {\n\tbackground-color: #A4EB34;\n\ttext-outline-color: #A4EB34;\n}\n\nnode.highlighted {\n\tmin-zoomed-font-size: 0;\n  z-index: 9999;\n}\n\nedge.highlighted {\n\topacity: 0.8;\n\twidth: 4;\n\tz-index: 9999;\n}\n\n.faded {\n  events: no;\n}\n\nnode.faded {\n  opacity: 0.08;\n}\n\nedge.faded {\n  opacity: 0.06;\n}\n\n.hidden {\n\tdisplay: none;\n}\n\n");

/***/ }),

/***/ "./src/client/env.js":
/*!***************************!*\
  !*** ./src/client/env.js ***!
  \***************************/
/*! exports provided: NODE_ENV, isProd, isDev */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NODE_ENV", function() { return NODE_ENV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isProd", function() { return isProd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDev", function() { return isDev; });
var NODE_ENV = "development";
var isProd = NODE_ENV === 'production';
var isDev = !isProd;

/***/ }),

/***/ "./src/client/index.js":
/*!*****************************!*\
  !*** ./src/client/index.js ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env */ "./src/client/env.js");
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var _components_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/app */ "./src/client/components/app.js");




if (!_env__WEBPACK_IMPORTED_MODULE_0__["isProd"]) {
  // set up livereload for dev
  var script = document.createElement('script');
  script.src = 'http://' + location.hostname + ':35729/livereload.js?snipver=1';
  document.head.appendChild(script);
}

var root = document.createElement('div');
root.setAttribute('id', 'root');
document.body.appendChild(root);
Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(Object(preact__WEBPACK_IMPORTED_MODULE_1__["h"])(_components_app__WEBPACK_IMPORTED_MODULE_2__["AppComponent"]), root);
console.log("You can view the source code of this Cytoscape.js-powered app at https://github.com/cytoscape/wineandcheesemap");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZS5janMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hlYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hlYXAvbGliL2hlYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWJvdW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLm1lbW9pemUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvY29tcG9uZW50cy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC9jb21wb25lbnRzL2N5dG9zY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvbWVudS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvbm9kZS1pbmZvLmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2N5LWNvbmYvZWxlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC9jeS1jb25mL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvY3ktY29uZi9zdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2Vudi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2luZGV4LmpzIl0sIm5hbWVzIjpbIkFwcENvbXBvbmVudCIsInByb3BzIiwiY3kiLCJDeXRvc2NhcGUiLCJlbGVtZW50cyIsInN0eWxlIiwibGF5b3V0IiwibmFtZSIsInNlbGVjdGlvblR5cGUiLCJib3hTZWxlY3Rpb25FbmFibGVkIiwibm9kZXMiLCJwYW5pZnkiLCJ1bmdyYWJpZnkiLCJjb250cm9sbGVyIiwiQ29udHJvbGxlciIsImJ1cyIsImlzRGV2Iiwid2luZG93Iiwic3RhdGUiLCJvbiIsIm9uU2hvd0luZm8iLCJub2RlIiwic2V0U3RhdGUiLCJpbmZvTm9kZSIsIm9uSGlkZUluZm8iLCJyZW1vdmVMaXN0ZW5lciIsImgiLCJDeXRvc2NhcGVDb21wb25lbnQiLCJOb2RlSW5mbyIsIk1lbnUiLCJDb21wb25lbnQiLCJpZCIsImNvbnRhaW5lciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJtb3VudCIsImZpdCIsIm9uVGFwIiwiZSIsInRhcmdldCIsInVuaGlnaGxpZ2h0IiwiaGlkZUluZm8iLCJjbG9zZU1lbnUiLCJoaWdobGlnaHQiLCJzaG93SW5mbyIsIm9wZW4iLCJpc01lbnVPcGVuIiwib25PcGVuTWVudSIsImZvY3VzVGV4dEJveCIsIm9uVXBkYXRlU2VhcmNoIiwic2VhcmNoTWF0Y2hOb2RlcyIsImRlYm91bmNlZFVwZGF0ZVNlYXJjaCIsImRlYm91bmNlIiwidXBkYXRlU2VhcmNoIiwib25DbG9zZU1lbnUiLCJvcGVuTWVudSIsImlucHV0IiwicmVzdWx0cyIsInF1ZXJ5U3RyaW5nIiwidmFsdWUiLCJzY3JvbGxUbyIsImZvY3VzIiwiY2xvc2VkIiwic2VhcmNoUmVzdWx0cyIsIm1hcCIsIm9uQ2xpY2siLCJzZWxlY3ROb2RlIiwiY2xhc3NOYW1lcyIsInRvZ2dsZU1lbnUiLCJ0eXBlIiwicGxhY2Vob2xkZXIiLCJvbktleURvd24iLCJkYXRhIiwiTm9kZVR5cGVGb3JtYXR0ZWQiLCJUeXBlIiwibWlsayIsIk1pbGsiLCJpc01pbGsiLCJjb3VudHJ5IiwiQ291bnRyeSIsImhhc0NvdW50cnkiLCJxIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiTm9kZVR5cGUiLCJlZGdlcyIsImNvbm5lY3RlZEVkZ2VzIiwiZWRnZSIsIm9yaWdfc2VudCIsImxheW91dFBhZGRpbmciLCJhbmltYXRpb25EdXJhdGlvbiIsImVhc2luZyIsIm1pbk1ldHJpY1ZhbHVlIiwibWluU2ltaWxhcml0eVZhbHVlIiwiZGVsYXlQcm9taXNlIiwiZHVyYXRpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJnZXRPcmdQb3MiLCJuIiwiT2JqZWN0IiwiYXNzaWduIiwiRXZlbnRFbWl0dGVyIiwibWVudSIsImNvbGxlY3Rpb24iLCJlbWl0IiwibGFzdEhpZ2hsaWdodGVkIiwiaGlnaGxpZ2h0SW5Qcm9ncmVzcyIsImFsbEVsZXMiLCJuaG9vZCIsImNsb3NlZE5laWdoYm9yaG9vZCIsIm90aGVycyIsImxhc3RVbmhpZ2hsaWdodGVkIiwibm90Iiwic2hvd092ZXJ2aWV3IiwiYmF0Y2giLCJyZW1vdmVDbGFzcyIsImFkZENsYXNzIiwicG9zaXRpb25zIiwiYW5pbWF0ZSIsImFuaW1hdGlvbkVhc2luZyIsInBhZGRpbmciLCJydW4iLCJwcm9taXNlT24iLCJydW5MYXlvdXQiLCJwIiwibWluTm9kZVNwYWNpbmciLCJib3VuZGluZ0JveCIsIngxIiwieCIsIngyIiwieTEiLCJ5IiwieTIiLCJhdm9pZE92ZXJsYXAiLCJjb25jZW50cmljIiwiZWxlIiwic2FtZSIsImxldmVsV2lkdGgiLCJwcm9taXNlIiwic2hvd090aGVyc0ZhZGVkIiwidGhlbiIsImhhc0hpZ2hsaWdodCIsImFsbE5vZGVzIiwic3RvcCIsImhpZGVPdGhlcnMiLCJyZXNldENsYXNzZXMiLCJhbmltYXRlVG9PcmdQb3MiLCJhbGwiLCJhbmltYXRpb24iLCJwb3NpdGlvbiIsInBsYXkiLCJyZXN0b3JlUG9zaXRpb25zIiwibm9ybWFsaXplIiwic3RyIiwidG9Mb3dlckNhc2UiLCJnZXRXb3JkcyIsInNwbGl0IiwicXVlcnlXb3JkcyIsImFkZFdvcmRzIiwid29yZExpc3QiLCJ3b3Jkc1N0ciIsInB1c2giLCJjYWNoZU5vZGVXb3JkcyIsIlN5bm9ueW0iLCJnZXRTdHJpbmdTaW1pbGFyaXR5IiwicXVlcnlXb3JkIiwibm9kZVdvcmQiLCJpbmRleCIsImluZGV4T2YiLCJkaWZmIiwiTWF0aCIsImFicyIsImxlbmd0aCIsIm1heExlbmd0aCIsIm1heCIsImdldE1ldHJpYyIsIm5vZGVXb3JkcyIsInNjb3JlIiwiaSIsImoiLCJzaW1pbGFyaXR5IiwiZ2V0Tm9kZU1ldHJpYyIsIm1lbW9pemUiLCJjYWNoZWROb2RlV29yZHMiLCJmb3JFYWNoIiwiZmlsdGVyIiwic29ydCIsIm5vZGVBIiwibm9kZUIiLCJvcmdQb3MiLCJyYW5kb20iLCJyZXBsYWNlIiwiTk9ERV9FTlYiLCJwcm9jZXNzIiwiaXNQcm9kIiwic2NyaXB0IiwiY3JlYXRlRWxlbWVudCIsInNyYyIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJyb290Iiwic2V0QXR0cmlidXRlIiwiYm9keSIsInJlbmRlciIsImNvbnNvbGUiLCJsb2ciXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3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QUN0QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0EsR0FBRzs7O0FBR0gsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QixnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsdUhBQXVIOztBQUV2SDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SDs7QUFFekg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSwrSEFBK0g7O0FBRS9IO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIOztBQUU3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7O0FBRTFGLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxhQUFhOztBQUViLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QixpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLGtDQUFrQztBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQSwyQ0FBMkM7O0FBRTNDLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RCxtQkFBbUIsY0FBYztBQUNqQyxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTCxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7O0FBR2hDLHNCQUFzQjs7QUFFdEI7QUFDQSxLQUFLO0FBQ0w7OztBQUdBLDRDQUE0QztBQUM1Qzs7QUFFQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBLE9BQU87OztBQUdQLHVCQUF1QixnQkFBZ0I7QUFDdkMseUJBQXlCLGdCQUFnQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsY0FBYztBQUNuQyw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckM7O0FBRUEsNEJBQTRCOzs7QUFHNUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEIsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBLE9BQU87OztBQUdQLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUCxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7O0FBRUEscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDLE9BQU87QUFDUCw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7O0FBRUEsc0JBQXNCLGVBQWU7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQixpQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCLG1CQUFtQjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOzs7QUFHNUIsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLHNGQUFzRjs7QUFFdEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckIsaUNBQWlDOztBQUVqQzs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQix5Q0FBeUM7O0FBRXpDLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0gseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQSxvQkFBb0IsV0FBVztBQUMvQixtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEMsbUJBQW1CLGtCQUFrQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLGlFQUFpRTtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQixtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQyxzQkFBc0I7O0FBRXRCO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUEsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjs7QUFFQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLHNCQUFzQjs7QUFFdEI7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1FQUFtRTtBQUNuRTs7QUFFQSxzQkFBc0IscUJBQXFCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkMsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6QyxxQkFBcUIsOEJBQThCO0FBQ25EO0FBQ0E7O0FBRUEsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDLG1CQUFtQixrQkFBa0I7QUFDckM7O0FBRUEscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBLGVBQWU7O0FBRWYscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0gsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDOztBQUVBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQix1REFBdUQ7O0FBRXZELG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLDBFQUEwRTtBQUMxRTs7QUFFQSwyREFBMkQ7QUFDM0QsR0FBRzs7O0FBR0gsbUJBQW1CLHVCQUF1QjtBQUMxQzs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixxQkFBcUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0EsaUJBQWlCOztBQUVqQixnQkFBZ0I7O0FBRWhCLGlCQUFpQjtBQUNqQjs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdILGlCQUFpQixxQkFBcUI7QUFDdEMsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBLG9CQUFvQix1QkFBdUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixlQUFlO0FBQ2xDOztBQUVBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQSxHQUFHOzs7QUFHSCxRQUFROztBQUVSLFNBQVM7O0FBRVQsUUFBUTs7QUFFUixRQUFROztBQUVSLFFBQVE7O0FBRVIsUUFBUTs7QUFFUjtBQUNBLGFBQWE7O0FBRWI7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0Isc0JBQXNCO0FBQ3RCOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLEdBQUc7OztBQUdIOztBQUVBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0wscUJBQXFCLFNBQVM7QUFDOUI7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixVQUFVO0FBQ2xDOztBQUVBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsZ0RBQWdEOztBQUVoRDtBQUNBOztBQUVBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQyxXQUFXO0FBQ1gscUNBQXFDO0FBQ3JDLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLDhCQUE4QjtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsNkRBQTZEO0FBQzdEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7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QUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTs7QUFFVDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFOztBQUVUO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDJCQUEyQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7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O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCLFdBQVc7O0FBRVg7QUFDQSw4RkFBOEY7QUFDOUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLElBQUk7O0FBRUwsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwwQ0FBMEM7O0FBRTFDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0MsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FB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d0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxvRUFBb0U7QUFDOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGOztBQUV4RixxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7O0FBR04scUNBQXFDLFNBQVM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUV0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxFQUFFOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxFQUFFOztBQUVMO0FBQ0E7QUFDQSxHQUFHLEVBQUU7O0FBRUwsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBLDRCQUE0QjtBQUM1QixHQUFHOzs7QUFHSCxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQSxHQUFHO0FBQ0gsbUJBQW1CLDZCQUE2QjtBQUNoRCxzQ0FBc0MsR0FBRztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUEsaUJBQWlCLDRCQUE0QjtB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O0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEU7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPOztBQUVQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQLHdEQUF3RDtBQUN4RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQzs7QUFFdEMsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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Q0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDBDQUEwQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDRCQUE0QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFD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LEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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QUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUNBQW1DLDBCQUEwQixvQkFBb0I7QUFDdkk7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QjJNLElBQWxCLENBQU47QUFFQUksT0FBTyxDQUFDQyxHQUFSLG1IIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2NsaWVudC9pbmRleC5qc1wiKTtcbiIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTcgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaW5uZXIgPSBjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG5cdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChpbm5lcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGFyZykge1xuXHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjbGFzc2VzLmpvaW4oJyAnKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdGNsYXNzTmFtZXMuZGVmYXVsdCA9IGNsYXNzTmFtZXM7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTksIFRoZSBDeXRvc2NhcGUgQ29uc29ydGl1bS5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSDigJxTb2Z0d2FyZeKAnSksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIOKAnEFTIElT4oCdLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgdXRpbCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdsb2Rhc2guZGVib3VuY2UnKSk7XG52YXIgSGVhcCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdoZWFwJykpO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxudmFyIHdpbmRvdyQxID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbnZhciBuYXZpZ2F0b3IgPSB3aW5kb3ckMSA/IHdpbmRvdyQxLm5hdmlnYXRvciA6IG51bGw7XG52YXIgZG9jdW1lbnQkMSA9IHdpbmRvdyQxID8gd2luZG93JDEuZG9jdW1lbnQgOiBudWxsO1xuXG52YXIgdHlwZW9mc3RyID0gX3R5cGVvZignJyk7XG5cbnZhciB0eXBlb2ZvYmogPSBfdHlwZW9mKHt9KTtcblxudmFyIHR5cGVvZmZuID0gX3R5cGVvZihmdW5jdGlvbiAoKSB7fSk7XG5cbnZhciB0eXBlb2ZodG1sZWxlID0gdHlwZW9mIEhUTUxFbGVtZW50ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoSFRNTEVsZW1lbnQpO1xuXG52YXIgaW5zdGFuY2VTdHIgPSBmdW5jdGlvbiBpbnN0YW5jZVN0cihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouaW5zdGFuY2VTdHJpbmcgJiYgZm4ob2JqLmluc3RhbmNlU3RyaW5nKSA/IG9iai5pbnN0YW5jZVN0cmluZygpIDogbnVsbDtcbn07XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT0gdHlwZW9mc3RyO1xufTtcbnZhciBmbiA9IGZ1bmN0aW9uIGZuKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSB0eXBlb2Zmbjtcbn07XG52YXIgYXJyYXkgPSBmdW5jdGlvbiBhcnJheShvYmopIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5KG9iaikgOiBvYmogIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiBBcnJheTtcbn07XG52YXIgcGxhaW5PYmplY3QgPSBmdW5jdGlvbiBwbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gdHlwZW9mb2JqICYmICFhcnJheShvYmopICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xufTtcbnZhciBvYmplY3QgPSBmdW5jdGlvbiBvYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IHR5cGVvZm9iajtcbn07XG52YXIgbnVtYmVyID0gZnVuY3Rpb24gbnVtYmVyKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSBfdHlwZW9mKDEpICYmICFpc05hTihvYmopO1xufTtcbnZhciBpbnRlZ2VyID0gZnVuY3Rpb24gaW50ZWdlcihvYmopIHtcbiAgcmV0dXJuIG51bWJlcihvYmopICYmIE1hdGguZmxvb3Iob2JqKSA9PT0gb2JqO1xufTtcbnZhciBodG1sRWxlbWVudCA9IGZ1bmN0aW9uIGh0bWxFbGVtZW50KG9iaikge1xuICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZmh0bWxlbGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsICE9IG9iaiAmJiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfVxufTtcbnZhciBlbGVtZW50T3JDb2xsZWN0aW9uID0gZnVuY3Rpb24gZWxlbWVudE9yQ29sbGVjdGlvbihvYmopIHtcbiAgcmV0dXJuIGVsZW1lbnQob2JqKSB8fCBjb2xsZWN0aW9uKG9iaik7XG59O1xudmFyIGVsZW1lbnQgPSBmdW5jdGlvbiBlbGVtZW50KG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvbGxlY3Rpb24nICYmIG9iai5fcHJpdmF0ZS5zaW5nbGU7XG59O1xudmFyIGNvbGxlY3Rpb24gPSBmdW5jdGlvbiBjb2xsZWN0aW9uKG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvbGxlY3Rpb24nICYmICFvYmouX3ByaXZhdGUuc2luZ2xlO1xufTtcbnZhciBjb3JlID0gZnVuY3Rpb24gY29yZShvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb3JlJztcbn07XG52YXIgc3R5bGVzaGVldCA9IGZ1bmN0aW9uIHN0eWxlc2hlZXQob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnc3R5bGVzaGVldCc7XG59O1xudmFyIGV2ZW50ID0gZnVuY3Rpb24gZXZlbnQob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnZXZlbnQnO1xufTtcbnZhciBlbXB0eVN0cmluZyA9IGZ1bmN0aW9uIGVtcHR5U3RyaW5nKG9iaikge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgLy8gbnVsbCBpcyBlbXB0eVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKG9iaiA9PT0gJycgfHwgb2JqLm1hdGNoKC9eXFxzKyQvKSkge1xuICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSBzdHJpbmcgaXMgZW1wdHlcbiAgfVxuXG4gIHJldHVybiBmYWxzZTsgLy8gb3RoZXJ3aXNlLCB3ZSBkb24ndCBrbm93IHdoYXQgd2UndmUgZ290XG59O1xudmFyIGRvbUVsZW1lbnQgPSBmdW5jdGlvbiBkb21FbGVtZW50KG9iaikge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgbm90IGluIGEgYnJvd3NlciBzbyBpdCBkb2Vzbid0IG1hdHRlclxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfVxufTtcbnZhciBib3VuZGluZ0JveCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94KG9iaikge1xuICByZXR1cm4gcGxhaW5PYmplY3Qob2JqKSAmJiBudW1iZXIob2JqLngxKSAmJiBudW1iZXIob2JqLngyKSAmJiBudW1iZXIob2JqLnkxKSAmJiBudW1iZXIob2JqLnkyKTtcbn07XG52YXIgcHJvbWlzZSA9IGZ1bmN0aW9uIHByb21pc2Uob2JqKSB7XG4gIHJldHVybiBvYmplY3Qob2JqKSAmJiBmbihvYmoudGhlbik7XG59O1xudmFyIG1zID0gZnVuY3Rpb24gbXMoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvbXNpZXx0cmlkZW50fGVkZ2UvaSk7XG59OyAvLyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRoaXMuLi5cblxudmFyIG1lbW9pemUgPSBmdW5jdGlvbiBtZW1vaXplKGZuLCBrZXlGbikge1xuICBpZiAoIWtleUZuKSB7XG4gICAga2V5Rm4gPSBmdW5jdGlvbiBrZXlGbigpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyZ3Muam9pbignJCcpO1xuICAgIH07XG4gIH1cblxuICB2YXIgbWVtb2l6ZWRGbiA9IGZ1bmN0aW9uIG1lbW9pemVkRm4oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciByZXQ7XG4gICAgdmFyIGsgPSBrZXlGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB2YXIgY2FjaGUgPSBtZW1vaXplZEZuLmNhY2hlO1xuXG4gICAgaWYgKCEocmV0ID0gY2FjaGVba10pKSB7XG4gICAgICByZXQgPSBjYWNoZVtrXSA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgbWVtb2l6ZWRGbi5jYWNoZSA9IHt9O1xuICByZXR1cm4gbWVtb2l6ZWRGbjtcbn07XG5cbnZhciBjYW1lbDJkYXNoID0gbWVtb2l6ZShmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiAnLScgKyB2LnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xufSk7XG52YXIgZGFzaDJjYW1lbCA9IG1lbW9pemUoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLygtXFx3KS9nLCBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2WzFdLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufSk7XG52YXIgcHJlcGVuZENhbWVsID0gbWVtb2l6ZShmdW5jdGlvbiAocHJlZml4LCBzdHIpIHtcbiAgcmV0dXJuIHByZWZpeCArIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn0sIGZ1bmN0aW9uIChwcmVmaXgsIHN0cikge1xuICByZXR1cm4gcHJlZml4ICsgJyQnICsgc3RyO1xufSk7XG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gIGlmIChlbXB0eVN0cmluZyhzdHIpKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxudmFyIG51bWJlciQxID0gJyg/OlstK10/KD86KD86XFxcXGQrfFxcXFxkKlxcXFwuXFxcXGQrKSg/OltFZV1bKy1dP1xcXFxkKyk/KSknO1xudmFyIHJnYmEgPSAncmdiW2FdP1xcXFwoKCcgKyBudW1iZXIkMSArICdbJV0/KVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJ1slXT8pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpKT9cXFxcKSc7XG52YXIgcmdiYU5vQmFja1JlZnMgPSAncmdiW2FdP1xcXFwoKD86JyArIG51bWJlciQxICsgJ1slXT8pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIkMSArICdbJV0/KVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyJDEgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKD86JyArIG51bWJlciQxICsgJykpP1xcXFwpJztcbnZhciBoc2xhID0gJ2hzbFthXT9cXFxcKCgnICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJ1slXSlcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICdbJV0pKD86XFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKSk/XFxcXCknO1xudmFyIGhzbGFOb0JhY2tSZWZzID0gJ2hzbFthXT9cXFxcKCg/OicgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIkMSArICdbJV0pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIkMSArICdbJV0pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIkMSArICcpKT9cXFxcKSc7XG52YXIgaGV4MyA9ICdcXFxcI1swLTlhLWZBLUZdezN9JztcbnZhciBoZXg2ID0gJ1xcXFwjWzAtOWEtZkEtRl17Nn0nO1xuXG52YXIgYXNjZW5kaW5nID0gZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG52YXIgZGVzY2VuZGluZyA9IGZ1bmN0aW9uIGRlc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gLTEgKiBhc2NlbmRpbmcoYSwgYik7XG59O1xuXG52YXIgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbiAhPSBudWxsID8gT2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCkgOiBmdW5jdGlvbiAodGd0KSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvYmogPSBhcmdzW2ldO1xuXG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBrID0ga2V5c1tqXTtcbiAgICAgIHRndFtrXSA9IG9ialtrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGd0O1xufTtcblxudmFyIGhleDJ0dXBsZSA9IGZ1bmN0aW9uIGhleDJ0dXBsZShoZXgpIHtcbiAgaWYgKCEoaGV4Lmxlbmd0aCA9PT0gNCB8fCBoZXgubGVuZ3RoID09PSA3KSB8fCBoZXhbMF0gIT09ICcjJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzaG9ydEhleCA9IGhleC5sZW5ndGggPT09IDQ7XG4gIHZhciByLCBnLCBiO1xuICB2YXIgYmFzZSA9IDE2O1xuXG4gIGlmIChzaG9ydEhleCkge1xuICAgIHIgPSBwYXJzZUludChoZXhbMV0gKyBoZXhbMV0sIGJhc2UpO1xuICAgIGcgPSBwYXJzZUludChoZXhbMl0gKyBoZXhbMl0sIGJhc2UpO1xuICAgIGIgPSBwYXJzZUludChoZXhbM10gKyBoZXhbM10sIGJhc2UpO1xuICB9IGVsc2Uge1xuICAgIHIgPSBwYXJzZUludChoZXhbMV0gKyBoZXhbMl0sIGJhc2UpO1xuICAgIGcgPSBwYXJzZUludChoZXhbM10gKyBoZXhbNF0sIGJhc2UpO1xuICAgIGIgPSBwYXJzZUludChoZXhbNV0gKyBoZXhbNl0sIGJhc2UpO1xuICB9XG5cbiAgcmV0dXJuIFtyLCBnLCBiXTtcbn07IC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSBoc2woMCwgMCwgMCkgb3IgaHNsYSgwLCAwLCAwLCAwKVxuXG52YXIgaHNsMnR1cGxlID0gZnVuY3Rpb24gaHNsMnR1cGxlKGhzbCkge1xuICB2YXIgcmV0O1xuICB2YXIgaCwgcywgbCwgYSwgciwgZywgYjtcblxuICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApIHQgKz0gMTtcbiAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICBpZiAodCA8IDEgLyA2KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTtcbiAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICB2YXIgbSA9IG5ldyBSZWdFeHAoJ14nICsgaHNsYSArICckJykuZXhlYyhoc2wpO1xuXG4gIGlmIChtKSB7XG4gICAgLy8gZ2V0IGh1ZVxuICAgIGggPSBwYXJzZUludChtWzFdKTtcblxuICAgIGlmIChoIDwgMCkge1xuICAgICAgaCA9ICgzNjAgLSAtMSAqIGggJSAzNjApICUgMzYwO1xuICAgIH0gZWxzZSBpZiAoaCA+IDM2MCkge1xuICAgICAgaCA9IGggJSAzNjA7XG4gICAgfVxuXG4gICAgaCAvPSAzNjA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgIHMgPSBwYXJzZUZsb2F0KG1bMl0pO1xuXG4gICAgaWYgKHMgPCAwIHx8IHMgPiAxMDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHNhdHVyYXRpb24gaXMgWzAsIDEwMF1cblxuXG4gICAgcyA9IHMgLyAxMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgIGwgPSBwYXJzZUZsb2F0KG1bM10pO1xuXG4gICAgaWYgKGwgPCAwIHx8IGwgPiAxMDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGxpZ2h0bmVzcyBpcyBbMCwgMTAwXVxuXG5cbiAgICBsID0gbCAvIDEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgYSA9IG1bNF07XG5cbiAgICBpZiAoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhID0gcGFyc2VGbG9hdChhKTtcblxuICAgICAgaWYgKGEgPCAwIHx8IGEgPiAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gYWxwaGEgaXMgWzAsIDFdXG5cbiAgICB9IC8vIG5vdywgY29udmVydCB0byByZ2JcbiAgICAvLyBjb2RlIGZyb20gaHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdFxuXG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgciA9IGcgPSBiID0gTWF0aC5yb3VuZChsICogMjU1KTsgLy8gYWNocm9tYXRpY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICAgIHIgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKSk7XG4gICAgICBnID0gTWF0aC5yb3VuZCgyNTUgKiBodWUycmdiKHAsIHEsIGgpKTtcbiAgICAgIGIgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKSk7XG4gICAgfVxuXG4gICAgcmV0ID0gW3IsIGcsIGIsIGFdO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07IC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSByZ2IoMCwgMCwgMCkgb3IgcmdiYSgwLCAwLCAwLCAwKVxuXG52YXIgcmdiMnR1cGxlID0gZnVuY3Rpb24gcmdiMnR1cGxlKHJnYikge1xuICB2YXIgcmV0O1xuICB2YXIgbSA9IG5ldyBSZWdFeHAoJ14nICsgcmdiYSArICckJykuZXhlYyhyZ2IpO1xuXG4gIGlmIChtKSB7XG4gICAgcmV0ID0gW107XG4gICAgdmFyIGlzUGN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSAzOyBpKyspIHtcbiAgICAgIHZhciBjaGFubmVsID0gbVtpXTtcblxuICAgICAgaWYgKGNoYW5uZWxbY2hhbm5lbC5sZW5ndGggLSAxXSA9PT0gJyUnKSB7XG4gICAgICAgIGlzUGN0W2ldID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY2hhbm5lbCA9IHBhcnNlRmxvYXQoY2hhbm5lbCk7XG5cbiAgICAgIGlmIChpc1BjdFtpXSkge1xuICAgICAgICBjaGFubmVsID0gY2hhbm5lbCAvIDEwMCAqIDI1NTsgLy8gbm9ybWFsaXNlIHRvIFswLCAyNTVdXG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFubmVsIDwgMCB8fCBjaGFubmVsID4gMjU1KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gaW52YWxpZCBjaGFubmVsIHZhbHVlXG5cblxuICAgICAgcmV0LnB1c2goTWF0aC5mbG9vcihjaGFubmVsKSk7XG4gICAgfVxuXG4gICAgdmFyIGF0TGVhc3RPbmVJc1BjdCA9IGlzUGN0WzFdIHx8IGlzUGN0WzJdIHx8IGlzUGN0WzNdO1xuICAgIHZhciBhbGxBcmVQY3QgPSBpc1BjdFsxXSAmJiBpc1BjdFsyXSAmJiBpc1BjdFszXTtcblxuICAgIGlmIChhdExlYXN0T25lSXNQY3QgJiYgIWFsbEFyZVBjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbXVzdCBhbGwgYmUgcGVyY2VudCB2YWx1ZXMgaWYgb25lIGlzXG5cblxuICAgIHZhciBhbHBoYSA9IG1bNF07XG5cbiAgICBpZiAoYWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KGFscGhhKTtcblxuICAgICAgaWYgKGFscGhhIDwgMCB8fCBhbHBoYSA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBpbnZhbGlkIGFscGhhIHZhbHVlXG5cblxuICAgICAgcmV0LnB1c2goYWxwaGEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xudmFyIGNvbG9ybmFtZTJ0dXBsZSA9IGZ1bmN0aW9uIGNvbG9ybmFtZTJ0dXBsZShjb2xvcikge1xuICByZXR1cm4gY29sb3JzW2NvbG9yLnRvTG93ZXJDYXNlKCldO1xufTtcbnZhciBjb2xvcjJ0dXBsZSA9IGZ1bmN0aW9uIGNvbG9yMnR1cGxlKGNvbG9yKSB7XG4gIHJldHVybiAoYXJyYXkoY29sb3IpID8gY29sb3IgOiBudWxsKSB8fCBjb2xvcm5hbWUydHVwbGUoY29sb3IpIHx8IGhleDJ0dXBsZShjb2xvcikgfHwgcmdiMnR1cGxlKGNvbG9yKSB8fCBoc2wydHVwbGUoY29sb3IpO1xufTtcbnZhciBjb2xvcnMgPSB7XG4gIC8vIHNwZWNpYWwgY29sb3VyIG5hbWVzXG4gIHRyYW5zcGFyZW50OiBbMCwgMCwgMCwgMF0sXG4gIC8vIE5CIGFscGhhID09PSAwXG4gIC8vIHJlZ3VsYXIgY29sb3Vyc1xuICBhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG4gIGFxdWE6IFswLCAyNTUsIDI1NV0sXG4gIGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyXSxcbiAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcbiAgYmVpZ2U6IFsyNDUsIDI0NSwgMjIwXSxcbiAgYmlzcXVlOiBbMjU1LCAyMjgsIDE5Nl0sXG4gIGJsYWNrOiBbMCwgMCwgMF0sXG4gIGJsYW5jaGVkYWxtb25kOiBbMjU1LCAyMzUsIDIwNV0sXG4gIGJsdWU6IFswLCAwLCAyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcbiAgYnJvd246IFsxNjUsIDQyLCA0Ml0sXG4gIGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzVdLFxuICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuICBjaGFydHJldXNlOiBbMTI3LCAyNTUsIDBdLFxuICBjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzBdLFxuICBjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLCAxNDksIDIzN10sXG4gIGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMF0sXG4gIGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG4gIGN5YW46IFswLCAyNTUsIDI1NV0sXG4gIGRhcmtibHVlOiBbMCwgMCwgMTM5XSxcbiAgZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG4gIGRhcmtnb2xkZW5yb2Q6IFsxODQsIDEzNCwgMTFdLFxuICBkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjldLFxuICBkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuICBkYXJrZ3JleTogWzE2OSwgMTY5LCAxNjldLFxuICBkYXJra2hha2k6IFsxODksIDE4MywgMTA3XSxcbiAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG4gIGRhcmtvbGl2ZWdyZWVuOiBbODUsIDEwNywgNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDBdLFxuICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcbiAgZGFya3JlZDogWzEzOSwgMCwgMF0sXG4gIGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyXSxcbiAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6IFs3MiwgNjEsIDEzOV0sXG4gIGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5XSxcbiAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuICBkYXJrdHVycXVvaXNlOiBbMCwgMjA2LCAyMDldLFxuICBkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTFdLFxuICBkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG4gIGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTVdLFxuICBkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNV0sXG4gIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgZG9kZ2VyYmx1ZTogWzMwLCAxNDQsIDI1NV0sXG4gIGZpcmVicmljazogWzE3OCwgMzQsIDM0XSxcbiAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwXSxcbiAgZm9yZXN0Z3JlZW46IFszNCwgMTM5LCAzNF0sXG4gIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LCAyNDgsIDI1NV0sXG4gIGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG4gIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgZ3JleTogWzEyOCwgMTI4LCAxMjhdLFxuICBncmVlbjogWzAsIDEyOCwgMF0sXG4gIGdyZWVueWVsbG93OiBbMTczLCAyNTUsIDQ3XSxcbiAgaG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwXSxcbiAgaG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuICBpbmRpYW5yZWQ6IFsyMDUsIDkyLCA5Ml0sXG4gIGluZGlnbzogWzc1LCAwLCAxMzBdLFxuICBpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuICBraGFraTogWzI0MCwgMjMwLCAxNDBdLFxuICBsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG4gIGxhd25ncmVlbjogWzEyNCwgMjUyLCAwXSxcbiAgbGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNV0sXG4gIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICBsaWdodGNvcmFsOiBbMjQwLCAxMjgsIDEyOF0sXG4gIGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTVdLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuICBsaWdodGdyYXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgbGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5M10sXG4gIGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMl0sXG4gIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuICBsaWdodHNreWJsdWU6IFsxMzUsIDIwNiwgMjUwXSxcbiAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsIDE5NiwgMjIyXSxcbiAgbGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0XSxcbiAgbGltZTogWzAsIDI1NSwgMF0sXG4gIGxpbWVncmVlbjogWzUwLCAyMDUsIDUwXSxcbiAgbGluZW46IFsyNTAsIDI0MCwgMjMwXSxcbiAgbWFnZW50YTogWzI1NSwgMCwgMjU1XSxcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzBdLFxuICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcbiAgbWVkaXVtb3JjaGlkOiBbMTg2LCA4NSwgMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOV0sXG4gIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcbiAgbWVkaXVtc2xhdGVibHVlOiBbMTIzLCAxMDQsIDIzOF0sXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuICBtZWRpdW12aW9sZXRyZWQ6IFsxOTksIDIxLCAxMzNdLFxuICBtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMl0sXG4gIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuICBtaXN0eXJvc2U6IFsyNTUsIDIyOCwgMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxXSxcbiAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcbiAgbmF2eTogWzAsIDAsIDEyOF0sXG4gIG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwXSxcbiAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gIG9saXZlZHJhYjogWzEwNywgMTQyLCAzNV0sXG4gIG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcbiAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG4gIG9yY2hpZDogWzIxOCwgMTEyLCAyMTRdLFxuICBwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MF0sXG4gIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuICBwYWxldHVycXVvaXNlOiBbMTc1LCAyMzgsIDIzOF0sXG4gIHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3XSxcbiAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuICBwZWFjaHB1ZmY6IFsyNTUsIDIxOCwgMTg1XSxcbiAgcGVydTogWzIwNSwgMTMzLCA2M10sXG4gIHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcbiAgcGx1bTogWzIyMSwgMTYwLCAyMjFdLFxuICBwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMF0sXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgcmVkOiBbMjU1LCAwLCAwXSxcbiAgcm9zeWJyb3duOiBbMTg4LCAxNDMsIDE0M10sXG4gIHJveWFsYmx1ZTogWzY1LCAxMDUsIDIyNV0sXG4gIHNhZGRsZWJyb3duOiBbMTM5LCA2OSwgMTldLFxuICBzYWxtb246IFsyNTAsIDEyOCwgMTE0XSxcbiAgc2FuZHlicm93bjogWzI0NCwgMTY0LCA5Nl0sXG4gIHNlYWdyZWVuOiBbNDYsIDEzOSwgODddLFxuICBzZWFzaGVsbDogWzI1NSwgMjQ1LCAyMzhdLFxuICBzaWVubmE6IFsxNjAsIDgyLCA0NV0sXG4gIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICBza3libHVlOiBbMTM1LCAyMDYsIDIzNV0sXG4gIHNsYXRlYmx1ZTogWzEwNiwgOTAsIDIwNV0sXG4gIHNsYXRlZ3JheTogWzExMiwgMTI4LCAxNDRdLFxuICBzbGF0ZWdyZXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgc25vdzogWzI1NSwgMjUwLCAyNTBdLFxuICBzcHJpbmdncmVlbjogWzAsIDI1NSwgMTI3XSxcbiAgc3RlZWxibHVlOiBbNzAsIDEzMCwgMTgwXSxcbiAgdGFuOiBbMjEwLCAxODAsIDE0MF0sXG4gIHRlYWw6IFswLCAxMjgsIDEyOF0sXG4gIHRoaXN0bGU6IFsyMTYsIDE5MSwgMjE2XSxcbiAgdG9tYXRvOiBbMjU1LCA5OSwgNzFdLFxuICB0dXJxdW9pc2U6IFs2NCwgMjI0LCAyMDhdLFxuICB2aW9sZXQ6IFsyMzgsIDEzMCwgMjM4XSxcbiAgd2hlYXQ6IFsyNDUsIDIyMiwgMTc5XSxcbiAgd2hpdGU6IFsyNTUsIDI1NSwgMjU1XSxcbiAgd2hpdGVzbW9rZTogWzI0NSwgMjQ1LCAyNDVdLFxuICB5ZWxsb3c6IFsyNTUsIDI1NSwgMF0sXG4gIHllbGxvd2dyZWVuOiBbMTU0LCAyMDUsIDUwXVxufTtcblxudmFyIHNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcChvcHRpb25zKSB7XG4gIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgIGlmIChwbGFpbk9iamVjdChrZXkpKSB7XG4gICAgICB0aHJvdyBFcnJvcignVHJpZWQgdG8gc2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICB9XG5cbiAgICBpZiAoaSA8IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgLy8gZXh0ZW5kIHRoZSBtYXAgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgfVxuXG4gICAgICBvYmogPSBvYmpba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0IHRoZSB2YWx1ZVxuICAgICAgb2JqW2tleV0gPSBvcHRpb25zLnZhbHVlO1xuICAgIH1cbiAgfVxufTsgLy8gZ2V0cyB0aGUgdmFsdWUgaW4gYSBtYXAgZXZlbiBpZiBpdCdzIG5vdCBidWlsdCBpbiBwbGFjZXNcblxudmFyIGdldE1hcCA9IGZ1bmN0aW9uIGdldE1hcChvcHRpb25zKSB7XG4gIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgIGlmIChwbGFpbk9iamVjdChrZXkpKSB7XG4gICAgICB0aHJvdyBFcnJvcignVHJpZWQgdG8gZ2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICB9XG5cbiAgICBvYmogPSBvYmpba2V5XTtcblxuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTsgLy8gZGVsZXRlcyB0aGUgZW50cnkgaW4gdGhlIG1hcFxuXG52YXIgcGVyZm9ybWFuY2UgPSB3aW5kb3ckMSA/IHdpbmRvdyQxLnBlcmZvcm1hbmNlIDogbnVsbDtcbnZhciBwbm93ID0gcGVyZm9ybWFuY2UgJiYgcGVyZm9ybWFuY2Uubm93ID8gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG59IDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG5cbnZhciByYWYgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh3aW5kb3ckMSkge1xuICAgIGlmICh3aW5kb3ckMS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgd2luZG93JDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh3aW5kb3ckMS5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgd2luZG93JDEubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh3aW5kb3ckMS53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgd2luZG93JDEud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh3aW5kb3ckMS5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICB3aW5kb3ckMS5tc1JlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBmbihwbm93KCkpO1xuICAgICAgfSwgMTAwMCAvIDYwKTtcbiAgICB9XG4gIH07XG59KCk7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pIHtcbiAgcmV0dXJuIHJhZihmbik7XG59O1xudmFyIHBlcmZvcm1hbmNlTm93ID0gcG5vdztcblxudmFyIERFRkFVTFRfU0VFRCA9IDUzODE7XG52YXIgaGFzaEl0ZXJhYmxlSW50cyA9IGZ1bmN0aW9uIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IpIHtcbiAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfU0VFRDtcbiAgLy8gZGpiMi9zdHJpbmctaGFzaFxuICB2YXIgaGFzaCA9IHNlZWQ7XG4gIHZhciBlbnRyeTtcblxuICBmb3IgKDs7KSB7XG4gICAgZW50cnkgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICBpZiAoZW50cnkuZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaGFzaCA9IChoYXNoIDw8IDUpICsgaGFzaCArIGVudHJ5LnZhbHVlIHwgMDtcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufTtcbnZhciBoYXNoSW50ID0gZnVuY3Rpb24gaGFzaEludChudW0pIHtcbiAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfU0VFRDtcbiAgLy8gZGpiMi9zdHJpbmctaGFzaFxuICByZXR1cm4gKHNlZWQgPDwgNSkgKyBzZWVkICsgbnVtIHwgMDtcbn07XG52YXIgaGFzaEludHNBcnJheSA9IGZ1bmN0aW9uIGhhc2hJbnRzQXJyYXkoaW50cywgc2VlZCkge1xuICB2YXIgZW50cnkgPSB7XG4gICAgdmFsdWU6IDAsXG4gICAgZG9uZTogZmFsc2VcbiAgfTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuZ3RoID0gaW50cy5sZW5ndGg7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSBpbnRzW2krK107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyeS5kb25lID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IsIHNlZWQpO1xufTtcbnZhciBoYXNoU3RyaW5nID0gZnVuY3Rpb24gaGFzaFN0cmluZyhzdHIsIHNlZWQpIHtcbiAgdmFyIGVudHJ5ID0ge1xuICAgIHZhbHVlOiAwLFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cnkuZG9uZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYXNoSXRlcmFibGVJbnRzKGl0ZXJhdG9yLCBzZWVkKTtcbn07XG52YXIgaGFzaFN0cmluZ3MgPSBmdW5jdGlvbiBoYXNoU3RyaW5ncygpIHtcbiAgcmV0dXJuIGhhc2hTdHJpbmdzQXJyYXkoYXJndW1lbnRzKTtcbn07XG52YXIgaGFzaFN0cmluZ3NBcnJheSA9IGZ1bmN0aW9uIGhhc2hTdHJpbmdzQXJyYXkoc3Rycykge1xuICB2YXIgaGFzaDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3RyID0gc3Ryc1tpXTtcblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBoYXNoID0gaGFzaFN0cmluZyhzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNoID0gaGFzaFN0cmluZyhzdHIsIGhhc2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufTtcblxuLypnbG9iYWwgY29uc29sZSAqL1xudmFyIHdhcm5pbmdzRW5hYmxlZCA9IHRydWU7XG52YXIgd2FyblN1cHBvcnRlZCA9IGNvbnNvbGUud2FybiAhPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxudmFyIHRyYWNlU3VwcG9ydGVkID0gY29uc29sZS50cmFjZSAhPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxudmFyIE1BWF9JTlQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xudmFyIHRydWVpZnkgPSBmdW5jdGlvbiB0cnVlaWZ5KCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgZmFsc2lmeSA9IGZ1bmN0aW9uIGZhbHNpZnkoKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgemVyb2lmeSA9IGZ1bmN0aW9uIHplcm9pZnkoKSB7XG4gIHJldHVybiAwO1xufTtcbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xudmFyIGVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufTtcbnZhciB3YXJuaW5ncyA9IGZ1bmN0aW9uIHdhcm5pbmdzKGVuYWJsZWQpIHtcbiAgaWYgKGVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHdhcm5pbmdzRW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd2FybmluZ3NFbmFibGVkO1xuICB9XG59O1xudmFyIHdhcm4gPSBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICghd2FybmluZ3MoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh3YXJuU3VwcG9ydGVkKSB7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2cobXNnKTtcblxuICAgIGlmICh0cmFjZVN1cHBvcnRlZCkge1xuICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgIH1cbiAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIGNsb25lID0gZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gIHJldHVybiBleHRlbmQoe30sIG9iaik7XG59OyAvLyBnZXRzIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBhcmd1bWVudFxuXG52YXIgY29weSA9IGZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAoYXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGNsb25lKG9iaik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcbnZhciBjb3B5QXJyYXkgPSBmdW5jdGlvbiBjb3B5QXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnIuc2xpY2UoKTtcbn07XG52YXIgdXVpZCA9IGZ1bmN0aW9uIHV1aWQoYSwgYlxuLyogcGxhY2Vob2xkZXJzICovXG4pIHtcbiAgZm9yICggLy8gbG9vcCA6KVxuICBiID0gYSA9ICcnOyAvLyBiIC0gcmVzdWx0ICwgYSAtIG51bWVyaWMgbGV0aWFibGVcbiAgYSsrIDwgMzY7IC8vXG4gIGIgKz0gYSAqIDUxICYgNTIgLy8gaWYgXCJhXCIgaXMgbm90IDkgb3IgMTQgb3IgMTkgb3IgMjRcbiAgPyAvLyAgcmV0dXJuIGEgcmFuZG9tIG51bWJlciBvciA0XG4gIChhIF4gMTUgLy8gaWYgXCJhXCIgaXMgbm90IDE1XG4gID8gLy8gZ2VuZXRhdGUgYSByYW5kb20gbnVtYmVyIGZyb20gMCB0byAxNVxuICA4IF4gTWF0aC5yYW5kb20oKSAqIChhIF4gMjAgPyAxNiA6IDQpIC8vIHVubGVzcyBcImFcIiBpcyAyMCwgaW4gd2hpY2ggY2FzZSBhIHJhbmRvbSBudW1iZXIgZnJvbSA4IHRvIDExXG4gIDogNCAvLyAgb3RoZXJ3aXNlIDRcbiAgKS50b1N0cmluZygxNikgOiAnLScgLy8gIGluIG90aGVyIGNhc2VzIChpZiBcImFcIiBpcyA5LDE0LDE5LDI0KSBpbnNlcnQgXCItXCJcbiAgKSB7XG4gIH1cblxuICByZXR1cm4gYjtcbn07XG52YXIgX3N0YXRpY0VtcHR5T2JqZWN0ID0ge307XG52YXIgc3RhdGljRW1wdHlPYmplY3QgPSBmdW5jdGlvbiBzdGF0aWNFbXB0eU9iamVjdCgpIHtcbiAgcmV0dXJuIF9zdGF0aWNFbXB0eU9iamVjdDtcbn07XG52YXIgZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyhfZGVmYXVsdHMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfZGVmYXVsdHMpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICB2YXIgZmlsbGVkT3B0cyA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBvcHRWYWwgPSBvcHRzID09IG51bGwgPyB1bmRlZmluZWQgOiBvcHRzW2tleV07XG4gICAgICBmaWxsZWRPcHRzW2tleV0gPSBvcHRWYWwgPT09IHVuZGVmaW5lZCA/IF9kZWZhdWx0c1trZXldIDogb3B0VmFsO1xuICAgIH1cblxuICAgIHJldHVybiBmaWxsZWRPcHRzO1xuICB9O1xufTtcbnZhciByZW1vdmVGcm9tQXJyYXkgPSBmdW5jdGlvbiByZW1vdmVGcm9tQXJyYXkoYXJyLCBlbGUsIG1hbnlDb3BpZXMpIHtcbiAgZm9yICh2YXIgaSA9IGFyci5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGFycltpXSA9PT0gZWxlKSB7XG4gICAgICBhcnIuc3BsaWNlKGksIDEpO1xuXG4gICAgICBpZiAoIW1hbnlDb3BpZXMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGNsZWFyQXJyYXkgPSBmdW5jdGlvbiBjbGVhckFycmF5KGFycikge1xuICBhcnIuc3BsaWNlKDAsIGFyci5sZW5ndGgpO1xufTtcbnZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChhcnIsIG90aGVyQXJyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJBcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBvdGhlckFycltpXTtcbiAgICBhcnIucHVzaChlbCk7XG4gIH1cbn07XG52YXIgZ2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBwcm9wTmFtZSwgcHJlZml4KSB7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBwcm9wTmFtZSA9IHByZXBlbmRDYW1lbChwcmVmaXgsIHByb3BOYW1lKTsgLy8gZS5nLiAobGFiZWxXaWR0aCwgc291cmNlKSA9PiBzb3VyY2VMYWJlbFdpZHRoXG4gIH1cblxuICByZXR1cm4gb2JqW3Byb3BOYW1lXTtcbn07XG52YXIgc2V0UHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByZWZpeGVkUHJvcGVydHkob2JqLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSkge1xuICBpZiAocHJlZml4KSB7XG4gICAgcHJvcE5hbWUgPSBwcmVwZW5kQ2FtZWwocHJlZml4LCBwcm9wTmFtZSk7IC8vIGUuZy4gKGxhYmVsV2lkdGgsIHNvdXJjZSkgPT4gc291cmNlTGFiZWxXaWR0aFxuICB9XG5cbiAgb2JqW3Byb3BOYW1lXSA9IHZhbHVlO1xufTtcblxuLyogZ2xvYmFsIE1hcCAqL1xudmFyIE9iamVjdE1hcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9iamVjdE1hcCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0TWFwKTtcblxuICAgIHRoaXMuX29iaiA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE9iamVjdE1hcCwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xuICAgICAgdGhpcy5fb2JqW2tleV0gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgICB0aGlzLl9vYmpba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuX29iaiA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX29ialtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqW2tleV07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9iamVjdE1hcDtcbn0oKTtcblxudmFyIE1hcCQxID0gdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgPyBNYXAgOiBPYmplY3RNYXA7XG5cbi8qIGdsb2JhbCBTZXQgKi9cbnZhciB1bmRlZiA9ICBcInVuZGVmaW5lZFwiIDtcblxudmFyIE9iamVjdFNldCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9iamVjdFNldChhcnJheU9yT2JqZWN0U2V0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdFNldCk7XG5cbiAgICB0aGlzLl9vYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc2l6ZSA9IDA7XG5cbiAgICBpZiAoYXJyYXlPck9iamVjdFNldCAhPSBudWxsKSB7XG4gICAgICB2YXIgYXJyO1xuXG4gICAgICBpZiAoYXJyYXlPck9iamVjdFNldC5pbnN0YW5jZVN0cmluZyAhPSBudWxsICYmIGFycmF5T3JPYmplY3RTZXQuaW5zdGFuY2VTdHJpbmcoKSA9PT0gdGhpcy5pbnN0YW5jZVN0cmluZygpKSB7XG4gICAgICAgIGFyciA9IGFycmF5T3JPYmplY3RTZXQudG9BcnJheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyID0gYXJyYXlPck9iamVjdFNldDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGQoYXJyW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT2JqZWN0U2V0LCBbe1xuICAgIGtleTogXCJpbnN0YW5jZVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICAgIHJldHVybiAnc2V0JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh2YWwpIHtcbiAgICAgIHZhciBvID0gdGhpcy5fb2JqO1xuXG4gICAgICBpZiAob1t2YWxdICE9PSAxKSB7XG4gICAgICAgIG9bdmFsXSA9IDE7XG4gICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZSh2YWwpIHtcbiAgICAgIHZhciBvID0gdGhpcy5fb2JqO1xuXG4gICAgICBpZiAob1t2YWxdID09PSAxKSB7XG4gICAgICAgIG9bdmFsXSA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuX29iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXModmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqW3ZhbF0gPT09IDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9vYmopLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5oYXMoa2V5KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2JqZWN0U2V0O1xufSgpO1xuXG52YXIgU2V0JDEgPSAodHlwZW9mIFNldCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKFNldCkpICE9PSB1bmRlZiA/IFNldCA6IE9iamVjdFNldDtcblxudmFyIEVsZW1lbnQgPSBmdW5jdGlvbiBFbGVtZW50KGN5LCBwYXJhbXMsIHJlc3RvcmUpIHtcbiAgcmVzdG9yZSA9IHJlc3RvcmUgPT09IHVuZGVmaW5lZCB8fCByZXN0b3JlID8gdHJ1ZSA6IGZhbHNlO1xuXG4gIGlmIChjeSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8ICFjb3JlKGN5KSkge1xuICAgIGVycm9yKCdBbiBlbGVtZW50IG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlIGFuZCBwYXJhbWV0ZXJzIHNldCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBncm91cCA9IHBhcmFtcy5ncm91cDsgLy8gdHJ5IHRvIGF1dG9tYXRpY2FsbHkgaW5mZXIgdGhlIGdyb3VwIGlmIHVuc3BlY2lmaWVkXG5cbiAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICBpZiAocGFyYW1zLmRhdGEgJiYgcGFyYW1zLmRhdGEuc291cmNlICE9IG51bGwgJiYgcGFyYW1zLmRhdGEudGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgIGdyb3VwID0gJ2VkZ2VzJztcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAgPSAnbm9kZXMnO1xuICAgIH1cbiAgfSAvLyB2YWxpZGF0ZSBncm91cFxuXG5cbiAgaWYgKGdyb3VwICE9PSAnbm9kZXMnICYmIGdyb3VwICE9PSAnZWRnZXMnKSB7XG4gICAgZXJyb3IoJ0FuIGVsZW1lbnQgbXVzdCBiZSBvZiB0eXBlIGBub2Rlc2Agb3IgYGVkZ2VzYDsgeW91IHNwZWNpZmllZCBgJyArIGdyb3VwICsgJ2AnKTtcbiAgICByZXR1cm47XG4gIH0gLy8gbWFrZSB0aGUgZWxlbWVudCBhcnJheS1saWtlLCBqdXN0IGxpa2UgYSBjb2xsZWN0aW9uXG5cblxuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXNbMF0gPSB0aGlzOyAvLyBOT1RFOiB3aGVuIHNvbWV0aGluZyBpcyBhZGRlZCBoZXJlLCBhZGQgYWxzbyB0byBlbGUuanNvbigpXG5cbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgc2luZ2xlOiB0cnVlLFxuICAgIC8vIGluZGljYXRlcyB0aGlzIGlzIGFuIGVsZW1lbnRcbiAgICBkYXRhOiBwYXJhbXMuZGF0YSB8fCB7fSxcbiAgICAvLyBkYXRhIG9iamVjdFxuICAgIHBvc2l0aW9uOiBwYXJhbXMucG9zaXRpb24gfHwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9LFxuICAgIC8vICh4LCB5KSBwb3NpdGlvbiBwYWlyXG4gICAgYXV0b1dpZHRoOiB1bmRlZmluZWQsXG4gICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiBub2RlcyBjYWxjdWxhdGVkIGJ5IHRoZSByZW5kZXJlciB3aGVuIHNldCB0byBzcGVjaWFsICdhdXRvJyB2YWx1ZVxuICAgIGF1dG9IZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICBhdXRvUGFkZGluZzogdW5kZWZpbmVkLFxuICAgIGNvbXBvdW5kQm91bmRzQ2xlYW46IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGNvbXBvdW5kIGRpbWVuc2lvbnMgbmVlZCB0byBiZSByZWNhbGN1bGF0ZWQgdGhlIG5leHQgdGltZSBkaW1lbnNpb25zIGFyZSByZWFkXG4gICAgbGlzdGVuZXJzOiBbXSxcbiAgICAvLyBhcnJheSBvZiBib3VuZCBsaXN0ZW5lcnNcbiAgICBncm91cDogZ3JvdXAsXG4gICAgLy8gc3RyaW5nOyAnbm9kZXMnIG9yICdlZGdlcydcbiAgICBzdHlsZToge30sXG4gICAgLy8gcHJvcGVydGllcyBhcyBzZXQgYnkgdGhlIHN0eWxlXG4gICAgcnN0eWxlOiB7fSxcbiAgICAvLyBwcm9wZXJ0aWVzIGZvciBzdHlsZSBzZW50IGZyb20gdGhlIHJlbmRlcmVyIHRvIHRoZSBjb3JlXG4gICAgc3R5bGVDeHRzOiBbXSxcbiAgICAvLyBhcHBsaWVkIHN0eWxlIGNvbnRleHRzIGZyb20gdGhlIHN0eWxlclxuICAgIHN0eWxlS2V5czoge30sXG4gICAgLy8gcGVyLWdyb3VwIGtleXMgb2Ygc3R5bGUgcHJvcGVydHkgdmFsdWVzXG4gICAgcmVtb3ZlZDogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIGl0J3MgaW5zaWRlIHRoZSB2aXM7IHRydWUgaWYgcmVtb3ZlZCAoc2V0IHRydWUgaGVyZSBzaW5jZSB3ZSBjYWxsIHJlc3RvcmUpXG4gICAgc2VsZWN0ZWQ6IHBhcmFtcy5zZWxlY3RlZCA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0ZWRcbiAgICBzZWxlY3RhYmxlOiBwYXJhbXMuc2VsZWN0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy5zZWxlY3RhYmxlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgaXQncyBzZWxlY3RhYmxlXG4gICAgbG9ja2VkOiBwYXJhbXMubG9ja2VkID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgbG9ja2VkIChjYW5ub3QgYmUgbW92ZWQpXG4gICAgZ3JhYmJlZDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBncmFiYmVkIGJ5IHRoZSBtb3VzZTsgcmVuZGVyZXIgc2V0cyB0aGlzIHByaXZhdGVseVxuICAgIGdyYWJiYWJsZTogcGFyYW1zLmdyYWJiYWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy5ncmFiYmFibGUgPyB0cnVlIDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBjYW4gYmUgZ3JhYmJlZFxuICAgIHBhbm5hYmxlOiBwYXJhbXMucGFubmFibGUgPT09IHVuZGVmaW5lZCA/IGdyb3VwID09PSAnZWRnZXMnID8gdHJ1ZSA6IGZhbHNlIDogcGFyYW1zLnBhbm5hYmxlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHBhc3N0aHJvdWdoIHBhbm5pbmcgZW5hYmxlZFxuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBhY3RpdmUgZnJvbSB1c2VyIGludGVyYWN0aW9uXG4gICAgY2xhc3NlczogbmV3IFNldCQxKCksXG4gICAgLy8gbWFwICggY2xhc3NOYW1lID0+IHRydWUgKVxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICBjdXJyZW50OiBbXSxcbiAgICAgIHF1ZXVlOiBbXVxuICAgIH0sXG4gICAgcnNjcmF0Y2g6IHt9LFxuICAgIC8vIG9iamVjdCBpbiB3aGljaCB0aGUgcmVuZGVyZXIgY2FuIHN0b3JlIGluZm9ybWF0aW9uXG4gICAgc2NyYXRjaDogcGFyYW1zLnNjcmF0Y2ggfHwge30sXG4gICAgLy8gc2NyYXRjaCBvYmplY3RzXG4gICAgZWRnZXM6IFtdLFxuICAgIC8vIGFycmF5IG9mIGNvbm5lY3RlZCBlZGdlc1xuICAgIGNoaWxkcmVuOiBbXSxcbiAgICAvLyBhcnJheSBvZiBjaGlsZHJlblxuICAgIHBhcmVudDogbnVsbCxcbiAgICAvLyBwYXJlbnQgcmVmXG4gICAgdHJhdmVyc2FsQ2FjaGU6IHt9LFxuICAgIC8vIGNhY2hlIG9mIG91dHB1dCBvZiB0cmF2ZXJzYWwgZnVuY3Rpb25zXG4gICAgYmFja2dyb3VuZGluZzogZmFsc2UsXG4gICAgLy8gd2hldGhlciBiYWNrZ3JvdW5kIGltYWdlcyBhcmUgbG9hZGluZ1xuICAgIGJiQ2FjaGU6IG51bGwsXG4gICAgLy8gY2FjaGUgb2YgdGhlIGN1cnJlbnQgYm91bmRpbmcgYm94XG4gICAgYmJDYWNoZVNoaWZ0OiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sXG4gICAgLy8gc2hpZnQgYXBwbGllZCB0byBjYWNoZWQgYmIgdG8gYmUgYXBwbGllZCBvbiBuZXh0IGdldFxuICAgIGJvZHlCb3VuZHM6IG51bGwsXG4gICAgLy8gYm91bmRzIGNhY2hlIG9mIGVsZW1lbnQgYm9keSwgdy9vIG92ZXJsYXlcbiAgICBvdmVybGF5Qm91bmRzOiBudWxsLFxuICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBlbGVtZW50IGJvZHksIGluY2x1ZGluZyBvdmVybGF5XG4gICAgbGFiZWxCb3VuZHM6IHtcbiAgICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBsYWJlbHNcbiAgICAgIGFsbDogbnVsbCxcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgIG1haW46IG51bGxcbiAgICB9LFxuICAgIGFycm93Qm91bmRzOiB7XG4gICAgICAvLyBib3VuZHMgY2FjaGUgb2YgZWRnZSBhcnJvd3NcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICdtaWQtc291cmNlJzogbnVsbCxcbiAgICAgICdtaWQtdGFyZ2V0JzogbnVsbFxuICAgIH1cbiAgfTtcblxuICBpZiAoX3AucG9zaXRpb24ueCA9PSBudWxsKSB7XG4gICAgX3AucG9zaXRpb24ueCA9IDA7XG4gIH1cblxuICBpZiAoX3AucG9zaXRpb24ueSA9PSBudWxsKSB7XG4gICAgX3AucG9zaXRpb24ueSA9IDA7XG4gIH0gLy8gcmVuZGVyZWRQb3NpdGlvbiBvdmVycmlkZXMgaWYgc3BlY2lmaWVkXG5cblxuICBpZiAocGFyYW1zLnJlbmRlcmVkUG9zaXRpb24pIHtcbiAgICB2YXIgcnBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICBfcC5wb3NpdGlvbiA9IHtcbiAgICAgIHg6IChycG9zLnggLSBwYW4ueCkgLyB6b29tLFxuICAgICAgeTogKHJwb3MueSAtIHBhbi55KSAvIHpvb21cbiAgICB9O1xuICB9XG5cbiAgdmFyIGNsYXNzZXMgPSBbXTtcblxuICBpZiAoYXJyYXkocGFyYW1zLmNsYXNzZXMpKSB7XG4gICAgY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzO1xuICB9IGVsc2UgaWYgKHN0cmluZyhwYXJhbXMuY2xhc3NlcykpIHtcbiAgICBjbGFzc2VzID0gcGFyYW1zLmNsYXNzZXMuc3BsaXQoL1xccysvKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcblxuICAgIGlmICghY2xzIHx8IGNscyA9PT0gJycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIF9wLmNsYXNzZXMuYWRkKGNscyk7XG4gIH1cblxuICB0aGlzLmNyZWF0ZUVtaXR0ZXIoKTtcbiAgdmFyIGJ5cGFzcyA9IHBhcmFtcy5zdHlsZSB8fCBwYXJhbXMuY3NzO1xuXG4gIGlmIChieXBhc3MpIHtcbiAgICB3YXJuKCdTZXR0aW5nIGEgYHN0eWxlYCBieXBhc3MgYXQgZWxlbWVudCBjcmVhdGlvbiBpcyBkZXByZWNhdGVkJyk7XG4gICAgdGhpcy5zdHlsZShieXBhc3MpO1xuICB9XG5cbiAgaWYgKHJlc3RvcmUgPT09IHVuZGVmaW5lZCB8fCByZXN0b3JlKSB7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbn07XG5cbnZhciBkZWZpbmVTZWFyY2ggPSBmdW5jdGlvbiBkZWZpbmVTZWFyY2gocGFyYW1zKSB7XG4gIHBhcmFtcyA9IHtcbiAgICBiZnM6IHBhcmFtcy5iZnMgfHwgIXBhcmFtcy5kZnMsXG4gICAgZGZzOiBwYXJhbXMuZGZzIHx8ICFwYXJhbXMuYmZzXG4gIH07IC8vIGZyb20gcHNldWRvY29kZSBvbiB3aWtpcGVkaWFcblxuICByZXR1cm4gZnVuY3Rpb24gc2VhcmNoRm4ocm9vdHMsIGZuJDEsIGRpcmVjdGVkKSB7XG4gICAgdmFyIG9wdGlvbnM7XG5cbiAgICBpZiAocGxhaW5PYmplY3Qocm9vdHMpICYmICFlbGVtZW50T3JDb2xsZWN0aW9uKHJvb3RzKSkge1xuICAgICAgb3B0aW9ucyA9IHJvb3RzO1xuICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzIHx8IG9wdGlvbnMucm9vdDtcbiAgICAgIGZuJDEgPSBvcHRpb25zLnZpc2l0O1xuICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH1cblxuICAgIGRpcmVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhZm4oZm4kMSkgPyBmbiQxIDogZGlyZWN0ZWQ7XG4gICAgZm4kMSA9IGZuKGZuJDEpID8gZm4kMSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHYgPSByb290cyA9IHN0cmluZyhyb290cykgPyB0aGlzLmZpbHRlcihyb290cykgOiByb290cztcbiAgICB2YXIgUSA9IFtdO1xuICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IFtdO1xuICAgIHZhciBjb25uZWN0ZWRCeSA9IHt9O1xuICAgIHZhciBpZDJkZXB0aCA9IHt9O1xuICAgIHZhciBWID0ge307XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBmb3VuZDtcblxuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzOyAvLyBlbnF1ZXVlIHZcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmkgPSB2W2ldO1xuICAgICAgdmFyIHZpSWQgPSB2aS5pZCgpO1xuXG4gICAgICBpZiAodmkuaXNOb2RlKCkpIHtcbiAgICAgICAgUS51bnNoaWZ0KHZpKTtcblxuICAgICAgICBpZiAocGFyYW1zLmJmcykge1xuICAgICAgICAgIFZbdmlJZF0gPSB0cnVlO1xuICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2godmkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWQyZGVwdGhbdmlJZF0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICB2YXIgdiA9IHBhcmFtcy5iZnMgPyBRLnNoaWZ0KCkgOiBRLnBvcCgpO1xuICAgICAgdmFyIHZJZCA9IHYuaWQoKTtcblxuICAgICAgaWYgKHBhcmFtcy5kZnMpIHtcbiAgICAgICAgaWYgKFZbdklkXSkge1xuICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cblxuICAgICAgICBWW3ZJZF0gPSB0cnVlO1xuICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHYpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFt2SWRdO1xuICAgICAgdmFyIHByZXZFZGdlID0gY29ubmVjdGVkQnlbdklkXTtcbiAgICAgIHZhciBzcmMgPSBwcmV2RWRnZSAhPSBudWxsID8gcHJldkVkZ2Uuc291cmNlKCkgOiBudWxsO1xuICAgICAgdmFyIHRndCA9IHByZXZFZGdlICE9IG51bGwgPyBwcmV2RWRnZS50YXJnZXQoKSA6IG51bGw7XG4gICAgICB2YXIgcHJldk5vZGUgPSBwcmV2RWRnZSA9PSBudWxsID8gdW5kZWZpbmVkIDogdi5zYW1lKHNyYykgPyB0Z3RbMF0gOiBzcmNbMF07XG4gICAgICB2YXIgcmV0ID0gdm9pZCAwO1xuICAgICAgcmV0ID0gZm4kMSh2LCBwcmV2RWRnZSwgcHJldk5vZGUsIGorKywgZGVwdGgpO1xuXG4gICAgICBpZiAocmV0ID09PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kID0gdjtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZ3RWRnZXMgPSB2LmNvbm5lY3RlZEVkZ2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiAoIWRpcmVjdGVkIHx8IGUuc291cmNlKCkuc2FtZSh2KSkgJiYgZWRnZXMuaGFzKGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHZ3RWRnZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbX2kyXTtcbiAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgcmV0dXJuICFuLnNhbWUodikgJiYgbm9kZXMuaGFzKG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHdJZCA9IHcuaWQoKTtcblxuICAgICAgICBpZiAody5sZW5ndGggIT09IDAgJiYgIVZbd0lkXSkge1xuICAgICAgICAgIHcgPSB3WzBdO1xuICAgICAgICAgIFEucHVzaCh3KTtcblxuICAgICAgICAgIGlmIChwYXJhbXMuYmZzKSB7XG4gICAgICAgICAgICBWW3dJZF0gPSB0cnVlO1xuICAgICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCh3KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25uZWN0ZWRCeVt3SWRdID0gZTtcbiAgICAgICAgICBpZDJkZXB0aFt3SWRdID0gaWQyZGVwdGhbdklkXSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX2xvb3A6IHdoaWxlIChRLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcDIoKTtcblxuICAgICAgc3dpdGNoIChfcmV0KSB7XG4gICAgICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGNhc2UgXCJicmVha1wiOlxuICAgICAgICAgIGJyZWFrIF9sb29wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb25uZWN0ZWRFbGVzID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGNvbm5lY3RlZE5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG5vZGUgPSBjb25uZWN0ZWROb2Rlc1tfaV07XG4gICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEJ5W25vZGUuaWQoKV07XG5cbiAgICAgIGlmIChlZGdlICE9IG51bGwpIHtcbiAgICAgICAgY29ubmVjdGVkRWxlcy5tZXJnZShlZGdlKTtcbiAgICAgIH1cblxuICAgICAgY29ubmVjdGVkRWxlcy5tZXJnZShub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogY3kuY29sbGVjdGlvbihjb25uZWN0ZWRFbGVzKSxcbiAgICAgIGZvdW5kOiBjeS5jb2xsZWN0aW9uKGZvdW5kKVxuICAgIH07XG4gIH07XG59OyAvLyBzZWFyY2gsIHNwYW5uaW5nIHRyZWVzLCBldGNcblxuXG52YXIgZWxlc2ZuID0ge1xuICBicmVhZHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCh7XG4gICAgYmZzOiB0cnVlXG4gIH0pLFxuICBkZXB0aEZpcnN0U2VhcmNoOiBkZWZpbmVTZWFyY2goe1xuICAgIGRmczogdHJ1ZVxuICB9KVxufTsgLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRoaWNhbCBhbGlhc1xuXG5lbGVzZm4uYmZzID0gZWxlc2ZuLmJyZWFkdGhGaXJzdFNlYXJjaDtcbmVsZXNmbi5kZnMgPSBlbGVzZm4uZGVwdGhGaXJzdFNlYXJjaDtcblxudmFyIGRpamtzdHJhRGVmYXVsdHMgPSBkZWZhdWx0cyh7XG4gIHJvb3Q6IG51bGwsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgZGlyZWN0ZWQ6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kMSA9IHtcbiAgZGlqa3N0cmE6IGZ1bmN0aW9uIGRpamtzdHJhKG9wdGlvbnMpIHtcbiAgICBpZiAoIXBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHJvb3Q6IGFyZ3NbMF0sXG4gICAgICAgIHdlaWdodDogYXJnc1sxXSxcbiAgICAgICAgZGlyZWN0ZWQ6IGFyZ3NbMl1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIF9kaWprc3RyYURlZmF1bHRzID0gZGlqa3N0cmFEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgcm9vdCA9IF9kaWprc3RyYURlZmF1bHRzLnJvb3QsXG4gICAgICAgIHdlaWdodCA9IF9kaWprc3RyYURlZmF1bHRzLndlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQgPSBfZGlqa3N0cmFEZWZhdWx0cy5kaXJlY3RlZDtcblxuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgd2VpZ2h0Rm4gPSB3ZWlnaHQ7XG4gICAgdmFyIHNvdXJjZSA9IHN0cmluZyhyb290KSA/IHRoaXMuZmlsdGVyKHJvb3QpWzBdIDogcm9vdFswXTtcbiAgICB2YXIgZGlzdCA9IHt9O1xuICAgIHZhciBwcmV2ID0ge307XG4gICAgdmFyIGtub3duRGlzdCA9IHt9O1xuXG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG5cbiAgICBlZGdlcy51bm1lcmdlQnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0xvb3AoKTtcbiAgICB9KTtcblxuICAgIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdChub2RlKSB7XG4gICAgICByZXR1cm4gZGlzdFtub2RlLmlkKCldO1xuICAgIH07XG5cbiAgICB2YXIgc2V0RGlzdCA9IGZ1bmN0aW9uIHNldERpc3Qobm9kZSwgZCkge1xuICAgICAgZGlzdFtub2RlLmlkKCldID0gZDtcbiAgICAgIFEudXBkYXRlSXRlbShub2RlKTtcbiAgICB9O1xuXG4gICAgdmFyIFEgPSBuZXcgSGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGdldERpc3QoYSkgLSBnZXREaXN0KGIpO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGRpc3Rbbm9kZS5pZCgpXSA9IG5vZGUuc2FtZShzb3VyY2UpID8gMCA6IEluZmluaXR5O1xuICAgICAgUS5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIHZhciBkaXN0QmV0d2VlbiA9IGZ1bmN0aW9uIGRpc3RCZXR3ZWVuKHUsIHYpIHtcbiAgICAgIHZhciB1dnMgPSAoZGlyZWN0ZWQgPyB1LmVkZ2VzVG8odikgOiB1LmVkZ2VzV2l0aCh2KSkuaW50ZXJzZWN0KGVkZ2VzKTtcbiAgICAgIHZhciBzbWFsbGVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICB2YXIgc21hbGxlc3RFZGdlO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdXZzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZWRnZSA9IHV2c1tfaV07XG5cbiAgICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcblxuICAgICAgICBpZiAoX3dlaWdodCA8IHNtYWxsZXN0RGlzdGFuY2UgfHwgIXNtYWxsZXN0RWRnZSkge1xuICAgICAgICAgIHNtYWxsZXN0RGlzdGFuY2UgPSBfd2VpZ2h0O1xuICAgICAgICAgIHNtYWxsZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWRnZTogc21hbGxlc3RFZGdlLFxuICAgICAgICBkaXN0OiBzbWFsbGVzdERpc3RhbmNlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB3aGlsZSAoUS5zaXplKCkgPiAwKSB7XG4gICAgICB2YXIgdSA9IFEucG9wKCk7XG4gICAgICB2YXIgc21hbGxldHNEaXN0ID0gZ2V0RGlzdCh1KTtcbiAgICAgIHZhciB1aWQgPSB1LmlkKCk7XG4gICAgICBrbm93bkRpc3RbdWlkXSA9IHNtYWxsZXRzRGlzdDtcblxuICAgICAgaWYgKHNtYWxsZXRzRGlzdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvcnMgPSB1Lm5laWdoYm9yaG9vZCgpLmludGVyc2VjdChub2Rlcyk7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5laWdoYm9ycy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciB2ID0gbmVpZ2hib3JzW19pMl07XG4gICAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG4gICAgICAgIHZhciB2RGlzdCA9IGRpc3RCZXR3ZWVuKHUsIHYpO1xuICAgICAgICB2YXIgYWx0ID0gc21hbGxldHNEaXN0ICsgdkRpc3QuZGlzdDtcblxuICAgICAgICBpZiAoYWx0IDwgZ2V0RGlzdCh2KSkge1xuICAgICAgICAgIHNldERpc3QodiwgYWx0KTtcbiAgICAgICAgICBwcmV2W3ZpZF0gPSB7XG4gICAgICAgICAgICBub2RlOiB1LFxuICAgICAgICAgICAgZWRnZTogdkRpc3QuZWRnZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yXG5cbiAgICB9IC8vIHdoaWxlXG5cblxuICAgIHJldHVybiB7XG4gICAgICBkaXN0YW5jZVRvOiBmdW5jdGlvbiBkaXN0YW5jZVRvKG5vZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgIHJldHVybiBrbm93bkRpc3RbdGFyZ2V0LmlkKCldO1xuICAgICAgfSxcbiAgICAgIHBhdGhUbzogZnVuY3Rpb24gcGF0aFRvKG5vZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgIHZhciBTID0gW107XG4gICAgICAgIHZhciB1ID0gdGFyZ2V0O1xuICAgICAgICB2YXIgdWlkID0gdS5pZCgpO1xuXG4gICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIFMudW5zaGlmdCh0YXJnZXQpO1xuXG4gICAgICAgICAgd2hpbGUgKHByZXZbdWlkXSkge1xuICAgICAgICAgICAgdmFyIHAgPSBwcmV2W3VpZF07XG4gICAgICAgICAgICBTLnVuc2hpZnQocC5lZGdlKTtcbiAgICAgICAgICAgIFMudW5zaGlmdChwLm5vZGUpO1xuICAgICAgICAgICAgdSA9IHAubm9kZTtcbiAgICAgICAgICAgIHVpZCA9IHUuaWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlcy5zcGF3bihTKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG52YXIgZWxlc2ZuJDIgPSB7XG4gIC8vIGtydXNrYWwncyBhbGdvcml0aG0gKGZpbmRzIG1pbiBzcGFubmluZyB0cmVlLCBhc3N1bWluZyB1bmRpcmVjdGVkIGdyYXBoKVxuICAvLyBpbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAga3J1c2thbDogZnVuY3Rpb24ga3J1c2thbCh3ZWlnaHRGbikge1xuICAgIHdlaWdodEZuID0gd2VpZ2h0Rm4gfHwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH07XG5cbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgZm9yZXN0ID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgQSA9IG5vZGVzOyAvLyBhc3N1bWVzIGJ5R3JvdXAoKSBjcmVhdGVzIG5ldyBjb2xsZWN0aW9ucyB0aGF0IGNhbiBiZSBzYWZlbHkgbXV0YXRlZFxuXG4gICAgdmFyIGZpbmRTZXRJbmRleCA9IGZ1bmN0aW9uIGZpbmRTZXRJbmRleChlbGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVzID0gZm9yZXN0W2ldO1xuXG4gICAgICAgIGlmIChlbGVzLmhhcyhlbGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvLyBzdGFydCB3aXRoIG9uZSBmb3Jlc3QgcGVyIG5vZGVcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBmb3Jlc3RbaV0gPSB0aGlzLnNwYXduKG5vZGVzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgUyA9IGVkZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiB3ZWlnaHRGbihhKSAtIHdlaWdodEZuKGIpO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IFNbX2ldO1xuICAgICAgdmFyIHUgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgdmFyIHYgPSBlZGdlLnRhcmdldCgpWzBdO1xuICAgICAgdmFyIHNldFVJbmRleCA9IGZpbmRTZXRJbmRleCh1KTtcbiAgICAgIHZhciBzZXRWSW5kZXggPSBmaW5kU2V0SW5kZXgodik7XG4gICAgICB2YXIgc2V0VSA9IGZvcmVzdFtzZXRVSW5kZXhdO1xuICAgICAgdmFyIHNldFYgPSBmb3Jlc3Rbc2V0VkluZGV4XTtcblxuICAgICAgaWYgKHNldFVJbmRleCAhPT0gc2V0VkluZGV4KSB7XG4gICAgICAgIEEubWVyZ2UoZWRnZSk7IC8vIGNvbWJpbmUgZm9yZXN0cyBmb3IgdSBhbmQgdlxuXG4gICAgICAgIHNldFUubWVyZ2Uoc2V0Vik7XG4gICAgICAgIGZvcmVzdC5zcGxpY2Uoc2V0VkluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQTtcbiAgfVxufTtcblxudmFyIGFTdGFyRGVmYXVsdHMgPSBkZWZhdWx0cyh7XG4gIHJvb3Q6IG51bGwsXG4gIGdvYWw6IG51bGwsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgaGV1cmlzdGljOiBmdW5jdGlvbiBoZXVyaXN0aWMoZWRnZSkge1xuICAgIHJldHVybiAwO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiQzID0ge1xuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgYVN0YXI6IGZ1bmN0aW9uIGFTdGFyKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICB2YXIgX2FTdGFyRGVmYXVsdHMgPSBhU3RhckRlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICByb290ID0gX2FTdGFyRGVmYXVsdHMucm9vdCxcbiAgICAgICAgZ29hbCA9IF9hU3RhckRlZmF1bHRzLmdvYWwsXG4gICAgICAgIGhldXJpc3RpYyA9IF9hU3RhckRlZmF1bHRzLmhldXJpc3RpYyxcbiAgICAgICAgZGlyZWN0ZWQgPSBfYVN0YXJEZWZhdWx0cy5kaXJlY3RlZCxcbiAgICAgICAgd2VpZ2h0ID0gX2FTdGFyRGVmYXVsdHMud2VpZ2h0O1xuXG4gICAgcm9vdCA9IGN5LmNvbGxlY3Rpb24ocm9vdClbMF07XG4gICAgZ29hbCA9IGN5LmNvbGxlY3Rpb24oZ29hbClbMF07XG4gICAgdmFyIHNpZCA9IHJvb3QuaWQoKTtcbiAgICB2YXIgdGlkID0gZ29hbC5pZCgpO1xuICAgIHZhciBnU2NvcmUgPSB7fTtcbiAgICB2YXIgZlNjb3JlID0ge307XG4gICAgdmFyIGNsb3NlZFNldElkcyA9IHt9O1xuICAgIHZhciBvcGVuU2V0ID0gbmV3IEhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmU2NvcmVbYS5pZCgpXSAtIGZTY29yZVtiLmlkKCldO1xuICAgIH0pO1xuICAgIHZhciBvcGVuU2V0SWRzID0gbmV3IFNldCQxKCk7XG4gICAgdmFyIGNhbWVGcm9tID0ge307XG4gICAgdmFyIGNhbWVGcm9tRWRnZSA9IHt9O1xuXG4gICAgdmFyIGFkZFRvT3BlblNldCA9IGZ1bmN0aW9uIGFkZFRvT3BlblNldChlbGUsIGlkKSB7XG4gICAgICBvcGVuU2V0LnB1c2goZWxlKTtcbiAgICAgIG9wZW5TZXRJZHMuYWRkKGlkKTtcbiAgICB9O1xuXG4gICAgdmFyIGNNaW4sIGNNaW5JZDtcblxuICAgIHZhciBwb3BGcm9tT3BlblNldCA9IGZ1bmN0aW9uIHBvcEZyb21PcGVuU2V0KCkge1xuICAgICAgY01pbiA9IG9wZW5TZXQucG9wKCk7XG4gICAgICBjTWluSWQgPSBjTWluLmlkKCk7XG4gICAgICBvcGVuU2V0SWRzW1wiZGVsZXRlXCJdKGNNaW5JZCk7XG4gICAgfTtcblxuICAgIHZhciBpc0luT3BlblNldCA9IGZ1bmN0aW9uIGlzSW5PcGVuU2V0KGlkKSB7XG4gICAgICByZXR1cm4gb3BlblNldElkcy5oYXMoaWQpO1xuICAgIH07XG5cbiAgICBhZGRUb09wZW5TZXQocm9vdCwgc2lkKTtcbiAgICBnU2NvcmVbc2lkXSA9IDA7XG4gICAgZlNjb3JlW3NpZF0gPSBoZXVyaXN0aWMocm9vdCk7IC8vIENvdW50ZXJcblxuICAgIHZhciBzdGVwcyA9IDA7IC8vIE1haW4gbG9vcFxuXG4gICAgd2hpbGUgKG9wZW5TZXQuc2l6ZSgpID4gMCkge1xuICAgICAgcG9wRnJvbU9wZW5TZXQoKTtcbiAgICAgIHN0ZXBzKys7IC8vIElmIHdlJ3ZlIGZvdW5kIG91ciBnb2FsLCB0aGVuIHdlIGFyZSBkb25lXG5cbiAgICAgIGlmIChjTWluSWQgPT09IHRpZCkge1xuICAgICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgICB2YXIgcGF0aE5vZGUgPSBnb2FsO1xuICAgICAgICB2YXIgcGF0aE5vZGVJZCA9IHRpZDtcbiAgICAgICAgdmFyIHBhdGhFZGdlID0gY2FtZUZyb21FZGdlW3BhdGhOb2RlSWRdO1xuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQocGF0aE5vZGUpO1xuXG4gICAgICAgICAgaWYgKHBhdGhFZGdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChwYXRoRWRnZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aE5vZGUgPSBjYW1lRnJvbVtwYXRoTm9kZUlkXTtcblxuICAgICAgICAgIGlmIChwYXRoTm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoTm9kZUlkID0gcGF0aE5vZGUuaWQoKTtcbiAgICAgICAgICBwYXRoRWRnZSA9IGNhbWVGcm9tRWRnZVtwYXRoTm9kZUlkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm91bmQ6IHRydWUsXG4gICAgICAgICAgZGlzdGFuY2U6IGdTY29yZVtjTWluSWRdLFxuICAgICAgICAgIHBhdGg6IHRoaXMuc3Bhd24ocGF0aCksXG4gICAgICAgICAgc3RlcHM6IHN0ZXBzXG4gICAgICAgIH07XG4gICAgICB9IC8vIEFkZCBjTWluIHRvIHByb2Nlc3NlZCBub2Rlc1xuXG5cbiAgICAgIGNsb3NlZFNldElkc1tjTWluSWRdID0gdHJ1ZTsgLy8gVXBkYXRlIHNjb3JlcyBmb3IgbmVpZ2hib3JzIG9mIGNNaW5cbiAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IGlmIGdyYXBoIGlzIGRpcmVjdGVkIG9yIG5vdFxuXG4gICAgICB2YXIgdndFZGdlcyA9IGNNaW4uX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbaV07IC8vIGVkZ2UgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG5cbiAgICAgICAgaWYgKCF0aGlzLmhhc0VsZW1lbnRXaXRoSWQoZS5pZCgpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGNNaW4gbXVzdCBiZSB0aGUgc291cmNlIG9mIGVkZ2UgaWYgZGlyZWN0ZWRcblxuXG4gICAgICAgIGlmIChkaXJlY3RlZCAmJiBlLmRhdGEoJ3NvdXJjZScpICE9PSBjTWluSWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3U3JjID0gZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHdUZ3QgPSBlLnRhcmdldCgpO1xuICAgICAgICB2YXIgdyA9IHdTcmMuaWQoKSAhPT0gY01pbklkID8gd1NyYyA6IHdUZ3Q7XG4gICAgICAgIHZhciB3aWQgPSB3LmlkKCk7IC8vIG5vZGUgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG5cbiAgICAgICAgaWYgKCF0aGlzLmhhc0VsZW1lbnRXaXRoSWQod2lkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGlmIG5vZGUgaXMgaW4gY2xvc2VkU2V0LCBpZ25vcmUgaXRcblxuXG4gICAgICAgIGlmIChjbG9zZWRTZXRJZHNbd2lkXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIE5ldyB0ZW50YXRpdmUgc2NvcmUgZm9yIG5vZGUgd1xuXG5cbiAgICAgICAgdmFyIHRlbXBTY29yZSA9IGdTY29yZVtjTWluSWRdICsgd2VpZ2h0KGUpOyAvLyBVcGRhdGUgZ1Njb3JlIGZvciBub2RlIHcgaWY6XG4gICAgICAgIC8vICAgdyBub3QgcHJlc2VudCBpbiBvcGVuU2V0XG4gICAgICAgIC8vIE9SXG4gICAgICAgIC8vICAgdGVudGF0aXZlIGdTY29yZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMgdmFsdWVcbiAgICAgICAgLy8gdyBub3QgaW4gb3BlblNldFxuXG4gICAgICAgIGlmICghaXNJbk9wZW5TZXQod2lkKSkge1xuICAgICAgICAgIGdTY29yZVt3aWRdID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVt3aWRdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgIGFkZFRvT3BlblNldCh3LCB3aWQpO1xuICAgICAgICAgIGNhbWVGcm9tW3dpZF0gPSBjTWluO1xuICAgICAgICAgIGNhbWVGcm9tRWRnZVt3aWRdID0gZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB3IGFscmVhZHkgaW4gb3BlblNldCwgYnV0IHdpdGggZ3JlYXRlciBnU2NvcmVcblxuXG4gICAgICAgIGlmICh0ZW1wU2NvcmUgPCBnU2NvcmVbd2lkXSkge1xuICAgICAgICAgIGdTY29yZVt3aWRdID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVt3aWRdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgIGNhbWVGcm9tW3dpZF0gPSBjTWluO1xuICAgICAgICB9XG4gICAgICB9IC8vIEVuZCBvZiBuZWlnaGJvcnMgdXBkYXRlXG5cbiAgICB9IC8vIEVuZCBvZiBtYWluIGxvb3BcbiAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIGhlcmUsIHRoZW4gd2UndmUgbm90IHJlYWNoZWQgb3VyIGdvYWxcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgIGRpc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgICBzdGVwczogc3RlcHNcbiAgICB9O1xuICB9XG59OyAvLyBlbGVzZm5cblxudmFyIGZsb3lkV2Fyc2hhbGxEZWZhdWx0cyA9IGRlZmF1bHRzKHtcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiQ0ID0ge1xuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgZmxveWRXYXJzaGFsbDogZnVuY3Rpb24gZmxveWRXYXJzaGFsbChvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgdmFyIF9mbG95ZFdhcnNoYWxsRGVmYXVsdCA9IGZsb3lkV2Fyc2hhbGxEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgd2VpZ2h0ID0gX2Zsb3lkV2Fyc2hhbGxEZWZhdWx0LndlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQgPSBfZmxveWRXYXJzaGFsbERlZmF1bHQuZGlyZWN0ZWQ7XG5cbiAgICB2YXIgd2VpZ2h0Rm4gPSB3ZWlnaHQ7XG5cbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgIHZhciBOID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBOc3EgPSBOICogTjtcblxuICAgIHZhciBpbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICB9O1xuXG4gICAgdmFyIGF0SW5kZXggPSBmdW5jdGlvbiBhdEluZGV4KGkpIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9OyAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuXG5cbiAgICB2YXIgZGlzdCA9IG5ldyBBcnJheShOc3EpO1xuXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBOc3E7IG4rKykge1xuICAgICAgdmFyIGogPSBuICUgTjtcbiAgICAgIHZhciBpID0gKG4gLSBqKSAvIE47XG5cbiAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgIGRpc3Rbbl0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzdFtuXSA9IEluZmluaXR5O1xuICAgICAgfVxuICAgIH0gLy8gSW5pdGlhbGl6ZSBtYXRyaXggdXNlZCBmb3IgcGF0aCByZWNvbnN0cnVjdGlvblxuICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG5cblxuICAgIHZhciBuZXh0ID0gbmV3IEFycmF5KE5zcSk7XG4gICAgdmFyIGVkZ2VOZXh0ID0gbmV3IEFycmF5KE5zcSk7IC8vIFByb2Nlc3MgZWRnZXNcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlZGdlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbX2ldO1xuICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKVswXTtcblxuICAgICAgaWYgKHNyYyA9PT0gdGd0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBleGNsdWRlIGxvb3BzXG5cblxuICAgICAgdmFyIHMgPSBpbmRleE9mKHNyYyk7XG4gICAgICB2YXIgdCA9IGluZGV4T2YodGd0KTtcbiAgICAgIHZhciBzdCA9IHMgKiBOICsgdDsgLy8gc291cmNlIHRvIHRhcmdldCBpbmRleFxuXG4gICAgICB2YXIgX3dlaWdodCA9IHdlaWdodEZuKGVkZ2UpOyAvLyBDaGVjayBpZiBhbHJlYWR5IHByb2Nlc3MgYW5vdGhlciBlZGdlIGJldHdlZW4gc2FtZSAyIG5vZGVzXG5cblxuICAgICAgaWYgKGRpc3Rbc3RdID4gX3dlaWdodCkge1xuICAgICAgICBkaXN0W3N0XSA9IF93ZWlnaHQ7XG4gICAgICAgIG5leHRbc3RdID0gdDtcbiAgICAgICAgZWRnZU5leHRbc3RdID0gZWRnZTtcbiAgICAgIH0gLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgcHJvY2VzcyAncmV2ZXJzZWQnIGVkZ2VcblxuXG4gICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgIHZhciB0cyA9IHQgKiBOICsgczsgLy8gdGFyZ2V0IHRvIHNvdXJjZSBpbmRleFxuXG4gICAgICAgIGlmICghZGlyZWN0ZWQgJiYgZGlzdFt0c10gPiBfd2VpZ2h0KSB7XG4gICAgICAgICAgZGlzdFt0c10gPSBfd2VpZ2h0O1xuICAgICAgICAgIG5leHRbdHNdID0gcztcbiAgICAgICAgICBlZGdlTmV4dFt0c10gPSBlZGdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBNYWluIGxvb3BcblxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBOOyBrKyspIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IE47IF9pMisrKSB7XG4gICAgICAgIHZhciBpayA9IF9pMiAqIE4gKyBrO1xuXG4gICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBOOyBfaisrKSB7XG4gICAgICAgICAgdmFyIGlqID0gX2kyICogTiArIF9qO1xuICAgICAgICAgIHZhciBraiA9IGsgKiBOICsgX2o7XG5cbiAgICAgICAgICBpZiAoZGlzdFtpa10gKyBkaXN0W2tqXSA8IGRpc3RbaWpdKSB7XG4gICAgICAgICAgICBkaXN0W2lqXSA9IGRpc3RbaWtdICsgZGlzdFtral07XG4gICAgICAgICAgICBuZXh0W2lqXSA9IG5leHRbaWtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZXRBcmdFbGUgPSBmdW5jdGlvbiBnZXRBcmdFbGUoZWxlKSB7XG4gICAgICByZXR1cm4gKHN0cmluZyhlbGUpID8gY3kuZmlsdGVyKGVsZSkgOiBlbGUpWzBdO1xuICAgIH07XG5cbiAgICB2YXIgaW5kZXhPZkFyZ0VsZSA9IGZ1bmN0aW9uIGluZGV4T2ZBcmdFbGUoZWxlKSB7XG4gICAgICByZXR1cm4gaW5kZXhPZihnZXRBcmdFbGUoZWxlKSk7XG4gICAgfTtcblxuICAgIHZhciByZXMgPSB7XG4gICAgICBkaXN0YW5jZTogZnVuY3Rpb24gZGlzdGFuY2UoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGkgPSBpbmRleE9mQXJnRWxlKGZyb20pO1xuICAgICAgICB2YXIgaiA9IGluZGV4T2ZBcmdFbGUodG8pO1xuICAgICAgICByZXR1cm4gZGlzdFtpICogTiArIGpdO1xuICAgICAgfSxcbiAgICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGkgPSBpbmRleE9mQXJnRWxlKGZyb20pO1xuICAgICAgICB2YXIgaiA9IGluZGV4T2ZBcmdFbGUodG8pO1xuICAgICAgICB2YXIgZnJvbU5vZGUgPSBhdEluZGV4KGkpO1xuXG4gICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21Ob2RlLmNvbGxlY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0W2kgKiBOICsgal0gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHByZXYgPSBpO1xuICAgICAgICB2YXIgZWRnZTtcbiAgICAgICAgcGF0aC5tZXJnZShmcm9tTm9kZSk7XG5cbiAgICAgICAgd2hpbGUgKGkgIT09IGopIHtcbiAgICAgICAgICBwcmV2ID0gaTtcbiAgICAgICAgICBpID0gbmV4dFtpICogTiArIGpdO1xuICAgICAgICAgIGVkZ2UgPSBlZGdlTmV4dFtwcmV2ICogTiArIGldO1xuICAgICAgICAgIHBhdGgubWVyZ2UoZWRnZSk7XG4gICAgICAgICAgcGF0aC5tZXJnZShhdEluZGV4KGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBmbG95ZFdhcnNoYWxsXG5cbn07IC8vIGVsZXNmblxuXG52YXIgYmVsbG1hbkZvcmREZWZhdWx0cyA9IGRlZmF1bHRzKHtcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgIHJldHVybiAxO1xuICB9LFxuICBkaXJlY3RlZDogZmFsc2UsXG4gIHJvb3Q6IG51bGxcbn0pO1xudmFyIGVsZXNmbiQ1ID0ge1xuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgYmVsbG1hbkZvcmQ6IGZ1bmN0aW9uIGJlbGxtYW5Gb3JkKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9iZWxsbWFuRm9yZERlZmF1bHRzID0gYmVsbG1hbkZvcmREZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgd2VpZ2h0ID0gX2JlbGxtYW5Gb3JkRGVmYXVsdHMud2VpZ2h0LFxuICAgICAgICBkaXJlY3RlZCA9IF9iZWxsbWFuRm9yZERlZmF1bHRzLmRpcmVjdGVkLFxuICAgICAgICByb290ID0gX2JlbGxtYW5Gb3JkRGVmYXVsdHMucm9vdDtcblxuICAgIHZhciB3ZWlnaHRGbiA9IHdlaWdodDtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXM7XG5cbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIGluZm9NYXAgPSBuZXcgTWFwJDEoKTtcbiAgICB2YXIgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSA9IGZhbHNlO1xuICAgIHZhciBuZWdhdGl2ZVdlaWdodEN5Y2xlcyA9IFtdO1xuICAgIHJvb3QgPSBjeS5jb2xsZWN0aW9uKHJvb3QpWzBdOyAvLyBpbiBjYXNlIHNlbGVjdG9yIHBhc3NlZFxuXG4gICAgZWRnZXMudW5tZXJnZUJ5KGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5pc0xvb3AoKTtcbiAgICB9KTtcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICB2YXIgZ2V0SW5mbyA9IGZ1bmN0aW9uIGdldEluZm8obm9kZSkge1xuICAgICAgdmFyIG9iaiA9IGluZm9NYXAuZ2V0KG5vZGUuaWQoKSk7XG5cbiAgICAgIGlmICghb2JqKSB7XG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgICBpbmZvTWFwLnNldChub2RlLmlkKCksIG9iaik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIHZhciBnZXROb2RlRnJvbVRvID0gZnVuY3Rpb24gZ2V0Tm9kZUZyb21Ubyh0bykge1xuICAgICAgcmV0dXJuIChzdHJpbmcodG8pID8gY3kuJCh0bykgOiB0bylbMF07XG4gICAgfTtcblxuICAgIHZhciBkaXN0YW5jZVRvID0gZnVuY3Rpb24gZGlzdGFuY2VUbyh0bykge1xuICAgICAgcmV0dXJuIGdldEluZm8oZ2V0Tm9kZUZyb21Ubyh0bykpLmRpc3Q7XG4gICAgfTtcblxuICAgIHZhciBwYXRoVG8gPSBmdW5jdGlvbiBwYXRoVG8odG8pIHtcbiAgICAgIHZhciB0aGlzU3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHJvb3Q7XG4gICAgICB2YXIgZW5kID0gZ2V0Tm9kZUZyb21Ubyh0byk7XG4gICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgdmFyIG5vZGUgPSBlbmQ7XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5zcGF3bigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9nZXRJbmZvID0gZ2V0SW5mbyhub2RlKSxcbiAgICAgICAgICAgIGVkZ2UgPSBfZ2V0SW5mby5lZGdlLFxuICAgICAgICAgICAgcHJlZCA9IF9nZXRJbmZvLnByZWQ7XG5cbiAgICAgICAgcGF0aC51bnNoaWZ0KG5vZGVbMF0pO1xuXG4gICAgICAgIGlmIChub2RlLnNhbWUodGhpc1N0YXJ0KSAmJiBwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGdlICE9IG51bGwpIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQoZWRnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gcHJlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZXMuc3Bhd24ocGF0aCk7XG4gICAgfTsgLy8gSW5pdGlhbGl6YXRpb25zIHsgZGlzdCwgcHJlZCwgZWRnZSB9XG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciBpbmZvID0gZ2V0SW5mbyhub2RlKTtcblxuICAgICAgaWYgKG5vZGUuc2FtZShyb290KSkge1xuICAgICAgICBpbmZvLmRpc3QgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mby5kaXN0ID0gSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGluZm8ucHJlZCA9IG51bGw7XG4gICAgICBpbmZvLmVkZ2UgPSBudWxsO1xuICAgIH0gLy8gRWRnZXMgcmVsYXhhdGlvblxuXG5cbiAgICB2YXIgcmVwbGFjZWRFZGdlID0gZmFsc2U7XG5cbiAgICB2YXIgY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudChub2RlMSwgbm9kZTIsIGVkZ2UsIGluZm8xLCBpbmZvMiwgd2VpZ2h0KSB7XG4gICAgICB2YXIgZGlzdCA9IGluZm8xLmRpc3QgKyB3ZWlnaHQ7XG5cbiAgICAgIGlmIChkaXN0IDwgaW5mbzIuZGlzdCAmJiAhZWRnZS5zYW1lKGluZm8xLmVkZ2UpKSB7XG4gICAgICAgIGluZm8yLmRpc3QgPSBkaXN0O1xuICAgICAgICBpbmZvMi5wcmVkID0gbm9kZTE7XG4gICAgICAgIGluZm8yLmVkZ2UgPSBlZGdlO1xuICAgICAgICByZXBsYWNlZEVkZ2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgbnVtTm9kZXM7IF9pKyspIHtcbiAgICAgIHJlcGxhY2VkRWRnZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBlID0gMDsgZSA8IG51bUVkZ2VzOyBlKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuXG4gICAgICAgIHZhciBfd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZSk7XG5cbiAgICAgICAgdmFyIHNyY0luZm8gPSBnZXRJbmZvKHNyYyk7XG4gICAgICAgIHZhciB0Z3RJbmZvID0gZ2V0SW5mbyh0Z3QpO1xuICAgICAgICBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudChzcmMsIHRndCwgZWRnZSwgc3JjSW5mbywgdGd0SW5mbywgX3dlaWdodCk7IC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlICdyZXZlcnNlJyBlZGdlXG5cbiAgICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICAgIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KHRndCwgc3JjLCBlZGdlLCB0Z3RJbmZvLCBzcmNJbmZvLCBfd2VpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlcGxhY2VkRWRnZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZWRFZGdlKSB7XG4gICAgICAvLyBDaGVjayBmb3IgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlc1xuICAgICAgZm9yICh2YXIgX2UgPSAwOyBfZSA8IG51bUVkZ2VzOyBfZSsrKSB7XG4gICAgICAgIHZhciBfZWRnZSA9IGVkZ2VzW19lXTtcblxuICAgICAgICB2YXIgX3NyYyA9IF9lZGdlLnNvdXJjZSgpO1xuXG4gICAgICAgIHZhciBfdGd0ID0gX2VkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgdmFyIF93ZWlnaHQyID0gd2VpZ2h0Rm4oX2VkZ2UpO1xuXG4gICAgICAgIHZhciBzcmNEaXN0ID0gZ2V0SW5mbyhfc3JjKS5kaXN0O1xuICAgICAgICB2YXIgdGd0RGlzdCA9IGdldEluZm8oX3RndCkuZGlzdDtcblxuICAgICAgICBpZiAoc3JjRGlzdCArIF93ZWlnaHQyIDwgdGd0RGlzdCB8fCAhZGlyZWN0ZWQgJiYgdGd0RGlzdCArIF93ZWlnaHQyIDwgc3JjRGlzdCkge1xuICAgICAgICAgIHdhcm4oJ0dyYXBoIGNvbnRhaW5zIGEgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlIGZvciBCZWxsbWFuLUZvcmQnKTtcbiAgICAgICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXN0YW5jZVRvOiBkaXN0YW5jZVRvLFxuICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlLFxuICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZXM6IG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzXG4gICAgfTtcbiAgfSAvLyBiZWxsbWFuRm9yZFxuXG59OyAvLyBlbGVzZm5cblxudmFyIHNxcnQyID0gTWF0aC5zcXJ0KDIpOyAvLyBGdW5jdGlvbiB3aGljaCBjb2xhcHNlcyAyIChtZXRhKSBub2RlcyBpbnRvIG9uZVxuLy8gVXBkYXRlcyB0aGUgcmVtYWluaW5nIGVkZ2UgbGlzdHNcbi8vIFJlY2VpdmVzIGFzIGEgcGFyYW1hdGVyIHRoZSBlZGdlIHdoaWNoIGNhdXNlcyB0aGUgY29sbGFwc2VcblxudmFyIGNvbGxhcHNlID0gZnVuY3Rpb24gY29sbGFwc2UoZWRnZUluZGV4LCBub2RlTWFwLCByZW1haW5pbmdFZGdlcykge1xuICBpZiAocmVtYWluaW5nRWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgZXJyb3IoXCJLYXJnZXItU3RlaW4gbXVzdCBiZSBydW4gb24gYSBjb25uZWN0ZWQgKHN1YilncmFwaFwiKTtcbiAgfVxuXG4gIHZhciBlZGdlSW5mbyA9IHJlbWFpbmluZ0VkZ2VzW2VkZ2VJbmRleF07XG4gIHZhciBzb3VyY2VJbiA9IGVkZ2VJbmZvWzFdO1xuICB2YXIgdGFyZ2V0SW4gPSBlZGdlSW5mb1syXTtcbiAgdmFyIHBhcnRpdGlvbjEgPSBub2RlTWFwW3NvdXJjZUluXTtcbiAgdmFyIHBhcnRpdGlvbjIgPSBub2RlTWFwW3RhcmdldEluXTtcbiAgdmFyIG5ld0VkZ2VzID0gcmVtYWluaW5nRWRnZXM7IC8vIHJlLXVzZSBhcnJheVxuICAvLyBEZWxldGUgYWxsIGVkZ2VzIGJldHdlZW4gcGFydGl0aW9uMSBhbmQgcGFydGl0aW9uMlxuXG4gIGZvciAodmFyIGkgPSBuZXdFZGdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBlZGdlID0gbmV3RWRnZXNbaV07XG4gICAgdmFyIHNyYyA9IGVkZ2VbMV07XG4gICAgdmFyIHRndCA9IGVkZ2VbMl07XG5cbiAgICBpZiAobm9kZU1hcFtzcmNdID09PSBwYXJ0aXRpb24xICYmIG5vZGVNYXBbdGd0XSA9PT0gcGFydGl0aW9uMiB8fCBub2RlTWFwW3NyY10gPT09IHBhcnRpdGlvbjIgJiYgbm9kZU1hcFt0Z3RdID09PSBwYXJ0aXRpb24xKSB7XG4gICAgICBuZXdFZGdlcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9IC8vIEFsbCBlZGdlcyBwb2ludGluZyB0byBwYXJ0aXRpb24yIHNob3VsZCBub3cgcG9pbnQgdG8gcGFydGl0aW9uMVxuXG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5ld0VkZ2VzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBfZWRnZSA9IG5ld0VkZ2VzW19pXTtcblxuICAgIGlmIChfZWRnZVsxXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgLy8gQ2hlY2sgc291cmNlXG4gICAgICBuZXdFZGdlc1tfaV0gPSBfZWRnZS5zbGljZSgpOyAvLyBjb3B5XG5cbiAgICAgIG5ld0VkZ2VzW19pXVsxXSA9IHBhcnRpdGlvbjE7XG4gICAgfSBlbHNlIGlmIChfZWRnZVsyXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgLy8gQ2hlY2sgdGFyZ2V0XG4gICAgICBuZXdFZGdlc1tfaV0gPSBfZWRnZS5zbGljZSgpOyAvLyBjb3B5XG5cbiAgICAgIG5ld0VkZ2VzW19pXVsyXSA9IHBhcnRpdGlvbjE7XG4gICAgfVxuICB9IC8vIE1vdmUgYWxsIG5vZGVzIGZyb20gcGFydGl0aW9uMiB0byBwYXJ0aXRpb24xXG5cblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlTWFwLmxlbmd0aDsgX2kyKyspIHtcbiAgICBpZiAobm9kZU1hcFtfaTJdID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICBub2RlTWFwW19pMl0gPSBwYXJ0aXRpb24xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdFZGdlcztcbn07IC8vIENvbnRyYWN0cyBhIGdyYXBoIHVudGlsIHdlIHJlYWNoIGEgY2VydGFpbiBudW1iZXIgb2YgbWV0YSBub2Rlc1xuXG5cbnZhciBjb250cmFjdFVudGlsID0gZnVuY3Rpb24gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMsIHNpemUsIHNpemVMaW1pdCkge1xuICB3aGlsZSAoc2l6ZSA+IHNpemVMaW1pdCkge1xuICAgIC8vIENob29zZSBhbiBlZGdlIHJhbmRvbWx5XG4gICAgdmFyIGVkZ2VJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJlbWFpbmluZ0VkZ2VzLmxlbmd0aCk7IC8vIENvbGxhcHNlIGdyYXBoIGJhc2VkIG9uIGVkZ2VcblxuICAgIHJlbWFpbmluZ0VkZ2VzID0gY29sbGFwc2UoZWRnZUluZGV4LCBtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMpO1xuICAgIHNpemUtLTtcbiAgfVxuXG4gIHJldHVybiByZW1haW5pbmdFZGdlcztcbn07XG5cbnZhciBlbGVzZm4kNiA9IHtcbiAgLy8gQ29tcHV0ZXMgdGhlIG1pbmltdW0gY3V0IG9mIGFuIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgLy8gUmV0dXJucyB0aGUgY29ycmVjdCBhbnN3ZXIgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG4gIGthcmdlclN0ZWluOiBmdW5jdGlvbiBrYXJnZXJTdGVpbigpIHtcbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgIGVkZ2VzLnVubWVyZ2VCeShmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuaXNMb29wKCk7XG4gICAgfSk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcbiAgICB2YXIgbnVtSXRlciA9IE1hdGguY2VpbChNYXRoLnBvdyhNYXRoLmxvZyhudW1Ob2RlcykgLyBNYXRoLkxOMiwgMikpO1xuICAgIHZhciBzdG9wU2l6ZSA9IE1hdGguZmxvb3IobnVtTm9kZXMgLyBzcXJ0Mik7XG5cbiAgICBpZiAobnVtTm9kZXMgPCAyKSB7XG4gICAgICBlcnJvcignQXQgbGVhc3QgMiBub2RlcyBhcmUgcmVxdWlyZWQgZm9yIEthcmdlci1TdGVpbiBhbGdvcml0aG0nKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSAvLyBOb3cgc3RvcmUgZWRnZSBkZXN0aW5hdGlvbiBhcyBpbmRleGVzXG4gICAgLy8gRm9ybWF0IGZvciBlYWNoIGVkZ2UgKGVkZ2UgaW5kZXgsIHNvdXJjZSBub2RlIGluZGV4LCB0YXJnZXQgbm9kZSBpbmRleClcblxuXG4gICAgdmFyIGVkZ2VJbmRleGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVkZ2VzOyBpKyspIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICBlZGdlSW5kZXhlcy5wdXNoKFtpLCBub2Rlcy5pbmRleE9mKGUuc291cmNlKCkpLCBub2Rlcy5pbmRleE9mKGUudGFyZ2V0KCkpXSk7XG4gICAgfSAvLyBXZSB3aWxsIHN0b3JlIHRoZSBiZXN0IGN1dCBmb3VuZCBoZXJlXG5cblxuICAgIHZhciBtaW5DdXRTaXplID0gSW5maW5pdHk7XG4gICAgdmFyIG1pbkN1dEVkZ2VJbmRleGVzID0gW107XG4gICAgdmFyIG1pbkN1dE5vZGVNYXAgPSBuZXcgQXJyYXkobnVtTm9kZXMpOyAvLyBJbml0aWFsIG1ldGEgbm9kZSBwYXJ0aXRpb25cblxuICAgIHZhciBtZXRhTm9kZU1hcCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIG1ldGFOb2RlTWFwMiA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG5cbiAgICB2YXIgY29weU5vZGVzTWFwID0gZnVuY3Rpb24gY29weU5vZGVzTWFwKGZyb20sIHRvKSB7XG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBudW1Ob2RlczsgX2kzKyspIHtcbiAgICAgICAgdG9bX2kzXSA9IGZyb21bX2kzXTtcbiAgICAgIH1cbiAgICB9OyAvLyBNYWluIGxvb3BcblxuXG4gICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPD0gbnVtSXRlcjsgaXRlcisrKSB7XG4gICAgICAvLyBSZXNldCBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBudW1Ob2RlczsgX2k0KyspIHtcbiAgICAgICAgbWV0YU5vZGVNYXBbX2k0XSA9IF9pNDtcbiAgICAgIH0gLy8gQ29udHJhY3QgdW50aWwgc3RvcCBwb2ludCAoc3RvcFNpemUgbm9kZXMpXG5cblxuICAgICAgdmFyIGVkZ2VzU3RhdGUgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlSW5kZXhlcy5zbGljZSgpLCBudW1Ob2Rlcywgc3RvcFNpemUpO1xuICAgICAgdmFyIGVkZ2VzU3RhdGUyID0gZWRnZXNTdGF0ZS5zbGljZSgpOyAvLyBjb3B5XG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBjb2xhcHNlZCBub2RlcyBzdGF0ZVxuXG4gICAgICBjb3B5Tm9kZXNNYXAobWV0YU5vZGVNYXAsIG1ldGFOb2RlTWFwMik7IC8vIFJ1biAyIGl0ZXJhdGlvbnMgc3RhcnRpbmcgaW4gdGhlIHN0b3Agc3RhdGVcblxuICAgICAgdmFyIHJlczEgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlc1N0YXRlLCBzdG9wU2l6ZSwgMik7XG4gICAgICB2YXIgcmVzMiA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAyLCBlZGdlc1N0YXRlMiwgc3RvcFNpemUsIDIpOyAvLyBJcyBhbnkgb2YgdGhlIDIgcmVzdWx0cyB0aGUgYmVzdCBjdXQgc28gZmFyP1xuXG4gICAgICBpZiAocmVzMS5sZW5ndGggPD0gcmVzMi5sZW5ndGggJiYgcmVzMS5sZW5ndGggPCBtaW5DdXRTaXplKSB7XG4gICAgICAgIG1pbkN1dFNpemUgPSByZXMxLmxlbmd0aDtcbiAgICAgICAgbWluQ3V0RWRnZUluZGV4ZXMgPSByZXMxO1xuICAgICAgICBjb3B5Tm9kZXNNYXAobWV0YU5vZGVNYXAsIG1pbkN1dE5vZGVNYXApO1xuICAgICAgfSBlbHNlIGlmIChyZXMyLmxlbmd0aCA8PSByZXMxLmxlbmd0aCAmJiByZXMyLmxlbmd0aCA8IG1pbkN1dFNpemUpIHtcbiAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczIubGVuZ3RoO1xuICAgICAgICBtaW5DdXRFZGdlSW5kZXhlcyA9IHJlczI7XG4gICAgICAgIGNvcHlOb2Rlc01hcChtZXRhTm9kZU1hcDIsIG1pbkN1dE5vZGVNYXApO1xuICAgICAgfVxuICAgIH0gLy8gZW5kIG9mIG1haW4gbG9vcFxuICAgIC8vIENvbnN0cnVjdCByZXN1bHRcblxuXG4gICAgdmFyIGN1dCA9IHRoaXMuc3Bhd24obWluQ3V0RWRnZUluZGV4ZXMubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZWRnZXNbZVswXV07XG4gICAgfSkpO1xuICAgIHZhciBwYXJ0aXRpb24xID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBwYXJ0aXRpb24yID0gdGhpcy5zcGF3bigpOyAvLyB0cmF2ZXJzZSBtZXRhTm9kZU1hcCBmb3IgYmVzdCBjdXRcblxuICAgIHZhciB3aXRuZXNzTm9kZVBhcnRpdGlvbiA9IG1pbkN1dE5vZGVNYXBbMF07XG5cbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBtaW5DdXROb2RlTWFwLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgIHZhciBwYXJ0aXRpb25JZCA9IG1pbkN1dE5vZGVNYXBbX2k1XTtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbX2k1XTtcblxuICAgICAgaWYgKHBhcnRpdGlvbklkID09PSB3aXRuZXNzTm9kZVBhcnRpdGlvbikge1xuICAgICAgICBwYXJ0aXRpb24xLm1lcmdlKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydGl0aW9uMi5tZXJnZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgY3V0OiBjdXQsXG4gICAgICBwYXJ0aXRpb24xOiBwYXJ0aXRpb24xLFxuICAgICAgcGFydGl0aW9uMjogcGFydGl0aW9uMlxuICAgIH07XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTsgLy8gZWxlc2ZuXG5cbnZhciBjb3B5UG9zaXRpb24gPSBmdW5jdGlvbiBjb3B5UG9zaXRpb24ocCkge1xuICByZXR1cm4ge1xuICAgIHg6IHAueCxcbiAgICB5OiBwLnlcbiAgfTtcbn07XG52YXIgbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24gPSBmdW5jdGlvbiBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwLCB6b29tLCBwYW4pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwLnggKiB6b29tICsgcGFuLngsXG4gICAgeTogcC55ICogem9vbSArIHBhbi55XG4gIH07XG59O1xudmFyIHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uID0gZnVuY3Rpb24gcmVuZGVyZWRUb01vZGVsUG9zaXRpb24ocCwgem9vbSwgcGFuKSB7XG4gIHJldHVybiB7XG4gICAgeDogKHAueCAtIHBhbi54KSAvIHpvb20sXG4gICAgeTogKHAueSAtIHBhbi55KSAvIHpvb21cbiAgfTtcbn07XG52YXIgYXJyYXkycG9pbnQgPSBmdW5jdGlvbiBhcnJheTJwb2ludChhcnIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBhcnJbMF0sXG4gICAgeTogYXJyWzFdXG4gIH07XG59O1xudmFyIG1pbiA9IGZ1bmN0aW9uIG1pbihhcnIpIHtcbiAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICB2YXIgbWluID0gSW5maW5pdHk7XG5cbiAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYXJyW2ldO1xuXG4gICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKHZhbCwgbWluKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluO1xufTtcbnZhciBtYXggPSBmdW5jdGlvbiBtYXgoYXJyKSB7XG4gIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgdmFyIG1heCA9IC1JbmZpbml0eTtcblxuICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG5cbiAgICBpZiAoaXNGaW5pdGUodmFsKSkge1xuICAgICAgbWF4ID0gTWF0aC5tYXgodmFsLCBtYXgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXg7XG59O1xudmFyIG1lYW4gPSBmdW5jdGlvbiBtZWFuKGFycikge1xuICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gIHZhciB0b3RhbCA9IDA7XG4gIHZhciBuID0gMDtcblxuICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG5cbiAgICBpZiAoaXNGaW5pdGUodmFsKSkge1xuICAgICAgdG90YWwgKz0gdmFsO1xuICAgICAgbisrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b3RhbCAvIG47XG59O1xudmFyIG1lZGlhbiA9IGZ1bmN0aW9uIG1lZGlhbihhcnIpIHtcbiAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICB2YXIgY29weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHNvcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBpbmNsdWRlSG9sZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG5cbiAgaWYgKGNvcHkpIHtcbiAgICBhcnIgPSBhcnIuc2xpY2UoYmVnaW4sIGVuZCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVuZCA8IGFyci5sZW5ndGgpIHtcbiAgICAgIGFyci5zcGxpY2UoZW5kLCBhcnIubGVuZ3RoIC0gZW5kKTtcbiAgICB9XG5cbiAgICBpZiAoYmVnaW4gPiAwKSB7XG4gICAgICBhcnIuc3BsaWNlKDAsIGJlZ2luKTtcbiAgICB9XG4gIH0gLy8gYWxsIG5vbiBmaW5pdGUgKGUuZy4gSW5maW5pdHksIE5hTikgZWxlbWVudHMgbXVzdCBiZSAtSW5maW5pdHkgc28gdGhleSBnbyB0byB0aGUgc3RhcnRcblxuXG4gIHZhciBvZmYgPSAwOyAvLyBvZmZzZXQgZnJvbSBub24tZmluaXRlIHZhbHVlc1xuXG4gIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgdiA9IGFycltpXTtcblxuICAgIGlmIChpbmNsdWRlSG9sZXMpIHtcbiAgICAgIGlmICghaXNGaW5pdGUodikpIHtcbiAgICAgICAgYXJyW2ldID0gLUluZmluaXR5O1xuICAgICAgICBvZmYrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganVzdCByZW1vdmUgaXQgaWYgd2UgZG9uJ3Qgd2FudCB0byBjb25zaWRlciBob2xlc1xuICAgICAgYXJyLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc29ydCkge1xuICAgIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7IC8vIHJlcXVpcmVzIGNvcHkgPSB0cnVlIGlmIHlvdSBkb24ndCB3YW50IHRvIGNoYW5nZSB0aGUgb3JpZ1xuICB9XG5cbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBtaWQgPSBNYXRoLmZsb29yKGxlbiAvIDIpO1xuXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgcmV0dXJuIGFyclttaWQgKyAxICsgb2ZmXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGFyclttaWQgLSAxICsgb2ZmXSArIGFyclttaWQgKyBvZmZdKSAvIDI7XG4gIH1cbn07XG52YXIgZGVnMnJhZCA9IGZ1bmN0aW9uIGRlZzJyYWQoZGVnKSB7XG4gIHJldHVybiBNYXRoLlBJICogZGVnIC8gMTgwO1xufTtcbnZhciBnZXRBbmdsZUZyb21EaXNwID0gZnVuY3Rpb24gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpIHtcbiAgcmV0dXJuIE1hdGguYXRhbjIoZGlzcFksIGRpc3BYKSAtIE1hdGguUEkgLyAyO1xufTtcbnZhciBsb2cyID0gTWF0aC5sb2cyIHx8IGZ1bmN0aW9uIChuKSB7XG4gIHJldHVybiBNYXRoLmxvZyhuKSAvIE1hdGgubG9nKDIpO1xufTtcbnZhciBzaWdudW0gPSBmdW5jdGlvbiBzaWdudW0oeCkge1xuICBpZiAoeCA+IDApIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmICh4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbnZhciBkaXN0ID0gZnVuY3Rpb24gZGlzdChwMSwgcDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzcWRpc3QocDEsIHAyKSk7XG59O1xudmFyIHNxZGlzdCA9IGZ1bmN0aW9uIHNxZGlzdChwMSwgcDIpIHtcbiAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gIHZhciBkeSA9IHAyLnkgLSBwMS55O1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59O1xudmFyIGluUGxhY2VTdW1Ob3JtYWxpemUgPSBmdW5jdGlvbiBpblBsYWNlU3VtTm9ybWFsaXplKHYpIHtcbiAgdmFyIGxlbmd0aCA9IHYubGVuZ3RoOyAvLyBGaXJzdCwgZ2V0IHN1bSBvZiBhbGwgZWxlbWVudHNcblxuICB2YXIgdG90YWwgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB0b3RhbCArPSB2W2ldO1xuICB9IC8vIE5vdywgZGl2aWRlIGVhY2ggYnkgdGhlIHN1bSBvZiBhbGwgZWxlbWVudHNcblxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBsZW5ndGg7IF9pKyspIHtcbiAgICB2W19pXSA9IHZbX2ldIC8gdG90YWw7XG4gIH1cblxuICByZXR1cm4gdjtcbn07XG5cbnZhciBxYmV6aWVyQXQgPSBmdW5jdGlvbiBxYmV6aWVyQXQocDAsIHAxLCBwMiwgdCkge1xuICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiBwMCArIDIgKiAoMSAtIHQpICogdCAqIHAxICsgdCAqIHQgKiBwMjtcbn07XG52YXIgcWJlemllclB0QXQgPSBmdW5jdGlvbiBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiB7XG4gICAgeDogcWJlemllckF0KHAwLngsIHAxLngsIHAyLngsIHQpLFxuICAgIHk6IHFiZXppZXJBdChwMC55LCBwMS55LCBwMi55LCB0KVxuICB9O1xufTtcbnZhciBsaW5lQXQgPSBmdW5jdGlvbiBsaW5lQXQocDAsIHAxLCB0LCBkKSB7XG4gIHZhciB2ZWMgPSB7XG4gICAgeDogcDEueCAtIHAwLngsXG4gICAgeTogcDEueSAtIHAwLnlcbiAgfTtcbiAgdmFyIHZlY0Rpc3QgPSBkaXN0KHAwLCBwMSk7XG4gIHZhciBub3JtVmVjID0ge1xuICAgIHg6IHZlYy54IC8gdmVjRGlzdCxcbiAgICB5OiB2ZWMueSAvIHZlY0Rpc3RcbiAgfTtcbiAgdCA9IHQgPT0gbnVsbCA/IDAgOiB0O1xuICBkID0gZCAhPSBudWxsID8gZCA6IHQgKiB2ZWNEaXN0O1xuICByZXR1cm4ge1xuICAgIHg6IHAwLnggKyBub3JtVmVjLnggKiBkLFxuICAgIHk6IHAwLnkgKyBub3JtVmVjLnkgKiBkXG4gIH07XG59O1xudmFyIGJvdW5kID0gZnVuY3Rpb24gYm91bmQobWluLCB2YWwsIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbCkpO1xufTsgLy8gbWFrZXMgYSBmdWxsIGJiICh4MSwgeTEsIHgyLCB5MiwgdywgaCkgZnJvbSBpbXBsaWNpdCBwYXJhbXNcblxudmFyIG1ha2VCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIG1ha2VCb3VuZGluZ0JveChiYikge1xuICBpZiAoYmIgPT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogSW5maW5pdHksXG4gICAgICB5MTogSW5maW5pdHksXG4gICAgICB4MjogLUluZmluaXR5LFxuICAgICAgeTI6IC1JbmZpbml0eSxcbiAgICAgIHc6IDAsXG4gICAgICBoOiAwXG4gICAgfTtcbiAgfSBlbHNlIGlmIChiYi54MSAhPSBudWxsICYmIGJiLnkxICE9IG51bGwpIHtcbiAgICBpZiAoYmIueDIgIT0gbnVsbCAmJiBiYi55MiAhPSBudWxsICYmIGJiLngyID49IGJiLngxICYmIGJiLnkyID49IGJiLnkxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogYmIueDEsXG4gICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgeDI6IGJiLngyLFxuICAgICAgICB5MjogYmIueTIsXG4gICAgICAgIHc6IGJiLngyIC0gYmIueDEsXG4gICAgICAgIGg6IGJiLnkyIC0gYmIueTFcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChiYi53ICE9IG51bGwgJiYgYmIuaCAhPSBudWxsICYmIGJiLncgPj0gMCAmJiBiYi5oID49IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICB4MjogYmIueDEgKyBiYi53LFxuICAgICAgICB5MjogYmIueTEgKyBiYi5oLFxuICAgICAgICB3OiBiYi53LFxuICAgICAgICBoOiBiYi5oXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbnZhciBjb3B5Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiBjb3B5Qm91bmRpbmdCb3goYmIpIHtcbiAgcmV0dXJuIHtcbiAgICB4MTogYmIueDEsXG4gICAgeDI6IGJiLngyLFxuICAgIHc6IGJiLncsXG4gICAgeTE6IGJiLnkxLFxuICAgIHkyOiBiYi55MixcbiAgICBoOiBiYi5oXG4gIH07XG59O1xudmFyIGNsZWFyQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBjbGVhckJvdW5kaW5nQm94KGJiKSB7XG4gIGJiLngxID0gSW5maW5pdHk7XG4gIGJiLnkxID0gSW5maW5pdHk7XG4gIGJiLngyID0gLUluZmluaXR5O1xuICBiYi55MiA9IC1JbmZpbml0eTtcbiAgYmIudyA9IDA7XG4gIGJiLmggPSAwO1xufTtcbnZhciB1cGRhdGVCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KGJiMSwgYmIyKSB7XG4gIC8vIHVwZGF0ZSBiYjEgd2l0aCBiYjIgYm91bmRzXG4gIGJiMS54MSA9IE1hdGgubWluKGJiMS54MSwgYmIyLngxKTtcbiAgYmIxLngyID0gTWF0aC5tYXgoYmIxLngyLCBiYjIueDIpO1xuICBiYjEudyA9IGJiMS54MiAtIGJiMS54MTtcbiAgYmIxLnkxID0gTWF0aC5taW4oYmIxLnkxLCBiYjIueTEpO1xuICBiYjEueTIgPSBNYXRoLm1heChiYjEueTIsIGJiMi55Mik7XG4gIGJiMS5oID0gYmIxLnkyIC0gYmIxLnkxO1xufTtcbnZhciBleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQgPSBmdW5jdGlvbiBleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQoYmIsIHgsIHkpIHtcbiAgYmIueDEgPSBNYXRoLm1pbihiYi54MSwgeCk7XG4gIGJiLngyID0gTWF0aC5tYXgoYmIueDIsIHgpO1xuICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgYmIueTEgPSBNYXRoLm1pbihiYi55MSwgeSk7XG4gIGJiLnkyID0gTWF0aC5tYXgoYmIueTIsIHkpO1xuICBiYi5oID0gYmIueTIgLSBiYi55MTtcbn07XG52YXIgZXhwYW5kQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBleHBhbmRCb3VuZGluZ0JveChiYikge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgYmIueDEgLT0gcGFkZGluZztcbiAgYmIueDIgKz0gcGFkZGluZztcbiAgYmIueTEgLT0gcGFkZGluZztcbiAgYmIueTIgKz0gcGFkZGluZztcbiAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICByZXR1cm4gYmI7XG59O1xudmFyIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMgPSBmdW5jdGlvbiBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiKSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbMF07XG4gIHZhciB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQ7XG5cbiAgaWYgKHBhZGRpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgdG9wID0gcmlnaHQgPSBib3R0b20gPSBsZWZ0ID0gcGFkZGluZ1swXTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gMikge1xuICAgIHRvcCA9IGJvdHRvbSA9IHBhZGRpbmdbMF07XG4gICAgbGVmdCA9IHJpZ2h0ID0gcGFkZGluZ1sxXTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBfcGFkZGluZyA9IF9zbGljZWRUb0FycmF5KHBhZGRpbmcsIDQpO1xuXG4gICAgdG9wID0gX3BhZGRpbmdbMF07XG4gICAgcmlnaHQgPSBfcGFkZGluZ1sxXTtcbiAgICBib3R0b20gPSBfcGFkZGluZ1syXTtcbiAgICBsZWZ0ID0gX3BhZGRpbmdbM107XG4gIH1cblxuICBiYi54MSAtPSBsZWZ0O1xuICBiYi54MiArPSByaWdodDtcbiAgYmIueTEgLT0gdG9wO1xuICBiYi55MiArPSBib3R0b207XG4gIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgcmV0dXJuIGJiO1xufTtcblxudmFyIGFzc2lnbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gYXNzaWduQm91bmRpbmdCb3goYmIxLCBiYjIpIHtcbiAgYmIxLngxID0gYmIyLngxO1xuICBiYjEueTEgPSBiYjIueTE7XG4gIGJiMS54MiA9IGJiMi54MjtcbiAgYmIxLnkyID0gYmIyLnkyO1xuICBiYjEudyA9IGJiMS54MiAtIGJiMS54MTtcbiAgYmIxLmggPSBiYjEueTIgLSBiYjEueTE7XG59O1xudmFyIGFzc2lnblNoaWZ0VG9Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGFzc2lnblNoaWZ0VG9Cb3VuZGluZ0JveChiYiwgZGVsdGEpIHtcbiAgYmIueDEgKz0gZGVsdGEueDtcbiAgYmIueDIgKz0gZGVsdGEueDtcbiAgYmIueTEgKz0gZGVsdGEueTtcbiAgYmIueTIgKz0gZGVsdGEueTtcbn07XG52YXIgYm91bmRpbmdCb3hlc0ludGVyc2VjdCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYmIxLCBiYjIpIHtcbiAgLy8gY2FzZTogb25lIGJiIHRvIHJpZ2h0IG9mIG90aGVyXG4gIGlmIChiYjEueDEgPiBiYjIueDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYmIyLngxID4gYmIxLngyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIGNhc2U6IG9uZSBiYiB0byBsZWZ0IG9mIG90aGVyXG5cblxuICBpZiAoYmIxLngyIDwgYmIyLngxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGJiMi54MiA8IGJiMS54MSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBjYXNlOiBvbmUgYmIgYWJvdmUgb3RoZXJcblxuXG4gIGlmIChiYjEueTIgPCBiYjIueTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYmIyLnkyIDwgYmIxLnkxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIGNhc2U6IG9uZSBiYiBiZWxvdyBvdGhlclxuXG5cbiAgaWYgKGJiMS55MSA+IGJiMi55Mikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChiYjIueTEgPiBiYjEueTIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gb3RoZXJ3aXNlLCBtdXN0IGhhdmUgc29tZSBvdmVybGFwXG5cblxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgaW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGluQm91bmRpbmdCb3goYmIsIHgsIHkpIHtcbiAgcmV0dXJuIGJiLngxIDw9IHggJiYgeCA8PSBiYi54MiAmJiBiYi55MSA8PSB5ICYmIHkgPD0gYmIueTI7XG59O1xudmFyIHBvaW50SW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIHBvaW50SW5Cb3VuZGluZ0JveChiYiwgcHQpIHtcbiAgcmV0dXJuIGluQm91bmRpbmdCb3goYmIsIHB0LngsIHB0LnkpO1xufTtcbnZhciBib3VuZGluZ0JveEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBib3VuZGluZ0JveEluQm91bmRpbmdCb3goYmIxLCBiYjIpIHtcbiAgcmV0dXJuIGluQm91bmRpbmdCb3goYmIxLCBiYjIueDEsIGJiMi55MSkgJiYgaW5Cb3VuZGluZ0JveChiYjEsIGJiMi54MiwgYmIyLnkyKTtcbn07XG52YXIgcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjsgLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIHN0cmFpZ2h0IGxpbmUgc2VnbWVudHNcblxuICB2YXIgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9uczsgLy8gVG9wIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcblxuICB7XG4gICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgdG9wU3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0IC0gcGFkZGluZztcbiAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgdG9wRW5kWSA9IHRvcFN0YXJ0WTtcbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuXG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9IC8vIFJpZ2h0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cblxuICB7XG4gICAgdmFyIHJpZ2h0U3RhcnRYID0gbm9kZVggKyBoYWxmV2lkdGggKyBwYWRkaW5nO1xuICAgIHZhciByaWdodFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIHJpZ2h0RW5kWCA9IHJpZ2h0U3RhcnRYO1xuICAgIHZhciByaWdodEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHJpZ2h0U3RhcnRYLCByaWdodFN0YXJ0WSwgcmlnaHRFbmRYLCByaWdodEVuZFksIGZhbHNlKTtcblxuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfSAvLyBCb3R0b20gc2VnbWVudCwgbGVmdCB0byByaWdodFxuXG4gIHtcbiAgICB2YXIgYm90dG9tU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciBib3R0b21TdGFydFkgPSBub2RlWSArIGhhbGZIZWlnaHQgKyBwYWRkaW5nO1xuICAgIHZhciBib3R0b21FbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciBib3R0b21FbmRZID0gYm90dG9tU3RhcnRZO1xuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbVN0YXJ0WCwgYm90dG9tU3RhcnRZLCBib3R0b21FbmRYLCBib3R0b21FbmRZLCBmYWxzZSk7XG5cbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH0gLy8gTGVmdCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG5cbiAge1xuICAgIHZhciBsZWZ0U3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggLSBwYWRkaW5nO1xuICAgIHZhciBsZWZ0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgbGVmdEVuZFggPSBsZWZ0U3RhcnRYO1xuICAgIHZhciBsZWZ0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgbGVmdFN0YXJ0WCwgbGVmdFN0YXJ0WSwgbGVmdEVuZFgsIGxlZnRFbmRZLCBmYWxzZSk7XG5cbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH0gLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIGFyYyBzZWdtZW50c1xuXG4gIHZhciBhcmNJbnRlcnNlY3Rpb25zOyAvLyBUb3AgTGVmdFxuXG4gIHtcbiAgICB2YXIgdG9wTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICB2YXIgdG9wTGVmdENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BMZWZ0Q2VudGVyWCwgdG9wTGVmdENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpOyAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSB0b3BMZWZ0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdIDw9IHRvcExlZnRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfSAvLyBUb3AgUmlnaHRcblxuICB7XG4gICAgdmFyIHRvcFJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgIHZhciB0b3BSaWdodENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BSaWdodENlbnRlclgsIHRvcFJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7IC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IHRvcFJpZ2h0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdIDw9IHRvcFJpZ2h0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH0gLy8gQm90dG9tIFJpZ2h0XG5cbiAge1xuICAgIHZhciBib3R0b21SaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICB2YXIgYm90dG9tUmlnaHRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tUmlnaHRDZW50ZXJYLCBib3R0b21SaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpOyAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSBib3R0b21SaWdodENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21SaWdodENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9IC8vIEJvdHRvbSBMZWZ0XG5cbiAge1xuICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbUxlZnRDZW50ZXJYLCBib3R0b21MZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7IC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IGJvdHRvbUxlZnRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPj0gYm90dG9tTGVmdENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTsgLy8gaWYgbm90aGluZ1xufTtcbnZhciBpbkxpbmVWaWNpbml0eSA9IGZ1bmN0aW9uIGluTGluZVZpY2luaXR5KHgsIHksIGx4MSwgbHkxLCBseDIsIGx5MiwgdG9sZXJhbmNlKSB7XG4gIHZhciB0ID0gdG9sZXJhbmNlO1xuICB2YXIgeDEgPSBNYXRoLm1pbihseDEsIGx4Mik7XG4gIHZhciB4MiA9IE1hdGgubWF4KGx4MSwgbHgyKTtcbiAgdmFyIHkxID0gTWF0aC5taW4obHkxLCBseTIpO1xuICB2YXIgeTIgPSBNYXRoLm1heChseTEsIGx5Mik7XG4gIHJldHVybiB4MSAtIHQgPD0geCAmJiB4IDw9IHgyICsgdCAmJiB5MSAtIHQgPD0geSAmJiB5IDw9IHkyICsgdDtcbn07XG52YXIgaW5CZXppZXJWaWNpbml0eSA9IGZ1bmN0aW9uIGluQmV6aWVyVmljaW5pdHkoeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlKSB7XG4gIHZhciBiYiA9IHtcbiAgICB4MTogTWF0aC5taW4oeDEsIHgzLCB4MikgLSB0b2xlcmFuY2UsXG4gICAgeDI6IE1hdGgubWF4KHgxLCB4MywgeDIpICsgdG9sZXJhbmNlLFxuICAgIHkxOiBNYXRoLm1pbih5MSwgeTMsIHkyKSAtIHRvbGVyYW5jZSxcbiAgICB5MjogTWF0aC5tYXgoeTEsIHkzLCB5MikgKyB0b2xlcmFuY2VcbiAgfTsgLy8gaWYgb3V0c2lkZSB0aGUgcm91Z2ggYm91bmRpbmcgYm94IGZvciB0aGUgYmV6aWVyLCB0aGVuIGl0IGNhbid0IGJlIGEgaGl0XG5cbiAgaWYgKHggPCBiYi54MSB8fCB4ID4gYmIueDIgfHwgeSA8IGJiLnkxIHx8IHkgPiBiYi55Mikge1xuICAgIC8vIGNvbnNvbGUubG9nKCdiZXppZXIgb3V0IG9mIHJvdWdoIGJiJylcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2RvIG1vcmUgZXhwZW5zaXZlIGNoZWNrJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgc29sdmVRdWFkcmF0aWMgPSBmdW5jdGlvbiBzb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCB2YWwpIHtcbiAgYyAtPSB2YWw7XG4gIHZhciByID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgaWYgKHIgPCAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIHNxcnRSID0gTWF0aC5zcXJ0KHIpO1xuICB2YXIgZGVub20gPSAyICogYTtcbiAgdmFyIHJvb3QxID0gKC1iICsgc3FydFIpIC8gZGVub207XG4gIHZhciByb290MiA9ICgtYiAtIHNxcnRSKSAvIGRlbm9tO1xuICByZXR1cm4gW3Jvb3QxLCByb290Ml07XG59O1xudmFyIHNvbHZlQ3ViaWMgPSBmdW5jdGlvbiBzb2x2ZUN1YmljKGEsIGIsIGMsIGQsIHJlc3VsdCkge1xuICAvLyBTb2x2ZXMgYSBjdWJpYyBmdW5jdGlvbiwgcmV0dXJucyByb290IGluIGZvcm0gW3IxLCBpMSwgcjIsIGkyLCByMywgaTNdLCB3aGVyZVxuICAvLyByIGlzIHRoZSByZWFsIGNvbXBvbmVudCwgaSBpcyB0aGUgaW1hZ2luYXJ5IGNvbXBvbmVudFxuICAvLyBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ2FyZGFubyBtZXRob2QgZnJvbSB0aGUgeWVhciAxNTQ1XG4gIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfZnVuY3Rpb24jVGhlX25hdHVyZV9vZl90aGVfcm9vdHNcbiAgdmFyIGVwc2lsb24gPSAwLjAwMDAxOyAvLyBhdm9pZCBkaXZpc2lvbiBieSB6ZXJvIHdoaWxlIGtlZXBpbmcgdGhlIG92ZXJhbGwgZXhwcmVzc2lvbiBjbG9zZSBpbiB2YWx1ZVxuXG4gIGlmIChhID09PSAwKSB7XG4gICAgYSA9IGVwc2lsb247XG4gIH1cblxuICBiIC89IGE7XG4gIGMgLz0gYTtcbiAgZCAvPSBhO1xuICB2YXIgZGlzY3JpbWluYW50LCBxLCByLCBkdW0xLCBzLCB0LCB0ZXJtMSwgcjEzO1xuICBxID0gKDMuMCAqIGMgLSBiICogYikgLyA5LjA7XG4gIHIgPSAtKDI3LjAgKiBkKSArIGIgKiAoOS4wICogYyAtIDIuMCAqIChiICogYikpO1xuICByIC89IDU0LjA7XG4gIGRpc2NyaW1pbmFudCA9IHEgKiBxICogcSArIHIgKiByO1xuICByZXN1bHRbMV0gPSAwO1xuICB0ZXJtMSA9IGIgLyAzLjA7XG5cbiAgaWYgKGRpc2NyaW1pbmFudCA+IDApIHtcbiAgICBzID0gciArIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIHMgPSBzIDwgMCA/IC1NYXRoLnBvdygtcywgMS4wIC8gMy4wKSA6IE1hdGgucG93KHMsIDEuMCAvIDMuMCk7XG4gICAgdCA9IHIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICB0ID0gdCA8IDAgPyAtTWF0aC5wb3coLXQsIDEuMCAvIDMuMCkgOiBNYXRoLnBvdyh0LCAxLjAgLyAzLjApO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIHMgKyB0O1xuICAgIHRlcm0xICs9IChzICsgdCkgLyAyLjA7XG4gICAgcmVzdWx0WzRdID0gcmVzdWx0WzJdID0gLXRlcm0xO1xuICAgIHRlcm0xID0gTWF0aC5zcXJ0KDMuMCkgKiAoLXQgKyBzKSAvIDI7XG4gICAgcmVzdWx0WzNdID0gdGVybTE7XG4gICAgcmVzdWx0WzVdID0gLXRlcm0xO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlc3VsdFs1XSA9IHJlc3VsdFszXSA9IDA7XG5cbiAgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xuICAgIHIxMyA9IHIgPCAwID8gLU1hdGgucG93KC1yLCAxLjAgLyAzLjApIDogTWF0aC5wb3cociwgMS4wIC8gMy4wKTtcbiAgICByZXN1bHRbMF0gPSAtdGVybTEgKyAyLjAgKiByMTM7XG4gICAgcmVzdWx0WzRdID0gcmVzdWx0WzJdID0gLShyMTMgKyB0ZXJtMSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcSA9IC1xO1xuICBkdW0xID0gcSAqIHEgKiBxO1xuICBkdW0xID0gTWF0aC5hY29zKHIgLyBNYXRoLnNxcnQoZHVtMSkpO1xuICByMTMgPSAyLjAgKiBNYXRoLnNxcnQocSk7XG4gIHJlc3VsdFswXSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKGR1bTEgLyAzLjApO1xuICByZXN1bHRbMl0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDIuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgcmVzdWx0WzRdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoKGR1bTEgKyA0LjAgKiBNYXRoLlBJKSAvIDMuMCk7XG4gIHJldHVybjtcbn07XG52YXIgc3FkaXN0VG9RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbiBzcWRpc3RUb1F1YWRyYXRpY0Jlemllcih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIC8vIEZpbmQgbWluaW11bSBkaXN0YW5jZSBieSB1c2luZyB0aGUgbWluaW11bSBvZiB0aGUgZGlzdGFuY2VcbiAgLy8gZnVuY3Rpb24gYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnQgYW5kIHRoZSBjdXJ2ZVxuICAvLyBUaGlzIGdpdmVzIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHJlc3VsdGluZyBjdWJpYyBlcXVhdGlvblxuICAvLyB3aG9zZSByb290cyB0ZWxsIHVzIHdoZXJlIGEgcG9zc2libGUgbWluaW11bSBpc1xuICAvLyAoQ29lZmZpY2llbnRzIGFyZSBkaXZpZGVkIGJ5IDQpXG4gIHZhciBhID0gMS4wICogeDEgKiB4MSAtIDQgKiB4MSAqIHgyICsgMiAqIHgxICogeDMgKyA0ICogeDIgKiB4MiAtIDQgKiB4MiAqIHgzICsgeDMgKiB4MyArIHkxICogeTEgLSA0ICogeTEgKiB5MiArIDIgKiB5MSAqIHkzICsgNCAqIHkyICogeTIgLSA0ICogeTIgKiB5MyArIHkzICogeTM7XG4gIHZhciBiID0gMS4wICogOSAqIHgxICogeDIgLSAzICogeDEgKiB4MSAtIDMgKiB4MSAqIHgzIC0gNiAqIHgyICogeDIgKyAzICogeDIgKiB4MyArIDkgKiB5MSAqIHkyIC0gMyAqIHkxICogeTEgLSAzICogeTEgKiB5MyAtIDYgKiB5MiAqIHkyICsgMyAqIHkyICogeTM7XG4gIHZhciBjID0gMS4wICogMyAqIHgxICogeDEgLSA2ICogeDEgKiB4MiArIHgxICogeDMgLSB4MSAqIHggKyAyICogeDIgKiB4MiArIDIgKiB4MiAqIHggLSB4MyAqIHggKyAzICogeTEgKiB5MSAtIDYgKiB5MSAqIHkyICsgeTEgKiB5MyAtIHkxICogeSArIDIgKiB5MiAqIHkyICsgMiAqIHkyICogeSAtIHkzICogeTtcbiAgdmFyIGQgPSAxLjAgKiB4MSAqIHgyIC0geDEgKiB4MSArIHgxICogeCAtIHgyICogeCArIHkxICogeTIgLSB5MSAqIHkxICsgeTEgKiB5IC0geTIgKiB5OyAvLyBkZWJ1ZyhcImNvZWZmaWNpZW50czogXCIgKyBhIC8gYSArIFwiLCBcIiArIGIgLyBhICsgXCIsIFwiICsgYyAvIGEgKyBcIiwgXCIgKyBkIC8gYSk7XG5cbiAgdmFyIHJvb3RzID0gW107IC8vIFVzZSB0aGUgY3ViaWMgc29sdmluZyBhbGdvcml0aG1cblxuICBzb2x2ZUN1YmljKGEsIGIsIGMsIGQsIHJvb3RzKTtcbiAgdmFyIHplcm9UaHJlc2hvbGQgPSAwLjAwMDAwMDE7XG4gIHZhciBwYXJhbXMgPSBbXTtcblxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXggKz0gMikge1xuICAgIGlmIChNYXRoLmFicyhyb290c1tpbmRleCArIDFdKSA8IHplcm9UaHJlc2hvbGQgJiYgcm9vdHNbaW5kZXhdID49IDAgJiYgcm9vdHNbaW5kZXhdIDw9IDEuMCkge1xuICAgICAgcGFyYW1zLnB1c2gocm9vdHNbaW5kZXhdKTtcbiAgICB9XG4gIH1cblxuICBwYXJhbXMucHVzaCgxLjApO1xuICBwYXJhbXMucHVzaCgwLjApO1xuICB2YXIgbWluRGlzdGFuY2VTcXVhcmVkID0gLTE7XG4gIHZhciBjdXJYLCBjdXJZLCBkaXN0U3F1YXJlZDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIGN1clggPSBNYXRoLnBvdygxLjAgLSBwYXJhbXNbaV0sIDIuMCkgKiB4MSArIDIuMCAqICgxIC0gcGFyYW1zW2ldKSAqIHBhcmFtc1tpXSAqIHgyICsgcGFyYW1zW2ldICogcGFyYW1zW2ldICogeDM7XG4gICAgY3VyWSA9IE1hdGgucG93KDEgLSBwYXJhbXNbaV0sIDIuMCkgKiB5MSArIDIgKiAoMS4wIC0gcGFyYW1zW2ldKSAqIHBhcmFtc1tpXSAqIHkyICsgcGFyYW1zW2ldICogcGFyYW1zW2ldICogeTM7XG4gICAgZGlzdFNxdWFyZWQgPSBNYXRoLnBvdyhjdXJYIC0geCwgMikgKyBNYXRoLnBvdyhjdXJZIC0geSwgMik7IC8vIGRlYnVnKCdkaXN0YW5jZSBmb3IgcGFyYW0gJyArIHBhcmFtc1tpXSArIFwiOiBcIiArIE1hdGguc3FydChkaXN0U3F1YXJlZCkpO1xuXG4gICAgaWYgKG1pbkRpc3RhbmNlU3F1YXJlZCA+PSAwKSB7XG4gICAgICBpZiAoZGlzdFNxdWFyZWQgPCBtaW5EaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbkRpc3RhbmNlU3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW5EaXN0YW5jZVNxdWFyZWQ7XG59O1xudmFyIHNxZGlzdFRvRmluaXRlTGluZSA9IGZ1bmN0aW9uIHNxZGlzdFRvRmluaXRlTGluZSh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgb2Zmc2V0ID0gW3ggLSB4MSwgeSAtIHkxXTtcbiAgdmFyIGxpbmUgPSBbeDIgLSB4MSwgeTIgLSB5MV07XG4gIHZhciBsaW5lU3EgPSBsaW5lWzBdICogbGluZVswXSArIGxpbmVbMV0gKiBsaW5lWzFdO1xuICB2YXIgaHlwU3EgPSBvZmZzZXRbMF0gKiBvZmZzZXRbMF0gKyBvZmZzZXRbMV0gKiBvZmZzZXRbMV07XG4gIHZhciBkb3RQcm9kdWN0ID0gb2Zmc2V0WzBdICogbGluZVswXSArIG9mZnNldFsxXSAqIGxpbmVbMV07XG4gIHZhciBhZGpTcSA9IGRvdFByb2R1Y3QgKiBkb3RQcm9kdWN0IC8gbGluZVNxO1xuXG4gIGlmIChkb3RQcm9kdWN0IDwgMCkge1xuICAgIHJldHVybiBoeXBTcTtcbiAgfVxuXG4gIGlmIChhZGpTcSA+IGxpbmVTcSkge1xuICAgIHJldHVybiAoeCAtIHgyKSAqICh4IC0geDIpICsgKHkgLSB5MikgKiAoeSAtIHkyKTtcbiAgfVxuXG4gIHJldHVybiBoeXBTcSAtIGFkalNxO1xufTtcbnZhciBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMgPSBmdW5jdGlvbiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSB7XG4gIHZhciB4MSwgeTEsIHgyLCB5MjtcbiAgdmFyIHkzOyAvLyBJbnRlcnNlY3Qgd2l0aCB2ZXJ0aWNhbCBsaW5lIHRocm91Z2ggKHgsIHkpXG5cbiAgdmFyIHVwID0gMDsgLy8gbGV0IGRvd24gPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHgxID0gcG9pbnRzW2kgKiAyXTtcbiAgICB5MSA9IHBvaW50c1tpICogMiArIDFdO1xuXG4gICAgaWYgKGkgKyAxIDwgcG9pbnRzLmxlbmd0aCAvIDIpIHtcbiAgICAgIHgyID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgIHkyID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHgyID0gcG9pbnRzWyhpICsgMSAtIHBvaW50cy5sZW5ndGggLyAyKSAqIDJdO1xuICAgICAgeTIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMiArIDFdO1xuICAgIH1cblxuICAgIGlmICh4MSA9PSB4ICYmIHgyID09IHgpIDsgZWxzZSBpZiAoeDEgPj0geCAmJiB4ID49IHgyIHx8IHgxIDw9IHggJiYgeCA8PSB4Mikge1xuICAgICAgeTMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKSAqICh5MiAtIHkxKSArIHkxO1xuXG4gICAgICBpZiAoeTMgPiB5KSB7XG4gICAgICAgIHVwKys7XG4gICAgICB9IC8vIGlmKCB5MyA8IHkgKXtcbiAgICAgIC8vIGRvd24rKztcbiAgICAgIC8vIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodXAgJSAyID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xudmFyIHBvaW50SW5zaWRlUG9seWdvbiA9IGZ1bmN0aW9uIHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTsgLy8gR2l2ZXMgbmVnYXRpdmUgYW5nbGVcblxuICB2YXIgYW5nbGU7XG5cbiAgaWYgKGRpcmVjdGlvblswXSAhPSBudWxsKSB7XG4gICAgYW5nbGUgPSBNYXRoLmF0YW4oZGlyZWN0aW9uWzFdIC8gZGlyZWN0aW9uWzBdKTtcblxuICAgIGlmIChkaXJlY3Rpb25bMF0gPCAwKSB7XG4gICAgICBhbmdsZSA9IGFuZ2xlICsgTWF0aC5QSSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuZ2xlID0gLWFuZ2xlIC0gTWF0aC5QSSAvIDI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFuZ2xlID0gZGlyZWN0aW9uO1xuICB9XG5cbiAgdmFyIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gIHZhciBzaW4gPSBNYXRoLnNpbigtYW5nbGUpOyAvLyAgICBjb25zb2xlLmxvZyhcImJhc2U6IFwiICsgYmFzZVBvaW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPSB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1tpICogMl0gKiBjb3MgLSBiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBzaW4pO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBoZWlnaHQgLyAyICogKGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGNvcyArIGJhc2VQb2ludHNbaSAqIDJdICogc2luKTtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gKz0gY2VudGVyWDtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdICs9IGNlbnRlclk7XG4gIH1cblxuICB2YXIgcG9pbnRzO1xuXG4gIGlmIChwYWRkaW5nID4gMCkge1xuICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBleHBhbmRQb2x5Z29uKHRyYW5zZm9ybWVkUG9pbnRzLCAtcGFkZGluZyk7XG4gICAgcG9pbnRzID0gam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gIH1cblxuICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cyk7XG59O1xudmFyIHBvaW50SW5zaWRlUm91bmRQb2x5Z29uID0gZnVuY3Rpb24gcG9pbnRJbnNpZGVSb3VuZFBvbHlnb24oeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgY3V0UG9seWdvblBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHNxdWFyZWRDb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgKiBjb3JuZXJSYWRpdXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlUG9pbnRzLmxlbmd0aCAvIDQ7IGkrKykge1xuICAgIHZhciBzb3VyY2VVdiA9IHZvaWQgMCxcbiAgICAgICAgZGVzdFV2ID0gdm9pZCAwO1xuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHNvdXJjZVV2ID0gYmFzZVBvaW50cy5sZW5ndGggLSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2VVdiA9IGkgKiA0IC0gMjtcbiAgICB9XG5cbiAgICBkZXN0VXYgPSBpICogNCArIDI7XG4gICAgdmFyIHB4ID0gY2VudGVyWCArIGhhbGZXICogYmFzZVBvaW50c1tpICogNF07XG4gICAgdmFyIHB5ID0gY2VudGVyWSArIGhhbGZIICogYmFzZVBvaW50c1tpICogNCArIDFdO1xuICAgIHZhciBjb3NUaGV0YSA9IC1iYXNlUG9pbnRzW3NvdXJjZVV2XSAqIGJhc2VQb2ludHNbZGVzdFV2XSAtIGJhc2VQb2ludHNbc291cmNlVXYgKyAxXSAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG4gICAgdmFyIG9mZnNldCA9IGNvcm5lclJhZGl1cyAvIE1hdGgudGFuKE1hdGguYWNvcyhjb3NUaGV0YSkgLyAyKTtcbiAgICB2YXIgY3AweCA9IHB4IC0gb2Zmc2V0ICogYmFzZVBvaW50c1tzb3VyY2VVdl07XG4gICAgdmFyIGNwMHkgPSBweSAtIG9mZnNldCAqIGJhc2VQb2ludHNbc291cmNlVXYgKyAxXTtcbiAgICB2YXIgY3AxeCA9IHB4ICsgb2Zmc2V0ICogYmFzZVBvaW50c1tkZXN0VXZdO1xuICAgIHZhciBjcDF5ID0gcHkgKyBvZmZzZXQgKiBiYXNlUG9pbnRzW2Rlc3RVdiArIDFdO1xuICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDRdID0gY3AweDtcbiAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0ICsgMV0gPSBjcDB5O1xuICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAyXSA9IGNwMXg7XG4gICAgY3V0UG9seWdvblBvaW50c1tpICogNCArIDNdID0gY3AxeTtcbiAgICB2YXIgb3J0aHggPSBiYXNlUG9pbnRzW3NvdXJjZVV2ICsgMV07XG4gICAgdmFyIG9ydGh5ID0gLWJhc2VQb2ludHNbc291cmNlVXZdO1xuICAgIHZhciBjb3NBbHBoYSA9IG9ydGh4ICogYmFzZVBvaW50c1tkZXN0VXZdICsgb3J0aHkgKiBiYXNlUG9pbnRzW2Rlc3RVdiArIDFdO1xuXG4gICAgaWYgKGNvc0FscGhhIDwgMCkge1xuICAgICAgb3J0aHggKj0gLTE7XG4gICAgICBvcnRoeSAqPSAtMTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSBjcDB4ICsgb3J0aHggKiBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIGN5ID0gY3AweSArIG9ydGh5ICogY29ybmVyUmFkaXVzO1xuICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBNYXRoLnBvdyhjeCAtIHgsIDIpICsgTWF0aC5wb3coY3kgLSB5LCAyKTtcblxuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPD0gc3F1YXJlZENvcm5lclJhZGl1cykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRQb2x5Z29uUG9pbnRzKTtcbn07XG52YXIgam9pbkxpbmVzID0gZnVuY3Rpb24gam9pbkxpbmVzKGxpbmVTZXQpIHtcbiAgdmFyIHZlcnRpY2VzID0gbmV3IEFycmF5KGxpbmVTZXQubGVuZ3RoIC8gMik7XG4gIHZhciBjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZO1xuICB2YXIgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLCBuZXh0TGluZUVuZFgsIG5leHRMaW5lRW5kWTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVTZXQubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgY3VycmVudExpbmVTdGFydFggPSBsaW5lU2V0W2kgKiA0XTtcbiAgICBjdXJyZW50TGluZVN0YXJ0WSA9IGxpbmVTZXRbaSAqIDQgKyAxXTtcbiAgICBjdXJyZW50TGluZUVuZFggPSBsaW5lU2V0W2kgKiA0ICsgMl07XG4gICAgY3VycmVudExpbmVFbmRZID0gbGluZVNldFtpICogNCArIDNdO1xuXG4gICAgaWYgKGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQgLSAxKSB7XG4gICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbKGkgKyAxKSAqIDRdO1xuICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMV07XG4gICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgM107XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFswXTtcbiAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsxXTtcbiAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WzNdO1xuICAgIH1cblxuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBmaW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZLCBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZLCB0cnVlKTtcbiAgICB2ZXJ0aWNlc1tpICogMl0gPSBpbnRlcnNlY3Rpb25bMF07XG4gICAgdmVydGljZXNbaSAqIDIgKyAxXSA9IGludGVyc2VjdGlvblsxXTtcbiAgfVxuXG4gIHJldHVybiB2ZXJ0aWNlcztcbn07XG52YXIgZXhwYW5kUG9seWdvbiA9IGZ1bmN0aW9uIGV4cGFuZFBvbHlnb24ocG9pbnRzLCBwYWQpIHtcbiAgdmFyIGV4cGFuZGVkTGluZVNldCA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoICogMik7XG4gIHZhciBjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZLCBuZXh0UG9pbnRYLCBuZXh0UG9pbnRZO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIGN1cnJlbnRQb2ludFggPSBwb2ludHNbaSAqIDJdO1xuICAgIGN1cnJlbnRQb2ludFkgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1swXTtcbiAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbMV07XG4gICAgfSAvLyBDdXJyZW50IGxpbmU6IFtjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZXSB0byBbbmV4dFBvaW50WCwgbmV4dFBvaW50WV1cbiAgICAvLyBBc3N1bWUgQ0NXIHBvbHlnb24gd2luZGluZ1xuXG5cbiAgICB2YXIgb2Zmc2V0WCA9IG5leHRQb2ludFkgLSBjdXJyZW50UG9pbnRZO1xuICAgIHZhciBvZmZzZXRZID0gLShuZXh0UG9pbnRYIC0gY3VycmVudFBvaW50WCk7IC8vIE5vcm1hbGl6ZVxuXG4gICAgdmFyIG9mZnNldExlbmd0aCA9IE1hdGguc3FydChvZmZzZXRYICogb2Zmc2V0WCArIG9mZnNldFkgKiBvZmZzZXRZKTtcbiAgICB2YXIgbm9ybWFsaXplZE9mZnNldFggPSBvZmZzZXRYIC8gb2Zmc2V0TGVuZ3RoO1xuICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WSA9IG9mZnNldFkgLyBvZmZzZXRMZW5ndGg7XG4gICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0XSA9IGN1cnJlbnRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAxXSA9IGN1cnJlbnRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAyXSA9IG5leHRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAzXSA9IG5leHRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgfVxuXG4gIHJldHVybiBleHBhbmRlZExpbmVTZXQ7XG59O1xudmFyIGludGVyc2VjdExpbmVFbGxpcHNlID0gZnVuY3Rpb24gaW50ZXJzZWN0TGluZUVsbGlwc2UoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgZWxsaXBzZVdyYWRpdXMsIGVsbGlwc2VIcmFkaXVzKSB7XG4gIHZhciBkaXNwWCA9IGNlbnRlclggLSB4O1xuICB2YXIgZGlzcFkgPSBjZW50ZXJZIC0geTtcbiAgZGlzcFggLz0gZWxsaXBzZVdyYWRpdXM7XG4gIGRpc3BZIC89IGVsbGlwc2VIcmFkaXVzO1xuICB2YXIgbGVuID0gTWF0aC5zcXJ0KGRpc3BYICogZGlzcFggKyBkaXNwWSAqIGRpc3BZKTtcbiAgdmFyIG5ld0xlbmd0aCA9IGxlbiAtIDE7XG5cbiAgaWYgKG5ld0xlbmd0aCA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbGVuUHJvcG9ydGlvbiA9IG5ld0xlbmd0aCAvIGxlbjtcbiAgcmV0dXJuIFsoY2VudGVyWCAtIHgpICogbGVuUHJvcG9ydGlvbiArIHgsIChjZW50ZXJZIC0geSkgKiBsZW5Qcm9wb3J0aW9uICsgeV07XG59O1xudmFyIGNoZWNrSW5FbGxpcHNlID0gZnVuY3Rpb24gY2hlY2tJbkVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZykge1xuICB4IC09IGNlbnRlclg7XG4gIHkgLT0gY2VudGVyWTtcbiAgeCAvPSB3aWR0aCAvIDIgKyBwYWRkaW5nO1xuICB5IC89IGhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICByZXR1cm4geCAqIHggKyB5ICogeSA8PSAxO1xufTsgLy8gUmV0dXJucyBpbnRlcnNlY3Rpb25zIG9mIGluY3JlYXNpbmcgZGlzdGFuY2UgZnJvbSBsaW5lJ3Mgc3RhcnQgcG9pbnRcblxudmFyIGludGVyc2VjdExpbmVDaXJjbGUgPSBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgxLCB5MSwgeDIsIHkyLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMpIHtcbiAgLy8gQ2FsY3VsYXRlIGQsIGRpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICB2YXIgZCA9IFt4MiAtIHgxLCB5MiAtIHkxXTsgLy8gRGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG5cbiAgdmFyIGYgPSBbeDEgLSBjZW50ZXJYLCB5MSAtIGNlbnRlclldO1xuICB2YXIgYSA9IGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV07XG4gIHZhciBiID0gMiAqIChmWzBdICogZFswXSArIGZbMV0gKiBkWzFdKTtcbiAgdmFyIGMgPSBmWzBdICogZlswXSArIGZbMV0gKiBmWzFdIC0gcmFkaXVzICogcmFkaXVzO1xuICB2YXIgZGlzY3JpbWluYW50ID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgdDEgPSAoLWIgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICB2YXIgdE1pbiA9IE1hdGgubWluKHQxLCB0Mik7XG4gIHZhciB0TWF4ID0gTWF0aC5tYXgodDEsIHQyKTtcbiAgdmFyIGluUmFuZ2VQYXJhbXMgPSBbXTtcblxuICBpZiAodE1pbiA+PSAwICYmIHRNaW4gPD0gMSkge1xuICAgIGluUmFuZ2VQYXJhbXMucHVzaCh0TWluKTtcbiAgfVxuXG4gIGlmICh0TWF4ID49IDAgJiYgdE1heCA8PSAxKSB7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNYXgpO1xuICB9XG5cbiAgaWYgKGluUmFuZ2VQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG5lYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMF0gKyB4MTtcbiAgdmFyIG5lYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMV0gKyB5MTtcblxuICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKGluUmFuZ2VQYXJhbXNbMF0gPT0gaW5SYW5nZVBhcmFtc1sxXSkge1xuICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzBdICsgeDE7XG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWSA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzFdICsgeTE7XG4gICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWSwgZmFySW50ZXJzZWN0aW9uWCwgZmFySW50ZXJzZWN0aW9uWV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZXTtcbiAgfVxufTtcbnZhciBtaWRPZlRocmVlID0gZnVuY3Rpb24gbWlkT2ZUaHJlZShhLCBiLCBjKSB7XG4gIGlmIChiIDw9IGEgJiYgYSA8PSBjIHx8IGMgPD0gYSAmJiBhIDw9IGIpIHtcbiAgICByZXR1cm4gYTtcbiAgfSBlbHNlIGlmIChhIDw9IGIgJiYgYiA8PSBjIHx8IGMgPD0gYiAmJiBiIDw9IGEpIHtcbiAgICByZXR1cm4gYjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYztcbiAgfVxufTsgLy8gKHgxLHkxKT0+KHgyLHkyKSBpbnRlcnNlY3Qgd2l0aCAoeDMseTMpPT4oeDQseTQpXG5cbnZhciBmaW5pdGVMaW5lc0ludGVyc2VjdCA9IGZ1bmN0aW9uIGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgaW5maW5pdGVMaW5lcykge1xuICB2YXIgZHgxMyA9IHgxIC0geDM7XG4gIHZhciBkeDIxID0geDIgLSB4MTtcbiAgdmFyIGR4NDMgPSB4NCAtIHgzO1xuICB2YXIgZHkxMyA9IHkxIC0geTM7XG4gIHZhciBkeTIxID0geTIgLSB5MTtcbiAgdmFyIGR5NDMgPSB5NCAtIHkzO1xuICB2YXIgdWFfdCA9IGR4NDMgKiBkeTEzIC0gZHk0MyAqIGR4MTM7XG4gIHZhciB1Yl90ID0gZHgyMSAqIGR5MTMgLSBkeTIxICogZHgxMztcbiAgdmFyIHVfYiA9IGR5NDMgKiBkeDIxIC0gZHg0MyAqIGR5MjE7XG5cbiAgaWYgKHVfYiAhPT0gMCkge1xuICAgIHZhciB1YSA9IHVhX3QgLyB1X2I7XG4gICAgdmFyIHViID0gdWJfdCAvIHVfYjtcbiAgICB2YXIgZmxwdFRocmVzaG9sZCA9IDAuMDAxO1xuXG4gICAgdmFyIF9taW4gPSAwIC0gZmxwdFRocmVzaG9sZDtcblxuICAgIHZhciBfbWF4ID0gMSArIGZscHRUaHJlc2hvbGQ7XG5cbiAgICBpZiAoX21pbiA8PSB1YSAmJiB1YSA8PSBfbWF4ICYmIF9taW4gPD0gdWIgJiYgdWIgPD0gX21heCkge1xuICAgICAgcmV0dXJuIFt4MSArIHVhICogZHgyMSwgeTEgKyB1YSAqIGR5MjFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWluZmluaXRlTGluZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt4MSArIHVhICogZHgyMSwgeTEgKyB1YSAqIGR5MjFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodWFfdCA9PT0gMCB8fCB1Yl90ID09PSAwKSB7XG4gICAgICAvLyBQYXJhbGxlbCwgY29pbmNpZGVudCBsaW5lcy4gQ2hlY2sgaWYgb3ZlcmxhcFxuICAgICAgLy8gQ2hlY2sgZW5kcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAgICAgIGlmIChtaWRPZlRocmVlKHgxLCB4MiwgeDQpID09PSB4NCkge1xuICAgICAgICByZXR1cm4gW3g0LCB5NF07XG4gICAgICB9IC8vIENoZWNrIHN0YXJ0IHBvaW50IG9mIHNlY29uZCBsaW5lXG5cblxuICAgICAgaWYgKG1pZE9mVGhyZWUoeDEsIHgyLCB4MykgPT09IHgzKSB7XG4gICAgICAgIHJldHVybiBbeDMsIHkzXTtcbiAgICAgIH0gLy8gRW5kcG9pbnQgb2YgZmlyc3QgbGluZVxuXG5cbiAgICAgIGlmIChtaWRPZlRocmVlKHgzLCB4NCwgeDIpID09PSB4Mikge1xuICAgICAgICByZXR1cm4gW3gyLCB5Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUGFyYWxsZWwsIG5vbi1jb2luY2lkZW50XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59OyAvLyBtYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKCB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nIClcbi8vIGludGVyc2VjdCBhIG5vZGUgcG9seWdvbiAocHRzIHRyYW5zZm9ybWVkKVxuLy9cbi8vIG1hdGgucG9seWdvbkludGVyc2VjdExpbmUoIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclkgKVxuLy8gaW50ZXJzZWN0IHRoZSBwb2ludHMgKG5vIHRyYW5zZm9ybSlcblxudmFyIHBvbHlnb25JbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICB2YXIgaW50ZXJzZWN0aW9uO1xuICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuICB2YXIgZG9UcmFuc2Zvcm0gPSB0cnVlO1xuXG4gIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgZG9UcmFuc2Zvcm0gPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBwb2ludHM7XG5cbiAgaWYgKGRvVHJhbnNmb3JtKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IGJhc2VQb2ludHNbaSAqIDJdICogd2lkdGggKyBjZW50ZXJYO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGhlaWdodCArIGNlbnRlclk7XG4gICAgfVxuXG4gICAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gZXhwYW5kUG9seWdvbih0cmFuc2Zvcm1lZFBvaW50cywgLXBhZGRpbmcpO1xuICAgICAgcG9pbnRzID0gam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBiYXNlUG9pbnRzO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBvaW50cy5sZW5ndGggLyAyOyBfaTIrKykge1xuICAgIGN1cnJlbnRYID0gcG9pbnRzW19pMiAqIDJdO1xuICAgIGN1cnJlbnRZID0gcG9pbnRzW19pMiAqIDIgKyAxXTtcblxuICAgIGlmIChfaTIgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgIG5leHRYID0gcG9pbnRzWyhfaTIgKyAxKSAqIDJdO1xuICAgICAgbmV4dFkgPSBwb2ludHNbKF9pMiArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0WCA9IHBvaW50c1swXTtcbiAgICAgIG5leHRZID0gcG9pbnRzWzFdO1xuICAgIH1cblxuICAgIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIGNlbnRlclgsIGNlbnRlclksIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZKTtcblxuICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufTtcbnZhciByb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gcm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gIHZhciBpbnRlcnNlY3Rpb247XG4gIHZhciBsaW5lcyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VQb2ludHMubGVuZ3RoIC8gNDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZVV2ID0gdm9pZCAwLFxuICAgICAgICBkZXN0VXYgPSB2b2lkIDA7XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgc291cmNlVXYgPSBiYXNlUG9pbnRzLmxlbmd0aCAtIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZVV2ID0gaSAqIDQgLSAyO1xuICAgIH1cblxuICAgIGRlc3RVdiA9IGkgKiA0ICsgMjtcbiAgICB2YXIgcHggPSBjZW50ZXJYICsgaGFsZlcgKiBiYXNlUG9pbnRzW2kgKiA0XTtcbiAgICB2YXIgcHkgPSBjZW50ZXJZICsgaGFsZkggKiBiYXNlUG9pbnRzW2kgKiA0ICsgMV07XG4gICAgdmFyIGNvc1RoZXRhID0gLWJhc2VQb2ludHNbc291cmNlVXZdICogYmFzZVBvaW50c1tkZXN0VXZdIC0gYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcbiAgICB2YXIgb2Zmc2V0ID0gY29ybmVyUmFkaXVzIC8gTWF0aC50YW4oTWF0aC5hY29zKGNvc1RoZXRhKSAvIDIpO1xuICAgIHZhciBjcDB4ID0gcHggLSBvZmZzZXQgKiBiYXNlUG9pbnRzW3NvdXJjZVV2XTtcbiAgICB2YXIgY3AweSA9IHB5IC0gb2Zmc2V0ICogYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgIHZhciBjcDF4ID0gcHggKyBvZmZzZXQgKiBiYXNlUG9pbnRzW2Rlc3RVdl07XG4gICAgdmFyIGNwMXkgPSBweSArIG9mZnNldCAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgbGluZXNbYmFzZVBvaW50cy5sZW5ndGggLSAyXSA9IGNwMHg7XG4gICAgICBsaW5lc1tiYXNlUG9pbnRzLmxlbmd0aCAtIDFdID0gY3AweTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZXNbaSAqIDQgLSAyXSA9IGNwMHg7XG4gICAgICBsaW5lc1tpICogNCAtIDFdID0gY3AweTtcbiAgICB9XG5cbiAgICBsaW5lc1tpICogNF0gPSBjcDF4O1xuICAgIGxpbmVzW2kgKiA0ICsgMV0gPSBjcDF5O1xuICAgIHZhciBvcnRoeCA9IGJhc2VQb2ludHNbc291cmNlVXYgKyAxXTtcbiAgICB2YXIgb3J0aHkgPSAtYmFzZVBvaW50c1tzb3VyY2VVdl07XG4gICAgdmFyIGNvc0FscGhhID0gb3J0aHggKiBiYXNlUG9pbnRzW2Rlc3RVdl0gKyBvcnRoeSAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG5cbiAgICBpZiAoY29zQWxwaGEgPCAwKSB7XG4gICAgICBvcnRoeCAqPSAtMTtcbiAgICAgIG9ydGh5ICo9IC0xO1xuICAgIH1cblxuICAgIHZhciBjeCA9IGNwMHggKyBvcnRoeCAqIGNvcm5lclJhZGl1cztcbiAgICB2YXIgY3kgPSBjcDB5ICsgb3J0aHkgKiBjb3JuZXJSYWRpdXM7XG4gICAgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBjeCwgY3ksIGNvcm5lclJhZGl1cyk7XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBsaW5lcy5sZW5ndGggLyA0OyBfaTMrKykge1xuICAgIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIGNlbnRlclgsIGNlbnRlclksIGxpbmVzW19pMyAqIDRdLCBsaW5lc1tfaTMgKiA0ICsgMV0sIGxpbmVzW19pMyAqIDQgKyAyXSwgbGluZXNbX2kzICogNCArIDNdLCBmYWxzZSk7XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPiAyKSB7XG4gICAgdmFyIGxvd2VzdEludGVyc2VjdGlvbiA9IFtpbnRlcnNlY3Rpb25zWzBdLCBpbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB2YXIgbG93ZXN0U3F1YXJlZERpc3RhbmNlID0gTWF0aC5wb3cobG93ZXN0SW50ZXJzZWN0aW9uWzBdIC0geCwgMikgKyBNYXRoLnBvdyhsb3dlc3RJbnRlcnNlY3Rpb25bMV0gLSB5LCAyKTtcblxuICAgIGZvciAodmFyIF9pNCA9IDE7IF9pNCA8IGludGVyc2VjdGlvbnMubGVuZ3RoIC8gMjsgX2k0KyspIHtcbiAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBNYXRoLnBvdyhpbnRlcnNlY3Rpb25zW19pNCAqIDJdIC0geCwgMikgKyBNYXRoLnBvdyhpbnRlcnNlY3Rpb25zW19pNCAqIDIgKyAxXSAtIHksIDIpO1xuXG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDw9IGxvd2VzdFNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgICBsb3dlc3RJbnRlcnNlY3Rpb25bMF0gPSBpbnRlcnNlY3Rpb25zW19pNCAqIDJdO1xuICAgICAgICBsb3dlc3RJbnRlcnNlY3Rpb25bMV0gPSBpbnRlcnNlY3Rpb25zW19pNCAqIDIgKyAxXTtcbiAgICAgICAgbG93ZXN0U3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsb3dlc3RJbnRlcnNlY3Rpb247XG4gIH1cblxuICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbn07XG52YXIgc2hvcnRlbkludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9uLCBvZmZzZXQsIGFtb3VudCkge1xuICB2YXIgZGlzcCA9IFtpbnRlcnNlY3Rpb25bMF0gLSBvZmZzZXRbMF0sIGludGVyc2VjdGlvblsxXSAtIG9mZnNldFsxXV07XG4gIHZhciBsZW5ndGggPSBNYXRoLnNxcnQoZGlzcFswXSAqIGRpc3BbMF0gKyBkaXNwWzFdICogZGlzcFsxXSk7XG4gIHZhciBsZW5SYXRpbyA9IChsZW5ndGggLSBhbW91bnQpIC8gbGVuZ3RoO1xuXG4gIGlmIChsZW5SYXRpbyA8IDApIHtcbiAgICBsZW5SYXRpbyA9IDAuMDAwMDE7XG4gIH1cblxuICByZXR1cm4gW29mZnNldFswXSArIGxlblJhdGlvICogZGlzcFswXSwgb2Zmc2V0WzFdICsgbGVuUmF0aW8gKiBkaXNwWzFdXTtcbn07XG52YXIgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlID0gZnVuY3Rpb24gZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgdmFyIHBvaW50cyA9IGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoc2lkZXMsIHJvdGF0aW9uUmFkaWFucyk7XG4gIHBvaW50cyA9IGZpdFBvbHlnb25Ub1NxdWFyZShwb2ludHMpO1xuICByZXR1cm4gcG9pbnRzO1xufTtcbnZhciBmaXRQb2x5Z29uVG9TcXVhcmUgPSBmdW5jdGlvbiBmaXRQb2x5Z29uVG9TcXVhcmUocG9pbnRzKSB7XG4gIHZhciB4LCB5O1xuICB2YXIgc2lkZXMgPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgdmFyIG1pblggPSBJbmZpbml0eSxcbiAgICAgIG1pblkgPSBJbmZpbml0eSxcbiAgICAgIG1heFggPSAtSW5maW5pdHksXG4gICAgICBtYXhZID0gLUluZmluaXR5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgIHggPSBwb2ludHNbMiAqIGldO1xuICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXTtcbiAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gIH0gLy8gc3RyZXRjaCBmYWN0b3JzXG5cblxuICB2YXIgc3ggPSAyIC8gKG1heFggLSBtaW5YKTtcbiAgdmFyIHN5ID0gMiAvIChtYXhZIC0gbWluWSk7XG5cbiAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgc2lkZXM7IF9pNSsrKSB7XG4gICAgeCA9IHBvaW50c1syICogX2k1XSA9IHBvaW50c1syICogX2k1XSAqIHN4O1xuICAgIHkgPSBwb2ludHNbMiAqIF9pNSArIDFdID0gcG9pbnRzWzIgKiBfaTUgKyAxXSAqIHN5O1xuICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgfVxuXG4gIGlmIChtaW5ZIDwgLTEpIHtcbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBzaWRlczsgX2k2KyspIHtcbiAgICAgIHkgPSBwb2ludHNbMiAqIF9pNiArIDFdID0gcG9pbnRzWzIgKiBfaTYgKyAxXSArICgtMSAtIG1pblkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59O1xudmFyIGdlbmVyYXRlVW5pdE5nb25Qb2ludHMgPSBmdW5jdGlvbiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgdmFyIGluY3JlbWVudCA9IDEuMCAvIHNpZGVzICogMiAqIE1hdGguUEk7XG4gIHZhciBzdGFydEFuZ2xlID0gc2lkZXMgJSAyID09PSAwID8gTWF0aC5QSSAvIDIuMCArIGluY3JlbWVudCAvIDIuMCA6IE1hdGguUEkgLyAyLjA7XG4gIHN0YXJ0QW5nbGUgKz0gcm90YXRpb25SYWRpYW5zO1xuICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KHNpZGVzICogMik7XG4gIHZhciBjdXJyZW50QW5nbGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgY3VycmVudEFuZ2xlID0gaSAqIGluY3JlbWVudCArIHN0YXJ0QW5nbGU7XG4gICAgcG9pbnRzWzIgKiBpXSA9IE1hdGguY29zKGN1cnJlbnRBbmdsZSk7IC8vIHhcblxuICAgIHBvaW50c1syICogaSArIDFdID0gTWF0aC5zaW4oLWN1cnJlbnRBbmdsZSk7IC8vIHlcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59OyAvLyBTZXQgdGhlIGRlZmF1bHQgcmFkaXVzLCB1bmxlc3MgaGFsZiBvZiB3aWR0aCBvciBoZWlnaHQgaXMgc21hbGxlciB0aGFuIGRlZmF1bHRcblxudmFyIGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzID0gZnVuY3Rpb24gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gTWF0aC5taW4od2lkdGggLyA0LCBoZWlnaHQgLyA0LCA4KTtcbn07IC8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXNcblxudmFyIGdldFJvdW5kUG9seWdvblJhZGl1cyA9IGZ1bmN0aW9uIGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDEwLCBoZWlnaHQgLyAxMCwgOCk7XG59O1xudmFyIGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCA9IGZ1bmN0aW9uIGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpIHtcbiAgcmV0dXJuIDg7XG59O1xudmFyIGJlemllclB0c1RvUXVhZENvZWZmID0gZnVuY3Rpb24gYmV6aWVyUHRzVG9RdWFkQ29lZmYocDAsIHAxLCBwMikge1xuICByZXR1cm4gW3AwIC0gMiAqIHAxICsgcDIsIDIgKiAocDEgLSBwMCksIHAwXTtcbn07IC8vIGdldCBjdXJ2ZSB3aWR0aCwgaGVpZ2h0LCBhbmQgY29udHJvbCBwb2ludCBwb3NpdGlvbiBvZmZzZXRzIGFzIGEgcGVyY2VudGFnZSBvZiBub2RlIGhlaWdodCAvIHdpZHRoXG5cbnZhciBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyA9IGZ1bmN0aW9uIGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIHtcbiAgICBoZWlnaHRPZmZzZXQ6IE1hdGgubWluKDE1LCAwLjA1ICogaGVpZ2h0KSxcbiAgICB3aWR0aE9mZnNldDogTWF0aC5taW4oMTAwLCAwLjI1ICogd2lkdGgpLFxuICAgIGN0cmxQdE9mZnNldFBjdDogMC4wNVxuICB9O1xufTtcblxudmFyIHBhZ2VSYW5rRGVmYXVsdHMgPSBkZWZhdWx0cyh7XG4gIGRhbXBpbmdGYWN0b3I6IDAuOCxcbiAgcHJlY2lzaW9uOiAwLjAwMDAwMSxcbiAgaXRlcmF0aW9uczogMjAwLFxuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0pO1xudmFyIGVsZXNmbiQ3ID0ge1xuICBwYWdlUmFuazogZnVuY3Rpb24gcGFnZVJhbmsob3B0aW9ucykge1xuICAgIHZhciBfcGFnZVJhbmtEZWZhdWx0cyA9IHBhZ2VSYW5rRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICAgIGRhbXBpbmdGYWN0b3IgPSBfcGFnZVJhbmtEZWZhdWx0cy5kYW1waW5nRmFjdG9yLFxuICAgICAgICBwcmVjaXNpb24gPSBfcGFnZVJhbmtEZWZhdWx0cy5wcmVjaXNpb24sXG4gICAgICAgIGl0ZXJhdGlvbnMgPSBfcGFnZVJhbmtEZWZhdWx0cy5pdGVyYXRpb25zLFxuICAgICAgICB3ZWlnaHQgPSBfcGFnZVJhbmtEZWZhdWx0cy53ZWlnaHQ7XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG5cbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIG51bU5vZGVzU3FkID0gbnVtTm9kZXMgKiBudW1Ob2RlcztcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7IC8vIENvbnN0cnVjdCB0cmFuc3Bvc2VkIGFkamFjZW5jeSBtYXRyaXhcbiAgICAvLyBGaXJzdCBsZXRzIGhhdmUgYSB6ZXJvZWQgbWF0cml4IG9mIHRoZSByaWdodCBzaXplXG4gICAgLy8gV2UnbGwgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBzdW0gb2YgZWFjaCBjb2x1bW5cblxuICAgIHZhciBtYXRyaXggPSBuZXcgQXJyYXkobnVtTm9kZXNTcWQpO1xuICAgIHZhciBjb2x1bW5TdW0gPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciBhZGRpdGlvbmFsUHJvYiA9ICgxIC0gZGFtcGluZ0ZhY3RvcikgLyBudW1Ob2RlczsgLy8gQ3JlYXRlIG51bGwgbWF0cml4XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICB2YXIgbiA9IGkgKiBudW1Ob2RlcyArIGo7XG4gICAgICAgIG1hdHJpeFtuXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbHVtblN1bVtpXSA9IDA7XG4gICAgfSAvLyBOb3csIHByb2Nlc3MgZWRnZXNcblxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bUVkZ2VzOyBfaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW19pXTtcbiAgICAgIHZhciBzcmNJZCA9IGVkZ2UuZGF0YSgnc291cmNlJyk7XG4gICAgICB2YXIgdGd0SWQgPSBlZGdlLmRhdGEoJ3RhcmdldCcpOyAvLyBEb24ndCBpbmNsdWRlIGxvb3BzIGluIHRoZSBtYXRyaXhcblxuICAgICAgaWYgKHNyY0lkID09PSB0Z3RJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHMgPSBub2Rlcy5pbmRleE9mSWQoc3JjSWQpO1xuICAgICAgdmFyIHQgPSBub2Rlcy5pbmRleE9mSWQodGd0SWQpO1xuICAgICAgdmFyIHcgPSB3ZWlnaHQoZWRnZSk7XG5cbiAgICAgIHZhciBfbiA9IHQgKiBudW1Ob2RlcyArIHM7IC8vIFVwZGF0ZSBtYXRyaXhcblxuXG4gICAgICBtYXRyaXhbX25dICs9IHc7IC8vIFVwZGF0ZSBjb2x1bW4gc3VtXG5cbiAgICAgIGNvbHVtblN1bVtzXSArPSB3O1xuICAgIH0gLy8gQWRkIGFkZGl0aW9uYWwgcHJvYmFiaWxpdHkgYmFzZWQgb24gZGFtcGluZyBmYWN0b3JcbiAgICAvLyBBbHNvLCB0YWtlIGludG8gYWNjb3VudCBjb2x1bW5zIHRoYXQgaGF2ZSBzdW0gPSAwXG5cblxuICAgIHZhciBwID0gMS4wIC8gbnVtTm9kZXMgKyBhZGRpdGlvbmFsUHJvYjsgLy8gU2hvcnRoYW5kXG4gICAgLy8gVHJhdmVyc2UgbWF0cml4LCBjb2x1bW4gYnkgY29sdW1uXG5cbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbnVtTm9kZXM7IF9qKyspIHtcbiAgICAgIGlmIChjb2x1bW5TdW1bX2pdID09PSAwKSB7XG4gICAgICAgIC8vIE5vICdsaW5rcycgb3V0IGZyb20gbm9kZSBqdGgsIGFzc3VtZSBlcXVhbCBwcm9iYWJpbGl0eSBmb3IgZWFjaCBwb3NzaWJsZSBub2RlXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG51bU5vZGVzOyBfaTIrKykge1xuICAgICAgICAgIHZhciBfbjIgPSBfaTIgKiBudW1Ob2RlcyArIF9qO1xuXG4gICAgICAgICAgbWF0cml4W19uMl0gPSBwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb2RlIGp0aCBoYXMgb3V0Z29pbmcgbGluaywgY29tcHV0ZSBub3JtYWxpemVkIHByb2JhYmlsaXRpZXNcbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbnVtTm9kZXM7IF9pMysrKSB7XG4gICAgICAgICAgdmFyIF9uMyA9IF9pMyAqIG51bU5vZGVzICsgX2o7XG5cbiAgICAgICAgICBtYXRyaXhbX24zXSA9IG1hdHJpeFtfbjNdIC8gY29sdW1uU3VtW19qXSArIGFkZGl0aW9uYWxQcm9iO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBDb21wdXRlIGRvbWluYW50IGVpZ2VudmVjdG9yIHVzaW5nIHBvd2VyIG1ldGhvZFxuXG5cbiAgICB2YXIgZWlnZW52ZWN0b3IgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciB0ZW1wID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgcHJldmlvdXM7IC8vIFN0YXJ0IHdpdGggYSB2ZWN0b3Igb2YgYWxsIDEnc1xuICAgIC8vIEFsc28sIGluaXRpYWxpemUgYSBudWxsIHZlY3RvciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgc2hvcnRoYW5kXG5cbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBudW1Ob2RlczsgX2k0KyspIHtcbiAgICAgIGVpZ2VudmVjdG9yW19pNF0gPSAxO1xuICAgIH1cblxuICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDwgaXRlcmF0aW9uczsgaXRlcisrKSB7XG4gICAgICAvLyBUZW1wIGFycmF5IHdpdGggYWxsIDAnc1xuICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbnVtTm9kZXM7IF9pNSsrKSB7XG4gICAgICAgIHRlbXBbX2k1XSA9IDA7XG4gICAgICB9IC8vIE11bHRpcGx5IG1hdHJpeCB3aXRoIHByZXZpb3VzIHJlc3VsdFxuXG5cbiAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG51bU5vZGVzOyBfaTYrKykge1xuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBudW1Ob2RlczsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgX240ID0gX2k2ICogbnVtTm9kZXMgKyBfajI7XG5cbiAgICAgICAgICB0ZW1wW19pNl0gKz0gbWF0cml4W19uNF0gKiBlaWdlbnZlY3RvcltfajJdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluUGxhY2VTdW1Ob3JtYWxpemUodGVtcCk7XG4gICAgICBwcmV2aW91cyA9IGVpZ2VudmVjdG9yO1xuICAgICAgZWlnZW52ZWN0b3IgPSB0ZW1wO1xuICAgICAgdGVtcCA9IHByZXZpb3VzO1xuICAgICAgdmFyIGRpZmYgPSAwOyAvLyBDb21wdXRlIGRpZmZlcmVuY2UgKHNxdWFyZWQgbW9kdWxlKSBvZiBib3RoIHZlY3RvcnNcblxuICAgICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgbnVtTm9kZXM7IF9pNysrKSB7XG4gICAgICAgIHZhciBkZWx0YSA9IHByZXZpb3VzW19pN10gLSBlaWdlbnZlY3RvcltfaTddO1xuICAgICAgICBkaWZmICs9IGRlbHRhICogZGVsdGE7XG4gICAgICB9IC8vIElmIGRpZmZlcmVuY2UgaXMgbGVzcyB0aGFuIHRoZSBkZXNpcmVkIHRocmVzaG9sZCwgc3RvcCBpdGVyYXRpbmdcblxuXG4gICAgICBpZiAoZGlmZiA8IHByZWNpc2lvbikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIENvbnN0cnVjdCByZXN1bHRcblxuXG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIHJhbms6IGZ1bmN0aW9uIHJhbmsobm9kZSkge1xuICAgICAgICBub2RlID0gY3kuY29sbGVjdGlvbihub2RlKVswXTtcbiAgICAgICAgcmV0dXJuIGVpZ2VudmVjdG9yW25vZGVzLmluZGV4T2Yobm9kZSldO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBwYWdlUmFua1xuXG59OyAvLyBlbGVzZm5cblxudmFyIGRlZmF1bHRzJDEgPSBkZWZhdWx0cyh7XG4gIHJvb3Q6IG51bGwsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgZGlyZWN0ZWQ6IGZhbHNlLFxuICBhbHBoYTogMFxufSk7XG52YXIgZWxlc2ZuJDggPSB7XG4gIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzJDEob3B0aW9ucyk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAoIW9wdGlvbnMuZGlyZWN0ZWQpIHtcbiAgICAgIHZhciBkZWdyZWVzID0ge307XG4gICAgICB2YXIgbWF4RGVncmVlID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07IC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eVxuXG4gICAgICAgIG9wdGlvbnMucm9vdCA9IG5vZGU7XG4gICAgICAgIHZhciBjdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChtYXhEZWdyZWUgPCBjdXJyRGVncmVlLmRlZ3JlZSkge1xuICAgICAgICAgIG1heERlZ3JlZSA9IGN1cnJEZWdyZWUuZGVncmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogZnVuY3Rpb24gZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4RGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkZWdyZWVzW25vZGUuaWQoKV0gLyBtYXhEZWdyZWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpbmRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBvdXRkZWdyZWVzID0ge307XG4gICAgICB2YXIgbWF4SW5kZWdyZWUgPSAwO1xuICAgICAgdmFyIG1heE91dGRlZ3JlZSA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudW1Ob2RlczsgX2krKykge1xuICAgICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG5cbiAgICAgICAgdmFyIGlkID0gX25vZGUuaWQoKTsgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG5cblxuICAgICAgICBvcHRpb25zLnJvb3QgPSBfbm9kZTtcblxuICAgICAgICB2YXIgX2N1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG1heEluZGVncmVlIDwgX2N1cnJEZWdyZWUuaW5kZWdyZWUpIG1heEluZGVncmVlID0gX2N1cnJEZWdyZWUuaW5kZWdyZWU7XG4gICAgICAgIGlmIChtYXhPdXRkZWdyZWUgPCBfY3VyckRlZ3JlZS5vdXRkZWdyZWUpIG1heE91dGRlZ3JlZSA9IF9jdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgICAgaW5kZWdyZWVzW2lkXSA9IF9jdXJyRGVncmVlLmluZGVncmVlO1xuICAgICAgICBvdXRkZWdyZWVzW2lkXSA9IF9jdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZWdyZWU6IGZ1bmN0aW9uIGluZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4SW5kZWdyZWUgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5kZWdyZWVzW25vZGUuaWQoKV0gLyBtYXhJbmRlZ3JlZTtcbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZGVncmVlOiBmdW5jdGlvbiBvdXRkZWdyZWUobm9kZSkge1xuICAgICAgICAgIGlmIChtYXhPdXRkZWdyZWUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG91dGRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heE91dGRlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIC8vIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkXG4gIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiBPcHNhaGwncyBwYXBlclxuICAvLyBcIk5vZGUgY2VudHJhbGl0eSBpbiB3ZWlnaHRlZCBuZXR3b3JrczogR2VuZXJhbGl6aW5nIGRlZ3JlZSBhbmQgc2hvcnRlc3QgcGF0aHNcIlxuICAvLyBjaGVjayB0aGUgaGVhZGluZyAyIFwiRGVncmVlXCJcbiAgZGVncmVlQ2VudHJhbGl0eTogZnVuY3Rpb24gZGVncmVlQ2VudHJhbGl0eShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzJDEob3B0aW9ucyk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBjYWxsaW5nRWxlcyA9IHRoaXM7XG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgcm9vdCA9IF9vcHRpb25zLnJvb3QsXG4gICAgICAgIHdlaWdodCA9IF9vcHRpb25zLndlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQgPSBfb3B0aW9ucy5kaXJlY3RlZCxcbiAgICAgICAgYWxwaGEgPSBfb3B0aW9ucy5hbHBoYTtcbiAgICByb290ID0gY3kuY29sbGVjdGlvbihyb290KVswXTtcblxuICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgIHZhciBjb25uRWRnZXMgPSByb290LmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGNhbGxpbmdFbGVzKTtcbiAgICAgIHZhciBrID0gY29ubkVkZ2VzLmxlbmd0aDtcbiAgICAgIHZhciBzID0gMDsgLy8gTm93LCBzdW0gZWRnZSB3ZWlnaHRzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ubkVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHMgKz0gd2VpZ2h0KGNvbm5FZGdlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogTWF0aC5wb3coaywgMSAtIGFscGhhKSAqIE1hdGgucG93KHMsIGFscGhhKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgdmFyIGluY29taW5nID0gZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLnRhcmdldCgpLnNhbWUocm9vdCkgJiYgY2FsbGluZ0VsZXMuaGFzKGVkZ2UpO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3V0Z29pbmcgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2Uuc291cmNlKCkuc2FtZShyb290KSAmJiBjYWxsaW5nRWxlcy5oYXMoZWRnZSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBrX2luID0gaW5jb21pbmcubGVuZ3RoO1xuICAgICAgdmFyIGtfb3V0ID0gb3V0Z29pbmcubGVuZ3RoO1xuICAgICAgdmFyIHNfaW4gPSAwO1xuICAgICAgdmFyIHNfb3V0ID0gMDsgLy8gTm93LCBzdW0gaW5jb21pbmcgZWRnZSB3ZWlnaHRzXG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGluY29taW5nLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgc19pbiArPSB3ZWlnaHQoaW5jb21pbmdbX2kyXSk7XG4gICAgICB9IC8vIE5vdywgc3VtIG91dGdvaW5nIGVkZ2Ugd2VpZ2h0c1xuXG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG91dGdvaW5nLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgc19vdXQgKz0gd2VpZ2h0KG91dGdvaW5nW19pM10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRlZ3JlZTogTWF0aC5wb3coa19pbiwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfaW4sIGFscGhhKSxcbiAgICAgICAgb3V0ZGVncmVlOiBNYXRoLnBvdyhrX291dCwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfb3V0LCBhbHBoYSlcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIGRlZ3JlZUNlbnRyYWxpdHlcblxufTsgLy8gZWxlc2ZuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5cbmVsZXNmbiQ4LmRjID0gZWxlc2ZuJDguZGVncmVlQ2VudHJhbGl0eTtcbmVsZXNmbiQ4LmRjbiA9IGVsZXNmbiQ4LmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpc2VkID0gZWxlc2ZuJDguZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbnZhciBkZWZhdWx0cyQyID0gZGVmYXVsdHMoe1xuICBoYXJtb25pYzogdHJ1ZSxcbiAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZSxcbiAgcm9vdDogbnVsbFxufSk7XG52YXIgZWxlc2ZuJDkgPSB7XG4gIGNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiBjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZChvcHRpb25zKSB7XG4gICAgdmFyIF9kZWZhdWx0cyA9IGRlZmF1bHRzJDIob3B0aW9ucyksXG4gICAgICAgIGhhcm1vbmljID0gX2RlZmF1bHRzLmhhcm1vbmljLFxuICAgICAgICB3ZWlnaHQgPSBfZGVmYXVsdHMud2VpZ2h0LFxuICAgICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0cy5kaXJlY3RlZDtcblxuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgY2xvc2VuZXNzZXMgPSB7fTtcbiAgICB2YXIgbWF4Q2xvc2VuZXNzID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGZ3ID0gdGhpcy5mbG95ZFdhcnNoYWxsKHtcbiAgICAgIHdlaWdodDogd2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQ6IGRpcmVjdGVkXG4gICAgfSk7IC8vIENvbXB1dGUgY2xvc2VuZXNzIGZvciBldmVyeSBub2RlIGFuZCBmaW5kIHRoZSBtYXhpbXVtIGNsb3NlbmVzc1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1cnJDbG9zZW5lc3MgPSAwO1xuICAgICAgdmFyIG5vZGVfaSA9IG5vZGVzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgdmFyIGQgPSBmdy5kaXN0YW5jZShub2RlX2ksIG5vZGVzW2pdKTtcblxuICAgICAgICAgIGlmIChoYXJtb25pYykge1xuICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSAxIC8gZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWhhcm1vbmljKSB7XG4gICAgICAgIGN1cnJDbG9zZW5lc3MgPSAxIC8gY3VyckNsb3NlbmVzcztcbiAgICAgIH1cblxuICAgICAgaWYgKG1heENsb3NlbmVzcyA8IGN1cnJDbG9zZW5lc3MpIHtcbiAgICAgICAgbWF4Q2xvc2VuZXNzID0gY3VyckNsb3NlbmVzcztcbiAgICAgIH1cblxuICAgICAgY2xvc2VuZXNzZXNbbm9kZV9pLmlkKCldID0gY3VyckNsb3NlbmVzcztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2xvc2VuZXNzOiBmdW5jdGlvbiBjbG9zZW5lc3Mobm9kZSkge1xuICAgICAgICBpZiAobWF4Q2xvc2VuZXNzID09IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKVswXS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9zZW5lc3Nlc1tub2RlXSAvIG1heENsb3NlbmVzcztcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgY2xvc2VuZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24gY2xvc2VuZXNzQ2VudHJhbGl0eShvcHRpb25zKSB7XG4gICAgdmFyIF9kZWZhdWx0czIgPSBkZWZhdWx0cyQyKG9wdGlvbnMpLFxuICAgICAgICByb290ID0gX2RlZmF1bHRzMi5yb290LFxuICAgICAgICB3ZWlnaHQgPSBfZGVmYXVsdHMyLndlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQgPSBfZGVmYXVsdHMyLmRpcmVjdGVkLFxuICAgICAgICBoYXJtb25pYyA9IF9kZWZhdWx0czIuaGFybW9uaWM7XG5cbiAgICByb290ID0gdGhpcy5maWx0ZXIocm9vdClbMF07IC8vIHdlIG5lZWQgZGlzdGFuY2UgZnJvbSB0aGlzIG5vZGUgdG8gZXZlcnkgb3RoZXIgbm9kZVxuXG4gICAgdmFyIGRpamtzdHJhID0gdGhpcy5kaWprc3RyYSh7XG4gICAgICByb290OiByb290LFxuICAgICAgd2VpZ2h0OiB3ZWlnaHQsXG4gICAgICBkaXJlY3RlZDogZGlyZWN0ZWRcbiAgICB9KTtcbiAgICB2YXIgdG90YWxEaXN0YW5jZSA9IDA7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcblxuICAgICAgaWYgKCFuLnNhbWUocm9vdCkpIHtcbiAgICAgICAgdmFyIGQgPSBkaWprc3RyYS5kaXN0YW5jZVRvKG4pO1xuXG4gICAgICAgIGlmIChoYXJtb25pYykge1xuICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gMSAvIGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWxEaXN0YW5jZSArPSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhcm1vbmljID8gdG90YWxEaXN0YW5jZSA6IDEgLyB0b3RhbERpc3RhbmNlO1xuICB9IC8vIGNsb3NlbmVzc0NlbnRyYWxpdHlcblxufTsgLy8gZWxlc2ZuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5cbmVsZXNmbiQ5LmNjID0gZWxlc2ZuJDkuY2xvc2VuZXNzQ2VudHJhbGl0eTtcbmVsZXNmbiQ5LmNjbiA9IGVsZXNmbiQ5LmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpc2VkID0gZWxlc2ZuJDkuY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbnZhciBkZWZhdWx0cyQzID0gZGVmYXVsdHMoe1xuICB3ZWlnaHQ6IG51bGwsXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJGEgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiB0aGUgcGFwZXIgXCJPbiBWYXJpYW50cyBvZiBTaG9ydGVzdC1QYXRoIEJldHdlZW5uZXNzIENlbnRyYWxpdHkgYW5kIHRoZWlyIEdlbmVyaWMgQ29tcHV0YXRpb25cIiBieSBVbHJpayBCcmFuZGVzXG4gIGJldHdlZW5uZXNzQ2VudHJhbGl0eTogZnVuY3Rpb24gYmV0d2Vlbm5lc3NDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICB2YXIgX2RlZmF1bHRzID0gZGVmYXVsdHMkMyhvcHRpb25zKSxcbiAgICAgICAgZGlyZWN0ZWQgPSBfZGVmYXVsdHMuZGlyZWN0ZWQsXG4gICAgICAgIHdlaWdodCA9IF9kZWZhdWx0cy53ZWlnaHQ7XG5cbiAgICB2YXIgd2VpZ2h0ZWQgPSB3ZWlnaHQgIT0gbnVsbDtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7IC8vIHN0YXJ0aW5nXG5cbiAgICB2YXIgViA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgQSA9IHt9O1xuICAgIHZhciBfQyA9IHt9O1xuICAgIHZhciBtYXggPSAwO1xuICAgIHZhciBDID0ge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWwpIHtcbiAgICAgICAgX0Nba2V5XSA9IHZhbDtcblxuICAgICAgICBpZiAodmFsID4gbWF4KSB7XG4gICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfQ1trZXldO1xuICAgICAgfVxuICAgIH07IC8vIEEgY29udGFpbnMgdGhlIG5laWdoYm9yaG9vZHMgb2YgZXZlcnkgbm9kZVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdiA9IFZbaV07XG4gICAgICB2YXIgdmlkID0gdi5pZCgpO1xuXG4gICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgQVt2aWRdID0gdi5vdXRnb2VycygpLm5vZGVzKCk7IC8vIGdldCBvdXRnb2VycyBvZiBldmVyeSBub2RlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBW3ZpZF0gPSB2Lm9wZW5OZWlnaGJvcmhvb2QoKS5ub2RlcygpOyAvLyBnZXQgbmVpZ2hib3JzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIH1cblxuICAgICAgQy5zZXQodmlkLCAwKTtcbiAgICB9XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChzKSB7XG4gICAgICB2YXIgc2lkID0gVltzXS5pZCgpO1xuICAgICAgdmFyIFMgPSBbXTsgLy8gc3RhY2tcblxuICAgICAgdmFyIFAgPSB7fTtcbiAgICAgIHZhciBnID0ge307XG4gICAgICB2YXIgZCA9IHt9O1xuICAgICAgdmFyIFEgPSBuZXcgSGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZFthXSAtIGRbYl07XG4gICAgICB9KTsgLy8gcXVldWVcbiAgICAgIC8vIGluaXQgZGljdGlvbmFyaWVzXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBWLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX3ZpZCA9IFZbX2ldLmlkKCk7XG5cbiAgICAgICAgUFtfdmlkXSA9IFtdO1xuICAgICAgICBnW192aWRdID0gMDtcbiAgICAgICAgZFtfdmlkXSA9IEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBnW3NpZF0gPSAxOyAvLyBzaWdtYVxuXG4gICAgICBkW3NpZF0gPSAwOyAvLyBkaXN0YW5jZSB0byBzXG5cbiAgICAgIFEucHVzaChzaWQpO1xuXG4gICAgICB3aGlsZSAoIVEuZW1wdHkoKSkge1xuICAgICAgICB2YXIgX3YgPSBRLnBvcCgpO1xuXG4gICAgICAgIFMucHVzaChfdik7XG5cbiAgICAgICAgaWYgKHdlaWdodGVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBBW192XS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHcgPSBBW192XVtqXTtcbiAgICAgICAgICAgIHZhciB2RWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoX3YpO1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmICh2RWxlLmVkZ2VzVG8odykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBlZGdlID0gdkVsZS5lZGdlc1RvKHcpWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWRnZSA9IHcuZWRnZXNUbyh2RWxlKVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVkZ2VXZWlnaHQgPSB3ZWlnaHQoZWRnZSk7XG4gICAgICAgICAgICB3ID0gdy5pZCgpO1xuXG4gICAgICAgICAgICBpZiAoZFt3XSA+IGRbX3ZdICsgZWRnZVdlaWdodCkge1xuICAgICAgICAgICAgICBkW3ddID0gZFtfdl0gKyBlZGdlV2VpZ2h0O1xuXG4gICAgICAgICAgICAgIGlmIChRLm5vZGVzLmluZGV4T2YodykgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy9pZiB3IGlzIG5vdCBpbiBRXG4gICAgICAgICAgICAgICAgUS5wdXNoKHcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiBpZiB3IGlzIGluIFFcbiAgICAgICAgICAgICAgICBRLnVwZGF0ZUl0ZW0odyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBnW3ddID0gMDtcbiAgICAgICAgICAgICAgUFt3XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZFt3XSA9PSBkW192XSArIGVkZ2VXZWlnaHQpIHtcbiAgICAgICAgICAgICAgZ1t3XSA9IGdbd10gKyBnW192XTtcbiAgICAgICAgICAgICAgUFt3XS5wdXNoKF92KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IEFbX3ZdLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgdmFyIF93ID0gQVtfdl1bX2pdLmlkKCk7XG5cbiAgICAgICAgICAgIGlmIChkW193XSA9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICBRLnB1c2goX3cpO1xuICAgICAgICAgICAgICBkW193XSA9IGRbX3ZdICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRbX3ddID09IGRbX3ZdICsgMSkge1xuICAgICAgICAgICAgICBnW193XSA9IGdbX3ddICsgZ1tfdl07XG5cbiAgICAgICAgICAgICAgUFtfd10ucHVzaChfdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlID0ge307XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IFYubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBlW1ZbX2kyXS5pZCgpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIF93MiA9IFMucG9wKCk7XG5cbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgUFtfdzJdLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgX3YyID0gUFtfdzJdW19qMl07XG4gICAgICAgICAgZVtfdjJdID0gZVtfdjJdICsgZ1tfdjJdIC8gZ1tfdzJdICogKDEgKyBlW193Ml0pO1xuXG4gICAgICAgICAgaWYgKF93MiAhPSBWW3NdLmlkKCkpIHtcbiAgICAgICAgICAgIEMuc2V0KF93MiwgQy5nZXQoX3cyKSArIGVbX3cyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgVi5sZW5ndGg7IHMrKykge1xuICAgICAgX2xvb3Aocyk7XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIGJldHdlZW5uZXNzOiBmdW5jdGlvbiBiZXR3ZWVubmVzcyhub2RlKSB7XG4gICAgICAgIHZhciBpZCA9IGN5LmNvbGxlY3Rpb24obm9kZSkuaWQoKTtcbiAgICAgICAgcmV0dXJuIEMuZ2V0KGlkKTtcbiAgICAgIH0sXG4gICAgICBiZXR3ZWVubmVzc05vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGJldHdlZW5uZXNzTm9ybWFsaXplZChub2RlKSB7XG4gICAgICAgIGlmIChtYXggPT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gY3kuY29sbGVjdGlvbihub2RlKS5pZCgpO1xuICAgICAgICByZXR1cm4gQy5nZXQoaWQpIC8gbWF4O1xuICAgICAgfVxuICAgIH07IC8vIGFsaWFzXG5cbiAgICByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpc2VkID0gcmV0LmJldHdlZW5uZXNzTm9ybWFsaXplZDtcbiAgICByZXR1cm4gcmV0O1xuICB9IC8vIGJldHdlZW5uZXNzQ2VudHJhbGl0eVxuXG59OyAvLyBlbGVzZm5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcblxuZWxlc2ZuJGEuYmMgPSBlbGVzZm4kYS5iZXR3ZWVubmVzc0NlbnRyYWxpdHk7XG5cbi8vIEltcGxlbWVudGVkIGJ5IFpvZSBYaSBAem9leGkgZm9yIEdTT0MgMjAxNlxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxudmFyIGRlZmF1bHRzJDQgPSBkZWZhdWx0cyh7XG4gIGV4cGFuZEZhY3RvcjogMixcbiAgLy8gYWZmZWN0cyB0aW1lIG9mIGNvbXB1dGF0aW9uIGFuZCBjbHVzdGVyIGdyYW51bGFyaXR5IHRvIHNvbWUgZXh0ZW50OiBNICogTVxuICBpbmZsYXRlRmFjdG9yOiAyLFxuICAvLyBhZmZlY3RzIGNsdXN0ZXIgZ3JhbnVsYXJpdHkgKHRoZSBncmVhdGVyIHRoZSB2YWx1ZSwgdGhlIG1vcmUgY2x1c3RlcnMpOiBNKGksaikgLyBFKGopXG4gIG11bHRGYWN0b3I6IDEsXG4gIC8vIG9wdGlvbmFsIHNlbGYgbG9vcHMgZm9yIGVhY2ggbm9kZS4gVXNlIGEgbmV1dHJhbCB2YWx1ZSB0byBpbXByb3ZlIGNsdXN0ZXIgY29tcHV0YXRpb25zLlxuICBtYXhJdGVyYXRpb25zOiAyMCxcbiAgLy8gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyBvZiB0aGUgTUNMIGFsZ29yaXRobSBpbiBhIHNpbmdsZSBydW5cbiAgYXR0cmlidXRlczogWy8vIGF0dHJpYnV0ZXMvZmVhdHVyZXMgdXNlZCB0byBncm91cCBub2RlcywgaWUuIHNpbWlsYXJpdHkgdmFsdWVzIGJldHdlZW4gbm9kZXNcbiAgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfV1cbn0pO1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG52YXIgc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gZGVmYXVsdHMkNChvcHRpb25zKTtcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxudmFyIGdldFNpbWlsYXJpdHkgPSBmdW5jdGlvbiBnZXRTaW1pbGFyaXR5KGVkZ2UsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIHRvdGFsID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0b3RhbCArPSBhdHRyaWJ1dGVzW2ldKGVkZ2UpO1xuICB9XG5cbiAgcmV0dXJuIHRvdGFsO1xufTtcblxudmFyIGFkZExvb3BzID0gZnVuY3Rpb24gYWRkTG9vcHMoTSwgbiwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgTVtpICogbiArIGldID0gdmFsO1xuICB9XG59O1xuXG52YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKE0sIG4pIHtcbiAgdmFyIHN1bTtcblxuICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBuOyBjb2wrKykge1xuICAgIHN1bSA9IDA7XG5cbiAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBuOyByb3crKykge1xuICAgICAgc3VtICs9IE1bcm93ICogbiArIGNvbF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX3JvdyA9IDA7IF9yb3cgPCBuOyBfcm93KyspIHtcbiAgICAgIE1bX3JvdyAqIG4gKyBjb2xdID0gTVtfcm93ICogbiArIGNvbF0gLyBzdW07XG4gICAgfVxuICB9XG59OyAvLyBUT0RPOiBibG9ja2VkIG1hdHJpeCBtdWx0aXBsaWNhdGlvbj9cblxuXG52YXIgbW11bHQgPSBmdW5jdGlvbiBtbXVsdChBLCBCLCBuKSB7XG4gIHZhciBDID0gbmV3IEFycmF5KG4gKiBuKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICBDW2kgKiBuICsgal0gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbjsgX2orKykge1xuICAgICAgICBDW2kgKiBuICsgX2pdICs9IEFbaSAqIG4gKyBrXSAqIEJbayAqIG4gKyBfal07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEM7XG59O1xuXG52YXIgZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kKE0sIG4sIGV4cGFuZEZhY3RvclxuLyoqIHBvd2VyICoqL1xuKSB7XG4gIHZhciBfTSA9IE0uc2xpY2UoMCk7XG5cbiAgZm9yICh2YXIgcCA9IDE7IHAgPCBleHBhbmRGYWN0b3I7IHArKykge1xuICAgIE0gPSBtbXVsdChNLCBfTSwgbik7XG4gIH1cblxuICByZXR1cm4gTTtcbn07XG5cbnZhciBpbmZsYXRlID0gZnVuY3Rpb24gaW5mbGF0ZShNLCBuLCBpbmZsYXRlRmFjdG9yXG4vKiogciAqKi9cbikge1xuICB2YXIgX00gPSBuZXcgQXJyYXkobiAqIG4pOyAvLyBNKGksaikgXiBpbmZsYXRlUG93ZXJcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbiAqIG47IGkrKykge1xuICAgIF9NW2ldID0gTWF0aC5wb3coTVtpXSwgaW5mbGF0ZUZhY3Rvcik7XG4gIH1cblxuICBub3JtYWxpemUoX00sIG4pO1xuICByZXR1cm4gX007XG59O1xuXG52YXIgaGFzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGFzQ29udmVyZ2VkKE0sIF9NLCBuMiwgcm91bmRGYWN0b3IpIHtcbiAgLy8gQ2hlY2sgdGhhdCBib3RoIG1hdHJpY2VzIGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgKGksailcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMjsgaSsrKSB7XG4gICAgdmFyIHYxID0gTWF0aC5yb3VuZChNW2ldICogTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKSkgLyBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpOyAvLyB0cnVuY2F0ZSB0byAncm91bmRGYWN0b3InIGRlY2ltYWwgcGxhY2VzXG5cbiAgICB2YXIgdjIgPSBNYXRoLnJvdW5kKF9NW2ldICogTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKSkgLyBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpO1xuXG4gICAgaWYgKHYxICE9PSB2Mikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbihNLCBuLCBub2RlcywgY3kpIHtcbiAgdmFyIGNsdXN0ZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgY2x1c3RlciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIC8vIFJvdy13aXNlIGF0dHJhY3RvcnMgYW5kIGVsZW1lbnRzIHRoYXQgdGhleSBhdHRyYWN0IGJlbG9uZyBpbiBzYW1lIGNsdXN0ZXJcbiAgICAgIGlmIChNYXRoLnJvdW5kKE1baSAqIG4gKyBqXSAqIDEwMDApIC8gMTAwMCA+IDApIHtcbiAgICAgICAgY2x1c3Rlci5wdXNoKG5vZGVzW2pdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2x1c3Rlci5sZW5ndGggIT09IDApIHtcbiAgICAgIGNsdXN0ZXJzLnB1c2goY3kuY29sbGVjdGlvbihjbHVzdGVyKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIGlzRHVwbGljYXRlID0gZnVuY3Rpb24gaXNEdXBsaWNhdGUoYzEsIGMyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYzEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWMyW2ldIHx8IGMxW2ldLmlkKCkgIT09IGMyW2ldLmlkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciByZW1vdmVEdXBsaWNhdGVzID0gZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlcyhjbHVzdGVycykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbHVzdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGkgIT0gaiAmJiBpc0R1cGxpY2F0ZShjbHVzdGVyc1tpXSwgY2x1c3RlcnNbal0pKSB7XG4gICAgICAgIGNsdXN0ZXJzLnNwbGljZShqLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG52YXIgbWFya292Q2x1c3RlcmluZyA9IGZ1bmN0aW9uIG1hcmtvdkNsdXN0ZXJpbmcob3B0aW9ucykge1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpOyAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06XG5cbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zKG9wdGlvbnMpOyAvLyBNYXAgZWFjaCBub2RlIHRvIGl0cyBwb3NpdGlvbiBpbiBub2RlIGFycmF5XG5cbiAgdmFyIGlkMnBvc2l0aW9uID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgfSAvLyBHZW5lcmF0ZSBzdG9jaGFzdGljIG1hdHJpeCBNIGZyb20gaW5wdXQgZ3JhcGggRyAoc2hvdWxkIGJlIHN5bW1ldHJpYy91bmRpcmVjdGVkKVxuXG5cbiAgdmFyIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBuMiA9IG4gKiBuO1xuXG4gIHZhciBNID0gbmV3IEFycmF5KG4yKSxcbiAgICAgIF9NO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBuMjsgX2krKykge1xuICAgIE1bX2ldID0gMDtcbiAgfVxuXG4gIGZvciAodmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2VdO1xuICAgIHZhciBfaTIgPSBpZDJwb3NpdGlvbltlZGdlLnNvdXJjZSgpLmlkKCldO1xuICAgIHZhciBqID0gaWQycG9zaXRpb25bZWRnZS50YXJnZXQoKS5pZCgpXTtcbiAgICB2YXIgc2ltID0gZ2V0U2ltaWxhcml0eShlZGdlLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgIE1bX2kyICogbiArIGpdICs9IHNpbTsgLy8gRyBzaG91bGQgYmUgc3ltbWV0cmljIGFuZCB1bmRpcmVjdGVkXG5cbiAgICBNW2ogKiBuICsgX2kyXSArPSBzaW07XG4gIH0gLy8gQmVnaW4gTWFya292IGNsdXN0ZXIgYWxnb3JpdGhtXG4gIC8vIFN0ZXAgMTogQWRkIHNlbGYgbG9vcHMgdG8gZWFjaCBub2RlLCBpZS4gYWRkIG11bHRGYWN0b3IgdG8gbWF0cml4IGRpYWdvbmFsXG5cblxuICBhZGRMb29wcyhNLCBuLCBvcHRzLm11bHRGYWN0b3IpOyAvLyBTdGVwIDI6IE0gPSBub3JtYWxpemUoIE0gKTtcblxuICBub3JtYWxpemUoTSwgbik7XG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7IC8vIFN0ZXAgMzpcblxuICAgIF9NID0gZXhwYW5kKE0sIG4sIG9wdHMuZXhwYW5kRmFjdG9yKTsgLy8gU3RlcCA0OlxuXG4gICAgTSA9IGluZmxhdGUoX00sIG4sIG9wdHMuaW5mbGF0ZUZhY3Rvcik7IC8vIFN0ZXAgNTogY2hlY2sgdG8gc2VlIGlmIH5zdGVhZHkgc3RhdGUgaGFzIGJlZW4gcmVhY2hlZFxuXG4gICAgaWYgKCFoYXNDb252ZXJnZWQoTSwgX00sIG4yLCA0KSkge1xuICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgaXRlcmF0aW9ucysrO1xuICB9IC8vIEJ1aWxkIGNsdXN0ZXJzIGZyb20gbWF0cml4XG5cblxuICB2YXIgY2x1c3RlcnMgPSBhc3NpZ24oTSwgbiwgbm9kZXMsIGN5KTsgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBjbHVzdGVycyBkdWUgdG8gc3ltbWV0cnkgb2YgZ3JhcGggYW5kIE0gbWF0cml4XG5cbiAgY2x1c3RlcnMgPSByZW1vdmVEdXBsaWNhdGVzKGNsdXN0ZXJzKTtcbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIG1hcmtvdkNsdXN0ZXJpbmckMSA9IHtcbiAgbWFya292Q2x1c3RlcmluZzogbWFya292Q2x1c3RlcmluZyxcbiAgbWNsOiBtYXJrb3ZDbHVzdGVyaW5nXG59O1xuXG4vLyBDb21tb24gZGlzdGFuY2UgbWV0cmljcyBmb3IgY2x1c3RlcmluZyBhbGdvcml0aG1zXG5cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuXG52YXIgYWJzRGlmZiA9IGZ1bmN0aW9uIGFic0RpZmYocCwgcSkge1xuICByZXR1cm4gTWF0aC5hYnMocSAtIHApO1xufTtcblxudmFyIGFkZEFic0RpZmYgPSBmdW5jdGlvbiBhZGRBYnNEaWZmKHRvdGFsLCBwLCBxKSB7XG4gIHJldHVybiB0b3RhbCArIGFic0RpZmYocCwgcSk7XG59O1xuXG52YXIgYWRkU3F1YXJlZERpZmYgPSBmdW5jdGlvbiBhZGRTcXVhcmVkRGlmZih0b3RhbCwgcCwgcSkge1xuICByZXR1cm4gdG90YWwgKyBNYXRoLnBvdyhxIC0gcCwgMik7XG59O1xuXG52YXIgc3FydCA9IGZ1bmN0aW9uIHNxcnQoeCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KHgpO1xufTtcblxudmFyIG1heEFic0RpZmYgPSBmdW5jdGlvbiBtYXhBYnNEaWZmKGN1cnJlbnRNYXgsIHAsIHEpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGN1cnJlbnRNYXgsIGFic0RpZmYocCwgcSkpO1xufTtcblxudmFyIGdldERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCBpbml0LCB2aXNpdCkge1xuICB2YXIgcG9zdCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogaWRlbnRpdHk7XG4gIHZhciByZXQgPSBpbml0O1xuICB2YXIgcCwgcTtcblxuICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCBsZW5ndGg7IGRpbSsrKSB7XG4gICAgcCA9IGdldFAoZGltKTtcbiAgICBxID0gZ2V0UShkaW0pO1xuICAgIHJldCA9IHZpc2l0KHJldCwgcCwgcSk7XG4gIH1cblxuICByZXR1cm4gcG9zdChyZXQpO1xufTtcblxudmFyIGRpc3RhbmNlcyA9IHtcbiAgZXVjbGlkZWFuOiBmdW5jdGlvbiBldWNsaWRlYW4obGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRTcXVhcmVkRGlmZiwgc3FydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBzaW5nbGUgYXR0ciBjYXNlLCBtb3JlIGVmZmljaWVudCB0byBhdm9pZCBzcXJ0XG4gICAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRBYnNEaWZmKTtcbiAgICB9XG4gIH0sXG4gIHNxdWFyZWRFdWNsaWRlYW46IGZ1bmN0aW9uIHNxdWFyZWRFdWNsaWRlYW4obGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkU3F1YXJlZERpZmYpO1xuICB9LFxuICBtYW5oYXR0YW46IGZ1bmN0aW9uIG1hbmhhdHRhbihsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRBYnNEaWZmKTtcbiAgfSxcbiAgbWF4OiBmdW5jdGlvbiBtYXgobGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgLUluZmluaXR5LCBtYXhBYnNEaWZmKTtcbiAgfVxufTsgLy8gaW4gY2FzZSB0aGUgdXNlciBhY2NpZGVudGFsbHkgZG9lc24ndCB1c2UgY2FtZWwgY2FzZVxuXG5kaXN0YW5jZXNbJ3NxdWFyZWQtZXVjbGlkZWFuJ10gPSBkaXN0YW5jZXNbJ3NxdWFyZWRFdWNsaWRlYW4nXTtcbmRpc3RhbmNlc1snc3F1YXJlZGV1Y2xpZGVhbiddID0gZGlzdGFuY2VzWydzcXVhcmVkRXVjbGlkZWFuJ107XG5mdW5jdGlvbiBjbHVzdGVyaW5nRGlzdGFuY2UgKG1ldGhvZCwgbGVuZ3RoLCBnZXRQLCBnZXRRLCBub2RlUCwgbm9kZVEpIHtcbiAgdmFyIGltcGw7XG5cbiAgaWYgKGZuKG1ldGhvZCkpIHtcbiAgICBpbXBsID0gbWV0aG9kO1xuICB9IGVsc2Uge1xuICAgIGltcGwgPSBkaXN0YW5jZXNbbWV0aG9kXSB8fCBkaXN0YW5jZXMuZXVjbGlkZWFuO1xuICB9XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBmbihtZXRob2QpKSB7XG4gICAgcmV0dXJuIGltcGwobm9kZVAsIG5vZGVRKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW1wbChsZW5ndGgsIGdldFAsIGdldFEsIG5vZGVQLCBub2RlUSk7XG4gIH1cbn1cblxudmFyIGRlZmF1bHRzJDUgPSBkZWZhdWx0cyh7XG4gIGs6IDIsXG4gIG06IDIsXG4gIHNlbnNpdGl2aXR5VGhyZXNob2xkOiAwLjAwMDEsXG4gIGRpc3RhbmNlOiAnZXVjbGlkZWFuJyxcbiAgbWF4SXRlcmF0aW9uczogMTAsXG4gIGF0dHJpYnV0ZXM6IFtdLFxuICB0ZXN0TW9kZTogZmFsc2UsXG4gIHRlc3RDZW50cm9pZHM6IG51bGxcbn0pO1xuXG52YXIgc2V0T3B0aW9ucyQxID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBkZWZhdWx0cyQ1KG9wdGlvbnMpO1xufTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxuXG52YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QodHlwZSwgbm9kZSwgY2VudHJvaWQsIGF0dHJpYnV0ZXMsIG1vZGUpIHtcbiAgdmFyIG5vTm9kZVAgPSBtb2RlICE9PSAna01lZG9pZHMnO1xuICB2YXIgZ2V0UCA9IG5vTm9kZVAgPyBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBjZW50cm9pZFtpXTtcbiAgfSA6IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0oY2VudHJvaWQpO1xuICB9O1xuXG4gIHZhciBnZXRRID0gZnVuY3Rpb24gZ2V0UShpKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0obm9kZSk7XG4gIH07XG5cbiAgdmFyIG5vZGVQID0gY2VudHJvaWQ7XG4gIHZhciBub2RlUSA9IG5vZGU7XG4gIHJldHVybiBjbHVzdGVyaW5nRGlzdGFuY2UodHlwZSwgYXR0cmlidXRlcy5sZW5ndGgsIGdldFAsIGdldFEsIG5vZGVQLCBub2RlUSk7XG59O1xuXG52YXIgcmFuZG9tQ2VudHJvaWRzID0gZnVuY3Rpb24gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBrLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBuZGltID0gYXR0cmlidXRlcy5sZW5ndGg7XG4gIHZhciBtaW4gPSBuZXcgQXJyYXkobmRpbSk7XG4gIHZhciBtYXggPSBuZXcgQXJyYXkobmRpbSk7XG4gIHZhciBjZW50cm9pZHMgPSBuZXcgQXJyYXkoayk7XG4gIHZhciBjZW50cm9pZCA9IG51bGw7IC8vIEZpbmQgbWluLCBtYXggdmFsdWVzIGZvciBlYWNoIGF0dHJpYnV0ZSBkaW1lbnNpb25cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5kaW07IGkrKykge1xuICAgIG1pbltpXSA9IG5vZGVzLm1pbihhdHRyaWJ1dGVzW2ldKS52YWx1ZTtcbiAgICBtYXhbaV0gPSBub2Rlcy5tYXgoYXR0cmlidXRlc1tpXSkudmFsdWU7XG4gIH0gLy8gQnVpbGQgayBjZW50cm9pZHMsIGVhY2ggcmVwcmVzZW50ZWQgYXMgYW4gbi1kaW0gZmVhdHVyZSB2ZWN0b3JcblxuXG4gIGZvciAodmFyIGMgPSAwOyBjIDwgazsgYysrKSB7XG4gICAgY2VudHJvaWQgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuZGltOyBfaSsrKSB7XG4gICAgICBjZW50cm9pZFtfaV0gPSBNYXRoLnJhbmRvbSgpICogKG1heFtfaV0gLSBtaW5bX2ldKSArIG1pbltfaV07IC8vIHJhbmRvbSBpbml0aWFsIHZhbHVlXG4gICAgfVxuXG4gICAgY2VudHJvaWRzW2NdID0gY2VudHJvaWQ7XG4gIH1cblxuICByZXR1cm4gY2VudHJvaWRzO1xufTtcblxudmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gY2xhc3NpZnkobm9kZSwgY2VudHJvaWRzLCBkaXN0YW5jZSwgYXR0cmlidXRlcywgdHlwZSkge1xuICB2YXIgbWluID0gSW5maW5pdHk7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZW50cm9pZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlzdCA9IGdldERpc3QoZGlzdGFuY2UsIG5vZGUsIGNlbnRyb2lkc1tpXSwgYXR0cmlidXRlcywgdHlwZSk7XG5cbiAgICBpZiAoZGlzdCA8IG1pbikge1xuICAgICAgbWluID0gZGlzdDtcbiAgICAgIGluZGV4ID0gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuXG52YXIgYnVpbGRDbHVzdGVyID0gZnVuY3Rpb24gYnVpbGRDbHVzdGVyKGNlbnRyb2lkLCBub2RlcywgYXNzaWdubWVudCkge1xuICB2YXIgY2x1c3RlciA9IFtdO1xuICB2YXIgbm9kZSA9IG51bGw7XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgIG5vZGUgPSBub2Rlc1tuXTtcblxuICAgIGlmIChhc3NpZ25tZW50W25vZGUuaWQoKV0gPT09IGNlbnRyb2lkKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiTm9kZSBcIiArIG5vZGUuaWQoKSArIFwiIGlzIGFzc29jaWF0ZWQgd2l0aCBtZWRvaWQgIzogXCIgKyBtKTtcbiAgICAgIGNsdXN0ZXIucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2x1c3Rlcjtcbn07XG5cbnZhciBoYXZlVmFsdWVzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGF2ZVZhbHVlc0NvbnZlcmdlZCh2MSwgdjIsIHNlbnNpdGl2aXR5VGhyZXNob2xkKSB7XG4gIHJldHVybiBNYXRoLmFicyh2MiAtIHYxKSA8PSBzZW5zaXRpdml0eVRocmVzaG9sZDtcbn07XG5cbnZhciBoYXZlTWF0cmljZXNDb252ZXJnZWQgPSBmdW5jdGlvbiBoYXZlTWF0cmljZXNDb252ZXJnZWQodjEsIHYyLCBzZW5zaXRpdml0eVRocmVzaG9sZCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB2MVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyh2MVtpXVtqXSAtIHYyW2ldW2pdKTtcblxuICAgICAgaWYgKGRpZmYgPiBzZW5zaXRpdml0eVRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgc2VlbkJlZm9yZSA9IGZ1bmN0aW9uIHNlZW5CZWZvcmUobm9kZSwgbWVkb2lkcywgbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGlmIChub2RlID09PSBtZWRvaWRzW2ldKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciByYW5kb21NZWRvaWRzID0gZnVuY3Rpb24gcmFuZG9tTWVkb2lkcyhub2Rlcywgaykge1xuICB2YXIgbWVkb2lkcyA9IG5ldyBBcnJheShrKTsgLy8gRm9yIHNtYWxsIGRhdGEgc2V0cywgdGhlIHByb2JhYmlsaXR5IG9mIG1lZG9pZCBjb25mbGljdCBpcyBncmVhdGVyLFxuICAvLyBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRvIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IHNlZW4gb3IgY2hvc2UgdGhpcyBub2RlIGJlZm9yZS5cblxuICBpZiAobm9kZXMubGVuZ3RoIDwgNTApIHtcbiAgICAvLyBSYW5kb21seSBzZWxlY3QgayBtZWRvaWRzIGZyb20gdGhlIG4gbm9kZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpXTsgLy8gSWYgd2UndmUgYWxyZWFkeSBjaG9zZW4gdGhpcyBub2RlIHRvIGJlIGEgbWVkb2lkLCBkb24ndCBjaG9vc2UgaXQgYWdhaW4gKGZvciBzbWFsbCBkYXRhIHNldHMpLlxuICAgICAgLy8gSW5zdGVhZCBjaG9vc2UgYSBkaWZmZXJlbnQgcmFuZG9tIG5vZGUuXG5cbiAgICAgIHdoaWxlIChzZWVuQmVmb3JlKG5vZGUsIG1lZG9pZHMsIGkpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpXTtcbiAgICAgIH1cblxuICAgICAgbWVkb2lkc1tpXSA9IG5vZGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbGF0aXZlbHkgbGFyZ2UgZGF0YSBzZXQsIHNvIHByZXR0eSBzYWZlIHRvIG5vdCBjaGVjayBhbmQganVzdCBzZWxlY3QgcmFuZG9tIG5vZGVzXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgazsgX2kyKyspIHtcbiAgICAgIG1lZG9pZHNbX2kyXSA9IG5vZGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZWRvaWRzO1xufTtcblxudmFyIGZpbmRDb3N0ID0gZnVuY3Rpb24gZmluZENvc3QocG90ZW50aWFsTmV3TWVkb2lkLCBjbHVzdGVyLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBjb3N0ID0gMDtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IGNsdXN0ZXIubGVuZ3RoOyBuKyspIHtcbiAgICBjb3N0ICs9IGdldERpc3QoJ21hbmhhdHRhbicsIGNsdXN0ZXJbbl0sIHBvdGVudGlhbE5ld01lZG9pZCwgYXR0cmlidXRlcywgJ2tNZWRvaWRzJyk7XG4gIH1cblxuICByZXR1cm4gY29zdDtcbn07XG5cbnZhciBrTWVhbnMgPSBmdW5jdGlvbiBrTWVhbnMob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG5vZGUgPSBudWxsOyAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06ICMgb2YgY2x1c3RlcnMsIGRpc3RhbmNlIG1ldHJpYywgZXRjLlxuXG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQxKG9wdGlvbnMpOyAvLyBCZWdpbiBrLW1lYW5zIGFsZ29yaXRobVxuXG4gIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShvcHRzLmspO1xuICB2YXIgYXNzaWdubWVudCA9IHt9O1xuICB2YXIgY2VudHJvaWRzOyAvLyBTdGVwIDE6IEluaXRpYWxpemUgY2VudHJvaWQgcG9zaXRpb25zXG5cbiAgaWYgKG9wdHMudGVzdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMudGVzdENlbnRyb2lkcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNlbnRyb2lkcyA9IHJhbmRvbUNlbnRyb2lkcyhub2Rlcywgb3B0cy5rLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRzLnRlc3RDZW50cm9pZHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgY2VudHJvaWRzID0gb3B0cy50ZXN0Q2VudHJvaWRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZW50cm9pZHMgPSByYW5kb21DZW50cm9pZHMobm9kZXMsIG9wdHMuaywgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2VudHJvaWRzID0gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBvcHRzLmssIG9wdHMuYXR0cmlidXRlcyk7XG4gIH1cblxuICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcblxuICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgLy8gU3RlcCAyOiBBc3NpZ24gbm9kZXMgdG8gdGhlIG5lYXJlc3QgY2VudHJvaWRcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICBub2RlID0gbm9kZXNbbl07IC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoaXMgbm9kZSBiZWxvbmdzIHRvOiBub2RlIGlkID0+IGNsdXN0ZXIgI1xuXG4gICAgICBhc3NpZ25tZW50W25vZGUuaWQoKV0gPSBjbGFzc2lmeShub2RlLCBjZW50cm9pZHMsIG9wdHMuZGlzdGFuY2UsIG9wdHMuYXR0cmlidXRlcywgJ2tNZWFucycpO1xuICAgIH0gLy8gU3RlcCAzOiBGb3IgZWFjaCBvZiB0aGUgayBjbHVzdGVycywgdXBkYXRlIGl0cyBjZW50cm9pZFxuXG5cbiAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IG9wdHMuazsgYysrKSB7XG4gICAgICAvLyBHZXQgYWxsIG5vZGVzIHRoYXQgYmVsb25nIHRvIHRoaXMgY2x1c3RlclxuICAgICAgdmFyIGNsdXN0ZXIgPSBidWlsZENsdXN0ZXIoYywgbm9kZXMsIGFzc2lnbm1lbnQpO1xuXG4gICAgICBpZiAoY2x1c3Rlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gSWYgY2x1c3RlciBpcyBlbXB0eSwgYnJlYWsgb3V0IGVhcmx5ICYgbW92ZSB0byBuZXh0IGNsdXN0ZXJcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIFVwZGF0ZSBjZW50cm9pZHMgYnkgY2FsY3VsYXRpbmcgYXZnIG9mIGFsbCBub2RlcyB3aXRoaW4gdGhlIGNsdXN0ZXIuXG5cblxuICAgICAgdmFyIG5kaW0gPSBvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgdmFyIGNlbnRyb2lkID0gY2VudHJvaWRzW2NdOyAvLyBbIGRpbV8xLCBkaW1fMiwgZGltXzMsIC4uLiAsIGRpbV9uIF1cblxuICAgICAgdmFyIG5ld0NlbnRyb2lkID0gbmV3IEFycmF5KG5kaW0pO1xuICAgICAgdmFyIHN1bSA9IG5ldyBBcnJheShuZGltKTtcblxuICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBuZGltOyBkKyspIHtcbiAgICAgICAgc3VtW2RdID0gMC4wO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3Rlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBjbHVzdGVyW2ldO1xuICAgICAgICAgIHN1bVtkXSArPSBvcHRzLmF0dHJpYnV0ZXNbZF0obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdDZW50cm9pZFtkXSA9IHN1bVtkXSAvIGNsdXN0ZXIubGVuZ3RoOyAvLyBDaGVjayB0byBzZWUgaWYgYWxnb3JpdGhtIGhhcyBjb252ZXJnZWQsIGkuZS4gd2hlbiBjZW50cm9pZHMgbm8gbG9uZ2VyIGNoYW5nZVxuXG4gICAgICAgIGlmICghaGF2ZVZhbHVlc0NvbnZlcmdlZChuZXdDZW50cm9pZFtkXSwgY2VudHJvaWRbZF0sIG9wdHMuc2Vuc2l0aXZpdHlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2VudHJvaWRzW2NdID0gbmV3Q2VudHJvaWQ7XG4gICAgICBjbHVzdGVyc1tjXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3Rlcik7XG4gICAgfVxuXG4gICAgaXRlcmF0aW9ucysrO1xuICB9XG5cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIGtNZWRvaWRzID0gZnVuY3Rpb24ga01lZG9pZHMob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG5vZGUgPSBudWxsO1xuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMShvcHRpb25zKTsgLy8gQmVnaW4gay1tZWRvaWRzIGFsZ29yaXRobVxuXG4gIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShvcHRzLmspO1xuICB2YXIgbWVkb2lkcztcbiAgdmFyIGFzc2lnbm1lbnQgPSB7fTtcbiAgdmFyIGN1ckNvc3Q7XG4gIHZhciBtaW5Db3N0cyA9IG5ldyBBcnJheShvcHRzLmspOyAvLyBtaW5pbXVtIGNvc3QgY29uZmlndXJhdGlvbiBmb3IgZWFjaCBjbHVzdGVyXG4gIC8vIFN0ZXAgMTogSW5pdGlhbGl6ZSBrIG1lZG9pZHNcblxuICBpZiAob3B0cy50ZXN0TW9kZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cy50ZXN0Q2VudHJvaWRzID09PSAnbnVtYmVyJykgOyBlbHNlIGlmIChfdHlwZW9mKG9wdHMudGVzdENlbnRyb2lkcykgPT09ICdvYmplY3QnKSB7XG4gICAgICBtZWRvaWRzID0gb3B0cy50ZXN0Q2VudHJvaWRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZWRvaWRzID0gcmFuZG9tTWVkb2lkcyhub2Rlcywgb3B0cy5rKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWVkb2lkcyA9IHJhbmRvbU1lZG9pZHMobm9kZXMsIG9wdHMuayk7XG4gIH1cblxuICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcblxuICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgLy8gU3RlcCAyOiBBc3NpZ24gbm9kZXMgdG8gdGhlIG5lYXJlc3QgbWVkb2lkXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgbm9kZSA9IG5vZGVzW25dOyAvLyBEZXRlcm1pbmUgd2hpY2ggY2x1c3RlciB0aGlzIG5vZGUgYmVsb25ncyB0bzogbm9kZSBpZCA9PiBjbHVzdGVyICNcblxuICAgICAgYXNzaWdubWVudFtub2RlLmlkKCldID0gY2xhc3NpZnkobm9kZSwgbWVkb2lkcywgb3B0cy5kaXN0YW5jZSwgb3B0cy5hdHRyaWJ1dGVzLCAna01lZG9pZHMnKTtcbiAgICB9XG5cbiAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7IC8vIFN0ZXAgMzogRm9yIGVhY2ggbWVkb2lkIG0sIGFuZCBmb3IgZWFjaCBub2RlIGFzc2NpYXRlZCB3aXRoIG1lZGlvZCBtLFxuICAgIC8vIHNlbGVjdCB0aGUgbm9kZSB3aXRoIHRoZSBsb3dlc3QgY29uZmlndXJhdGlvbiBjb3N0IGFzIG5ldyBtZWRvaWQuXG5cbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IG1lZG9pZHMubGVuZ3RoOyBtKyspIHtcbiAgICAgIC8vIEdldCBhbGwgbm9kZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBtZWRvaWRcbiAgICAgIHZhciBjbHVzdGVyID0gYnVpbGRDbHVzdGVyKG0sIG5vZGVzLCBhc3NpZ25tZW50KTtcblxuICAgICAgaWYgKGNsdXN0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIElmIGNsdXN0ZXIgaXMgZW1wdHksIGJyZWFrIG91dCBlYXJseSAmIG1vdmUgdG8gbmV4dCBjbHVzdGVyXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBtaW5Db3N0c1ttXSA9IGZpbmRDb3N0KG1lZG9pZHNbbV0sIGNsdXN0ZXIsIG9wdHMuYXR0cmlidXRlcyk7IC8vIG9yaWdpbmFsIGNvc3RcbiAgICAgIC8vIFNlbGVjdCBkaWZmZXJlbnQgbWVkb2lkIGlmIGl0cyBjb25maWd1cmF0aW9uIGhhcyB0aGUgbG93ZXN0IGNvc3RcblxuICAgICAgZm9yICh2YXIgX24gPSAwOyBfbiA8IGNsdXN0ZXIubGVuZ3RoOyBfbisrKSB7XG4gICAgICAgIGN1ckNvc3QgPSBmaW5kQ29zdChjbHVzdGVyW19uXSwgY2x1c3Rlciwgb3B0cy5hdHRyaWJ1dGVzKTtcblxuICAgICAgICBpZiAoY3VyQ29zdCA8IG1pbkNvc3RzW21dKSB7XG4gICAgICAgICAgbWluQ29zdHNbbV0gPSBjdXJDb3N0O1xuICAgICAgICAgIG1lZG9pZHNbbV0gPSBjbHVzdGVyW19uXTtcbiAgICAgICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbHVzdGVyc1ttXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3Rlcik7XG4gICAgfVxuXG4gICAgaXRlcmF0aW9ucysrO1xuICB9XG5cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIHVwZGF0ZUNlbnRyb2lkcyA9IGZ1bmN0aW9uIHVwZGF0ZUNlbnRyb2lkcyhjZW50cm9pZHMsIG5vZGVzLCBVLCB3ZWlnaHQsIG9wdHMpIHtcbiAgdmFyIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2VudHJvaWRzLmxlbmd0aDsgYysrKSB7XG4gICAgICB3ZWlnaHRbbl1bY10gPSBNYXRoLnBvdyhVW25dW2NdLCBvcHRzLm0pO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9jID0gMDsgX2MgPCBjZW50cm9pZHMubGVuZ3RoOyBfYysrKSB7XG4gICAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgb3B0cy5hdHRyaWJ1dGVzLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIG51bWVyYXRvciA9IDA7XG4gICAgICBkZW5vbWluYXRvciA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9uMiA9IDA7IF9uMiA8IG5vZGVzLmxlbmd0aDsgX24yKyspIHtcbiAgICAgICAgbnVtZXJhdG9yICs9IHdlaWdodFtfbjJdW19jXSAqIG9wdHMuYXR0cmlidXRlc1tkaW1dKG5vZGVzW19uMl0pO1xuICAgICAgICBkZW5vbWluYXRvciArPSB3ZWlnaHRbX24yXVtfY107XG4gICAgICB9XG5cbiAgICAgIGNlbnRyb2lkc1tfY11bZGltXSA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHVwZGF0ZU1lbWJlcnNoaXAgPSBmdW5jdGlvbiB1cGRhdGVNZW1iZXJzaGlwKFUsIF9VLCBjZW50cm9pZHMsIG5vZGVzLCBvcHRzKSB7XG4gIC8vIFNhdmUgcHJldmlvdXMgc3RlcFxuICBmb3IgKHZhciBpID0gMDsgaSA8IFUubGVuZ3RoOyBpKyspIHtcbiAgICBfVVtpXSA9IFVbaV0uc2xpY2UoKTtcbiAgfVxuXG4gIHZhciBzdW0sIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG4gIHZhciBwb3cgPSAyIC8gKG9wdHMubSAtIDEpO1xuXG4gIGZvciAodmFyIGMgPSAwOyBjIDwgY2VudHJvaWRzLmxlbmd0aDsgYysrKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgc3VtID0gMDtcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjZW50cm9pZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgLy8gYWdhaW5zdCBhbGwgb3RoZXIgY2VudHJvaWRzXG4gICAgICAgIG51bWVyYXRvciA9IGdldERpc3Qob3B0cy5kaXN0YW5jZSwgbm9kZXNbbl0sIGNlbnRyb2lkc1tjXSwgb3B0cy5hdHRyaWJ1dGVzLCAnY21lYW5zJyk7XG4gICAgICAgIGRlbm9taW5hdG9yID0gZ2V0RGlzdChvcHRzLmRpc3RhbmNlLCBub2Rlc1tuXSwgY2VudHJvaWRzW2tdLCBvcHRzLmF0dHJpYnV0ZXMsICdjbWVhbnMnKTtcbiAgICAgICAgc3VtICs9IE1hdGgucG93KG51bWVyYXRvciAvIGRlbm9taW5hdG9yLCBwb3cpO1xuICAgICAgfVxuXG4gICAgICBVW25dW2NdID0gMSAvIHN1bTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBhc3NpZ24kMSA9IGZ1bmN0aW9uIGFzc2lnbihub2RlcywgVSwgb3B0cywgY3kpIHtcbiAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KG9wdHMuayk7XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBjbHVzdGVycy5sZW5ndGg7IGMrKykge1xuICAgIGNsdXN0ZXJzW2NdID0gW107XG4gIH1cblxuICB2YXIgbWF4O1xuICB2YXIgaW5kZXg7XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBVLmxlbmd0aDsgbisrKSB7XG4gICAgLy8gZm9yIGVhY2ggbm9kZSAoVSBpcyBOIHggQyBtYXRyaXgpXG4gICAgbWF4ID0gLUluZmluaXR5O1xuICAgIGluZGV4ID0gLTE7IC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoZSBub2RlIGlzIG1vc3QgbGlrZWx5IHRvIGJlbG9uZyBpblxuXG4gICAgZm9yICh2YXIgX2MyID0gMDsgX2MyIDwgVVswXS5sZW5ndGg7IF9jMisrKSB7XG4gICAgICBpZiAoVVtuXVtfYzJdID4gbWF4KSB7XG4gICAgICAgIG1heCA9IFVbbl1bX2MyXTtcbiAgICAgICAgaW5kZXggPSBfYzI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2x1c3RlcnNbaW5kZXhdLnB1c2gobm9kZXNbbl0pO1xuICB9IC8vIFR1cm4gZXZlcnkgYXJyYXkgaW50byBhIGNvbGxlY3Rpb24gb2Ygbm9kZXNcblxuXG4gIGZvciAodmFyIF9jMyA9IDA7IF9jMyA8IGNsdXN0ZXJzLmxlbmd0aDsgX2MzKyspIHtcbiAgICBjbHVzdGVyc1tfYzNdID0gY3kuY29sbGVjdGlvbihjbHVzdGVyc1tfYzNdKTtcbiAgfVxuXG4gIHJldHVybiBjbHVzdGVycztcbn07XG5cbnZhciBmdXp6eUNNZWFucyA9IGZ1bmN0aW9uIGZ1enp5Q01lYW5zKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQxKG9wdGlvbnMpOyAvLyBCZWdpbiBmdXp6eSBjLW1lYW5zIGFsZ29yaXRobVxuXG4gIHZhciBjbHVzdGVycztcbiAgdmFyIGNlbnRyb2lkcztcbiAgdmFyIFU7XG5cbiAgdmFyIF9VO1xuXG4gIHZhciB3ZWlnaHQ7IC8vIFN0ZXAgMTogSW5pdGlhbGl6ZSBsZXRpYWJsZXMuXG5cbiAgX1UgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTiB4IEMgbWF0cml4XG4gICAgX1VbaV0gPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgfVxuXG4gIFUgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBub2Rlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgLy8gTiB4IEMgbWF0cml4XG4gICAgVVtfaTNdID0gbmV3IEFycmF5KG9wdHMuayk7XG4gIH1cblxuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2Rlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3B0cy5rOyBqKyspIHtcbiAgICAgIFVbX2k0XVtqXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB0b3RhbCArPSBVW19pNF1bal07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG9wdHMuazsgX2orKykge1xuICAgICAgVVtfaTRdW19qXSA9IFVbX2k0XVtfal0gLyB0b3RhbDtcbiAgICB9XG4gIH1cblxuICBjZW50cm9pZHMgPSBuZXcgQXJyYXkob3B0cy5rKTtcblxuICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBvcHRzLms7IF9pNSsrKSB7XG4gICAgY2VudHJvaWRzW19pNV0gPSBuZXcgQXJyYXkob3B0cy5hdHRyaWJ1dGVzLmxlbmd0aCk7XG4gIH1cblxuICB3ZWlnaHQgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBub2Rlcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgLy8gTiB4IEMgbWF0cml4XG4gICAgd2VpZ2h0W19pNl0gPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgfSAvLyBlbmQgaW5pdCBGQ01cblxuXG4gIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7IC8vIFN0ZXAgMjogQ2FsY3VsYXRlIHRoZSBjZW50cm9pZHMgZm9yIGVhY2ggc3RlcC5cblxuICAgIHVwZGF0ZUNlbnRyb2lkcyhjZW50cm9pZHMsIG5vZGVzLCBVLCB3ZWlnaHQsIG9wdHMpOyAvLyBTdGVwIDM6IFVwZGF0ZSB0aGUgcGFydGl0aW9uIG1hdHJpeCBVLlxuXG4gICAgdXBkYXRlTWVtYmVyc2hpcChVLCBfVSwgY2VudHJvaWRzLCBub2Rlcywgb3B0cyk7IC8vIFN0ZXAgNDogQ2hlY2sgZm9yIGNvbnZlcmdlbmNlLlxuXG4gICAgaWYgKCFoYXZlTWF0cmljZXNDb252ZXJnZWQoVSwgX1UsIG9wdHMuc2Vuc2l0aXZpdHlUaHJlc2hvbGQpKSB7XG4gICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpdGVyYXRpb25zKys7XG4gIH0gLy8gQXNzaWduIG5vZGVzIHRvIGNsdXN0ZXJzIHdpdGggaGlnaGVzdCBwcm9iYWJpbGl0eS5cblxuXG4gIGNsdXN0ZXJzID0gYXNzaWduJDEobm9kZXMsIFUsIG9wdHMsIGN5KTtcbiAgcmV0dXJuIHtcbiAgICBjbHVzdGVyczogY2x1c3RlcnMsXG4gICAgZGVncmVlT2ZNZW1iZXJzaGlwOiBVXG4gIH07XG59O1xuXG52YXIga0NsdXN0ZXJpbmcgPSB7XG4gIGtNZWFuczoga01lYW5zLFxuICBrTWVkb2lkczoga01lZG9pZHMsXG4gIGZ1enp5Q01lYW5zOiBmdXp6eUNNZWFucyxcbiAgZmNtOiBmdXp6eUNNZWFuc1xufTtcblxuLy8gSW1wbGVtZW50ZWQgYnkgWm9lIFhpIEB6b2V4aSBmb3IgR1NPQyAyMDE2XG52YXIgZGVmYXVsdHMkNiA9IGRlZmF1bHRzKHtcbiAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICAvLyBkaXN0YW5jZSBtZXRyaWMgdG8gY29tcGFyZSBub2Rlc1xuICBsaW5rYWdlOiAnbWluJyxcbiAgLy8gbGlua2FnZSBjcml0ZXJpb24gOiBob3cgdG8gZGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGNsdXN0ZXJzIG9mIG5vZGVzXG4gIG1vZGU6ICd0aHJlc2hvbGQnLFxuICAvLyBtb2RlOid0aHJlc2hvbGQnID0+IGNsdXN0ZXJzIG11c3QgYmUgdGhyZXNob2xkIGRpc3RhbmNlIGFwYXJ0XG4gIHRocmVzaG9sZDogSW5maW5pdHksXG4gIC8vIHRoZSBkaXN0YW5jZSB0aHJlc2hvbGRcbiAgLy8gbW9kZTonZGVuZHJvZ3JhbScgPT4gdGhlIG5vZGVzIGFyZSBvcmdhbmlzZWQgYXMgbGVhdmVzIGluIGEgdHJlZSAoc2libGluZ3MgYXJlIGNsb3NlKSwgbWVyZ2luZyBtYWtlcyBjbHVzdGVyc1xuICBhZGREZW5kcm9ncmFtOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byBhZGQgdGhlIGRlbmRyb2dyYW0gdG8gdGhlIGdyYXBoIGZvciB2aXpcbiAgZGVuZHJvZ3JhbURlcHRoOiAwLFxuICAvLyBkZXB0aCBhdCB3aGljaCBkZW5kcm9ncmFtIGJyYW5jaGVzIGFyZSBtZXJnZWQgaW50byB0aGUgcmV0dXJuZWQgY2x1c3RlcnNcbiAgYXR0cmlidXRlczogW10gLy8gYXJyYXkgb2YgYXR0ciBmdW5jdGlvbnNcblxufSk7XG52YXIgbGlua2FnZUFsaWFzZXMgPSB7XG4gICdzaW5nbGUnOiAnbWluJyxcbiAgJ2NvbXBsZXRlJzogJ21heCdcbn07XG5cbnZhciBzZXRPcHRpb25zJDIgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBkZWZhdWx0cyQ2KG9wdGlvbnMpO1xuICB2YXIgcHJlZmVycmVkQWxpYXMgPSBsaW5rYWdlQWxpYXNlc1tvcHRzLmxpbmthZ2VdO1xuXG4gIGlmIChwcmVmZXJyZWRBbGlhcyAhPSBudWxsKSB7XG4gICAgb3B0cy5saW5rYWdlID0gcHJlZmVycmVkQWxpYXM7XG4gIH1cblxuICByZXR1cm4gb3B0cztcbn07XG5cbnZhciBtZXJnZUNsb3Nlc3QgPSBmdW5jdGlvbiBtZXJnZUNsb3Nlc3QoY2x1c3RlcnMsIGluZGV4LCBkaXN0cywgbWlucywgb3B0cykge1xuICAvLyBGaW5kIHR3byBjbG9zZXN0IGNsdXN0ZXJzIGZyb20gY2FjaGVkIG1pbnNcbiAgdmFyIG1pbktleSA9IDA7XG4gIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgdmFyIGRpc3Q7XG4gIHZhciBhdHRycyA9IG9wdHMuYXR0cmlidXRlcztcblxuICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QobjEsIG4yKSB7XG4gICAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZShvcHRzLmRpc3RhbmNlLCBhdHRycy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objEpO1xuICAgIH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objIpO1xuICAgIH0sIG4xLCBuMik7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBjbHVzdGVyc1tpXS5rZXk7XG4gICAgdmFyIF9kaXN0ID0gZGlzdHNba2V5XVttaW5zW2tleV1dO1xuXG4gICAgaWYgKF9kaXN0IDwgbWluKSB7XG4gICAgICBtaW5LZXkgPSBrZXk7XG4gICAgICBtaW4gPSBfZGlzdDtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5tb2RlID09PSAndGhyZXNob2xkJyAmJiBtaW4gPj0gb3B0cy50aHJlc2hvbGQgfHwgb3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScgJiYgY2x1c3RlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGMxID0gaW5kZXhbbWluS2V5XTtcbiAgdmFyIGMyID0gaW5kZXhbbWluc1ttaW5LZXldXTtcbiAgdmFyIG1lcmdlZDsgLy8gTWVyZ2UgdHdvIGNsb3Nlc3QgY2x1c3RlcnNcblxuICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICBtZXJnZWQgPSB7XG4gICAgICBsZWZ0OiBjMSxcbiAgICAgIHJpZ2h0OiBjMixcbiAgICAgIGtleTogYzEua2V5XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtZXJnZWQgPSB7XG4gICAgICB2YWx1ZTogYzEudmFsdWUuY29uY2F0KGMyLnZhbHVlKSxcbiAgICAgIGtleTogYzEua2V5XG4gICAgfTtcbiAgfVxuXG4gIGNsdXN0ZXJzW2MxLmluZGV4XSA9IG1lcmdlZDtcbiAgY2x1c3RlcnMuc3BsaWNlKGMyLmluZGV4LCAxKTtcbiAgaW5kZXhbYzEua2V5XSA9IG1lcmdlZDsgLy8gVXBkYXRlIGRpc3RhbmNlcyB3aXRoIG5ldyBtZXJnZWQgY2x1c3RlclxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBjbHVzdGVycy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgY3VyID0gY2x1c3RlcnNbX2ldO1xuXG4gICAgaWYgKGMxLmtleSA9PT0gY3VyLmtleSkge1xuICAgICAgZGlzdCA9IEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAob3B0cy5saW5rYWdlID09PSAnbWluJykge1xuICAgICAgZGlzdCA9IGRpc3RzW2MxLmtleV1bY3VyLmtleV07XG5cbiAgICAgIGlmIChkaXN0c1tjMS5rZXldW2N1ci5rZXldID4gZGlzdHNbYzIua2V5XVtjdXIua2V5XSkge1xuICAgICAgICBkaXN0ID0gZGlzdHNbYzIua2V5XVtjdXIua2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdHMubGlua2FnZSA9PT0gJ21heCcpIHtcbiAgICAgIGRpc3QgPSBkaXN0c1tjMS5rZXldW2N1ci5rZXldO1xuXG4gICAgICBpZiAoZGlzdHNbYzEua2V5XVtjdXIua2V5XSA8IGRpc3RzW2MyLmtleV1bY3VyLmtleV0pIHtcbiAgICAgICAgZGlzdCA9IGRpc3RzW2MyLmtleV1bY3VyLmtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRzLmxpbmthZ2UgPT09ICdtZWFuJykge1xuICAgICAgZGlzdCA9IChkaXN0c1tjMS5rZXldW2N1ci5rZXldICogYzEuc2l6ZSArIGRpc3RzW2MyLmtleV1bY3VyLmtleV0gKiBjMi5zaXplKSAvIChjMS5zaXplICsgYzIuc2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykgZGlzdCA9IGdldERpc3QoY3VyLnZhbHVlLCBjMS52YWx1ZSk7ZWxzZSBkaXN0ID0gZ2V0RGlzdChjdXIudmFsdWVbMF0sIGMxLnZhbHVlWzBdKTtcbiAgICB9XG5cbiAgICBkaXN0c1tjMS5rZXldW2N1ci5rZXldID0gZGlzdHNbY3VyLmtleV1bYzEua2V5XSA9IGRpc3Q7IC8vIGRpc3RhbmNlIG1hdHJpeCBpcyBzeW1tZXRyaWNcbiAgfSAvLyBVcGRhdGUgY2FjaGVkIG1pbnNcblxuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNsdXN0ZXJzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIga2V5MSA9IGNsdXN0ZXJzW19pMl0ua2V5O1xuXG4gICAgaWYgKG1pbnNba2V5MV0gPT09IGMxLmtleSB8fCBtaW5zW2tleTFdID09PSBjMi5rZXkpIHtcbiAgICAgIHZhciBfbWluID0ga2V5MTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbHVzdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIga2V5MiA9IGNsdXN0ZXJzW2pdLmtleTtcblxuICAgICAgICBpZiAoZGlzdHNba2V5MV1ba2V5Ml0gPCBkaXN0c1trZXkxXVtfbWluXSkge1xuICAgICAgICAgIF9taW4gPSBrZXkyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1pbnNba2V5MV0gPSBfbWluO1xuICAgIH1cblxuICAgIGNsdXN0ZXJzW19pMl0uaW5kZXggPSBfaTI7XG4gIH0gLy8gQ2xlYW4gdXAgbWV0YSBkYXRhIHVzZWQgZm9yIGNsdXN0ZXJpbmdcblxuXG4gIGMxLmtleSA9IGMyLmtleSA9IGMxLmluZGV4ID0gYzIuaW5kZXggPSBudWxsO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBnZXRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIGdldEFsbENoaWxkcmVuKHJvb3QsIGFyciwgY3kpIHtcbiAgaWYgKCFyb290KSByZXR1cm47XG5cbiAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICBhcnIucHVzaChyb290LnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocm9vdC5sZWZ0KSBnZXRBbGxDaGlsZHJlbihyb290LmxlZnQsIGFycik7XG4gICAgaWYgKHJvb3QucmlnaHQpIGdldEFsbENoaWxkcmVuKHJvb3QucmlnaHQsIGFycik7XG4gIH1cbn07XG5cbnZhciBidWlsZERlbmRyb2dyYW0gPSBmdW5jdGlvbiBidWlsZERlbmRyb2dyYW0ocm9vdCwgY3kpIHtcbiAgaWYgKCFyb290KSByZXR1cm4gJyc7XG5cbiAgaWYgKHJvb3QubGVmdCAmJiByb290LnJpZ2h0KSB7XG4gICAgdmFyIGxlZnRTdHIgPSBidWlsZERlbmRyb2dyYW0ocm9vdC5sZWZ0LCBjeSk7XG4gICAgdmFyIHJpZ2h0U3RyID0gYnVpbGREZW5kcm9ncmFtKHJvb3QucmlnaHQsIGN5KTtcbiAgICB2YXIgbm9kZSA9IGN5LmFkZCh7XG4gICAgICBncm91cDogJ25vZGVzJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaWQ6IGxlZnRTdHIgKyAnLCcgKyByaWdodFN0clxuICAgICAgfVxuICAgIH0pO1xuICAgIGN5LmFkZCh7XG4gICAgICBncm91cDogJ2VkZ2VzJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc291cmNlOiBsZWZ0U3RyLFxuICAgICAgICB0YXJnZXQ6IG5vZGUuaWQoKVxuICAgICAgfVxuICAgIH0pO1xuICAgIGN5LmFkZCh7XG4gICAgICBncm91cDogJ2VkZ2VzJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc291cmNlOiByaWdodFN0cixcbiAgICAgICAgdGFyZ2V0OiBub2RlLmlkKClcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZS5pZCgpO1xuICB9IGVsc2UgaWYgKHJvb3QudmFsdWUpIHtcbiAgICByZXR1cm4gcm9vdC52YWx1ZS5pZCgpO1xuICB9XG59O1xuXG52YXIgYnVpbGRDbHVzdGVyc0Zyb21UcmVlID0gZnVuY3Rpb24gYnVpbGRDbHVzdGVyc0Zyb21UcmVlKHJvb3QsIGssIGN5KSB7XG4gIGlmICghcm9vdCkgcmV0dXJuIFtdO1xuICB2YXIgbGVmdCA9IFtdLFxuICAgICAgcmlnaHQgPSBbXSxcbiAgICAgIGxlYXZlcyA9IFtdO1xuXG4gIGlmIChrID09PSAwKSB7XG4gICAgLy8gZG9uJ3QgY3V0IHRyZWUsIHNpbXBseSByZXR1cm4gYWxsIG5vZGVzIGFzIDEgc2luZ2xlIGNsdXN0ZXJcbiAgICBpZiAocm9vdC5sZWZ0KSBnZXRBbGxDaGlsZHJlbihyb290LmxlZnQsIGxlZnQpO1xuICAgIGlmIChyb290LnJpZ2h0KSBnZXRBbGxDaGlsZHJlbihyb290LnJpZ2h0LCByaWdodCk7XG4gICAgbGVhdmVzID0gbGVmdC5jb25jYXQocmlnaHQpO1xuICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihsZWF2ZXMpXTtcbiAgfSBlbHNlIGlmIChrID09PSAxKSB7XG4gICAgLy8gY3V0IGF0IHJvb3RcbiAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgLy8gbGVhZiBub2RlXG4gICAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24ocm9vdC52YWx1ZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocm9vdC5sZWZ0KSBnZXRBbGxDaGlsZHJlbihyb290LmxlZnQsIGxlZnQpO1xuICAgICAgaWYgKHJvb3QucmlnaHQpIGdldEFsbENoaWxkcmVuKHJvb3QucmlnaHQsIHJpZ2h0KTtcbiAgICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihsZWZ0KSwgY3kuY29sbGVjdGlvbihyaWdodCldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKHJvb3QudmFsdWUpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJvb3QubGVmdCkgbGVmdCA9IGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZShyb290LmxlZnQsIGsgLSAxLCBjeSk7XG4gICAgICBpZiAocm9vdC5yaWdodCkgcmlnaHQgPSBidWlsZENsdXN0ZXJzRnJvbVRyZWUocm9vdC5yaWdodCwgayAtIDEsIGN5KTtcbiAgICAgIHJldHVybiBsZWZ0LmNvbmNhdChyaWdodCk7XG4gICAgfVxuICB9XG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbnZhciBoaWVyYXJjaGljYWxDbHVzdGVyaW5nID0gZnVuY3Rpb24gaGllcmFyY2hpY2FsQ2x1c3RlcmluZyhvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpOyAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06IGxpbmthZ2UgdHlwZSwgZGlzdGFuY2UgbWV0cmljLCBldGMuXG5cbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDIob3B0aW9ucyk7XG4gIHZhciBhdHRycyA9IG9wdHMuYXR0cmlidXRlcztcblxuICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QobjEsIG4yKSB7XG4gICAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZShvcHRzLmRpc3RhbmNlLCBhdHRycy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objEpO1xuICAgIH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cnNbaV0objIpO1xuICAgIH0sIG4xLCBuMik7XG4gIH07IC8vIEJlZ2luIGhpZXJhcmNoaWNhbCBhbGdvcml0aG1cblxuXG4gIHZhciBjbHVzdGVycyA9IFtdO1xuICB2YXIgZGlzdHMgPSBbXTsgLy8gZGlzdGFuY2VzIGJldHdlZW4gZWFjaCBwYWlyIG9mIGNsdXN0ZXJzXG5cbiAgdmFyIG1pbnMgPSBbXTsgLy8gY2xvc2VzdCBjbHVzdGVyIGZvciBlYWNoIGNsdXN0ZXJcblxuICB2YXIgaW5kZXggPSBbXTsgLy8gaGFzaCBvZiBhbGwgY2x1c3RlcnMgYnkga2V5XG4gIC8vIEluIGFnZ2xvbWVyYXRpdmUgKGJvdHRvbS11cCkgY2x1c3RlcmluZywgZWFjaCBub2RlIHN0YXJ0cyBhcyBpdHMgb3duIGNsdXN0ZXJcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgdmFyIGNsdXN0ZXIgPSB7XG4gICAgICB2YWx1ZTogb3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScgPyBub2Rlc1tuXSA6IFtub2Rlc1tuXV0sXG4gICAgICBrZXk6IG4sXG4gICAgICBpbmRleDogblxuICAgIH07XG4gICAgY2x1c3RlcnNbbl0gPSBjbHVzdGVyO1xuICAgIGluZGV4W25dID0gY2x1c3RlcjtcbiAgICBkaXN0c1tuXSA9IFtdO1xuICAgIG1pbnNbbl0gPSAwO1xuICB9IC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBlYWNoIHBhaXIgb2YgY2x1c3RlcnNcblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBpOyBqKyspIHtcbiAgICAgIHZhciBkaXN0ID0gdm9pZCAwO1xuXG4gICAgICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICAgICAgLy8gbW9kZXMgc3RvcmUgY2x1c3RlciB2YWx1ZXMgZGlmZmVyZW50bHlcbiAgICAgICAgZGlzdCA9IGkgPT09IGogPyBJbmZpbml0eSA6IGdldERpc3QoY2x1c3RlcnNbaV0udmFsdWUsIGNsdXN0ZXJzW2pdLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3QgPSBpID09PSBqID8gSW5maW5pdHkgOiBnZXREaXN0KGNsdXN0ZXJzW2ldLnZhbHVlWzBdLCBjbHVzdGVyc1tqXS52YWx1ZVswXSk7XG4gICAgICB9XG5cbiAgICAgIGRpc3RzW2ldW2pdID0gZGlzdDtcbiAgICAgIGRpc3RzW2pdW2ldID0gZGlzdDtcblxuICAgICAgaWYgKGRpc3QgPCBkaXN0c1tpXVttaW5zW2ldXSkge1xuICAgICAgICBtaW5zW2ldID0gajsgLy8gQ2FjaGUgbWluczogY2xvc2VzdCBjbHVzdGVyIHRvIGNsdXN0ZXIgaSBpcyBjbHVzdGVyIGpcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gRmluZCB0aGUgY2xvc2VzdCBwYWlyIG9mIGNsdXN0ZXJzIGFuZCBtZXJnZSB0aGVtIGludG8gYSBzaW5nbGUgY2x1c3Rlci5cbiAgLy8gVXBkYXRlIGRpc3RhbmNlcyBiZXR3ZWVuIG5ldyBjbHVzdGVyIGFuZCBlYWNoIG9mIHRoZSBvbGQgY2x1c3RlcnMsIGFuZCBsb29wIHVudGlsIHRocmVzaG9sZCByZWFjaGVkLlxuXG5cbiAgdmFyIG1lcmdlZCA9IG1lcmdlQ2xvc2VzdChjbHVzdGVycywgaW5kZXgsIGRpc3RzLCBtaW5zLCBvcHRzKTtcblxuICB3aGlsZSAobWVyZ2VkKSB7XG4gICAgbWVyZ2VkID0gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpO1xuICB9XG5cbiAgdmFyIHJldENsdXN0ZXJzOyAvLyBEZW5kcm9ncmFtIG1vZGUgYnVpbGRzIHRoZSBoaWVyYXJjaHkgYW5kIGFkZHMgaW50ZXJtZWRpYXJ5IG5vZGVzICsgZWRnZXNcbiAgLy8gaW4gYWRkaXRpb24gdG8gcmV0dXJuaW5nIHRoZSBjbHVzdGVycy5cblxuICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICByZXRDbHVzdGVycyA9IGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZShjbHVzdGVyc1swXSwgb3B0cy5kZW5kcm9ncmFtRGVwdGgsIGN5KTtcbiAgICBpZiAob3B0cy5hZGREZW5kcm9ncmFtKSBidWlsZERlbmRyb2dyYW0oY2x1c3RlcnNbMF0sIGN5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZWd1bGFyIG1vZGUgc2ltcGx5IHJldHVybnMgdGhlIGNsdXN0ZXJzXG4gICAgcmV0Q2x1c3RlcnMgPSBuZXcgQXJyYXkoY2x1c3RlcnMubGVuZ3RoKTtcbiAgICBjbHVzdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjbHVzdGVyLCBpKSB7XG4gICAgICAvLyBDbGVhbiB1cCBtZXRhIGRhdGEgdXNlZCBmb3IgY2x1c3RlcmluZ1xuICAgICAgY2x1c3Rlci5rZXkgPSBjbHVzdGVyLmluZGV4ID0gbnVsbDtcbiAgICAgIHJldENsdXN0ZXJzW2ldID0gY3kuY29sbGVjdGlvbihjbHVzdGVyLnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXRDbHVzdGVycztcbn07XG5cbnZhciBoaWVyYXJjaGljYWxDbHVzdGVyaW5nJDEgPSB7XG4gIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmc6IGhpZXJhcmNoaWNhbENsdXN0ZXJpbmcsXG4gIGhjYTogaGllcmFyY2hpY2FsQ2x1c3RlcmluZ1xufTtcblxuLy8gSW1wbGVtZW50ZWQgYnkgWm9lIFhpIEB6b2V4aSBmb3IgR1NPQyAyMDE2XG52YXIgZGVmYXVsdHMkNyA9IGRlZmF1bHRzKHtcbiAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICAvLyBkaXN0YW5jZSBtZXRyaWMgdG8gY29tcGFyZSBhdHRyaWJ1dGVzIGJldHdlZW4gdHdvIG5vZGVzXG4gIHByZWZlcmVuY2U6ICdtZWRpYW4nLFxuICAvLyBzdWl0YWJpbGl0eSBvZiBhIGRhdGEgcG9pbnQgdG8gc2VydmUgYXMgYW4gZXhlbXBsYXJcbiAgZGFtcGluZzogMC44LFxuICAvLyBkYW1waW5nIGZhY3RvciBiZXR3ZWVuIFswLjUsIDEpXG4gIG1heEl0ZXJhdGlvbnM6IDEwMDAsXG4gIC8vIG1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBydW5cbiAgbWluSXRlcmF0aW9uczogMTAwLFxuICAvLyBtaW4gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcnVuIGluIG9yZGVyIGZvciBjbHVzdGVyaW5nIHRvIHN0b3BcbiAgYXR0cmlidXRlczogWy8vIGZ1bmN0aW9ucyB0byBxdWFudGlmeSB0aGUgc2ltaWxhcml0eSBiZXR3ZWVuIGFueSB0d28gcG9pbnRzXG4gICAgLy8gZS5nLiBub2RlID0+IG5vZGUuZGF0YSgnd2VpZ2h0JylcbiAgXVxufSk7XG5cbnZhciBzZXRPcHRpb25zJDMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIGRtcCA9IG9wdGlvbnMuZGFtcGluZztcbiAgdmFyIHByZWYgPSBvcHRpb25zLnByZWZlcmVuY2U7XG5cbiAgaWYgKCEoMC41IDw9IGRtcCAmJiBkbXAgPCAxKSkge1xuICAgIGVycm9yKFwiRGFtcGluZyBtdXN0IHJhbmdlIG9uIFswLjUsIDEpLiAgR290OiBcIi5jb25jYXQoZG1wKSk7XG4gIH1cblxuICB2YXIgdmFsaWRQcmVmcyA9IFsnbWVkaWFuJywgJ21lYW4nLCAnbWluJywgJ21heCddO1xuXG4gIGlmICghKHZhbGlkUHJlZnMuc29tZShmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2ID09PSBwcmVmO1xuICB9KSB8fCBudW1iZXIocHJlZikpKSB7XG4gICAgZXJyb3IoXCJQcmVmZXJlbmNlIG11c3QgYmUgb25lIG9mIFtcIi5jb25jYXQodmFsaWRQcmVmcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBcIidcIi5jb25jYXQocCwgXCInXCIpO1xuICAgIH0pLmpvaW4oJywgJyksIFwiXSBvciBhIG51bWJlci4gIEdvdDogXCIpLmNvbmNhdChwcmVmKSk7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdHMkNyhvcHRpb25zKTtcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxudmFyIGdldFNpbWlsYXJpdHkkMSA9IGZ1bmN0aW9uIGdldFNpbWlsYXJpdHkodHlwZSwgbjEsIG4yLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBhdHRyID0gZnVuY3Rpb24gYXR0cihuLCBpKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0obik7XG4gIH07IC8vIG5iIG5lZ2F0aXZlIGJlY2F1c2Ugc2ltaWxhcml0eSBzaG91bGQgaGF2ZSBhbiBpbnZlcnNlIHJlbGF0aW9uc2hpcCB0byBkaXN0YW5jZVxuXG5cbiAgcmV0dXJuIC1jbHVzdGVyaW5nRGlzdGFuY2UodHlwZSwgYXR0cmlidXRlcy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGF0dHIobjEsIGkpO1xuICB9LCBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBhdHRyKG4yLCBpKTtcbiAgfSwgbjEsIG4yKTtcbn07XG5cbnZhciBnZXRQcmVmZXJlbmNlID0gZnVuY3Rpb24gZ2V0UHJlZmVyZW5jZShTLCBwcmVmZXJlbmNlKSB7XG4gIC8vIGxhcmdlciBwcmVmZXJlbmNlID0gZ3JlYXRlciAjIG9mIGNsdXN0ZXJzXG4gIHZhciBwID0gbnVsbDtcblxuICBpZiAocHJlZmVyZW5jZSA9PT0gJ21lZGlhbicpIHtcbiAgICBwID0gbWVkaWFuKFMpO1xuICB9IGVsc2UgaWYgKHByZWZlcmVuY2UgPT09ICdtZWFuJykge1xuICAgIHAgPSBtZWFuKFMpO1xuICB9IGVsc2UgaWYgKHByZWZlcmVuY2UgPT09ICdtaW4nKSB7XG4gICAgcCA9IG1pbihTKTtcbiAgfSBlbHNlIGlmIChwcmVmZXJlbmNlID09PSAnbWF4Jykge1xuICAgIHAgPSBtYXgoUyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ3VzdG9tIHByZWZlcmVuY2UgbnVtYmVyLCBhcyBzZXQgYnkgdXNlclxuICAgIHAgPSBwcmVmZXJlbmNlO1xuICB9XG5cbiAgcmV0dXJuIHA7XG59O1xuXG52YXIgZmluZEV4ZW1wbGFycyA9IGZ1bmN0aW9uIGZpbmRFeGVtcGxhcnMobiwgUiwgQSkge1xuICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKFJbaSAqIG4gKyBpXSArIEFbaSAqIG4gKyBpXSA+IDApIHtcbiAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kaWNlcztcbn07XG5cbnZhciBhc3NpZ25DbHVzdGVycyA9IGZ1bmN0aW9uIGFzc2lnbkNsdXN0ZXJzKG4sIFMsIGV4ZW1wbGFycykge1xuICB2YXIgY2x1c3RlcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBlaSA9IDA7IGVpIDwgZXhlbXBsYXJzLmxlbmd0aDsgZWkrKykge1xuICAgICAgdmFyIGUgPSBleGVtcGxhcnNbZWldO1xuXG4gICAgICBpZiAoU1tpICogbiArIGVdID4gbWF4KSB7XG4gICAgICAgIGluZGV4ID0gZTtcbiAgICAgICAgbWF4ID0gU1tpICogbiArIGVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIGNsdXN0ZXJzLnB1c2goaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9laSA9IDA7IF9laSA8IGV4ZW1wbGFycy5sZW5ndGg7IF9laSsrKSB7XG4gICAgY2x1c3RlcnNbZXhlbXBsYXJzW19laV1dID0gZXhlbXBsYXJzW19laV07XG4gIH1cblxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG52YXIgYXNzaWduJDIgPSBmdW5jdGlvbiBhc3NpZ24obiwgUywgZXhlbXBsYXJzKSB7XG4gIHZhciBjbHVzdGVycyA9IGFzc2lnbkNsdXN0ZXJzKG4sIFMsIGV4ZW1wbGFycyk7XG5cbiAgZm9yICh2YXIgZWkgPSAwOyBlaSA8IGV4ZW1wbGFycy5sZW5ndGg7IGVpKyspIHtcbiAgICB2YXIgaWkgPSBbXTtcblxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2x1c3RlcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgIGlmIChjbHVzdGVyc1tjXSA9PT0gZXhlbXBsYXJzW2VpXSkge1xuICAgICAgICBpaS5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtYXhJID0gLTE7XG4gICAgdmFyIG1heFN1bSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlpLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHN1bSArPSBTW2lpW2pdICogbiArIGlpW2ldXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN1bSA+IG1heFN1bSkge1xuICAgICAgICBtYXhJID0gaTtcbiAgICAgICAgbWF4U3VtID0gc3VtO1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4ZW1wbGFyc1tlaV0gPSBpaVttYXhJXTtcbiAgfVxuXG4gIGNsdXN0ZXJzID0gYXNzaWduQ2x1c3RlcnMobiwgUywgZXhlbXBsYXJzKTtcbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcblxudmFyIGFmZmluaXR5UHJvcGFnYXRpb24gPSBmdW5jdGlvbiBhZmZpbml0eVByb3BhZ2F0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQzKG9wdGlvbnMpOyAvLyBNYXAgZWFjaCBub2RlIHRvIGl0cyBwb3NpdGlvbiBpbiBub2RlIGFycmF5XG5cbiAgdmFyIGlkMnBvc2l0aW9uID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgfSAvLyBCZWdpbiBhZmZpbml0eSBwcm9wYWdhdGlvbiBhbGdvcml0aG1cblxuXG4gIHZhciBuOyAvLyBudW1iZXIgb2YgZGF0YSBwb2ludHNcblxuICB2YXIgbjI7IC8vIHNpemUgb2YgbWF0cmljZXNcblxuICB2YXIgUzsgLy8gc2ltaWxhcml0eSBtYXRyaXggKDFEIGFycmF5KVxuXG4gIHZhciBwOyAvLyBwcmVmZXJlbmNlL3N1aXRhYmlsaXR5IG9mIGEgZGF0YSBwb2ludCB0byBzZXJ2ZSBhcyBhbiBleGVtcGxhclxuXG4gIHZhciBSOyAvLyByZXNwb25zaWJpbGl0eSBtYXRyaXggKDFEIGFycmF5KVxuXG4gIHZhciBBOyAvLyBhdmFpbGFiaWxpdHkgbWF0cml4ICgxRCBhcnJheSlcblxuICBuID0gbm9kZXMubGVuZ3RoO1xuICBuMiA9IG4gKiBuOyAvLyBJbml0aWFsaXplIGFuZCBidWlsZCBTIHNpbWlsYXJpdHkgbWF0cml4XG5cbiAgUyA9IG5ldyBBcnJheShuMik7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG4yOyBfaSsrKSB7XG4gICAgU1tfaV0gPSAtSW5maW5pdHk7IC8vIGZvciBjYXNlcyB3aGVyZSB0d28gZGF0YSBwb2ludHMgc2hvdWxkbid0IGJlIGxpbmtlZCB0b2dldGhlclxuICB9XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbjsgX2kyKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgaWYgKF9pMiAhPT0gaikge1xuICAgICAgICBTW19pMiAqIG4gKyBqXSA9IGdldFNpbWlsYXJpdHkkMShvcHRzLmRpc3RhbmNlLCBub2Rlc1tfaTJdLCBub2Rlc1tqXSwgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUGxhY2UgcHJlZmVyZW5jZXMgb24gdGhlIGRpYWdvbmFsIG9mIFNcblxuXG4gIHAgPSBnZXRQcmVmZXJlbmNlKFMsIG9wdHMucHJlZmVyZW5jZSk7XG5cbiAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbjsgX2kzKyspIHtcbiAgICBTW19pMyAqIG4gKyBfaTNdID0gcDtcbiAgfSAvLyBJbml0aWFsaXplIFIgcmVzcG9uc2liaWxpdHkgbWF0cml4XG5cblxuICBSID0gbmV3IEFycmF5KG4yKTtcblxuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBuMjsgX2k0KyspIHtcbiAgICBSW19pNF0gPSAwLjA7XG4gIH0gLy8gSW5pdGlhbGl6ZSBBIGF2YWlsYWJpbGl0eSBtYXRyaXhcblxuXG4gIEEgPSBuZXcgQXJyYXkobjIpO1xuXG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG4yOyBfaTUrKykge1xuICAgIEFbX2k1XSA9IDAuMDtcbiAgfVxuXG4gIHZhciBvbGQgPSBuZXcgQXJyYXkobik7XG4gIHZhciBScCA9IG5ldyBBcnJheShuKTtcbiAgdmFyIHNlID0gbmV3IEFycmF5KG4pO1xuXG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG47IF9pNisrKSB7XG4gICAgb2xkW19pNl0gPSAwLjA7XG4gICAgUnBbX2k2XSA9IDAuMDtcbiAgICBzZVtfaTZdID0gMDtcbiAgfVxuXG4gIHZhciBlID0gbmV3IEFycmF5KG4gKiBvcHRzLm1pbkl0ZXJhdGlvbnMpO1xuXG4gIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IGUubGVuZ3RoOyBfaTcrKykge1xuICAgIGVbX2k3XSA9IDA7XG4gIH1cblxuICB2YXIgaXRlcjtcblxuICBmb3IgKGl0ZXIgPSAwOyBpdGVyIDwgb3B0cy5tYXhJdGVyYXRpb25zOyBpdGVyKyspIHtcbiAgICAvLyBtYWluIGFsZ29yaXRobWljIGxvb3BcbiAgICAvLyBVcGRhdGUgUiByZXNwb25zaWJpbGl0eSBtYXRyaXhcbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBuOyBfaTgrKykge1xuICAgICAgdmFyIG1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgICBtYXgyID0gLUluZmluaXR5LFxuICAgICAgICAgIG1heEkgPSAtMSxcbiAgICAgICAgICBBUyA9IDAuMDtcblxuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG47IF9qKyspIHtcbiAgICAgICAgb2xkW19qXSA9IFJbX2k4ICogbiArIF9qXTtcbiAgICAgICAgQVMgPSBBW19pOCAqIG4gKyBfal0gKyBTW19pOCAqIG4gKyBfal07XG5cbiAgICAgICAgaWYgKEFTID49IG1heCkge1xuICAgICAgICAgIG1heDIgPSBtYXg7XG4gICAgICAgICAgbWF4ID0gQVM7XG4gICAgICAgICAgbWF4SSA9IF9qO1xuICAgICAgICB9IGVsc2UgaWYgKEFTID4gbWF4Mikge1xuICAgICAgICAgIG1heDIgPSBBUztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBuOyBfajIrKykge1xuICAgICAgICBSW19pOCAqIG4gKyBfajJdID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKFNbX2k4ICogbiArIF9qMl0gLSBtYXgpICsgb3B0cy5kYW1waW5nICogb2xkW19qMl07XG4gICAgICB9XG5cbiAgICAgIFJbX2k4ICogbiArIG1heEldID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKFNbX2k4ICogbiArIG1heEldIC0gbWF4MikgKyBvcHRzLmRhbXBpbmcgKiBvbGRbbWF4SV07XG4gICAgfSAvLyBVcGRhdGUgQSBhdmFpbGFiaWxpdHkgbWF0cml4XG5cblxuICAgIGZvciAodmFyIF9pOSA9IDA7IF9pOSA8IG47IF9pOSsrKSB7XG4gICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgZm9yICh2YXIgX2ozID0gMDsgX2ozIDwgbjsgX2ozKyspIHtcbiAgICAgICAgb2xkW19qM10gPSBBW19qMyAqIG4gKyBfaTldO1xuICAgICAgICBScFtfajNdID0gTWF0aC5tYXgoMCwgUltfajMgKiBuICsgX2k5XSk7XG4gICAgICAgIHN1bSArPSBScFtfajNdO1xuICAgICAgfVxuXG4gICAgICBzdW0gLT0gUnBbX2k5XTtcbiAgICAgIFJwW19pOV0gPSBSW19pOSAqIG4gKyBfaTldO1xuICAgICAgc3VtICs9IFJwW19pOV07XG5cbiAgICAgIGZvciAodmFyIF9qNCA9IDA7IF9qNCA8IG47IF9qNCsrKSB7XG4gICAgICAgIEFbX2o0ICogbiArIF9pOV0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiBNYXRoLm1pbigwLCBzdW0gLSBScFtfajRdKSArIG9wdHMuZGFtcGluZyAqIG9sZFtfajRdO1xuICAgICAgfVxuXG4gICAgICBBW19pOSAqIG4gKyBfaTldID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKHN1bSAtIFJwW19pOV0pICsgb3B0cy5kYW1waW5nICogb2xkW19pOV07XG4gICAgfSAvLyBDaGVjayBmb3IgY29udmVyZ2VuY2VcblxuXG4gICAgdmFyIEsgPSAwO1xuXG4gICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBuOyBfaTEwKyspIHtcbiAgICAgIHZhciBFID0gQVtfaTEwICogbiArIF9pMTBdICsgUltfaTEwICogbiArIF9pMTBdID4gMCA/IDEgOiAwO1xuICAgICAgZVtpdGVyICUgb3B0cy5taW5JdGVyYXRpb25zICogbiArIF9pMTBdID0gRTtcbiAgICAgIEsgKz0gRTtcbiAgICB9XG5cbiAgICBpZiAoSyA+IDAgJiYgKGl0ZXIgPj0gb3B0cy5taW5JdGVyYXRpb25zIC0gMSB8fCBpdGVyID09IG9wdHMubWF4SXRlcmF0aW9ucyAtIDEpKSB7XG4gICAgICB2YXIgX3N1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgbjsgX2kxMSsrKSB7XG4gICAgICAgIHNlW19pMTFdID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfajUgPSAwOyBfajUgPCBvcHRzLm1pbkl0ZXJhdGlvbnM7IF9qNSsrKSB7XG4gICAgICAgICAgc2VbX2kxMV0gKz0gZVtfajUgKiBuICsgX2kxMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VbX2kxMV0gPT09IDAgfHwgc2VbX2kxMV0gPT09IG9wdHMubWluSXRlcmF0aW9ucykge1xuICAgICAgICAgIF9zdW0rKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoX3N1bSA9PT0gbikge1xuICAgICAgICAvLyB0aGVuIHdlIGhhdmUgY29udmVyZ2VuY2VcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIElkZW50aWZ5IGV4ZW1wbGFycyAoY2x1c3RlciBjZW50ZXJzKVxuXG5cbiAgdmFyIGV4ZW1wbGFyc0luZGljZXMgPSBmaW5kRXhlbXBsYXJzKG4sIFIsIEEpOyAvLyBBc3NpZ24gbm9kZXMgdG8gY2x1c3RlcnNcblxuICB2YXIgY2x1c3RlckluZGljZXMgPSBhc3NpZ24kMihuLCBTLCBleGVtcGxhcnNJbmRpY2VzKTtcbiAgdmFyIGNsdXN0ZXJzID0ge307XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBleGVtcGxhcnNJbmRpY2VzLmxlbmd0aDsgYysrKSB7XG4gICAgY2x1c3RlcnNbZXhlbXBsYXJzSW5kaWNlc1tjXV0gPSBbXTtcbiAgfVxuXG4gIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgbm9kZXMubGVuZ3RoOyBfaTEyKyspIHtcbiAgICB2YXIgcG9zID0gaWQycG9zaXRpb25bbm9kZXNbX2kxMl0uaWQoKV07XG5cbiAgICB2YXIgY2x1c3RlckluZGV4ID0gY2x1c3RlckluZGljZXNbcG9zXTtcblxuICAgIGlmIChjbHVzdGVySW5kZXggIT0gbnVsbCkge1xuICAgICAgLy8gdGhlIG5vZGUgbWF5IGhhdmUgbm90IGJlZW4gYXNzaWduZWQgYSBjbHVzdGVyIGlmIG5vIHZhbGlkIGF0dHJpYnV0ZXMgd2VyZSBzcGVjaWZpZWRcbiAgICAgIGNsdXN0ZXJzW2NsdXN0ZXJJbmRleF0ucHVzaChub2Rlc1tfaTEyXSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJldENsdXN0ZXJzID0gbmV3IEFycmF5KGV4ZW1wbGFyc0luZGljZXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBfYyA9IDA7IF9jIDwgZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGg7IF9jKyspIHtcbiAgICByZXRDbHVzdGVyc1tfY10gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXJzW2V4ZW1wbGFyc0luZGljZXNbX2NdXSk7XG4gIH1cblxuICByZXR1cm4gcmV0Q2x1c3RlcnM7XG59O1xuXG52YXIgYWZmaW5pdHlQcm9wYWdhdGlvbiQxID0ge1xuICBhZmZpbml0eVByb3BhZ2F0aW9uOiBhZmZpbml0eVByb3BhZ2F0aW9uLFxuICBhcDogYWZmaW5pdHlQcm9wYWdhdGlvblxufTtcblxudmFyIGhpZXJob2x6ZXJEZWZhdWx0cyA9IGRlZmF1bHRzKHtcbiAgcm9vdDogdW5kZWZpbmVkLFxuICBkaXJlY3RlZDogZmFsc2Vcbn0pO1xudmFyIGVsZXNmbiRiID0ge1xuICBoaWVyaG9semVyOiBmdW5jdGlvbiBoaWVyaG9semVyKG9wdGlvbnMpIHtcbiAgICBpZiAoIXBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHJvb3Q6IGFyZ3NbMF0sXG4gICAgICAgIGRpcmVjdGVkOiBhcmdzWzFdXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBfaGllcmhvbHplckRlZmF1bHRzID0gaGllcmhvbHplckRlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICByb290ID0gX2hpZXJob2x6ZXJEZWZhdWx0cy5yb290LFxuICAgICAgICBkaXJlY3RlZCA9IF9oaWVyaG9semVyRGVmYXVsdHMuZGlyZWN0ZWQ7XG5cbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGRmbGFnID0gZmFsc2U7XG4gICAgdmFyIG9kZEluO1xuICAgIHZhciBvZGRPdXQ7XG4gICAgdmFyIHN0YXJ0VmVydGV4O1xuICAgIGlmIChyb290KSBzdGFydFZlcnRleCA9IHN0cmluZyhyb290KSA/IHRoaXMuZmlsdGVyKHJvb3QpWzBdLmlkKCkgOiByb290WzBdLmlkKCk7XG4gICAgdmFyIG5vZGVzID0ge307XG4gICAgdmFyIGVkZ2VzID0ge307XG5cbiAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICB2YXIgaW5kID0gZWxlLmluZGVncmVlKHRydWUpO1xuICAgICAgICAgIHZhciBvdXRkID0gZWxlLm91dGRlZ3JlZSh0cnVlKTtcbiAgICAgICAgICB2YXIgZDEgPSBpbmQgLSBvdXRkO1xuICAgICAgICAgIHZhciBkMiA9IG91dGQgLSBpbmQ7XG5cbiAgICAgICAgICBpZiAoZDEgPT0gMSkge1xuICAgICAgICAgICAgaWYgKG9kZEluKSBkZmxhZyA9IHRydWU7ZWxzZSBvZGRJbiA9IGlkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZDIgPT0gMSkge1xuICAgICAgICAgICAgaWYgKG9kZE91dCkgZGZsYWcgPSB0cnVlO2Vsc2Ugb2RkT3V0ID0gaWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChkMiA+IDEgfHwgZDEgPiAxKSB7XG4gICAgICAgICAgICBkZmxhZyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZXNbaWRdID0gW107XG4gICAgICAgICAgZWxlLm91dGdvZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUuaXNFZGdlKCkpIG5vZGVzW2lkXS5wdXNoKGUuaWQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRnZXNbaWRdID0gW3VuZGVmaW5lZCwgZWxlLnRhcmdldCgpLmlkKCldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgIHZhciBkID0gZWxlLmRlZ3JlZSh0cnVlKTtcblxuICAgICAgICAgIGlmIChkICUgMikge1xuICAgICAgICAgICAgaWYgKCFvZGRJbikgb2RkSW4gPSBpZDtlbHNlIGlmICghb2RkT3V0KSBvZGRPdXQgPSBpZDtlbHNlIGRmbGFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2Rlc1tpZF0gPSBbXTtcbiAgICAgICAgICBlbGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbaWRdLnB1c2goZS5pZCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGdlc1tpZF0gPSBbZWxlLnNvdXJjZSgpLmlkKCksIGVsZS50YXJnZXQoKS5pZCgpXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgIHRyYWlsOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmIChkZmxhZykgcmV0dXJuIHJlc3VsdDtlbHNlIGlmIChvZGRPdXQgJiYgb2RkSW4pIHtcbiAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICBpZiAoc3RhcnRWZXJ0ZXggJiYgb2RkT3V0ICE9IHN0YXJ0VmVydGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0VmVydGV4ID0gb2RkT3V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0VmVydGV4ICYmIG9kZE91dCAhPSBzdGFydFZlcnRleCAmJiBvZGRJbiAhPSBzdGFydFZlcnRleCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXJ0VmVydGV4KSB7XG4gICAgICAgICAgc3RhcnRWZXJ0ZXggPSBvZGRPdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzdGFydFZlcnRleCkgc3RhcnRWZXJ0ZXggPSBlbGVzWzBdLmlkKCk7XG4gICAgfVxuXG4gICAgdmFyIHdhbGsgPSBmdW5jdGlvbiB3YWxrKHYpIHtcbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHY7XG4gICAgICB2YXIgc3VidG91ciA9IFt2XTtcbiAgICAgIHZhciBhZGosIGFkalRhaWwsIGFkakhlYWQ7XG5cbiAgICAgIHdoaWxlIChub2Rlc1tjdXJyZW50Tm9kZV0ubGVuZ3RoKSB7XG4gICAgICAgIGFkaiA9IG5vZGVzW2N1cnJlbnROb2RlXS5zaGlmdCgpO1xuICAgICAgICBhZGpUYWlsID0gZWRnZXNbYWRqXVswXTtcbiAgICAgICAgYWRqSGVhZCA9IGVkZ2VzW2Fkal1bMV07XG5cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlICE9IGFkakhlYWQpIHtcbiAgICAgICAgICBub2Rlc1thZGpIZWFkXSA9IG5vZGVzW2FkakhlYWRdLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgIT0gYWRqO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGN1cnJlbnROb2RlID0gYWRqSGVhZDtcbiAgICAgICAgfSBlbHNlIGlmICghZGlyZWN0ZWQgJiYgY3VycmVudE5vZGUgIT0gYWRqVGFpbCkge1xuICAgICAgICAgIG5vZGVzW2FkalRhaWxdID0gbm9kZXNbYWRqVGFpbF0uZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZSAhPSBhZGo7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBhZGpUYWlsO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VidG91ci51bnNoaWZ0KGFkaik7XG4gICAgICAgIHN1YnRvdXIudW5zaGlmdChjdXJyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdWJ0b3VyO1xuICAgIH07XG5cbiAgICB2YXIgdHJhaWwgPSBbXTtcbiAgICB2YXIgc3VidG91ciA9IFtdO1xuICAgIHN1YnRvdXIgPSB3YWxrKHN0YXJ0VmVydGV4KTtcblxuICAgIHdoaWxlIChzdWJ0b3VyLmxlbmd0aCAhPSAxKSB7XG4gICAgICBpZiAobm9kZXNbc3VidG91clswXV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgdHJhaWwudW5zaGlmdChlbGVzLmdldEVsZW1lbnRCeUlkKHN1YnRvdXIuc2hpZnQoKSkpO1xuICAgICAgICB0cmFpbC51bnNoaWZ0KGVsZXMuZ2V0RWxlbWVudEJ5SWQoc3VidG91ci5zaGlmdCgpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJ0b3VyID0gd2FsayhzdWJ0b3VyLnNoaWZ0KCkpLmNvbmNhdChzdWJ0b3VyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cmFpbC51bnNoaWZ0KGVsZXMuZ2V0RWxlbWVudEJ5SWQoc3VidG91ci5zaGlmdCgpKSk7IC8vIGZpbmFsIG5vZGVcblxuICAgIGZvciAodmFyIGQgaW4gbm9kZXMpIHtcbiAgICAgIGlmIChub2Rlc1tkXS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQuZm91bmQgPSB0cnVlO1xuICAgIHJlc3VsdC50cmFpbCA9IHRoaXMuc3Bhd24odHJhaWwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBlbGVzZm4kYyA9IHt9O1xuW2VsZXNmbiwgZWxlc2ZuJDEsIGVsZXNmbiQyLCBlbGVzZm4kMywgZWxlc2ZuJDQsIGVsZXNmbiQ1LCBlbGVzZm4kNiwgZWxlc2ZuJDcsIGVsZXNmbiQ4LCBlbGVzZm4kOSwgZWxlc2ZuJGEsIG1hcmtvdkNsdXN0ZXJpbmckMSwga0NsdXN0ZXJpbmcsIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmckMSwgYWZmaW5pdHlQcm9wYWdhdGlvbiQxLCBlbGVzZm4kYl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKGVsZXNmbiRjLCBwcm9wcyk7XG59KTtcblxuLyohXG5FbWJlZGRhYmxlIE1pbmltdW0gU3RyaWN0bHktQ29tcGxpYW50IFByb21pc2VzL0ErIDEuMS4xIFRoZW5hYmxlXG5Db3B5cmlnaHQgKGMpIDIwMTMtMjAxNCBSYWxmIFMuIEVuZ2Vsc2NoYWxsIChodHRwOi8vZW5nZWxzY2hhbGwuY29tKVxuTGljZW5zZWQgdW5kZXIgVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuKi9cblxuLyogIHByb21pc2Ugc3RhdGVzIFtQcm9taXNlcy9BKyAyLjFdICAqL1xudmFyIFNUQVRFX1BFTkRJTkcgPSAwO1xuLyogIFtQcm9taXNlcy9BKyAyLjEuMV0gICovXG5cbnZhciBTVEFURV9GVUxGSUxMRUQgPSAxO1xuLyogIFtQcm9taXNlcy9BKyAyLjEuMl0gICovXG5cbnZhciBTVEFURV9SRUpFQ1RFRCA9IDI7XG4vKiAgW1Byb21pc2VzL0ErIDIuMS4zXSAgKi9cblxuLyogIHByb21pc2Ugb2JqZWN0IGNvbnN0cnVjdG9yICAqL1xuXG52YXIgYXBpID0gZnVuY3Rpb24gYXBpKGV4ZWN1dG9yKSB7XG4gIC8qICBvcHRpb25hbGx5IHN1cHBvcnQgbm9uLWNvbnN0cnVjdG9yL3BsYWluLWZ1bmN0aW9uIGNhbGwgICovXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBhcGkpKSByZXR1cm4gbmV3IGFwaShleGVjdXRvcik7XG4gIC8qICBpbml0aWFsaXplIG9iamVjdCAgKi9cblxuICB0aGlzLmlkID0gJ1RoZW5hYmxlLzEuMC43JztcbiAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BFTkRJTkc7XG4gIC8qICBpbml0aWFsIHN0YXRlICAqL1xuXG4gIHRoaXMuZnVsZmlsbFZhbHVlID0gdW5kZWZpbmVkO1xuICAvKiAgaW5pdGlhbCB2YWx1ZSAgKi9cblxuICAvKiAgW1Byb21pc2VzL0ErIDEuMywgMi4xLjIuMl0gICovXG5cbiAgdGhpcy5yZWplY3RSZWFzb24gPSB1bmRlZmluZWQ7XG4gIC8qICBpbml0aWFsIHJlYXNvbiAqL1xuXG4gIC8qICBbUHJvbWlzZXMvQSsgMS41LCAyLjEuMy4yXSAgKi9cblxuICB0aGlzLm9uRnVsZmlsbGVkID0gW107XG4gIC8qICBpbml0aWFsIGhhbmRsZXJzICAqL1xuXG4gIHRoaXMub25SZWplY3RlZCA9IFtdO1xuICAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cblxuICAvKiAgcHJvdmlkZSBvcHRpb25hbCBpbmZvcm1hdGlvbi1oaWRpbmcgcHJveHkgICovXG5cbiAgdGhpcy5wcm94eSA9IHtcbiAgICB0aGVuOiB0aGlzLnRoZW4uYmluZCh0aGlzKVxuICB9O1xuICAvKiAgc3VwcG9ydCBvcHRpb25hbCBleGVjdXRvciBmdW5jdGlvbiAgKi9cblxuICBpZiAodHlwZW9mIGV4ZWN1dG9yID09PSAnZnVuY3Rpb24nKSBleGVjdXRvci5jYWxsKHRoaXMsIHRoaXMuZnVsZmlsbC5iaW5kKHRoaXMpLCB0aGlzLnJlamVjdC5iaW5kKHRoaXMpKTtcbn07XG4vKiAgcHJvbWlzZSBBUEkgbWV0aG9kcyAgKi9cblxuXG5hcGkucHJvdG90eXBlID0ge1xuICAvKiAgcHJvbWlzZSByZXNvbHZpbmcgbWV0aG9kcyAgKi9cbiAgZnVsZmlsbDogZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX0ZVTEZJTExFRCwgJ2Z1bGZpbGxWYWx1ZScsIHZhbHVlKTtcbiAgfSxcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gZGVsaXZlcih0aGlzLCBTVEFURV9SRUpFQ1RFRCwgJ3JlamVjdFJlYXNvbicsIHZhbHVlKTtcbiAgfSxcblxuICAvKiAgXCJUaGUgdGhlbiBNZXRob2RcIiBbUHJvbWlzZXMvQSsgMS4xLCAxLjIsIDIuMl0gICovXG4gIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgY3VyciA9IHRoaXM7XG4gICAgdmFyIG5leHQgPSBuZXcgYXBpKCk7XG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjIuN10gICovXG5cbiAgICBjdXJyLm9uRnVsZmlsbGVkLnB1c2gocmVzb2x2ZXIob25GdWxmaWxsZWQsIG5leHQsICdmdWxmaWxsJykpO1xuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIvMi4yLjZdICAqL1xuXG4gICAgY3Vyci5vblJlamVjdGVkLnB1c2gocmVzb2x2ZXIob25SZWplY3RlZCwgbmV4dCwgJ3JlamVjdCcpKTtcbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4zLzIuMi42XSAgKi9cblxuICAgIGV4ZWN1dGUoY3Vycik7XG4gICAgcmV0dXJuIG5leHQucHJveHk7XG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNywgMy4zXSAgKi9cbiAgfVxufTtcbi8qICBkZWxpdmVyIGFuIGFjdGlvbiAgKi9cblxudmFyIGRlbGl2ZXIgPSBmdW5jdGlvbiBkZWxpdmVyKGN1cnIsIHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUEVORElORykge1xuICAgIGN1cnIuc3RhdGUgPSBzdGF0ZTtcbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjEsIDIuMS4zLjFdICAqL1xuXG4gICAgY3VycltuYW1lXSA9IHZhbHVlO1xuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMiwgMi4xLjMuMl0gICovXG5cbiAgICBleGVjdXRlKGN1cnIpO1xuICB9XG5cbiAgcmV0dXJuIGN1cnI7XG59O1xuLyogIGV4ZWN1dGUgYWxsIGhhbmRsZXJzICAqL1xuXG5cbnZhciBleGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZShjdXJyKSB7XG4gIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9GVUxGSUxMRUQpIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgJ29uRnVsZmlsbGVkJywgY3Vyci5mdWxmaWxsVmFsdWUpO2Vsc2UgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX1JFSkVDVEVEKSBleGVjdXRlX2hhbmRsZXJzKGN1cnIsICdvblJlamVjdGVkJywgY3Vyci5yZWplY3RSZWFzb24pO1xufTtcbi8qICBleGVjdXRlIHBhcnRpY3VsYXIgc2V0IG9mIGhhbmRsZXJzICAqL1xuXG5cbnZhciBleGVjdXRlX2hhbmRsZXJzID0gZnVuY3Rpb24gZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCBuYW1lLCB2YWx1ZSkge1xuICAvKiBnbG9iYWwgc2V0SW1tZWRpYXRlOiB0cnVlICovXG5cbiAgLyogZ2xvYmFsIHNldFRpbWVvdXQ6IHRydWUgKi9cblxuICAvKiAgc2hvcnQtY2lyY3VpdCBwcm9jZXNzaW5nICAqL1xuICBpZiAoY3VycltuYW1lXS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgLyogIGl0ZXJhdGUgb3ZlciBhbGwgaGFuZGxlcnMsIGV4YWN0bHkgb25jZSAgKi9cblxuICB2YXIgaGFuZGxlcnMgPSBjdXJyW25hbWVdO1xuICBjdXJyW25hbWVdID0gW107XG4gIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMywgMi4yLjMuM10gICovXG5cbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhbmRsZXJzW2ldKHZhbHVlKTtcbiAgICB9XG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNV0gICovXG5cbiAgfTtcbiAgLyogIGV4ZWN1dGUgcHJvY2VkdXJlIGFzeW5jaHJvbm91c2x5ICAqL1xuXG4gIC8qICBbUHJvbWlzZXMvQSsgMi4yLjQsIDMuMV0gICovXG5cblxuICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykgc2V0SW1tZWRpYXRlKGZ1bmMpO2Vsc2Ugc2V0VGltZW91dChmdW5jLCAwKTtcbn07XG4vKiAgZ2VuZXJhdGUgYSByZXNvbHZlciBmdW5jdGlvbiAgKi9cblxuXG52YXIgcmVzb2x2ZXIgPSBmdW5jdGlvbiByZXNvbHZlcihjYiwgbmV4dCwgbWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMSwgMi4yLjcuMywgMi4yLjcuNF0gICovXG4gICAgICBuZXh0W21ldGhvZF0uY2FsbChuZXh0LCB2YWx1ZSk7XG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMSwgMi4yLjMuMSwgMi4yLjUsIDMuMl0gICovXG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgbmV4dC5yZWplY3QoZSk7XG4gICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4yXSAgKi9cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUobmV4dCwgcmVzdWx0KTtcbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4xXSAgKi9cbiAgICAgIH1cbiAgfTtcbn07XG4vKiAgXCJQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXCIgICovXG5cbi8qICBbUHJvbWlzZXMvQSsgMi4zXSAgKi9cblxuXG52YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgeCkge1xuICAvKiAgc2FuaXR5IGNoZWNrIGFyZ3VtZW50cyAgKi9cblxuICAvKiAgW1Byb21pc2VzL0ErIDIuMy4xXSAgKi9cbiAgaWYgKHByb21pc2UgPT09IHggfHwgcHJvbWlzZS5wcm94eSA9PT0geCkge1xuICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qICBzdXJnaWNhbGx5IGNoZWNrIGZvciBhIFwidGhlblwiIG1ldGhvZFxuICAgIChtYWlubHkgdG8ganVzdCBjYWxsIHRoZSBcImdldHRlclwiIG9mIFwidGhlblwiIG9ubHkgb25jZSkgICovXG5cblxuICB2YXIgdGhlbjtcblxuICBpZiAoX3R5cGVvZih4KSA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB0aGVuID0geC50aGVuO1xuICAgIH1cbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjEsIDMuNV0gICovXG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHByb21pc2UucmVqZWN0KGUpO1xuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4yXSAgKi9cblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvKiAgaGFuZGxlIG93biBUaGVuYWJsZXMgICAgW1Byb21pc2VzL0ErIDIuMy4yXVxuICAgIGFuZCBzaW1pbGFyIFwidGhlbmFibGVzXCIgW1Byb21pc2VzL0ErIDIuMy4zXSAgKi9cblxuXG4gIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXNvbHZlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8qICBjYWxsIHJldHJpZXZlZCBcInRoZW5cIiBtZXRob2QgKi9cblxuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zXSAgKi9cbiAgICAgIHRoZW4uY2FsbCh4LFxuICAgICAgLyogIHJlc29sdmVQcm9taXNlICAqL1xuXG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMV0gICovXG4gICAgICBmdW5jdGlvbiAoeSkge1xuICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjtcbiAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG5cbiAgICAgICAgaWYgKHkgPT09IHgpXG4gICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAzLjZdICAqL1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2NpcmN1bGFyIHRoZW5hYmxlIGNoYWluJykpO2Vsc2UgcmVzb2x2ZShwcm9taXNlLCB5KTtcbiAgICAgIH0sXG4gICAgICAvKiAgcmVqZWN0UHJvbWlzZSAgKi9cblxuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjJdICAqL1xuICAgICAgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm47XG4gICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuXG4gICAgICAgIHByb21pc2UucmVqZWN0KHIpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICBwcm9taXNlLnJlamVjdChlKTtcbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy40XSAgKi9cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cbiAgLyogIGhhbmRsZSBvdGhlciB2YWx1ZXMgICovXG5cblxuICBwcm9taXNlLmZ1bGZpbGwoeCk7XG4gIC8qICBbUHJvbWlzZXMvQSsgMi4zLjQsIDIuMy4zLjRdICAqL1xufTsgLy8gc28gd2UgYWx3YXlzIGhhdmUgUHJvbWlzZS5hbGwoKVxuXG5cbmFwaS5hbGwgPSBmdW5jdGlvbiAocHMpIHtcbiAgcmV0dXJuIG5ldyBhcGkoZnVuY3Rpb24gKHJlc29sdmVBbGwsIHJlamVjdEFsbCkge1xuICAgIHZhciB2YWxzID0gbmV3IEFycmF5KHBzLmxlbmd0aCk7XG4gICAgdmFyIGRvbmVDb3VudCA9IDA7XG5cbiAgICB2YXIgZnVsZmlsbCA9IGZ1bmN0aW9uIGZ1bGZpbGwoaSwgdmFsKSB7XG4gICAgICB2YWxzW2ldID0gdmFsO1xuICAgICAgZG9uZUNvdW50Kys7XG5cbiAgICAgIGlmIChkb25lQ291bnQgPT09IHBzLmxlbmd0aCkge1xuICAgICAgICByZXNvbHZlQWxsKHZhbHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIHAgPSBwc1tpXTtcbiAgICAgICAgdmFyIGlzUHJvbWlzZSA9IHAgIT0gbnVsbCAmJiBwLnRoZW4gIT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNQcm9taXNlKSB7XG4gICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGZ1bGZpbGwoaSwgdmFsKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3RBbGwoZXJyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsID0gcDtcbiAgICAgICAgICBmdWxmaWxsKGksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pKGkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5hcGkucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBhcGkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlc29sdmUodmFsKTtcbiAgfSk7XG59O1xuXG5hcGkucmVqZWN0ID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHZhbCk7XG4gIH0pO1xufTtcblxudmFyIFByb21pc2UkMSA9IHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyA/IFByb21pc2UgOiBhcGk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxudmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIEFuaW1hdGlvbih0YXJnZXQsIG9wdHMsIG9wdHMyKSB7XG4gIHZhciBpc0NvcmUgPSBjb3JlKHRhcmdldCk7XG4gIHZhciBpc0VsZSA9ICFpc0NvcmU7XG5cbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IGV4dGVuZCh7XG4gICAgZHVyYXRpb246IDEwMDBcbiAgfSwgb3B0cywgb3B0czIpO1xuXG4gIF9wLnRhcmdldCA9IHRhcmdldDtcbiAgX3Auc3R5bGUgPSBfcC5zdHlsZSB8fCBfcC5jc3M7XG4gIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgX3AucGxheWluZyA9IGZhbHNlO1xuICBfcC5ob29rZWQgPSBmYWxzZTtcbiAgX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgX3AucHJvZ3Jlc3MgPSAwO1xuICBfcC5jb21wbGV0ZXMgPSBbXTtcbiAgX3AuZnJhbWVzID0gW107XG5cbiAgaWYgKF9wLmNvbXBsZXRlICYmIGZuKF9wLmNvbXBsZXRlKSkge1xuICAgIF9wLmNvbXBsZXRlcy5wdXNoKF9wLmNvbXBsZXRlKTtcbiAgfVxuXG4gIGlmIChpc0VsZSkge1xuICAgIHZhciBwb3MgPSB0YXJnZXQucG9zaXRpb24oKTtcbiAgICBfcC5zdGFydFBvc2l0aW9uID0gX3Auc3RhcnRQb3NpdGlvbiB8fCB7XG4gICAgICB4OiBwb3MueCxcbiAgICAgIHk6IHBvcy55XG4gICAgfTtcbiAgICBfcC5zdGFydFN0eWxlID0gX3Auc3RhcnRTdHlsZSB8fCB0YXJnZXQuY3koKS5zdHlsZSgpLmdldEFuaW1hdGlvblN0YXJ0U3R5bGUodGFyZ2V0LCBfcC5zdHlsZSk7XG4gIH1cblxuICBpZiAoaXNDb3JlKSB7XG4gICAgdmFyIHBhbiA9IHRhcmdldC5wYW4oKTtcbiAgICBfcC5zdGFydFBhbiA9IHtcbiAgICAgIHg6IHBhbi54LFxuICAgICAgeTogcGFuLnlcbiAgICB9O1xuICAgIF9wLnN0YXJ0Wm9vbSA9IHRhcmdldC56b29tKCk7XG4gIH0gLy8gZm9yIGZ1dHVyZSB0aW1lbGluZS9hbmltYXRpb25zIGltcGxcblxuXG4gIHRoaXMubGVuZ3RoID0gMTtcbiAgdGhpc1swXSA9IHRoaXM7XG59O1xuXG52YXIgYW5pZm4gPSBBbmltYXRpb24ucHJvdG90eXBlO1xuZXh0ZW5kKGFuaWZuLCB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICByZXR1cm4gJ2FuaW1hdGlvbic7XG4gIH0sXG4gIGhvb2s6IGZ1bmN0aW9uIGhvb2soKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmICghX3AuaG9va2VkKSB7XG4gICAgICAvLyBhZGQgdG8gdGFyZ2V0J3MgYW5pbWF0aW9uIHF1ZXVlXG4gICAgICB2YXIgcTtcbiAgICAgIHZhciB0QW5pID0gX3AudGFyZ2V0Ll9wcml2YXRlLmFuaW1hdGlvbjtcblxuICAgICAgaWYgKF9wLnF1ZXVlKSB7XG4gICAgICAgIHEgPSB0QW5pLnF1ZXVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcSA9IHRBbmkuY3VycmVudDtcbiAgICAgIH1cblxuICAgICAgcS5wdXNoKHRoaXMpOyAvLyBhZGQgdG8gdGhlIGFuaW1hdGlvbiBsb29wIHBvb2xcblxuICAgICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oX3AudGFyZ2V0KSkge1xuICAgICAgICBfcC50YXJnZXQuY3koKS5hZGRUb0FuaW1hdGlvblBvb2woX3AudGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgX3AuaG9va2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcGxheTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlOyAvLyBhdXRvcmV3aW5kXG5cbiAgICBpZiAoX3AucHJvZ3Jlc3MgPT09IDEpIHtcbiAgICAgIF9wLnByb2dyZXNzID0gMDtcbiAgICB9XG5cbiAgICBfcC5wbGF5aW5nID0gdHJ1ZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7IC8vIG5lZWRzIHRvIGJlIHN0YXJ0ZWQgYnkgYW5pbWF0aW9uIGxvb3BcblxuICAgIF9wLnN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhvb2soKTsgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgc3RhcnQgdGhlIGFuaW1hdGlvbi4uLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBsYXlpbmc6IGZ1bmN0aW9uIHBsYXlpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGxheWluZztcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgX3AuYXBwbHlpbmcgPSB0cnVlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgc3RhcnRlZCBieSBhbmltYXRpb24gbG9vcFxuXG4gICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuaG9vaygpOyAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBhcHBseSB0aGUgYW5pbWF0aW9uIGF0IHRoaXMgcHJvZ3Jlc3NcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhcHBseWluZzogZnVuY3Rpb24gYXBwbHlpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXBwbHlpbmc7XG4gIH0sXG4gIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgIF9wLnN0b3BwZWQgPSB0cnVlOyAvLyB0byBiZSByZW1vdmVkIGZyb20gYW5pbWF0aW9uIHF1ZXVlc1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJld2luZDogZnVuY3Rpb24gcmV3aW5kKCkge1xuICAgIHJldHVybiB0aGlzLnByb2dyZXNzKDApO1xuICB9LFxuICBmYXN0Zm9yd2FyZDogZnVuY3Rpb24gZmFzdGZvcndhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3MoMSk7XG4gIH0sXG4gIHRpbWU6IGZ1bmN0aW9uIHRpbWUodCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX3AucHJvZ3Jlc3MgKiBfcC5kdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3ModCAvIF9wLmR1cmF0aW9uKTtcbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhwKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG5cbiAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX3AucHJvZ3Jlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIH1cblxuICAgICAgX3AucHJvZ3Jlc3MgPSBwO1xuICAgICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29tcGxldGVkOiBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucHJvZ3Jlc3MgPT09IDE7XG4gIH0sXG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG5cbiAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cblxuICAgIF9wLnByb2dyZXNzID0gMSAtIF9wLnByb2dyZXNzO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIHZhciBzd2FwID0gZnVuY3Rpb24gc3dhcChhLCBiKSB7XG4gICAgICB2YXIgX3BhID0gX3BbYV07XG5cbiAgICAgIGlmIChfcGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF9wW2FdID0gX3BbYl07XG4gICAgICBfcFtiXSA9IF9wYTtcbiAgICB9O1xuXG4gICAgc3dhcCgnem9vbScsICdzdGFydFpvb20nKTtcbiAgICBzd2FwKCdwYW4nLCAnc3RhcnRQYW4nKTtcbiAgICBzd2FwKCdwb3NpdGlvbicsICdzdGFydFBvc2l0aW9uJyk7IC8vIHN3YXAgc3R5bGVzXG5cbiAgICBpZiAoX3Auc3R5bGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3Auc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBfcC5zdHlsZVtpXTtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciBzdGFydFN0eWxlUHJvcCA9IF9wLnN0YXJ0U3R5bGVbbmFtZV07XG4gICAgICAgIF9wLnN0YXJ0U3R5bGVbbmFtZV0gPSBwcm9wO1xuICAgICAgICBfcC5zdHlsZVtpXSA9IHN0YXJ0U3R5bGVQcm9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZSh0eXBlKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgYXJyO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICAgIGFyciA9IF9wLmZyYW1lcztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICBhcnIgPSBfcC5jb21wbGV0ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgYXJyLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufSk7XG5hbmlmbi5jb21wbGV0ZSA9IGFuaWZuLmNvbXBsZXRlZDtcbmFuaWZuLnJ1biA9IGFuaWZuLnBsYXk7XG5hbmlmbi5ydW5uaW5nID0gYW5pZm4ucGxheWluZztcblxudmFyIGRlZmluZSA9IHtcbiAgYW5pbWF0ZWQ6IGZ1bmN0aW9uIGFuaW1hdGVkKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlZEltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZSA9IGFsbFswXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50Lmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgLy8gYW5pbWF0ZWRcbiAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJRdWV1ZUltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0sXG4gIC8vIGNsZWFyUXVldWVcbiAgZGVsYXk6IGZ1bmN0aW9uIGRlbGF5KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUltcGwodGltZSwgY29tcGxldGUpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuICAvLyBkZWxheVxuICBkZWxheUFuaW1hdGlvbjogZnVuY3Rpb24gZGVsYXlBbmltYXRpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5QW5pbWF0aW9uSW1wbCh0aW1lLCBjb21wbGV0ZSkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24oe1xuICAgICAgICBkZWxheTogdGltZSxcbiAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSxcbiAgLy8gZGVsYXlcbiAgYW5pbWF0aW9uOiBmdW5jdGlvbiBhbmltYXRpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGlvbkltcGwocHJvcGVydGllcywgcGFyYW1zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgdmFyIGlzQ29yZSA9ICFzZWxmSXNBcnJheUxpa2U7XG4gICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgIHByb3BlcnRpZXMgPSBleHRlbmQoe30sIHByb3BlcnRpZXMsIHBhcmFtcyk7XG4gICAgICB2YXIgcHJvcGVydGllc0VtcHR5ID0gT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoID09PSAwO1xuXG4gICAgICBpZiAocHJvcGVydGllc0VtcHR5KSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGFsbFswXSwgcHJvcGVydGllcyk7IC8vIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydGllcy5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSA0MDA7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcGVydGllcy5kdXJhdGlvbikge1xuICAgICAgICBjYXNlICdzbG93JzpcbiAgICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gNjAwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Zhc3QnOlxuICAgICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSAyMDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VsZXMpIHtcbiAgICAgICAgcHJvcGVydGllcy5zdHlsZSA9IHN0eWxlLmdldFByb3BzTGlzdChwcm9wZXJ0aWVzLnN0eWxlIHx8IHByb3BlcnRpZXMuY3NzKTtcbiAgICAgICAgcHJvcGVydGllcy5jc3MgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VsZXMgJiYgcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHJwb3MgPSBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgIHByb3BlcnRpZXMucG9zaXRpb24gPSByZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihycG9zLCB6b29tLCBwYW4pO1xuICAgICAgfSAvLyBvdmVycmlkZSBwYW4gdy8gcGFuQnkgaWYgc2V0XG5cblxuICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLnBhbkJ5ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHBhbkJ5ID0gcHJvcGVydGllcy5wYW5CeTtcbiAgICAgICAgdmFyIGN5UGFuID0gY3kucGFuKCk7XG4gICAgICAgIHByb3BlcnRpZXMucGFuID0ge1xuICAgICAgICAgIHg6IGN5UGFuLnggKyBwYW5CeS54LFxuICAgICAgICAgIHk6IGN5UGFuLnkgKyBwYW5CeS55XG4gICAgICAgIH07XG4gICAgICB9IC8vIG92ZXJyaWRlIHBhbiB3LyBjZW50ZXIgaWYgc2V0XG5cblxuICAgICAgdmFyIGNlbnRlciA9IHByb3BlcnRpZXMuY2VudGVyIHx8IHByb3BlcnRpZXMuY2VudHJlO1xuXG4gICAgICBpZiAoaXNDb3JlICYmIGNlbnRlciAhPSBudWxsKSB7XG4gICAgICAgIHZhciBjZW50ZXJQYW4gPSBjeS5nZXRDZW50ZXJQYW4oY2VudGVyLmVsZXMsIHByb3BlcnRpZXMuem9vbSk7XG5cbiAgICAgICAgaWYgKGNlbnRlclBhbiAhPSBudWxsKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBjZW50ZXJQYW47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gb3ZlcnJpZGUgcGFuICYgem9vbSB3LyBmaXQgaWYgc2V0XG5cblxuICAgICAgaWYgKGlzQ29yZSAmJiBwcm9wZXJ0aWVzLmZpdCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBmaXQgPSBwcm9wZXJ0aWVzLmZpdDtcbiAgICAgICAgdmFyIGZpdFZwID0gY3kuZ2V0Rml0Vmlld3BvcnQoZml0LmVsZXMgfHwgZml0LmJvdW5kaW5nQm94LCBmaXQucGFkZGluZyk7XG5cbiAgICAgICAgaWYgKGZpdFZwICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGZpdFZwLnBhbjtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSBmaXRWcC56b29tO1xuICAgICAgICB9XG4gICAgICB9IC8vIG92ZXJyaWRlIHpvb20gKCYgcG90ZW50aWFsbHkgcGFuKSB3LyB6b29tIG9iaiBpZiBzZXRcblxuXG4gICAgICBpZiAoaXNDb3JlICYmIHBsYWluT2JqZWN0KHByb3BlcnRpZXMuem9vbSkpIHtcbiAgICAgICAgdmFyIHZwID0gY3kuZ2V0Wm9vbWVkVmlld3BvcnQocHJvcGVydGllcy56b29tKTtcblxuICAgICAgICBpZiAodnAgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh2cC56b29tZWQpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IHZwLnpvb207XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZwLnBhbm5lZCkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wYW4gPSB2cC5wYW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGFsbFswXSwgcHJvcGVydGllcyk7XG4gICAgfTtcbiAgfSxcbiAgLy8gYW5pbWF0ZVxuICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlSW1wbChwcm9wZXJ0aWVzLCBwYXJhbXMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgcHJvcGVydGllcyA9IGV4dGVuZCh7fSwgcHJvcGVydGllcywgcGFyYW1zKTtcbiAgICAgIH0gLy8gbWFudWFsbHkgaG9vayBhbmQgcnVuIHRoZSBhbmltYXRpb25cblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICB2YXIgcXVldWUgPSBlbGUuYW5pbWF0ZWQoKSAmJiAocHJvcGVydGllcy5xdWV1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BlcnRpZXMucXVldWUpO1xuICAgICAgICB2YXIgYW5pID0gZWxlLmFuaW1hdGlvbihwcm9wZXJ0aWVzLCBxdWV1ZSA/IHtcbiAgICAgICAgICBxdWV1ZTogdHJ1ZVxuICAgICAgICB9IDogdW5kZWZpbmVkKTtcbiAgICAgICAgYW5pLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfTtcbiAgfSxcbiAgLy8gYW5pbWF0ZVxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzdG9wSW1wbChjbGVhclF1ZXVlLCBqdW1wVG9FbmQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIGFuaXMgPSBfcC5hbmltYXRpb24uY3VycmVudDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFuaXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgYW5pID0gYW5pc1tqXTtcbiAgICAgICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG5cbiAgICAgICAgICBpZiAoanVtcFRvRW5kKSB7XG4gICAgICAgICAgICAvLyBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGxvb3AsIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgIC8vIHdpbGwgZ28gc3RyYWlnaHQgdG8gdGhlIGVuZCBhbmQgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgYW5pX3AuZHVyYXRpb24gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBjbGVhciB0aGUgcXVldWUgb2YgZnV0dXJlIGFuaW1hdGlvbnNcblxuXG4gICAgICAgIGlmIChjbGVhclF1ZXVlKSB7XG4gICAgICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWp1bXBUb0VuZCkge1xuICAgICAgICAgIF9wLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICAgIH1cbiAgICAgIH0gLy8gd2UgaGF2ZSB0byBub3RpZnkgKHRoZSBhbmltYXRpb24gbG9vcCBkb2Vzbid0IGRvIGl0IGZvciB1cyBvbiBgc3RvcGApXG5cblxuICAgICAgY3kubm90aWZ5KCdkcmF3Jyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9IC8vIHN0b3BcblxufTsgLy8gZGVmaW5lXG5cbnZhciBkZWZpbmUkMSA9IHtcbiAgLy8gYWNjZXNzIGRhdGEgZmllbGRcbiAgZGF0YTogZnVuY3Rpb24gZGF0YShwYXJhbXMpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogZmFsc2UsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9LFxuICAgICAgLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICB1cGRhdGVTdHlsZTogZmFsc2UsXG4gICAgICBiZWZvcmVHZXQ6IGZ1bmN0aW9uIGJlZm9yZUdldChzZWxmKSB7fSxcbiAgICAgIGJlZm9yZVNldDogZnVuY3Rpb24gYmVmb3JlU2V0KHNlbGYsIG9iaikge30sXG4gICAgICBvblNldDogZnVuY3Rpb24gb25TZXQoc2VsZikge30sXG4gICAgICBjYW5TZXQ6IGZ1bmN0aW9uIGNhblNldChzZWxmKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGF0YUltcGwobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG5cbiAgICAgIHZhciBzaW5nbGUgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmWzBdIDogc2VsZjsgLy8gLmRhdGEoJ2ZvbycsIC4uLilcblxuICAgICAgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgICAgICAvLyBzZXQgb3IgZ2V0IHByb3BlcnR5XG4gICAgICAgIC8vIC5kYXRhKCdmb28nKVxuICAgICAgICBpZiAocC5hbGxvd0dldHRpbmcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGdldFxuICAgICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgICAgICBwLmJlZm9yZUdldChzaW5nbGUpO1xuICAgICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXQ7IC8vIC5kYXRhKCdmb28nLCAnYmFyJylcbiAgICAgICAgfSBlbHNlIGlmIChwLmFsbG93U2V0dGluZyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gc2V0XG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1tuYW1lXTtcblxuICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IF9kZWZpbmVQcm9wZXJ0eSh7fSwgbmFtZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBwLmJlZm9yZVNldChzZWxmLCBjaGFuZ2UpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFsbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcblxuICAgICAgICAgICAgICBpZiAocC5jYW5TZXQoZWxlKSkge1xuICAgICAgICAgICAgICAgIGVsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG5cblxuICAgICAgICAgICAgaWYgKHAudXBkYXRlU3R5bGUpIHtcbiAgICAgICAgICAgICAgc2VsZi51cGRhdGVTdHlsZSgpO1xuICAgICAgICAgICAgfSAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG5cblxuICAgICAgICAgICAgcC5vblNldChzZWxmKTtcblxuICAgICAgICAgICAgaWYgKHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQpIHtcbiAgICAgICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuc2V0dGluZ0V2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gLmRhdGEoeyAnZm9vJzogJ2JhcicgfSlcblxuICAgICAgfSBlbHNlIGlmIChwLmFsbG93U2V0dGluZyAmJiBwbGFpbk9iamVjdChuYW1lKSkge1xuICAgICAgICAvLyBleHRlbmRcbiAgICAgICAgdmFyIG9iaiA9IG5hbWU7XG4gICAgICAgIHZhciBrLCB2O1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIHAuYmVmb3JlU2V0KHNlbGYsIG9iaik7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgayA9IGtleXNbX2ldO1xuICAgICAgICAgIHYgPSBvYmpba107XG5cbiAgICAgICAgICB2YXIgX3ZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trXTtcblxuICAgICAgICAgIGlmIChfdmFsaWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfZWxlID0gYWxsW2pdO1xuXG4gICAgICAgICAgICAgIGlmIChwLmNhblNldChfZWxlKSkge1xuICAgICAgICAgICAgICAgIF9lbGUuX3ByaXZhdGVbcC5maWVsZF1ba10gPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG5cblxuICAgICAgICBpZiAocC51cGRhdGVTdHlsZSkge1xuICAgICAgICAgIHNlbGYudXBkYXRlU3R5bGUoKTtcbiAgICAgICAgfSAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG5cblxuICAgICAgICBwLm9uU2V0KHNlbGYpO1xuXG4gICAgICAgIGlmIChwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50KSB7XG4gICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuc2V0dGluZ0V2ZW50KTtcbiAgICAgICAgfSAvLyAuZGF0YShmdW5jdGlvbigpeyAuLi4gfSlcblxuICAgICAgfSBlbHNlIGlmIChwLmFsbG93QmluZGluZyAmJiBmbihuYW1lKSkge1xuICAgICAgICAvLyBiaW5kIHRvIGV2ZW50XG4gICAgICAgIHZhciBmbiQxID0gbmFtZTtcbiAgICAgICAgc2VsZi5vbihwLmJpbmRpbmdFdmVudCwgZm4kMSk7IC8vIC5kYXRhKClcbiAgICAgIH0gZWxzZSBpZiAocC5hbGxvd0dldHRpbmcgJiYgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGdldCB3aG9sZSBvYmplY3RcbiAgICAgICAgdmFyIF9yZXQ7XG5cbiAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgIHAuYmVmb3JlR2V0KHNpbmdsZSk7XG4gICAgICAgICAgX3JldCA9IHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfcmV0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5hYmlsaXR5XG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSxcbiAgLy8gZGF0YVxuICAvLyByZW1vdmUgZGF0YSBmaWVsZFxuICByZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKHBhcmFtcykge1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZSxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9IC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuXG4gICAgfTtcbiAgICBwYXJhbXMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVEYXRhSW1wbChuYW1lcykge1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIC8vIC5yZW1vdmVEYXRhKCdmb28gYmFyJylcblxuICAgICAgaWYgKHN0cmluZyhuYW1lcykpIHtcbiAgICAgICAgLy8gdGhlbiBnZXQgdGhlIGxpc3Qgb2Yga2V5cywgYW5kIGRlbGV0ZSB0aGVtXG4gICAgICAgIHZhciBrZXlzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIC8vIGRlbGV0ZSBlYWNoIG5vbi1lbXB0eSBrZXlcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChlbXB0eVN0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW2tleV07IC8vIG5vdCB2YWxpZCBpZiBpbW11dGFibGVcblxuICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaV9hID0gMCwgbF9hID0gYWxsLmxlbmd0aDsgaV9hIDwgbF9hOyBpX2ErKykge1xuICAgICAgICAgICAgICBhbGxbaV9hXS5fcHJpdmF0ZVtwLmZpZWxkXVtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLnRyaWdnZXJFdmVudCkge1xuICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLmV2ZW50KTtcbiAgICAgICAgfSAvLyAucmVtb3ZlRGF0YSgpXG5cbiAgICAgIH0gZWxzZSBpZiAobmFtZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0aGVuIGRlbGV0ZSBhbGwga2V5c1xuICAgICAgICBmb3IgKHZhciBfaV9hID0gMCwgX2xfYSA9IGFsbC5sZW5ndGg7IF9pX2EgPCBfbF9hOyBfaV9hKyspIHtcbiAgICAgICAgICB2YXIgX3ByaXZhdGVGaWVsZHMgPSBhbGxbX2lfYV0uX3ByaXZhdGVbcC5maWVsZF07XG5cbiAgICAgICAgICB2YXIgX2tleXMgPSBPYmplY3Qua2V5cyhfcHJpdmF0ZUZpZWxkcyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBfa2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICB2YXIgX2tleSA9IF9rZXlzW19pMl07XG4gICAgICAgICAgICB2YXIgdmFsaWRLZXlUb0RlbGV0ZSA9ICFwLmltbXV0YWJsZUtleXNbX2tleV07XG5cbiAgICAgICAgICAgIGlmICh2YWxpZEtleVRvRGVsZXRlKSB7XG4gICAgICAgICAgICAgIF9wcml2YXRlRmllbGRzW19rZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwLnRyaWdnZXJFdmVudCkge1xuICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLmV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9IC8vIHJlbW92ZURhdGFcblxufTsgLy8gZGVmaW5lXG5cbnZhciBkZWZpbmUkMiA9IHtcbiAgZXZlbnRBbGlhc2VzT246IGZ1bmN0aW9uIGV2ZW50QWxpYXNlc09uKHByb3RvKSB7XG4gICAgdmFyIHAgPSBwcm90bztcbiAgICBwLmFkZExpc3RlbmVyID0gcC5saXN0ZW4gPSBwLmJpbmQgPSBwLm9uO1xuICAgIHAudW5saXN0ZW4gPSBwLnVuYmluZCA9IHAub2ZmID0gcC5yZW1vdmVMaXN0ZW5lcjtcbiAgICBwLnRyaWdnZXIgPSBwLmVtaXQ7IC8vIHRoaXMgaXMganVzdCBhIHdyYXBwZXIgYWxpYXMgb2YgLm9uKClcblxuICAgIHAucG9uID0gcC5wcm9taXNlT24gPSBmdW5jdGlvbiAoZXZlbnRzLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhlKSB7XG4gICAgICAgICAgc2VsZi5vZmYuYXBwbHkoc2VsZiwgb2ZmQXJncyk7XG4gICAgICAgICAgcmVzb2x2ZShlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb25BcmdzID0gYXJncy5jb25jYXQoW2NhbGxiYWNrXSk7XG4gICAgICAgIHZhciBvZmZBcmdzID0gb25BcmdzLmNvbmNhdChbXSk7XG4gICAgICAgIHNlbGYub24uYXBwbHkoc2VsZiwgb25BcmdzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn07IC8vIGRlZmluZVxuXG4vLyB1c2UgdGhpcyBtb2R1bGUgdG8gY2hlcnJ5IHBpY2sgZnVuY3Rpb25zIGludG8geW91ciBwcm90b3R5cGVcbnZhciBkZWZpbmUkMyA9IHt9O1xuW2RlZmluZSwgZGVmaW5lJDEsIGRlZmluZSQyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gIGV4dGVuZChkZWZpbmUkMywgbSk7XG59KTtcblxudmFyIGVsZXNmbiRkID0ge1xuICBhbmltYXRlOiBkZWZpbmUkMy5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lJDMuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUkMy5hbmltYXRlZCgpLFxuICBjbGVhclF1ZXVlOiBkZWZpbmUkMy5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUkMy5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lJDMuZGVsYXlBbmltYXRpb24oKSxcbiAgc3RvcDogZGVmaW5lJDMuc3RvcCgpXG59O1xuXG52YXIgZWxlc2ZuJGUgPSB7XG4gIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoX2NsYXNzZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoX2NsYXNzZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBzZWxmWzBdLl9wcml2YXRlLmNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgIHJldHVybiByZXQucHVzaChjbHMpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBlbHNlIGlmICghYXJyYXkoX2NsYXNzZXMpKSB7XG4gICAgICAvLyBleHRyYWN0IGNsYXNzZXMgZnJvbSBzdHJpbmdcbiAgICAgIF9jbGFzc2VzID0gKF9jbGFzc2VzIHx8ICcnKS5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICB9XG5cbiAgICB2YXIgY2hhbmdlZCA9IFtdO1xuICAgIHZhciBjbGFzc2VzU2V0ID0gbmV3IFNldCQxKF9jbGFzc2VzKTsgLy8gY2hlY2sgYW5kIHVwZGF0ZSBlYWNoIGVsZVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZWxlID0gc2VsZltqXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBlbGVDbGFzc2VzID0gX3AuY2xhc3NlcztcbiAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7IC8vIGNoZWNrIGlmIGVsZSBoYXMgYWxsIG9mIHRoZSBwYXNzZWQgY2xhc3Nlc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9jbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjbHMgPSBfY2xhc3Nlc1tpXTtcbiAgICAgICAgdmFyIGVsZUhhc0NsYXNzID0gZWxlQ2xhc3Nlcy5oYXMoY2xzKTtcblxuICAgICAgICBpZiAoIWVsZUhhc0NsYXNzKSB7XG4gICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY2hlY2sgaWYgZWxlIGhhcyBjbGFzc2VzIG91dHNpZGUgb2YgdGhvc2UgcGFzc2VkXG5cblxuICAgICAgaWYgKCFjaGFuZ2VkRWxlKSB7XG4gICAgICAgIGNoYW5nZWRFbGUgPSBlbGVDbGFzc2VzLnNpemUgIT09IF9jbGFzc2VzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWRFbGUpIHtcbiAgICAgICAgX3AuY2xhc3NlcyA9IGNsYXNzZXNTZXQ7XG4gICAgICAgIGNoYW5nZWQucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH0gLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG5cblxuICAgIGlmIChjaGFuZ2VkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc3Bhd24oY2hhbmdlZCkudXBkYXRlU3R5bGUoKS5lbWl0KCdjbGFzcycpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoY2xhc3Nlcykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzZXMsIHRydWUpO1xuICB9LFxuICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZSAhPSBudWxsICYmIGVsZS5fcHJpdmF0ZS5jbGFzc2VzLmhhcyhjbGFzc05hbWUpO1xuICB9LFxuICB0b2dnbGVDbGFzczogZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoY2xhc3NlcywgdG9nZ2xlKSB7XG4gICAgaWYgKCFhcnJheShjbGFzc2VzKSkge1xuICAgICAgLy8gZXh0cmFjdCBjbGFzc2VzIGZyb20gc3RyaW5nXG4gICAgICBjbGFzc2VzID0gY2xhc3Nlcy5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRvZ2dsZVVuZGVmZCA9IHRvZ2dsZSA9PT0gdW5kZWZpbmVkO1xuICAgIHZhciBjaGFuZ2VkID0gW107IC8vIGVsZXMgd2hvIGhhZCBjbGFzc2VzIGNoYW5nZWRcblxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHNlbGYubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHNlbGZbaV07XG4gICAgICB2YXIgZWxlQ2xhc3NlcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzO1xuICAgICAgdmFyIGNoYW5nZWRFbGUgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2pdO1xuICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGVDbGFzc2VzLmhhcyhjbHMpO1xuICAgICAgICB2YXIgY2hhbmdlZE5vdyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0b2dnbGUgfHwgdG9nZ2xlVW5kZWZkICYmICFoYXNDbGFzcykge1xuICAgICAgICAgIGVsZUNsYXNzZXMuYWRkKGNscyk7XG4gICAgICAgICAgY2hhbmdlZE5vdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRvZ2dsZSB8fCB0b2dnbGVVbmRlZmQgJiYgaGFzQ2xhc3MpIHtcbiAgICAgICAgICBlbGVDbGFzc2VzW1wiZGVsZXRlXCJdKGNscyk7XG4gICAgICAgICAgY2hhbmdlZE5vdyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNoYW5nZWRFbGUgJiYgY2hhbmdlZE5vdykge1xuICAgICAgICAgIGNoYW5nZWQucHVzaChlbGUpO1xuICAgICAgICAgIGNoYW5nZWRFbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBqIGNsYXNzZXNcblxuICAgIH0gLy8gZm9yIGkgZWxlc1xuICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuXG5cbiAgICBpZiAoY2hhbmdlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNwYXduKGNoYW5nZWQpLnVwZGF0ZVN0eWxlKCkuZW1pdCgnY2xhc3MnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGVDbGFzcyhjbGFzc2VzLCBmYWxzZSk7XG4gIH0sXG4gIGZsYXNoQ2xhc3M6IGZ1bmN0aW9uIGZsYXNoQ2xhc3MoY2xhc3NlcywgZHVyYXRpb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgZHVyYXRpb24gPSAyNTA7XG4gICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIHNlbGY7IC8vIG5vdGhpbmcgdG8gZG8gcmVhbGx5XG4gICAgfVxuXG4gICAgc2VsZi5hZGRDbGFzcyhjbGFzc2VzKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoY2xhc3Nlcyk7XG4gICAgfSwgZHVyYXRpb24pO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG59O1xuZWxlc2ZuJGUuY2xhc3NOYW1lID0gZWxlc2ZuJGUuY2xhc3NOYW1lcyA9IGVsZXNmbiRlLmNsYXNzZXM7XG5cbnZhciB0b2tlbnMgPSB7XG4gIG1ldGFDaGFyOiAnW1xcXFwhXFxcXFwiXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwuXFxcXC9cXFxcOlxcXFw7XFxcXDxcXFxcPVxcXFw+XFxcXD9cXFxcQFxcXFxbXFxcXF1cXFxcXlxcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dJyxcbiAgLy8gY2hhcnMgd2UgbmVlZCB0byBlc2NhcGUgaW4gbGV0IG5hbWVzLCBldGNcbiAgY29tcGFyYXRvck9wOiAnPXxcXFxcIT18Pnw+PXw8fDw9fFxcXFwkPXxcXFxcXj18XFxcXCo9JyxcbiAgLy8gYmluYXJ5IGNvbXBhcmlzb24gb3AgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpXG4gIGJvb2xPcDogJ1xcXFw/fFxcXFwhfFxcXFxeJyxcbiAgLy8gYm9vbGVhbiAodW5hcnkpIG9wZXJhdG9ycyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgc3RyaW5nOiAnXCIoPzpcXFxcXFxcXFwifFteXCJdKSpcIicgKyAnfCcgKyBcIicoPzpcXFxcXFxcXCd8W14nXSkqJ1wiLFxuICAvLyBzdHJpbmcgbGl0ZXJhbHMgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tIGRvdWJsZXF1b3RlcyB8IHNpbmdsZXF1b3Rlc1xuICBudW1iZXI6IG51bWJlciQxLFxuICAvLyBudW1iZXIgbGl0ZXJhbCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0tIGUuZy4gMC4xMjM0LCAxMjM0LCAxMmUxMjNcbiAgbWV0YTogJ2RlZ3JlZXxpbmRlZ3JlZXxvdXRkZWdyZWUnLFxuICAvLyBhbGxvd2VkIG1ldGFkYXRhIGZpZWxkcyAoaS5lLiBhbGxvd2VkIGZ1bmN0aW9ucyB0byB1c2UgZnJvbSBDb2xsZWN0aW9uKVxuICBzZXBhcmF0b3I6ICdcXFxccyosXFxcXHMqJyxcbiAgLy8gcXVlcmllcyBhcmUgc2VwYXJhdGVkIGJ5IGNvbW1hcywgZS5nLiBlZGdlW2ZvbyA9ICdiYXInXSwgbm9kZS5zb21lQ2xhc3NcbiAgZGVzY2VuZGFudDogJ1xcXFxzKycsXG4gIGNoaWxkOiAnXFxcXHMrPlxcXFxzKycsXG4gIHN1YmplY3Q6ICdcXFxcJCcsXG4gIGdyb3VwOiAnbm9kZXxlZGdlfFxcXFwqJyxcbiAgZGlyZWN0ZWRFZGdlOiAnXFxcXHMrLT5cXFxccysnLFxuICB1bmRpcmVjdGVkRWRnZTogJ1xcXFxzKzwtPlxcXFxzKydcbn07XG50b2tlbnMudmFyaWFibGUgPSAnKD86W1xcXFx3LV18KD86XFxcXFxcXFwnICsgdG9rZW5zLm1ldGFDaGFyICsgJykpKyc7IC8vIGEgdmFyaWFibGUgbmFtZVxuXG50b2tlbnMudmFsdWUgPSB0b2tlbnMuc3RyaW5nICsgJ3wnICsgdG9rZW5zLm51bWJlcjsgLy8gYSB2YWx1ZSBsaXRlcmFsLCBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyXG5cbnRva2Vucy5jbGFzc05hbWUgPSB0b2tlbnMudmFyaWFibGU7IC8vIGEgY2xhc3MgbmFtZSAoZm9sbG93cyB2YXJpYWJsZSBjb252ZW50aW9ucylcblxudG9rZW5zLmlkID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhbiBlbGVtZW50IGlkIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuXG4oZnVuY3Rpb24gKCkge1xuICB2YXIgb3BzLCBvcCwgaTsgLy8gYWRkIEAgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG5cbiAgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCgnfCcpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBvcCA9IG9wc1tpXTtcbiAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8QCcgKyBvcDtcbiAgfSAvLyBhZGQgISB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcblxuXG4gIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3AgPSBvcHNbaV07XG5cbiAgICBpZiAob3AuaW5kZXhPZignIScpID49IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gc2tpcCBvcHMgdGhhdCBleHBsaWNpdGx5IGNvbnRhaW4gIVxuXG5cbiAgICBpZiAob3AgPT09ICc9Jykge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBza2lwID0gYi9jICE9IGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuXG5cbiAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8XFxcXCEnICsgb3A7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogTWFrZSBhIG5ldyBxdWVyeSBvYmplY3RcbiAqXG4gKiBAcHJvcCB0eXBlIHtUeXBlfSBUaGUgdHlwZSBlbnVtIChpbnQpIG9mIHRoZSBxdWVyeVxuICogQHByb3AgY2hlY2tzIExpc3Qgb2YgY2hlY2tzIHRvIG1ha2UgYWdhaW5zdCBhbiBlbGUgdG8gdGVzdCBmb3IgYSBtYXRjaFxuICovXG52YXIgbmV3UXVlcnkgPSBmdW5jdGlvbiBuZXdRdWVyeSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjaGVja3M6IFtdXG4gIH07XG59O1xuXG4vKipcbiAqIEEgY2hlY2sgdHlwZSBlbnVtLWxpa2Ugb2JqZWN0LiAgVXNlcyBpbnRlZ2VyIHZhbHVlcyBmb3IgZmFzdCBtYXRjaCgpIGxvb2t1cC5cbiAqIFRoZSBvcmRlcmluZyBkb2VzIG5vdCBtYXR0ZXIgYXMgbG9uZyBhcyB0aGUgaW50cyBhcmUgdW5pcXVlLlxuICovXG52YXIgVHlwZSA9IHtcbiAgLyoqIEUuZy4gbm9kZSAqL1xuICBHUk9VUDogMCxcblxuICAvKiogQSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzICovXG4gIENPTExFQ1RJT046IDEsXG5cbiAgLyoqIEEgZmlsdGVyKGVsZSkgZnVuY3Rpb24gKi9cbiAgRklMVEVSOiAyLFxuXG4gIC8qKiBFLmcuIFtmb28gPiAxXSAqL1xuICBEQVRBX0NPTVBBUkU6IDMsXG5cbiAgLyoqIEUuZy4gW2Zvb10gKi9cbiAgREFUQV9FWElTVDogNCxcblxuICAvKiogRS5nLiBbP2Zvb10gKi9cbiAgREFUQV9CT09MOiA1LFxuXG4gIC8qKiBFLmcuIFtbZGVncmVlID4gMl1dICovXG4gIE1FVEFfQ09NUEFSRTogNixcblxuICAvKiogRS5nLiA6c2VsZWN0ZWQgKi9cbiAgU1RBVEU6IDcsXG5cbiAgLyoqIEUuZy4gI2ZvbyAqL1xuICBJRDogOCxcblxuICAvKiogRS5nLiAuZm9vICovXG4gIENMQVNTOiA5LFxuXG4gIC8qKiBFLmcuICNmb28gPC0+ICNiYXIgKi9cbiAgVU5ESVJFQ1RFRF9FREdFOiAxMCxcblxuICAvKiogRS5nLiAjZm9vIC0+ICNiYXIgKi9cbiAgRElSRUNURURfRURHRTogMTEsXG5cbiAgLyoqIEUuZy4gJCNmb28gLT4gI2JhciAqL1xuICBOT0RFX1NPVVJDRTogMTIsXG5cbiAgLyoqIEUuZy4gI2ZvbyAtPiAkI2JhciAqL1xuICBOT0RFX1RBUkdFVDogMTMsXG5cbiAgLyoqIEUuZy4gJCNmb28gPC0+ICNiYXIgKi9cbiAgTk9ERV9ORUlHSEJPUjogMTQsXG5cbiAgLyoqIEUuZy4gI2ZvbyA+ICNiYXIgKi9cbiAgQ0hJTEQ6IDE1LFxuXG4gIC8qKiBFLmcuICNmb28gI2JhciAqL1xuICBERVNDRU5EQU5UOiAxNixcblxuICAvKiogRS5nLiAkI2ZvbyA+ICNiYXIgKi9cbiAgUEFSRU5UOiAxNyxcblxuICAvKiogRS5nLiAkI2ZvbyAjYmFyICovXG4gIEFOQ0VTVE9SOiAxOCxcblxuICAvKiogRS5nLiAjZm9vID4gJGJhciA+ICNiYXogKi9cbiAgQ09NUE9VTkRfU1BMSVQ6IDE5LFxuXG4gIC8qKiBBbHdheXMgbWF0Y2hlcywgdXNlZnVsIHBsYWNlaG9sZGVyIGZvciBzdWJqZWN0IGluIGBDT01QT1VORF9TUExJVGAgKi9cbiAgVFJVRTogMjBcbn07XG5cbnZhciBzdGF0ZVNlbGVjdG9ycyA9IFt7XG4gIHNlbGVjdG9yOiAnOnNlbGVjdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5zZWxlY3RlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuc2VsZWN0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpzZWxlY3RhYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bnNlbGVjdGFibGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnNlbGVjdGFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpsb2NrZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUubG9ja2VkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5sb2NrZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmxvY2tlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnZpc2libGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUudmlzaWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmhpZGRlbicsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnRyYW5zcGFyZW50JyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnRyYW5zcGFyZW50KCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6Z3JhYmJlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5ncmFiYmVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6ZnJlZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuZ3JhYmJlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnJlbW92ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUucmVtb3ZlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmluc2lkZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUucmVtb3ZlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmdyYWJiYWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5ncmFiYmFibGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmdyYWJiYWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuZ3JhYmJhYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6YW5pbWF0ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYW5pbWF0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp1bmFuaW1hdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5hbmltYXRlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnBhcmVudCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc1BhcmVudCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNoaWxkbGVzcycsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0NoaWxkbGVzcygpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNoaWxkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpvcnBoYW4nLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNPcnBoYW4oKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpub25vcnBoYW4nLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNDaGlsZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmNvbXBvdW5kJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICByZXR1cm4gZWxlLmlzUGFyZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGUuc291cmNlKCkuaXNQYXJlbnQoKSB8fCBlbGUudGFyZ2V0KCkuaXNQYXJlbnQoKTtcbiAgICB9XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6bG9vcCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0xvb3AoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpzaW1wbGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNTaW1wbGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzphY3RpdmUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYWN0aXZlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6aW5hY3RpdmUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmFjdGl2ZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmJhY2tncm91bmRpbmcnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuYmFja2dyb3VuZGluZygpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOm5vbmJhY2tncm91bmRpbmcnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmJhY2tncm91bmRpbmcoKTtcbiAgfVxufV0uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAvLyBuLmIuIHNlbGVjdG9ycyB0aGF0IGFyZSBzdGFydGluZyBzdWJzdHJpbmdzIG9mIG90aGVycyBtdXN0IGhhdmUgdGhlIGxvbmdlciBvbmVzIGZpcnN0XG4gIHJldHVybiBkZXNjZW5kaW5nKGEuc2VsZWN0b3IsIGIuc2VsZWN0b3IpO1xufSk7XG5cbnZhciBsb29rdXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxUb0ZuID0ge307XG4gIHZhciBzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBzID0gc3RhdGVTZWxlY3RvcnNbaV07XG4gICAgc2VsVG9GbltzLnNlbGVjdG9yXSA9IHMubWF0Y2hlcztcbiAgfVxuXG4gIHJldHVybiBzZWxUb0ZuO1xufSgpO1xuXG52YXIgc3RhdGVTZWxlY3Rvck1hdGNoZXMgPSBmdW5jdGlvbiBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyhzZWwsIGVsZSkge1xuICByZXR1cm4gbG9va3VwW3NlbF0oZWxlKTtcbn07XG52YXIgc3RhdGVTZWxlY3RvclJlZ2V4ID0gJygnICsgc3RhdGVTZWxlY3RvcnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gIHJldHVybiBzLnNlbGVjdG9yO1xufSkuam9pbignfCcpICsgJyknO1xuXG4vLyBzbyB0aGF0IHZhbHVlcyBnZXQgY29tcGFyZWQgcHJvcGVybHkgaW4gU2VsZWN0b3IuZmlsdGVyKClcblxudmFyIGNsZWFuTWV0YUNoYXJzID0gZnVuY3Rpb24gY2xlYW5NZXRhQ2hhcnMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcXFxcXCgnICsgdG9rZW5zLm1ldGFDaGFyICsgJyknLCAnZycpLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gICAgcmV0dXJuICQxO1xuICB9KTtcbn07XG5cbnZhciByZXBsYWNlTGFzdFF1ZXJ5ID0gZnVuY3Rpb24gcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgZXhhbWluaW5nUXVlcnksIHJlcGxhY2VtZW50UXVlcnkpIHtcbiAgc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV0gPSByZXBsYWNlbWVudFF1ZXJ5O1xufTsgLy8gTk9URTogYWRkIG5ldyBleHByZXNzaW9uIHN5bnRheCBoZXJlIHRvIGhhdmUgaXQgcmVjb2duaXNlZCBieSB0aGUgcGFyc2VyO1xuLy8gLSBhIHF1ZXJ5IGNvbnRhaW5zIGFsbCBhZGphY2VudCAoaS5lLiBubyBzZXBhcmF0b3IgaW4gYmV0d2VlbikgZXhwcmVzc2lvbnM7XG4vLyAtIHRoZSBjdXJyZW50IHF1ZXJ5IGlzIHN0b3JlZCBpbiBzZWxlY3RvcltpXVxuLy8gLSB5b3UgbmVlZCB0byBjaGVjayB0aGUgcXVlcnkgb2JqZWN0cyBpbiBtYXRjaCgpIGZvciBpdCBhY3R1YWxseSBmaWx0ZXIgcHJvcGVybHksIGJ1dCB0aGF0J3MgcHJldHR5IHN0cmFpZ2h0IGZvcndhcmRcblxuXG52YXIgZXhwcnMgPSBbe1xuICBuYW1lOiAnZ3JvdXAnLFxuICAvLyBqdXN0IHVzZWQgZm9yIGlkZW50aWZ5aW5nIHdoZW4gZGVidWdnaW5nXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJygnICsgdG9rZW5zLmdyb3VwICsgJyknLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgIGdyb3VwID0gX3JlZjJbMF07XG5cbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkdST1VQLFxuICAgICAgdmFsdWU6IGdyb3VwID09PSAnKicgPyBncm91cCA6IGdyb3VwICsgJ3MnXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ3N0YXRlJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiBzdGF0ZVNlbGVjdG9yUmVnZXgsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYzKSB7XG4gICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDEpLFxuICAgICAgICBzdGF0ZSA9IF9yZWY0WzBdO1xuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5TVEFURSxcbiAgICAgIHZhbHVlOiBzdGF0ZVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdpZCcsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFwjKCcgKyB0b2tlbnMuaWQgKyAnKScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY1KSB7XG4gICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDEpLFxuICAgICAgICBpZCA9IF9yZWY2WzBdO1xuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5JRCxcbiAgICAgIHZhbHVlOiBjbGVhbk1ldGFDaGFycyhpZClcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnY2xhc3NOYW1lJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXC4oJyArIHRva2Vucy5jbGFzc05hbWUgKyAnKScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY3KSB7XG4gICAgdmFyIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDEpLFxuICAgICAgICBjbGFzc05hbWUgPSBfcmVmOFswXTtcblxuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuQ0xBU1MsXG4gICAgICB2YWx1ZTogY2xlYW5NZXRhQ2hhcnMoY2xhc3NOYW1lKVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhRXhpc3RzJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmOSkge1xuICAgIHZhciBfcmVmMTAgPSBfc2xpY2VkVG9BcnJheShfcmVmOSwgMSksXG4gICAgICAgIHZhcmlhYmxlID0gX3JlZjEwWzBdO1xuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5EQVRBX0VYSVNULFxuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhQ29tcGFyZScsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKignICsgdG9rZW5zLmNvbXBhcmF0b3JPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMudmFsdWUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjExKSB7XG4gICAgdmFyIF9yZWYxMiA9IF9zbGljZWRUb0FycmF5KF9yZWYxMSwgMyksXG4gICAgICAgIHZhcmlhYmxlID0gX3JlZjEyWzBdLFxuICAgICAgICBjb21wYXJhdG9yT3AgPSBfcmVmMTJbMV0sXG4gICAgICAgIHZhbHVlID0gX3JlZjEyWzJdO1xuXG4gICAgdmFyIHZhbHVlSXNTdHJpbmcgPSBuZXcgUmVnRXhwKCdeJyArIHRva2Vucy5zdHJpbmcgKyAnJCcpLmV4ZWModmFsdWUpICE9IG51bGw7XG5cbiAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5EQVRBX0NPTVBBUkUsXG4gICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9XG59LCB7XG4gIG5hbWU6ICdkYXRhQm9vbCcsXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMuYm9vbE9wICsgJylcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTMpIHtcbiAgICB2YXIgX3JlZjE0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjEzLCAyKSxcbiAgICAgICAgYm9vbE9wID0gX3JlZjE0WzBdLFxuICAgICAgICB2YXJpYWJsZSA9IF9yZWYxNFsxXTtcblxuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuREFUQV9CT09MLFxuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgIG9wZXJhdG9yOiBib29sT3BcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnbWV0YUNvbXBhcmUnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcW1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMubWV0YSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy5udW1iZXIgKyAnKVxcXFxzKlxcXFxdXFxcXF0nLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTUpIHtcbiAgICB2YXIgX3JlZjE2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE1LCAzKSxcbiAgICAgICAgbWV0YSA9IF9yZWYxNlswXSxcbiAgICAgICAgY29tcGFyYXRvck9wID0gX3JlZjE2WzFdLFxuICAgICAgICBudW1iZXIgPSBfcmVmMTZbMl07XG5cbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLk1FVEFfQ09NUEFSRSxcbiAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyhtZXRhKSxcbiAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ25leHRRdWVyeScsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5zZXBhcmF0b3IsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICB2YXIgY3VycmVudFN1YmplY3QgPSBzZWxlY3Rvci5jdXJyZW50U3ViamVjdDtcbiAgICB2YXIgZWRnZUNvdW50ID0gc2VsZWN0b3IuZWRnZUNvdW50O1xuICAgIHZhciBjb21wb3VuZENvdW50ID0gc2VsZWN0b3IuY29tcG91bmRDb3VudDtcbiAgICB2YXIgbGFzdFEgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcblxuICAgIGlmIChjdXJyZW50U3ViamVjdCAhPSBudWxsKSB7XG4gICAgICBsYXN0US5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG4gICAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IG51bGw7XG4gICAgfVxuXG4gICAgbGFzdFEuZWRnZUNvdW50ID0gZWRnZUNvdW50O1xuICAgIGxhc3RRLmNvbXBvdW5kQ291bnQgPSBjb21wb3VuZENvdW50O1xuICAgIHNlbGVjdG9yLmVkZ2VDb3VudCA9IDA7XG4gICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCA9IDA7IC8vIGdvIG9uIHRvIG5leHQgcXVlcnlcblxuICAgIHZhciBuZXh0UXVlcnkgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGgrK10gPSBuZXdRdWVyeSgpO1xuICAgIHJldHVybiBuZXh0UXVlcnk7IC8vIHRoaXMgaXMgdGhlIG5ldyBxdWVyeSB0byBiZSBmaWxsZWQgYnkgdGhlIGZvbGxvd2luZyBleHByc1xuICB9XG59LCB7XG4gIG5hbWU6ICdkaXJlY3RlZEVkZ2UnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuZGlyZWN0ZWRFZGdlLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09IG51bGwpIHtcbiAgICAgIC8vIHVuZGlyZWN0ZWQgZWRnZVxuICAgICAgdmFyIGVkZ2VRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgc291cmNlID0gcXVlcnk7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3UXVlcnkoKTtcbiAgICAgIGVkZ2VRdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuRElSRUNURURfRURHRSxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIGVkZ2UgcmF0aGVyIHRoYW4gdGhlIHNvdXJjZVxuXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgZWRnZVF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc291cmNlL3RhcmdldFxuICAgICAgdmFyIHNyY1RndFEgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9zb3VyY2UgPSBxdWVyeTtcblxuICAgICAgdmFyIF90YXJnZXQgPSBuZXdRdWVyeSgpO1xuXG4gICAgICBzcmNUZ3RRLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5OT0RFX1NPVVJDRSxcbiAgICAgICAgc291cmNlOiBfc291cmNlLFxuICAgICAgICB0YXJnZXQ6IF90YXJnZXRcbiAgICAgIH0pOyAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgbmVpZ2hib3VyaG9vZCByYXRoZXIgdGhhbiB0aGUgbm9kZVxuXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgc3JjVGd0USk7XG4gICAgICBzZWxlY3Rvci5lZGdlQ291bnQrKztcbiAgICAgIHJldHVybiBfdGFyZ2V0OyAvLyBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHdpdGggdGhlIGZvbGxvd2luZyBleHByZXNzaW9uc1xuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAndW5kaXJlY3RlZEVkZ2UnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMudW5kaXJlY3RlZEVkZ2UsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gdW5kaXJlY3RlZCBlZGdlXG4gICAgICB2YXIgZWRnZVF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBzb3VyY2UgPSBxdWVyeTtcbiAgICAgIHZhciB0YXJnZXQgPSBuZXdRdWVyeSgpO1xuICAgICAgZWRnZVF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5VTkRJUkVDVEVEX0VER0UsXG4gICAgICAgIG5vZGVzOiBbc291cmNlLCB0YXJnZXRdXG4gICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIGVkZ2UgcmF0aGVyIHRoYW4gdGhlIHNvdXJjZVxuXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgZWRnZVF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbmVpZ2hib3VyaG9vZFxuICAgICAgdmFyIG5ob29kUSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgbm9kZSA9IHF1ZXJ5O1xuICAgICAgdmFyIG5laWdoYm9yID0gbmV3UXVlcnkoKTtcbiAgICAgIG5ob29kUS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuTk9ERV9ORUlHSEJPUixcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgbmVpZ2hib3I6IG5laWdoYm9yXG4gICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIG5laWdoYm91cmhvb2QgcmF0aGVyIHRoYW4gdGhlIG5vZGVcblxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIG5ob29kUSk7XG4gICAgICByZXR1cm4gbmVpZ2hib3I7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSBuZWlnaGJvciB3aXRoIGZvbGxvd2luZyBleHByZXNzaW9uc1xuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAnY2hpbGQnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuY2hpbGQsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgLy8gZGVmYXVsdDogY2hpbGQgcXVlcnlcbiAgICAgIHZhciBwYXJlbnRDaGlsZFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBjaGlsZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICBwYXJlbnRDaGlsZFF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5DSElMRCxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGNoaWxkOiBjaGlsZFxuICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSAnPicgaXRzZWxmXG5cbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBwYXJlbnRDaGlsZFF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKzsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkIHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT09IHF1ZXJ5KSB7XG4gICAgICAvLyBjb21wb3VuZCBzcGxpdCBxdWVyeVxuICAgICAgdmFyIGNvbXBvdW5kID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBsZWZ0ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmlnaHQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHN1YmplY3QgPSBuZXdRdWVyeSgpO1xuXG4gICAgICB2YXIgX2NoaWxkID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9wYXJlbnQgPSBuZXdRdWVyeSgpOyAvLyBzZXQgdXAgdGhlIHJvb3QgY29tcG91bmQgcVxuXG5cbiAgICAgIGNvbXBvdW5kLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5DT01QT1VORF9TUExJVCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICBzdWJqZWN0OiBzdWJqZWN0XG4gICAgICB9KTsgLy8gcG9wdWxhdGUgdGhlIHN1YmplY3QgYW5kIHJlcGxhY2UgdGhlIHEgYXQgdGhlIG9sZCBzcG90ICh3aXRoaW4gbGVmdCkgd2l0aCBUUlVFXG5cbiAgICAgIHN1YmplY3QuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0YWtlIHRoZSBjaGVja3MgZnJvbSB0aGUgbGVmdFxuXG4gICAgICBxdWVyeS5jaGVja3MgPSBbe1xuICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgIH1dOyAvLyBjaGVja3MgdW5kZXIgbGVmdCByZWZzIHRoZSBzdWJqZWN0IGltcGxpY2l0bHlcbiAgICAgIC8vIHNldCB1cCB0aGUgcmlnaHQgcVxuXG4gICAgICBfcGFyZW50LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICB9KTsgLy8gcGFyZW50IGltcGxpY2l0bHkgcmVmcyB0aGUgc3ViamVjdFxuXG5cbiAgICAgIHJpZ2h0LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5QQVJFTlQsXG4gICAgICAgIC8vIHR5cGUgaXMgc3dhcHBlZCBvbiByaWdodCBzaWRlIHF1ZXJpZXNcbiAgICAgICAgcGFyZW50OiBfcGFyZW50LFxuICAgICAgICBjaGlsZDogX2NoaWxkIC8vIGVtcHR5IGZvciBub3dcblxuICAgICAgfSk7XG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBsZWZ0LCBjb21wb3VuZCk7IC8vIHVwZGF0ZSB0aGUgcmVmIHNpbmNlIHdlIG1vdmVkIHRoaW5ncyBhcm91bmQgZm9yIGBxdWVyeWBcblxuICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9jaGlsZDsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIHJpZ2h0IHNpZGUncyBjaGlsZFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJlbnQgcXVlcnlcbiAgICAgIC8vIGluZm8gZm9yIHBhcmVudCBxdWVyeVxuICAgICAgdmFyIF9wYXJlbnQyID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9jaGlsZDIgPSBuZXdRdWVyeSgpO1xuXG4gICAgICB2YXIgcGNRQ2hlY2tzID0gW3tcbiAgICAgICAgdHlwZTogVHlwZS5QQVJFTlQsXG4gICAgICAgIHBhcmVudDogX3BhcmVudDIsXG4gICAgICAgIGNoaWxkOiBfY2hpbGQyXG4gICAgICB9XTsgLy8gdGhlIHBhcmVudC1jaGlsZCBxdWVyeSB0YWtlcyB0aGUgcGxhY2Ugb2YgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgYmVpbmcgcG9wdWxhdGVkXG5cbiAgICAgIF9wYXJlbnQyLmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGhlIHByZXZpb3VzIHF1ZXJ5IGNvbnRhaW5zIHRoZSBjaGVja3MgZm9yIHRoZSBwYXJlbnRcblxuICAgICAgcXVlcnkuY2hlY2tzID0gcGNRQ2hlY2tzOyAvLyBwYyBxdWVyeSB0YWtlcyBvdmVyXG5cbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgIHJldHVybiBfY2hpbGQyOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGRcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2Rlc2NlbmRhbnQnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuZGVzY2VuZGFudCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAvLyBkZWZhdWx0OiBkZXNjZW5kYW50IHF1ZXJ5XG4gICAgICB2YXIgYW5jQ2hRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgZGVzY2VuZGFudCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIGFuY0NoUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkRFU0NFTkRBTlQsXG4gICAgICAgIGFuY2VzdG9yOiBhbmNlc3RvcixcbiAgICAgICAgZGVzY2VuZGFudDogZGVzY2VuZGFudFxuICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSAnPicgaXRzZWxmXG5cbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBhbmNDaFF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKzsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGRlc2NlbmRhbnQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuXG4gICAgICByZXR1cm4gZGVzY2VuZGFudDtcbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09PSBxdWVyeSkge1xuICAgICAgLy8gY29tcG91bmQgc3BsaXQgcXVlcnlcbiAgICAgIHZhciBjb21wb3VuZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgbGVmdCA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHJpZ2h0ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBzdWJqZWN0ID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9kZXNjZW5kYW50ID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9hbmNlc3RvciA9IG5ld1F1ZXJ5KCk7IC8vIHNldCB1cCB0aGUgcm9vdCBjb21wb3VuZCBxXG5cblxuICAgICAgY29tcG91bmQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkNPTVBPVU5EX1NQTElULFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHN1YmplY3Q6IHN1YmplY3RcbiAgICAgIH0pOyAvLyBwb3B1bGF0ZSB0aGUgc3ViamVjdCBhbmQgcmVwbGFjZSB0aGUgcSBhdCB0aGUgb2xkIHNwb3QgKHdpdGhpbiBsZWZ0KSB3aXRoIFRSVUVcblxuICAgICAgc3ViamVjdC5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRha2UgdGhlIGNoZWNrcyBmcm9tIHRoZSBsZWZ0XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcyA9IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgfV07IC8vIGNoZWNrcyB1bmRlciBsZWZ0IHJlZnMgdGhlIHN1YmplY3QgaW1wbGljaXRseVxuICAgICAgLy8gc2V0IHVwIHRoZSByaWdodCBxXG5cbiAgICAgIF9hbmNlc3Rvci5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgfSk7IC8vIGFuY2VzdG9yIGltcGxpY2l0bHkgcmVmcyB0aGUgc3ViamVjdFxuXG5cbiAgICAgIHJpZ2h0LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5BTkNFU1RPUixcbiAgICAgICAgLy8gdHlwZSBpcyBzd2FwcGVkIG9uIHJpZ2h0IHNpZGUgcXVlcmllc1xuICAgICAgICBhbmNlc3RvcjogX2FuY2VzdG9yLFxuICAgICAgICBkZXNjZW5kYW50OiBfZGVzY2VuZGFudCAvLyBlbXB0eSBmb3Igbm93XG5cbiAgICAgIH0pO1xuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgbGVmdCwgY29tcG91bmQpOyAvLyB1cGRhdGUgdGhlIHJlZiBzaW5jZSB3ZSBtb3ZlZCB0aGluZ3MgYXJvdW5kIGZvciBgcXVlcnlgXG5cbiAgICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgIHJldHVybiBfZGVzY2VuZGFudDsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIHJpZ2h0IHNpZGUncyBkZXNjZW5kYW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFuY2VzdG9yIHF1ZXJ5XG4gICAgICAvLyBpbmZvIGZvciBwYXJlbnQgcXVlcnlcbiAgICAgIHZhciBfYW5jZXN0b3IyID0gbmV3UXVlcnkoKTtcblxuICAgICAgdmFyIF9kZXNjZW5kYW50MiA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgIHZhciBhZFFDaGVja3MgPSBbe1xuICAgICAgICB0eXBlOiBUeXBlLkFOQ0VTVE9SLFxuICAgICAgICBhbmNlc3RvcjogX2FuY2VzdG9yMixcbiAgICAgICAgZGVzY2VuZGFudDogX2Rlc2NlbmRhbnQyXG4gICAgICB9XTsgLy8gdGhlIHBhcmVudC1jaGlsZCBxdWVyeSB0YWtlcyB0aGUgcGxhY2Ugb2YgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgYmVpbmcgcG9wdWxhdGVkXG5cbiAgICAgIF9hbmNlc3RvcjIuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0aGUgcHJldmlvdXMgcXVlcnkgY29udGFpbnMgdGhlIGNoZWNrcyBmb3IgdGhlIHBhcmVudFxuXG4gICAgICBxdWVyeS5jaGVja3MgPSBhZFFDaGVja3M7IC8vIHBjIHF1ZXJ5IHRha2VzIG92ZXJcblxuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgcmV0dXJuIF9kZXNjZW5kYW50MjsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkXG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6ICdzdWJqZWN0JyxcbiAgbW9kaWZpZXI6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuc3ViamVjdCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCAhPSBudWxsICYmIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ICE9PSBxdWVyeSkge1xuICAgICAgd2FybignUmVkZWZpbml0aW9uIG9mIHN1YmplY3QgaW4gc2VsZWN0b3IgYCcgKyBzZWxlY3Rvci50b1N0cmluZygpICsgJ2AnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IHF1ZXJ5O1xuICAgIHZhciB0b3BRID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgdmFyIHRvcENoayA9IHRvcFEuY2hlY2tzWzBdO1xuICAgIHZhciB0b3BUeXBlID0gdG9wQ2hrID09IG51bGwgPyBudWxsIDogdG9wQ2hrLnR5cGU7XG5cbiAgICBpZiAodG9wVHlwZSA9PT0gVHlwZS5ESVJFQ1RFRF9FREdFKSB7XG4gICAgICAvLyBkaXJlY3RlZCBlZGdlIHdpdGggc3ViamVjdCBvbiB0aGUgdGFyZ2V0XG4gICAgICAvLyBjaGFuZ2UgdG8gdGFyZ2V0IG5vZGUgY2hlY2tcbiAgICAgIHRvcENoay50eXBlID0gVHlwZS5OT0RFX1RBUkdFVDtcbiAgICB9IGVsc2UgaWYgKHRvcFR5cGUgPT09IFR5cGUuVU5ESVJFQ1RFRF9FREdFKSB7XG4gICAgICAvLyB1bmRpcmVjdGVkIGVkZ2Ugd2l0aCBzdWJqZWN0IG9uIHRoZSBzZWNvbmQgbm9kZVxuICAgICAgLy8gY2hhbmdlIHRvIG5laWdoYm9yIGNoZWNrXG4gICAgICB0b3BDaGsudHlwZSA9IFR5cGUuTk9ERV9ORUlHSEJPUjtcbiAgICAgIHRvcENoay5ub2RlID0gdG9wQ2hrLm5vZGVzWzFdOyAvLyBzZWNvbmQgbm9kZSBpcyBzdWJqZWN0XG5cbiAgICAgIHRvcENoay5uZWlnaGJvciA9IHRvcENoay5ub2Rlc1swXTsgLy8gY2xlYW4gdXAgdW51c2VkIGZpZWxkcyBmb3IgbmV3IHR5cGVcblxuICAgICAgdG9wQ2hrLm5vZGVzID0gbnVsbDtcbiAgICB9XG4gIH1cbn1dO1xuZXhwcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZS5yZWdleE9iaiA9IG5ldyBSZWdFeHAoJ14nICsgZS5yZWdleCk7XG59KTtcblxuLyoqXG4gKiBPZiBhbGwgdGhlIGV4cHJlc3Npb25zLCBmaW5kIHRoZSBmaXJzdCBtYXRjaCBpbiB0aGUgcmVtYWluaW5nIHRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtYWluaW5nIFRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICogQHJldHVybnMgVGhlIG1hdGNoZWQgZXhwcmVzc2lvbiBhbmQgdGhlIG5ld2x5IHJlbWFpbmluZyB0ZXh0IGB7IGV4cHIsIG1hdGNoLCBuYW1lLCByZW1haW5pbmcgfWBcbiAqL1xuXG52YXIgY29uc3VtZUV4cHIgPSBmdW5jdGlvbiBjb25zdW1lRXhwcihyZW1haW5pbmcpIHtcbiAgdmFyIGV4cHI7XG4gIHZhciBtYXRjaDtcbiAgdmFyIG5hbWU7XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCBleHBycy5sZW5ndGg7IGorKykge1xuICAgIHZhciBlID0gZXhwcnNbal07XG4gICAgdmFyIG4gPSBlLm5hbWU7XG4gICAgdmFyIG0gPSByZW1haW5pbmcubWF0Y2goZS5yZWdleE9iaik7XG5cbiAgICBpZiAobSAhPSBudWxsKSB7XG4gICAgICBtYXRjaCA9IG07XG4gICAgICBleHByID0gZTtcbiAgICAgIG5hbWUgPSBuO1xuICAgICAgdmFyIGNvbnN1bWVkID0gbVswXTtcbiAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoY29uc3VtZWQubGVuZ3RoKTtcbiAgICAgIGJyZWFrOyAvLyB3ZSd2ZSBjb25zdW1lZCBvbmUgZXhwciwgc28gd2UgY2FuIHJldHVybiBub3dcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cHI6IGV4cHIsXG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcmVtYWluaW5nOiByZW1haW5pbmdcbiAgfTtcbn07XG4vKipcbiAqIENvbnN1bWUgYWxsIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1haW5pbmcgVGhlIHRleHQgdG8gY29uc3VtZVxuICogQHJldHVybnMgVGhlIHRleHQgd2l0aCB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWRcbiAqL1xuXG5cbnZhciBjb25zdW1lV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIGNvbnN1bWVXaGl0ZXNwYWNlKHJlbWFpbmluZykge1xuICB2YXIgbWF0Y2ggPSByZW1haW5pbmcubWF0Y2goL15cXHMrLyk7XG5cbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGNvbnN1bWVkID0gbWF0Y2hbMF07XG4gICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyhjb25zdW1lZC5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHJlbWFpbmluZztcbn07XG4vKipcbiAqIFBhcnNlIHRoZSBzdHJpbmcgYW5kIHN0b3JlIHRoZSBwYXJzZWQgcmVwcmVzZW50YXRpb24gaW4gdGhlIFNlbGVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFRoZSBzZWxlY3RvciBzdHJpbmdcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2VsZWN0b3Igd2FzIHN1Y2Nlc3NmdWxseSBwYXJzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKi9cblxuXG52YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShzZWxlY3Rvcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZW1haW5pbmcgPSBzZWxmLmlucHV0VGV4dCA9IHNlbGVjdG9yO1xuICB2YXIgY3VycmVudFF1ZXJ5ID0gc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gIHNlbGYubGVuZ3RoID0gMTtcbiAgcmVtYWluaW5nID0gY29uc3VtZVdoaXRlc3BhY2UocmVtYWluaW5nKTsgLy8gZ2V0IHJpZCBvZiBsZWFkaW5nIHdoaXRlc3BhY2VcblxuICBmb3IgKDs7KSB7XG4gICAgdmFyIGV4cHJJbmZvID0gY29uc3VtZUV4cHIocmVtYWluaW5nKTtcblxuICAgIGlmIChleHBySW5mby5leHByID09IG51bGwpIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2BpcyBpbnZhbGlkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gZXhwckluZm8ubWF0Y2guc2xpY2UoMSk7IC8vIGxldCB0aGUgdG9rZW4gcG9wdWxhdGUgdGhlIHNlbGVjdG9yIG9iamVjdCBpbiBjdXJyZW50UXVlcnlcblxuICAgICAgdmFyIHJldCA9IGV4cHJJbmZvLmV4cHIucG9wdWxhdGUoc2VsZiwgY3VycmVudFF1ZXJ5LCBhcmdzKTtcblxuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBleGl0IGlmIHBvcHVsYXRpb24gZmFpbGVkXG4gICAgICB9IGVsc2UgaWYgKHJldCAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRRdWVyeSA9IHJldDsgLy8gY2hhbmdlIHRoZSBjdXJyZW50IHF1ZXJ5IHRvIGJlIGZpbGxlZCBpZiB0aGUgZXhwciBzcGVjaWZpZXNcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW1haW5pbmcgPSBleHBySW5mby5yZW1haW5pbmc7IC8vIHdlJ3JlIGRvbmUgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBwYXJzZVxuXG4gICAgaWYgKHJlbWFpbmluZy5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYXN0USA9IHNlbGZbc2VsZi5sZW5ndGggLSAxXTtcblxuICBpZiAoc2VsZi5jdXJyZW50U3ViamVjdCAhPSBudWxsKSB7XG4gICAgbGFzdFEuc3ViamVjdCA9IHNlbGYuY3VycmVudFN1YmplY3Q7XG4gIH1cblxuICBsYXN0US5lZGdlQ291bnQgPSBzZWxmLmVkZ2VDb3VudDtcbiAgbGFzdFEuY29tcG91bmRDb3VudCA9IHNlbGYuY29tcG91bmRDb3VudDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcSA9IHNlbGZbaV07IC8vIGluIGZ1dHVyZSwgdGhpcyBjb3VsZCBwb3RlbnRpYWxseSBiZSBhbGxvd2VkIGlmIHRoZXJlIHdlcmUgb3BlcmF0b3IgcHJlY2VkZW5jZSBhbmQgZGV0ZWN0aW9uIG9mIGludmFsaWQgY29tYmluYXRpb25zXG5cbiAgICBpZiAocS5jb21wb3VuZENvdW50ID4gMCAmJiBxLmVkZ2VDb3VudCA+IDApIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgaW52YWxpZCBiZWNhdXNlIGl0IHVzZXMgYm90aCBhIGNvbXBvdW5kIHNlbGVjdG9yIGFuZCBhbiBlZGdlIHNlbGVjdG9yJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHEuZWRnZUNvdW50ID4gMSkge1xuICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBpbnZhbGlkIGJlY2F1c2UgaXQgdXNlcyBtdWx0aXBsZSBlZGdlIHNlbGVjdG9ycycpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAocS5lZGdlQ291bnQgPT09IDEpIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgZGVwcmVjYXRlZC4gIEVkZ2Ugc2VsZWN0b3JzIGRvIG5vdCB0YWtlIGVmZmVjdCBvbiBjaGFuZ2VzIHRvIHNvdXJjZSBhbmQgdGFyZ2V0IG5vZGVzIGFmdGVyIGFuIGVkZ2UgaXMgYWRkZWQsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiAgVXNlIGEgY2xhc3Mgb3IgZGF0YSBzZWxlY3RvciBvbiBlZGdlcyBpbnN0ZWFkLCB1cGRhdGluZyB0aGUgY2xhc3Mgb3IgZGF0YSBvZiBhbiBlZGdlIHdoZW4geW91ciBhcHAgZGV0ZWN0cyBhIGNoYW5nZSBpbiBzb3VyY2Ugb3IgdGFyZ2V0IG5vZGVzLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlOyAvLyBzdWNjZXNzXG59O1xuLyoqXG4gKiBHZXQgdGhlIHNlbGVjdG9yIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLiAgVGhpcyB2YWx1ZSB1c2VzIGRlZmF1bHQgZm9ybWF0dGluZyxcbiAqIHNvIHRoaW5ncyBsaWtlIHNwYWNpbmcgbWF5IGRpZmZlciBmcm9tIHRoZSBpbnB1dCB0ZXh0IHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2VsZWN0b3Igc3RyaW5nXG4gKi9cblxuXG52YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgaWYgKHRoaXMudG9TdHJpbmdDYWNoZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmdDYWNoZTtcbiAgfVxuXG4gIHZhciBjbGVhbiA9IGZ1bmN0aW9uIGNsZWFuKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY2xlYW5WYWwgPSBmdW5jdGlvbiBjbGVhblZhbCh2YWwpIHtcbiAgICBpZiAoc3RyaW5nKHZhbCkpIHtcbiAgICAgIHJldHVybiAnXCInICsgdmFsICsgJ1wiJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNsZWFuKHZhbCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzcGFjZSA9IGZ1bmN0aW9uIHNwYWNlKHZhbCkge1xuICAgIHJldHVybiAnICcgKyB2YWwgKyAnICc7XG4gIH07XG5cbiAgdmFyIGNoZWNrVG9TdHJpbmcgPSBmdW5jdGlvbiBjaGVja1RvU3RyaW5nKGNoZWNrLCBzdWJqZWN0KSB7XG4gICAgdmFyIHR5cGUgPSBjaGVjay50eXBlLFxuICAgICAgICB2YWx1ZSA9IGNoZWNrLnZhbHVlO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFR5cGUuR1JPVVA6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSBjbGVhbih2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwLnN1YnN0cmluZygwLCBncm91cC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuREFUQV9DT01QQVJFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICAgICAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3I7XG4gICAgICAgICAgcmV0dXJuICdbJyArIGZpZWxkICsgc3BhY2UoY2xlYW4ob3BlcmF0b3IpKSArIGNsZWFuVmFsKHZhbHVlKSArICddJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuREFUQV9CT09MOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgICAgICAgICBfZmllbGQgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICByZXR1cm4gJ1snICsgY2xlYW4oX29wZXJhdG9yKSArIF9maWVsZCArICddJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuREFUQV9FWElTVDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZmllbGQyID0gY2hlY2suZmllbGQ7XG4gICAgICAgICAgcmV0dXJuICdbJyArIF9maWVsZDIgKyAnXSc7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBUeXBlLk1FVEFfQ09NUEFSRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfb3BlcmF0b3IyID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICAgICAgICAgIF9maWVsZDMgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICByZXR1cm4gJ1tbJyArIF9maWVsZDMgKyBzcGFjZShjbGVhbihfb3BlcmF0b3IyKSkgKyBjbGVhblZhbCh2YWx1ZSkgKyAnXV0nO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5TVEFURTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuSUQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gJyMnICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBUeXBlLkNMQVNTOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuICcuJyArIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5QQVJFTlQ6XG4gICAgICBjYXNlIFR5cGUuQ0hJTEQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcXVlcnlUb1N0cmluZyhjaGVjay5wYXJlbnQsIHN1YmplY3QpICsgc3BhY2UoJz4nKSArIHF1ZXJ5VG9TdHJpbmcoY2hlY2suY2hpbGQsIHN1YmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVHlwZS5BTkNFU1RPUjpcbiAgICAgIGNhc2UgVHlwZS5ERVNDRU5EQU5UOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5VG9TdHJpbmcoY2hlY2suYW5jZXN0b3IsIHN1YmplY3QpICsgJyAnICsgcXVlcnlUb1N0cmluZyhjaGVjay5kZXNjZW5kYW50LCBzdWJqZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuQ09NUE9VTkRfU1BMSVQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGhzID0gcXVlcnlUb1N0cmluZyhjaGVjay5sZWZ0LCBzdWJqZWN0KTtcbiAgICAgICAgICB2YXIgc3ViID0gcXVlcnlUb1N0cmluZyhjaGVjay5zdWJqZWN0LCBzdWJqZWN0KTtcbiAgICAgICAgICB2YXIgcmhzID0gcXVlcnlUb1N0cmluZyhjaGVjay5yaWdodCwgc3ViamVjdCk7XG4gICAgICAgICAgcmV0dXJuIGxocyArIChsaHMubGVuZ3RoID4gMCA/ICcgJyA6ICcnKSArIHN1YiArIHJocztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFR5cGUuVFJVRTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcXVlcnlUb1N0cmluZyA9IGZ1bmN0aW9uIHF1ZXJ5VG9TdHJpbmcocXVlcnksIHN1YmplY3QpIHtcbiAgICByZXR1cm4gcXVlcnkuY2hlY2tzLnJlZHVjZShmdW5jdGlvbiAoc3RyLCBjaGssIGkpIHtcbiAgICAgIHJldHVybiBzdHIgKyAoc3ViamVjdCA9PT0gcXVlcnkgJiYgaSA9PT0gMCA/ICckJyA6ICcnKSArIGNoZWNrVG9TdHJpbmcoY2hrLCBzdWJqZWN0KTtcbiAgICB9LCAnJyk7XG4gIH07XG5cbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBxdWVyeSA9IHRoaXNbaV07XG4gICAgc3RyICs9IHF1ZXJ5VG9TdHJpbmcocXVlcnksIHF1ZXJ5LnN1YmplY3QpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSAmJiBpIDwgdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICBzdHIgKz0gJywgJztcbiAgICB9XG4gIH1cblxuICB0aGlzLnRvU3RyaW5nQ2FjaGUgPSBzdHI7XG4gIHJldHVybiBzdHI7XG59O1xudmFyIHBhcnNlJDEgPSB7XG4gIHBhcnNlOiBwYXJzZSxcbiAgdG9TdHJpbmc6IHRvU3RyaW5nXG59O1xuXG52YXIgdmFsQ21wID0gZnVuY3Rpb24gdmFsQ21wKGZpZWxkVmFsLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgdmFyIG1hdGNoZXM7XG4gIHZhciBpc0ZpZWxkU3RyID0gc3RyaW5nKGZpZWxkVmFsKTtcbiAgdmFyIGlzRmllbGROdW0gPSBudW1iZXIoZmllbGRWYWwpO1xuICB2YXIgaXNWYWxTdHIgPSBzdHJpbmcodmFsdWUpO1xuICB2YXIgZmllbGRTdHIsIHZhbFN0cjtcbiAgdmFyIGNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xuICB2YXIgbm90RXhwciA9IGZhbHNlO1xuICB2YXIgaXNJbmVxQ21wID0gZmFsc2U7XG5cbiAgaWYgKG9wZXJhdG9yLmluZGV4T2YoJyEnKSA+PSAwKSB7XG4gICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCchJywgJycpO1xuICAgIG5vdEV4cHIgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wZXJhdG9yLmluZGV4T2YoJ0AnKSA+PSAwKSB7XG4gICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCdAJywgJycpO1xuICAgIGNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XG4gIH1cblxuICBpZiAoaXNGaWVsZFN0ciB8fCBpc1ZhbFN0ciB8fCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICBmaWVsZFN0ciA9ICFpc0ZpZWxkU3RyICYmICFpc0ZpZWxkTnVtID8gJycgOiAnJyArIGZpZWxkVmFsO1xuICAgIHZhbFN0ciA9ICcnICsgdmFsdWU7XG4gIH0gLy8gaWYgd2UncmUgZG9pbmcgYSBjYXNlIGluc2Vuc2l0aXZlIGNvbXBhcmlzb24sIHRoZW4gd2UncmUgdXNpbmcgYSBTVFJJTkcgY29tcGFyaXNvblxuICAvLyBldmVuIGlmIHdlJ3JlIGNvbXBhcmluZyBudW1iZXJzXG5cblxuICBpZiAoY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgZmllbGRWYWwgPSBmaWVsZFN0ciA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsdWUgPSB2YWxTdHIgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlICcqPSc6XG4gICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZih2YWxTdHIpID49IDA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJyQ9JzpcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKHZhbFN0ciwgZmllbGRTdHIubGVuZ3RoIC0gdmFsU3RyLmxlbmd0aCkgPj0gMDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnXj0nOlxuICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyKSA9PT0gMDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPSc6XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPT09IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICc+JzpcbiAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPiB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA+PSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPCc6XG4gICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsIDwgdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJzw9JzpcbiAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICBtYXRjaGVzID0gZmllbGRWYWwgPD0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBtYXRjaGVzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgfSAvLyBhcHBseSB0aGUgbm90IG9wLCBidXQgbnVsbCB2YWxzIGZvciBpbmVxdWFsaXRpZXMgc2hvdWxkIGFsd2F5cyBzdGF5IG5vbi1tYXRjaGluZ1xuXG5cbiAgaWYgKG5vdEV4cHIgJiYgKGZpZWxkVmFsICE9IG51bGwgfHwgIWlzSW5lcUNtcCkpIHtcbiAgICBtYXRjaGVzID0gIW1hdGNoZXM7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn07XG52YXIgYm9vbENtcCA9IGZ1bmN0aW9uIGJvb2xDbXAoZmllbGRWYWwsIG9wZXJhdG9yKSB7XG4gIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICBjYXNlICc/JzpcbiAgICAgIHJldHVybiBmaWVsZFZhbCA/IHRydWUgOiBmYWxzZTtcblxuICAgIGNhc2UgJyEnOlxuICAgICAgcmV0dXJuIGZpZWxkVmFsID8gZmFsc2UgOiB0cnVlO1xuXG4gICAgY2FzZSAnXic6XG4gICAgICByZXR1cm4gZmllbGRWYWwgPT09IHVuZGVmaW5lZDtcbiAgfVxufTtcbnZhciBleGlzdENtcCA9IGZ1bmN0aW9uIGV4aXN0Q21wKGZpZWxkVmFsKSB7XG4gIHJldHVybiBmaWVsZFZhbCAhPT0gdW5kZWZpbmVkO1xufTtcbnZhciBkYXRhID0gZnVuY3Rpb24gZGF0YShlbGUsIGZpZWxkKSB7XG4gIHJldHVybiBlbGUuZGF0YShmaWVsZCk7XG59O1xudmFyIG1ldGEgPSBmdW5jdGlvbiBtZXRhKGVsZSwgZmllbGQpIHtcbiAgcmV0dXJuIGVsZVtmaWVsZF0oKTtcbn07XG5cbi8qKiBBIGxvb2t1cCBvZiBgbWF0Y2goY2hlY2ssIGVsZSlgIGZ1bmN0aW9ucyBieSBgVHlwZWAgaW50ICovXG5cbnZhciBtYXRjaCA9IFtdO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHF1ZXJ5IG1hdGNoZXMgZm9yIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gcXVlcnkgVGhlIGB7IHR5cGUsIHZhbHVlLCAuLi4gfWAgcXVlcnkgb2JqZWN0XG4gKiBAcGFyYW0gZWxlIFRoZSBlbGVtZW50IHRvIGNvbXBhcmUgYWdhaW5zdFxuKi9cblxudmFyIG1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKHF1ZXJ5LCBlbGUpIHtcbiAgcmV0dXJuIHF1ZXJ5LmNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hrKSB7XG4gICAgcmV0dXJuIG1hdGNoW2Noay50eXBlXShjaGssIGVsZSk7XG4gIH0pO1xufTtcblxubWF0Y2hbVHlwZS5HUk9VUF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZ3JvdXAgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGdyb3VwID09PSAnKicgfHwgZ3JvdXAgPT09IGVsZS5ncm91cCgpO1xufTtcblxubWF0Y2hbVHlwZS5TVEFURV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgc3RhdGVTZWxlY3RvciA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gc3RhdGVTZWxlY3Rvck1hdGNoZXMoc3RhdGVTZWxlY3RvciwgZWxlKTtcbn07XG5cbm1hdGNoW1R5cGUuSURdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGlkID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBlbGUuaWQoKSA9PT0gaWQ7XG59O1xuXG5tYXRjaFtUeXBlLkNMQVNTXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBjbHMgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGVsZS5oYXNDbGFzcyhjbHMpO1xufTtcblxubWF0Y2hbVHlwZS5NRVRBX0NPTVBBUkVdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIHZhbENtcChtZXRhKGVsZSwgZmllbGQpLCBvcGVyYXRvciwgdmFsdWUpO1xufTtcblxubWF0Y2hbVHlwZS5EQVRBX0NPTVBBUkVdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIHZhbENtcChkYXRhKGVsZSwgZmllbGQpLCBvcGVyYXRvciwgdmFsdWUpO1xufTtcblxubWF0Y2hbVHlwZS5EQVRBX0JPT0xdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yO1xuICByZXR1cm4gYm9vbENtcChkYXRhKGVsZSwgZmllbGQpLCBvcGVyYXRvcik7XG59O1xuXG5tYXRjaFtUeXBlLkRBVEFfRVhJU1RdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yO1xuICByZXR1cm4gZXhpc3RDbXAoZGF0YShlbGUsIGZpZWxkKSk7XG59O1xuXG5tYXRjaFtUeXBlLlVORElSRUNURURfRURHRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgcUEgPSBjaGVjay5ub2Rlc1swXTtcbiAgdmFyIHFCID0gY2hlY2subm9kZXNbMV07XG4gIHZhciBzcmMgPSBlbGUuc291cmNlKCk7XG4gIHZhciB0Z3QgPSBlbGUudGFyZ2V0KCk7XG4gIHJldHVybiBtYXRjaGVzKHFBLCBzcmMpICYmIG1hdGNoZXMocUIsIHRndCkgfHwgbWF0Y2hlcyhxQiwgc3JjKSAmJiBtYXRjaGVzKHFBLCB0Z3QpO1xufTtcblxubWF0Y2hbVHlwZS5OT0RFX05FSUdIQk9SXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzKGNoZWNrLm5vZGUsIGVsZSkgJiYgZWxlLm5laWdoYm9yaG9vZCgpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzKGNoZWNrLm5laWdoYm9yLCBuKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLkRJUkVDVEVEX0VER0VdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMoY2hlY2suc291cmNlLCBlbGUuc291cmNlKCkpICYmIG1hdGNoZXMoY2hlY2sudGFyZ2V0LCBlbGUudGFyZ2V0KCkpO1xufTtcblxubWF0Y2hbVHlwZS5OT0RFX1NPVVJDRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyhjaGVjay5zb3VyY2UsIGVsZSkgJiYgZWxlLm91dGdvZXJzKCkuc29tZShmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBuLmlzTm9kZSgpICYmIG1hdGNoZXMoY2hlY2sudGFyZ2V0LCBuKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLk5PREVfVEFSR0VUXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzKGNoZWNrLnRhcmdldCwgZWxlKSAmJiBlbGUuaW5jb21lcnMoKS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4uaXNOb2RlKCkgJiYgbWF0Y2hlcyhjaGVjay5zb3VyY2UsIG4pO1xuICB9KTtcbn07XG5cbm1hdGNoW1R5cGUuQ0hJTERdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMoY2hlY2suY2hpbGQsIGVsZSkgJiYgbWF0Y2hlcyhjaGVjay5wYXJlbnQsIGVsZS5wYXJlbnQoKSk7XG59O1xuXG5tYXRjaFtUeXBlLlBBUkVOVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyhjaGVjay5wYXJlbnQsIGVsZSkgJiYgZWxlLmNoaWxkcmVuKCkuc29tZShmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiBtYXRjaGVzKGNoZWNrLmNoaWxkLCBjKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLkRFU0NFTkRBTlRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMoY2hlY2suZGVzY2VuZGFudCwgZWxlKSAmJiBlbGUuYW5jZXN0b3JzKCkuc29tZShmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBtYXRjaGVzKGNoZWNrLmFuY2VzdG9yLCBhKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLkFOQ0VTVE9SXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzKGNoZWNrLmFuY2VzdG9yLCBlbGUpICYmIGVsZS5kZXNjZW5kYW50cygpLnNvbWUoZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyhjaGVjay5kZXNjZW5kYW50LCBkKTtcbiAgfSk7XG59O1xuXG5tYXRjaFtUeXBlLkNPTVBPVU5EX1NQTElUXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzKGNoZWNrLnN1YmplY3QsIGVsZSkgJiYgbWF0Y2hlcyhjaGVjay5sZWZ0LCBlbGUpICYmIG1hdGNoZXMoY2hlY2sucmlnaHQsIGVsZSk7XG59O1xuXG5tYXRjaFtUeXBlLlRSVUVdID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1hdGNoW1R5cGUuQ09MTEVDVElPTl0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgY29sbGVjdGlvbiA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gY29sbGVjdGlvbi5oYXMoZWxlKTtcbn07XG5cbm1hdGNoW1R5cGUuRklMVEVSXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBmaWx0ZXIgPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGZpbHRlcihlbGUpO1xufTtcblxudmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uKSB7XG4gIHZhciBzZWxmID0gdGhpczsgLy8gZm9yIDEgaWQgI2ZvbyBxdWVyaWVzLCBqdXN0IGdldCB0aGUgZWxlbWVudFxuXG4gIGlmIChzZWxmLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmNoZWNrcy5sZW5ndGggPT09IDEgJiYgc2VsZlswXS5jaGVja3NbMF0udHlwZSA9PT0gVHlwZS5JRCkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmdldEVsZW1lbnRCeUlkKHNlbGZbMF0uY2hlY2tzWzBdLnZhbHVlKS5jb2xsZWN0aW9uKCk7XG4gIH1cblxuICB2YXIgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIHNlbGVjdG9yRnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcblxuICAgICAgaWYgKG1hdGNoZXMocXVlcnksIGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBpZiAoc2VsZi50ZXh0KCkgPT0gbnVsbCkge1xuICAgIHNlbGVjdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiBzZWxlY3RvckZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBjb2xsZWN0aW9uLmZpbHRlcihzZWxlY3RvckZ1bmN0aW9uKTtcbn07IC8vIGZpbHRlclxuLy8gZG9lcyBzZWxlY3RvciBtYXRjaCBhIHNpbmdsZSBlbGVtZW50P1xuXG5cbnZhciBtYXRjaGVzJDEgPSBmdW5jdGlvbiBtYXRjaGVzJDEoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuXG4gICAgaWYgKG1hdGNoZXMocXVlcnksIGVsZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07IC8vIG1hdGNoZXNcblxuXG52YXIgbWF0Y2hpbmcgPSB7XG4gIG1hdGNoZXM6IG1hdGNoZXMkMSxcbiAgZmlsdGVyOiBmaWx0ZXJcbn07XG5cbnZhciBTZWxlY3RvciA9IGZ1bmN0aW9uIFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHRoaXMuaW5wdXRUZXh0ID0gc2VsZWN0b3I7XG4gIHRoaXMuY3VycmVudFN1YmplY3QgPSBudWxsO1xuICB0aGlzLmNvbXBvdW5kQ291bnQgPSAwO1xuICB0aGlzLmVkZ2VDb3VudCA9IDA7XG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICBpZiAoc2VsZWN0b3IgPT0gbnVsbCB8fCBzdHJpbmcoc2VsZWN0b3IpICYmIHNlbGVjdG9yLm1hdGNoKC9eXFxzKiQvKSkgOyBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKHNlbGVjdG9yKSkge1xuICAgIHRoaXMuYWRkUXVlcnkoe1xuICAgICAgY2hlY2tzOiBbe1xuICAgICAgICB0eXBlOiBUeXBlLkNPTExFQ1RJT04sXG4gICAgICAgIHZhbHVlOiBzZWxlY3Rvci5jb2xsZWN0aW9uKClcbiAgICAgIH1dXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZm4oc2VsZWN0b3IpKSB7XG4gICAgdGhpcy5hZGRRdWVyeSh7XG4gICAgICBjaGVja3M6IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuRklMVEVSLFxuICAgICAgICB2YWx1ZTogc2VsZWN0b3JcbiAgICAgIH1dXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc3RyaW5nKHNlbGVjdG9yKSkge1xuICAgIGlmICghdGhpcy5wYXJzZShzZWxlY3RvcikpIHtcbiAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVycm9yKCdBIHNlbGVjdG9yIG11c3QgYmUgY3JlYXRlZCBmcm9tIGEgc3RyaW5nOyBmb3VuZCAnKTtcbiAgfVxufTtcblxudmFyIHNlbGZuID0gU2VsZWN0b3IucHJvdG90eXBlO1xuW3BhcnNlJDEsIG1hdGNoaW5nXS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBleHRlbmQoc2VsZm4sIHApO1xufSk7XG5cbnNlbGZuLnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlucHV0VGV4dDtcbn07XG5cbnNlbGZuLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbnNlbGZuLmVxID0gZnVuY3Rpb24gKGkpIHtcbiAgcmV0dXJuIHRoaXNbaV07XG59O1xuXG5zZWxmbi5zYW1lVGV4dCA9IGZ1bmN0aW9uIChvdGhlclNlbCkge1xuICByZXR1cm4gIXRoaXMuaW52YWxpZCAmJiAhb3RoZXJTZWwuaW52YWxpZCAmJiB0aGlzLnRleHQoKSA9PT0gb3RoZXJTZWwudGV4dCgpO1xufTtcblxuc2VsZm4uYWRkUXVlcnkgPSBmdW5jdGlvbiAocSkge1xuICB0aGlzW3RoaXMubGVuZ3RoKytdID0gcTtcbn07XG5cbnNlbGZuLnNlbGVjdG9yID0gc2VsZm4udG9TdHJpbmc7XG5cbnZhciBlbGVzZm4kZiA9IHtcbiAgYWxsQXJlOiBmdW5jdGlvbiBhbGxBcmUoc2VsZWN0b3IpIHtcbiAgICB2YXIgc2VsT2JqID0gbmV3IFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoZWxlKTtcbiAgICB9KTtcbiAgfSxcbiAgaXM6IGZ1bmN0aW9uIGlzKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNlbE9iaiA9IG5ldyBTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoZWxlKTtcbiAgICB9KTtcbiAgfSxcbiAgc29tZTogZnVuY3Rpb24gc29tZShmbiwgdGhpc0FyZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4odGhpc1tpXSwgaSwgdGhpcykgOiBmbi5hcHBseSh0aGlzQXJnLCBbdGhpc1tpXSwgaSwgdGhpc10pO1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGZuLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmV0ID0gIXRoaXNBcmcgPyBmbih0aGlzW2ldLCBpLCB0aGlzKSA6IGZuLmFwcGx5KHRoaXNBcmcsIFt0aGlzW2ldLCBpLCB0aGlzXSk7XG5cbiAgICAgIGlmICghcmV0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgc2FtZTogZnVuY3Rpb24gc2FtZShjb2xsZWN0aW9uKSB7XG4gICAgLy8gY2hlYXAgY29sbGVjdGlvbiByZWYgY2hlY2tcbiAgICBpZiAodGhpcyA9PT0gY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgIHZhciB0aGlzTGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgdmFyIGNvbGxlY3Rpb25MZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDsgLy8gY2hlYXAgbGVuZ3RoIGNoZWNrXG5cbiAgICBpZiAodGhpc0xlbmd0aCAhPT0gY29sbGVjdGlvbkxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY2hlYXAgZWxlbWVudCByZWYgY2hlY2tcblxuXG4gICAgaWYgKHRoaXNMZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzWzBdID09PSBjb2xsZWN0aW9uWzBdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9LFxuICBhbnlTYW1lOiBmdW5jdGlvbiBhbnlTYW1lKGNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICB9KTtcbiAgfSxcbiAgYWxsQXJlTmVpZ2hib3JzOiBmdW5jdGlvbiBhbGxBcmVOZWlnaGJvcnMoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICB2YXIgbmhvb2QgPSB0aGlzLm5laWdoYm9yaG9vZCgpO1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBuaG9vZC5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICB9KTtcbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uIGNvbnRhaW5zKGNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBzZWxmLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9XG59O1xuZWxlc2ZuJGYuYWxsQXJlTmVpZ2hib3VycyA9IGVsZXNmbiRmLmFsbEFyZU5laWdoYm9ycztcbmVsZXNmbiRmLmhhcyA9IGVsZXNmbiRmLmNvbnRhaW5zO1xuZWxlc2ZuJGYuZXF1YWwgPSBlbGVzZm4kZi5lcXVhbHMgPSBlbGVzZm4kZi5zYW1lO1xuXG52YXIgY2FjaGUgPSBmdW5jdGlvbiBjYWNoZShmbiwgbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gdHJhdmVyc2FsQ2FjaGUoYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgIHZhciBzZWxlY3Rvck9yRWxlcyA9IGFyZzE7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBrZXk7XG5cbiAgICBpZiAoc2VsZWN0b3JPckVsZXMgPT0gbnVsbCkge1xuICAgICAga2V5ID0gJyc7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKHNlbGVjdG9yT3JFbGVzKSAmJiBzZWxlY3Rvck9yRWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGtleSA9IHNlbGVjdG9yT3JFbGVzLmlkKCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZXMubGVuZ3RoID09PSAxICYmIGtleSkge1xuICAgICAgdmFyIF9wID0gZWxlc1swXS5fcHJpdmF0ZTtcbiAgICAgIHZhciB0Y2ggPSBfcC50cmF2ZXJzYWxDYWNoZSA9IF9wLnRyYXZlcnNhbENhY2hlIHx8IHt9O1xuICAgICAgdmFyIGNoID0gdGNoW25hbWVdID0gdGNoW25hbWVdIHx8IFtdO1xuICAgICAgdmFyIGhhc2ggPSBoYXNoU3RyaW5nKGtleSk7XG4gICAgICB2YXIgY2FjaGVIaXQgPSBjaFtoYXNoXTtcblxuICAgICAgaWYgKGNhY2hlSGl0KSB7XG4gICAgICAgIHJldHVybiBjYWNoZUhpdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaFtoYXNoXSA9IGZuLmNhbGwoZWxlcywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKGVsZXMsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBlbGVzZm4kZyA9IHtcbiAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoc2VsZWN0b3IpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdOyAvLyBvcHRpbWlzYXRpb24gZm9yIHNpbmdsZSBlbGUgY2FsbFxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpc1swXS5fcHJpdmF0ZS5wYXJlbnQ7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIF9wYXJlbnQgPSBlbGUuX3ByaXZhdGUucGFyZW50O1xuXG4gICAgICBpZiAoX3BhcmVudCkge1xuICAgICAgICBwYXJlbnRzLnB1c2goX3BhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocGFyZW50cywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgcGFyZW50czogZnVuY3Rpb24gcGFyZW50cyhzZWxlY3Rvcikge1xuICAgIHZhciBwYXJlbnRzID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzLnBhcmVudCgpO1xuXG4gICAgd2hpbGUgKGVsZXMubm9uZW1wdHkoKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICBwYXJlbnRzLnB1c2goZWxlKTtcbiAgICAgIH1cblxuICAgICAgZWxlcyA9IGVsZXMucGFyZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocGFyZW50cywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgY29tbW9uQW5jZXN0b3JzOiBmdW5jdGlvbiBjb21tb25BbmNlc3RvcnMoc2VsZWN0b3IpIHtcbiAgICB2YXIgYW5jZXN0b3JzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBwYXJlbnRzID0gZWxlLnBhcmVudHMoKTtcbiAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycyB8fCBwYXJlbnRzO1xuICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmludGVyc2VjdChwYXJlbnRzKTsgLy8gY3VycmVudCBsaXN0IG11c3QgYmUgY29tbW9uIHdpdGggY3VycmVudCBlbGUgcGFyZW50cyBzZXRcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JzLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIG9ycGhhbnM6IGZ1bmN0aW9uIG9ycGhhbnMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc09ycGhhbigpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIG5vbm9ycGhhbnM6IGZ1bmN0aW9uIG5vbm9ycGhhbnMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgY2hpbGRyZW46IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBlbGVDaGlsZHJlbiA9IGVsZS5fcHJpdmF0ZS5jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVDaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGVsZUNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihjaGlsZHJlbiwge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ2NoaWxkcmVuJyksXG4gIHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncyhzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCkubm90KHRoaXMpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIGlzUGFyZW50OiBmdW5jdGlvbiBpc1BhcmVudCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMDtcbiAgICB9XG4gIH0sXG4gIGlzQ2hpbGRsZXNzOiBmdW5jdGlvbiBpc0NoaWxkbGVzcygpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gIH0sXG4gIGlzQ2hpbGQ6IGZ1bmN0aW9uIGlzQ2hpbGQoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5wYXJlbnQgIT0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGlzT3JwaGFuOiBmdW5jdGlvbiBpc09ycGhhbigpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLnBhcmVudCA9PSBudWxsO1xuICAgIH1cbiAgfSxcbiAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uIGRlc2NlbmRhbnRzKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICBmdW5jdGlvbiBhZGQoZWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG5cbiAgICAgICAgaWYgKGVsZS5jaGlsZHJlbigpLm5vbmVtcHR5KCkpIHtcbiAgICAgICAgICBhZGQoZWxlLmNoaWxkcmVuKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWRkKHRoaXMuY2hpbGRyZW4oKSk7XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZvckVhY2hDb21wb3VuZChlbGVzLCBmbiwgaW5jbHVkZVNlbGYsIHJlY3Vyc2l2ZVN0ZXApIHtcbiAgdmFyIHEgPSBbXTtcbiAgdmFyIGRpZCA9IG5ldyBTZXQkMSgpO1xuICB2YXIgY3kgPSBlbGVzLmN5KCk7XG4gIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICBpZiAoaW5jbHVkZVNlbGYpIHtcbiAgICAgIHEucHVzaChlbGUpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICByZWN1cnNpdmVTdGVwKHEsIGRpZCwgZWxlKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAocS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIF9lbGUgPSBxLnNoaWZ0KCk7XG5cbiAgICBmbihfZWxlKTtcbiAgICBkaWQuYWRkKF9lbGUuaWQoKSk7XG5cbiAgICBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICByZWN1cnNpdmVTdGVwKHEsIGRpZCwgX2VsZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZXM7XG59XG5cbmZ1bmN0aW9uIGFkZENoaWxkcmVuKHEsIGRpZCwgZWxlKSB7XG4gIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsZS5fcHJpdmF0ZS5jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoIWRpZC5oYXMoY2hpbGQuaWQoKSkpIHtcbiAgICAgICAgcS5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gdmVyeSBlZmZpY2llbnQgdmVyc2lvbiBvZiBlbGVzLmFkZCggZWxlcy5kZXNjZW5kYW50cygpICkuZm9yRWFjaCgpXG4vLyBmb3IgaW50ZXJuYWwgdXNlXG5cblxuZWxlc2ZuJGcuZm9yRWFjaERvd24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkQ2hpbGRyZW4pO1xufTtcblxuZnVuY3Rpb24gYWRkUGFyZW50KHEsIGRpZCwgZWxlKSB7XG4gIGlmIChlbGUuaXNDaGlsZCgpKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsZS5fcHJpdmF0ZS5wYXJlbnQ7XG5cbiAgICBpZiAoIWRpZC5oYXMocGFyZW50LmlkKCkpKSB7XG4gICAgICBxLnB1c2gocGFyZW50KTtcbiAgICB9XG4gIH1cbn1cblxuZWxlc2ZuJGcuZm9yRWFjaFVwID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBpbmNsdWRlU2VsZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgcmV0dXJuIGZvckVhY2hDb21wb3VuZCh0aGlzLCBmbiwgaW5jbHVkZVNlbGYsIGFkZFBhcmVudCk7XG59O1xuXG5mdW5jdGlvbiBhZGRQYXJlbnRBbmRDaGlsZHJlbihxLCBkaWQsIGVsZSkge1xuICBhZGRQYXJlbnQocSwgZGlkLCBlbGUpO1xuICBhZGRDaGlsZHJlbihxLCBkaWQsIGVsZSk7XG59XG5cbmVsZXNmbiRnLmZvckVhY2hVcEFuZERvd24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkUGFyZW50QW5kQ2hpbGRyZW4pO1xufTsgLy8gYWxpYXNlc1xuXG5cbmVsZXNmbiRnLmFuY2VzdG9ycyA9IGVsZXNmbiRnLnBhcmVudHM7XG5cbnZhciBmbiQxLCBlbGVzZm4kaDtcbmZuJDEgPSBlbGVzZm4kaCA9IHtcbiAgZGF0YTogZGVmaW5lJDMuZGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgJ2lkJzogdHJ1ZSxcbiAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAncGFyZW50JzogdHJ1ZVxuICAgIH0sXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJlbW92ZURhdGE6IGRlZmluZSQzLnJlbW92ZURhdGEoe1xuICAgIGZpZWxkOiAnZGF0YScsXG4gICAgZXZlbnQ6ICdkYXRhJyxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgIGltbXV0YWJsZUtleXM6IHtcbiAgICAgICdpZCc6IHRydWUsXG4gICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICd0YXJnZXQnOiB0cnVlLFxuICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICB9LFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICBzY3JhdGNoOiBkZWZpbmUkMy5kYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGJpbmRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlU2NyYXRjaDogZGVmaW5lJDMucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICBldmVudDogJ3NjcmF0Y2gnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHJzY3JhdGNoOiBkZWZpbmUkMy5kYXRhKHtcbiAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gIH0pLFxuICByZW1vdmVSc2NyYXRjaDogZGVmaW5lJDMucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgdHJpZ2dlckV2ZW50OiBmYWxzZVxuICB9KSxcbiAgaWQ6IGZ1bmN0aW9uIGlkKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIH1cbiAgfVxufTsgLy8gYWxpYXNlc1xuXG5mbiQxLmF0dHIgPSBmbiQxLmRhdGE7XG5mbiQxLnJlbW92ZUF0dHIgPSBmbiQxLnJlbW92ZURhdGE7XG52YXIgZGF0YSQxID0gZWxlc2ZuJGg7XG5cbnZhciBlbGVzZm4kaSA9IHt9O1xuXG5mdW5jdGlvbiBkZWZpbmVEZWdyZWVGdW5jdGlvbihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChpbmNsdWRlTG9vcHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5jbHVkZUxvb3BzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5pc05vZGUoKSAmJiAhc2VsZi5yZW1vdmVkKCkpIHtcbiAgICAgIHZhciBkZWdyZWUgPSAwO1xuICAgICAgdmFyIG5vZGUgPSBzZWxmWzBdO1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2ldO1xuXG4gICAgICAgIGlmICghaW5jbHVkZUxvb3BzICYmIGVkZ2UuaXNMb29wKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZ3JlZSArPSBjYWxsYmFjayhub2RlLCBlZGdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZ3JlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcbn1cblxuZXh0ZW5kKGVsZXNmbiRpLCB7XG4gIGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS5zb3VyY2UoKS5zYW1lKGVkZ2UudGFyZ2V0KCkpKSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KSxcbiAgaW5kZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBlZGdlKSB7XG4gICAgaWYgKGVkZ2UudGFyZ2V0KCkuc2FtZShub2RlKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSksXG4gIG91dGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS5zb3VyY2UoKS5zYW1lKG5vZGUpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KVxufSk7XG5cbmZ1bmN0aW9uIGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKGRlZ3JlZUZuLCBjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgIHZhciByZXQ7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIGRlZ3JlZSA9IGVsZVtkZWdyZWVGbl0oaW5jbHVkZUxvb3BzKTtcblxuICAgICAgaWYgKGRlZ3JlZSAhPT0gdW5kZWZpbmVkICYmIChyZXQgPT09IHVuZGVmaW5lZCB8fCBjYWxsYmFjayhkZWdyZWUsIHJldCkpKSB7XG4gICAgICAgIHJldCA9IGRlZ3JlZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuXG5leHRlbmQoZWxlc2ZuJGksIHtcbiAgbWluRGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG4gIG1heERlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2RlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pLFxuICBtaW5JbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2luZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG4gIG1heEluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtYXgpIHtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9KSxcbiAgbWluT3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWluKSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG4gIG1heE91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pXG59KTtcbmV4dGVuZChlbGVzZm4kaSwge1xuICB0b3RhbERlZ3JlZTogZnVuY3Rpb24gdG90YWxEZWdyZWUoaW5jbHVkZUxvb3BzKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbCArPSBub2Rlc1tpXS5kZWdyZWUoaW5jbHVkZUxvb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cbn0pO1xuXG52YXIgZm4kMiwgZWxlc2ZuJGo7XG5cbnZhciBiZWZvcmVQb3NpdGlvblNldCA9IGZ1bmN0aW9uIGJlZm9yZVBvc2l0aW9uU2V0KGVsZXMsIG5ld1Bvcywgc2lsZW50KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgaWYgKCFlbGUubG9ja2VkKCkpIHtcbiAgICAgIHZhciBvbGRQb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB2YXIgZGVsdGEgPSB7XG4gICAgICAgIHg6IG5ld1Bvcy54ICE9IG51bGwgPyBuZXdQb3MueCAtIG9sZFBvcy54IDogMCxcbiAgICAgICAgeTogbmV3UG9zLnkgIT0gbnVsbCA/IG5ld1Bvcy55IC0gb2xkUG9zLnkgOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoZWxlLmlzUGFyZW50KCkgJiYgIShkZWx0YS54ID09PSAwICYmIGRlbHRhLnkgPT09IDApKSB7XG4gICAgICAgIGVsZS5jaGlsZHJlbigpLnNoaWZ0KGRlbHRhLCBzaWxlbnQpO1xuICAgICAgfVxuXG4gICAgICBlbGUuc2hpZnRDYWNoZWRCb3VuZGluZ0JveChkZWx0YSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcG9zaXRpb25EZWYgPSB7XG4gIGZpZWxkOiAncG9zaXRpb24nLFxuICBiaW5kaW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICBzZXR0aW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICB0cmlnZ2VyRm5OYW1lOiAnZW1pdEFuZE5vdGlmeScsXG4gIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgdmFsaWRLZXlzOiBbJ3gnLCAneSddLFxuICBiZWZvcmVHZXQ6IGZ1bmN0aW9uIGJlZm9yZUdldChlbGUpIHtcbiAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgfSxcbiAgYmVmb3JlU2V0OiBmdW5jdGlvbiBiZWZvcmVTZXQoZWxlcywgbmV3UG9zKSB7XG4gICAgYmVmb3JlUG9zaXRpb25TZXQoZWxlcywgbmV3UG9zLCBmYWxzZSk7XG4gIH0sXG4gIG9uU2V0OiBmdW5jdGlvbiBvblNldChlbGVzKSB7XG4gICAgZWxlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgfSxcbiAgY2FuU2V0OiBmdW5jdGlvbiBjYW5TZXQoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gIH1cbn07XG5mbiQyID0gZWxlc2ZuJGogPSB7XG4gIHBvc2l0aW9uOiBkZWZpbmUkMy5kYXRhKHBvc2l0aW9uRGVmKSxcbiAgLy8gcG9zaXRpb24gYnV0IG5vIG5vdGlmaWNhdGlvbiB0byByZW5kZXJlclxuICBzaWxlbnRQb3NpdGlvbjogZGVmaW5lJDMuZGF0YShleHRlbmQoe30sIHBvc2l0aW9uRGVmLCB7XG4gICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgIGFsbG93R2V0dGluZzogZmFsc2UsXG4gICAgYmVmb3JlU2V0OiBmdW5jdGlvbiBiZWZvcmVTZXQoZWxlcywgbmV3UG9zKSB7XG4gICAgICBiZWZvcmVQb3NpdGlvblNldChlbGVzLCBuZXdQb3MsIHRydWUpO1xuICAgIH1cbiAgfSkpLFxuICBwb3NpdGlvbnM6IGZ1bmN0aW9uIHBvc2l0aW9ucyhwb3MsIHNpbGVudCkge1xuICAgIGlmIChwbGFpbk9iamVjdChwb3MpKSB7XG4gICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgIHRoaXMuc2lsZW50UG9zaXRpb24ocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ocG9zKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZuKHBvcykpIHtcbiAgICAgIHZhciBfZm4gPSBwb3M7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICB2YXIgX3BvcyA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoX3BvcyA9IF9mbihlbGUsIGkpKSB7XG4gICAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgICAgZWxlLnNpbGVudFBvc2l0aW9uKF9wb3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGUucG9zaXRpb24oX3Bvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHNpbGVudFBvc2l0aW9uczogZnVuY3Rpb24gc2lsZW50UG9zaXRpb25zKHBvcykge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucyhwb3MsIHRydWUpO1xuICB9LFxuICBzaGlmdDogZnVuY3Rpb24gc2hpZnQoZGltLCB2YWwsIHNpbGVudCkge1xuICAgIHZhciBkZWx0YTtcblxuICAgIGlmIChwbGFpbk9iamVjdChkaW0pKSB7XG4gICAgICBkZWx0YSA9IHtcbiAgICAgICAgeDogbnVtYmVyKGRpbS54KSA/IGRpbS54IDogMCxcbiAgICAgICAgeTogbnVtYmVyKGRpbS55KSA/IGRpbS55IDogMFxuICAgICAgfTtcbiAgICAgIHNpbGVudCA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhkaW0pICYmIG51bWJlcih2YWwpKSB7XG4gICAgICBkZWx0YSA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIGRlbHRhW2RpbV0gPSB2YWw7XG4gICAgfVxuXG4gICAgaWYgKGRlbHRhICE9IG51bGwpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBuZXdQb3MgPSB7XG4gICAgICAgICAgeDogcG9zLnggKyBkZWx0YS54LFxuICAgICAgICAgIHk6IHBvcy55ICsgZGVsdGEueVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgICBlbGUuc2lsZW50UG9zaXRpb24obmV3UG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGUucG9zaXRpb24obmV3UG9zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzaWxlbnRTaGlmdDogZnVuY3Rpb24gc2lsZW50U2hpZnQoZGltLCB2YWwpIHtcbiAgICBpZiAocGxhaW5PYmplY3QoZGltKSkge1xuICAgICAgdGhpcy5zaGlmdChkaW0sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKGRpbSkgJiYgbnVtYmVyKHZhbCkpIHtcbiAgICAgIHRoaXMuc2hpZnQoZGltLCB2YWwsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBnZXQvc2V0IHRoZSByZW5kZXJlZCAoaS5lLiBvbiBzY3JlZW4pIHBvc2l0b24gb2YgdGhlIGVsZW1lbnRcbiAgcmVuZGVyZWRQb3NpdGlvbjogZnVuY3Rpb24gcmVuZGVyZWRQb3NpdGlvbihkaW0sIHZhbCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHJwb3MgPSBwbGFpbk9iamVjdChkaW0pID8gZGltIDogdW5kZWZpbmVkO1xuICAgIHZhciBzZXR0aW5nID0gcnBvcyAhPT0gdW5kZWZpbmVkIHx8IHZhbCAhPT0gdW5kZWZpbmVkICYmIHN0cmluZyhkaW0pO1xuXG4gICAgaWYgKGVsZSAmJiBlbGUuaXNOb2RlKCkpIHtcbiAgICAgIC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgIGlmIChzZXR0aW5nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfZWxlID0gdGhpc1tpXTtcblxuICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgIF9lbGUucG9zaXRpb24oZGltLCAodmFsIC0gcGFuW2RpbV0pIC8gem9vbSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChycG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgX2VsZS5wb3NpdGlvbihyZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihycG9zLCB6b29tLCBwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgICBycG9zID0gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ocG9zLCB6b29tLCBwYW4pO1xuXG4gICAgICAgIGlmIChkaW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBycG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgcmV0dXJuIHJwb3NbZGltXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXNldHRpbmcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgLy8gZ2V0L3NldCB0aGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhcmVudFxuICByZWxhdGl2ZVBvc2l0aW9uOiBmdW5jdGlvbiByZWxhdGl2ZVBvc2l0aW9uKGRpbSwgdmFsKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBwcG9zID0gcGxhaW5PYmplY3QoZGltKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2V0dGluZyA9IHBwb3MgIT09IHVuZGVmaW5lZCB8fCB2YWwgIT09IHVuZGVmaW5lZCAmJiBzdHJpbmcoZGltKTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmIChlbGUgJiYgZWxlLmlzTm9kZSgpKSB7XG4gICAgICAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX2VsZTIgPSB0aGlzW2ldO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBoYXNDb21wb3VuZE5vZGVzID8gX2VsZTIucGFyZW50KCkgOiBudWxsO1xuICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgdmFyIHJlbGF0aXZlVG9QYXJlbnQgPSBoYXNQYXJlbnQ7XG5cbiAgICAgICAgICBpZiAoaGFzUGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9yaWdpbiA9IHJlbGF0aXZlVG9QYXJlbnQgPyBwYXJlbnQucG9zaXRpb24oKSA6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgIF9lbGUyLnBvc2l0aW9uKGRpbSwgdmFsICsgb3JpZ2luW2RpbV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgIF9lbGUyLnBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgeDogcHBvcy54ICsgb3JpZ2luLngsXG4gICAgICAgICAgICAgIHk6IHBwb3MueSArIG9yaWdpbi55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuXG4gICAgICAgIHZhciBfcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IGVsZS5wYXJlbnQoKSA6IG51bGw7XG5cbiAgICAgICAgdmFyIF9oYXNQYXJlbnQgPSBfcGFyZW50ICYmIF9wYXJlbnQubGVuZ3RoID4gMDtcblxuICAgICAgICB2YXIgX3JlbGF0aXZlVG9QYXJlbnQgPSBfaGFzUGFyZW50O1xuXG4gICAgICAgIGlmIChfaGFzUGFyZW50KSB7XG4gICAgICAgICAgX3BhcmVudCA9IF9wYXJlbnRbMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX29yaWdpbiA9IF9yZWxhdGl2ZVRvUGFyZW50ID8gX3BhcmVudC5wb3NpdGlvbigpIDoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuXG4gICAgICAgIHBwb3MgPSB7XG4gICAgICAgICAgeDogcG9zLnggLSBfb3JpZ2luLngsXG4gICAgICAgICAgeTogcG9zLnkgLSBfb3JpZ2luLnlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZGltID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICByZXR1cm4gcHBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgIHJldHVybiBwcG9zW2RpbV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFzZXR0aW5nKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH1cbn07IC8vIGFsaWFzZXNcblxuZm4kMi5tb2RlbFBvc2l0aW9uID0gZm4kMi5wb2ludCA9IGZuJDIucG9zaXRpb247XG5mbiQyLm1vZGVsUG9zaXRpb25zID0gZm4kMi5wb2ludHMgPSBmbiQyLnBvc2l0aW9ucztcbmZuJDIucmVuZGVyZWRQb2ludCA9IGZuJDIucmVuZGVyZWRQb3NpdGlvbjtcbmZuJDIucmVsYXRpdmVQb2ludCA9IGZuJDIucmVsYXRpdmVQb3NpdGlvbjtcbnZhciBwb3NpdGlvbiA9IGVsZXNmbiRqO1xuXG52YXIgZm4kMywgZWxlc2ZuJGs7XG5mbiQzID0gZWxlc2ZuJGsgPSB7fTtcblxuZWxlc2ZuJGsucmVuZGVyZWRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3gob3B0aW9ucyk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIHgxID0gYmIueDEgKiB6b29tICsgcGFuLng7XG4gIHZhciB4MiA9IGJiLngyICogem9vbSArIHBhbi54O1xuICB2YXIgeTEgPSBiYi55MSAqIHpvb20gKyBwYW4ueTtcbiAgdmFyIHkyID0gYmIueTIgKiB6b29tICsgcGFuLnk7XG4gIHJldHVybiB7XG4gICAgeDE6IHgxLFxuICAgIHgyOiB4MixcbiAgICB5MTogeTEsXG4gICAgeTI6IHkyLFxuICAgIHc6IHgyIC0geDEsXG4gICAgaDogeTIgLSB5MVxuICB9O1xufTtcblxuZWxlc2ZuJGsuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLmZvckVhY2hVcChmdW5jdGlvbiAoZWxlKSB7XG4gICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICBfcC5jb21wb3VuZEJvdW5kc0NsZWFuID0gZmFsc2U7XG4gICAgICBfcC5iYkNhY2hlID0gbnVsbDtcbiAgICAgIGVsZS5lbWl0QW5kTm90aWZ5KCdib3VuZHMnKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmVsZXNmbiRrLnVwZGF0ZUNvbXBvdW5kQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7IC8vIG5vdCBwb3NzaWJsZSB0byBkbyBvbiBub24tY29tcG91bmQgZ3JhcGhzIG9yIHdpdGggdGhlIHN0eWxlIGRpc2FibGVkXG5cbiAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBiYXRjaGluZyAtLSBidXQgYm91bmRzIHdpbGwgYmUgc3RhbGUgKG9yIG5vdCBleGlzdCB5ZXQpXG5cblxuICBpZiAoIWZvcmNlICYmIGN5LmJhdGNoaW5nKCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShwYXJlbnQpIHtcbiAgICBpZiAoIXBhcmVudC5pc1BhcmVudCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9wID0gcGFyZW50Ll9wcml2YXRlO1xuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbigpO1xuICAgIHZhciBpbmNsdWRlTGFiZWxzID0gcGFyZW50LnBzdHlsZSgnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnKS52YWx1ZSA9PT0gJ2luY2x1ZGUnO1xuICAgIHZhciBtaW4gPSB7XG4gICAgICB3aWR0aDoge1xuICAgICAgICB2YWw6IHBhcmVudC5wc3R5bGUoJ21pbi13aWR0aCcpLnBmVmFsdWUsXG4gICAgICAgIGxlZnQ6IHBhcmVudC5wc3R5bGUoJ21pbi13aWR0aC1iaWFzLWxlZnQnKSxcbiAgICAgICAgcmlnaHQ6IHBhcmVudC5wc3R5bGUoJ21pbi13aWR0aC1iaWFzLXJpZ2h0JylcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgdmFsOiBwYXJlbnQucHN0eWxlKCdtaW4taGVpZ2h0JykucGZWYWx1ZSxcbiAgICAgICAgdG9wOiBwYXJlbnQucHN0eWxlKCdtaW4taGVpZ2h0LWJpYXMtdG9wJyksXG4gICAgICAgIGJvdHRvbTogcGFyZW50LnBzdHlsZSgnbWluLWhlaWdodC1iaWFzLWJvdHRvbScpXG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgYmIgPSBjaGlsZHJlbi5ib3VuZGluZ0JveCh7XG4gICAgICBpbmNsdWRlTGFiZWxzOiBpbmNsdWRlTGFiZWxzLFxuICAgICAgaW5jbHVkZU92ZXJsYXlzOiBmYWxzZSxcbiAgICAgIC8vIHVwZGF0aW5nIHRoZSBjb21wb3VuZCBib3VuZHMgaGFwcGVucyBvdXRzaWRlIG9mIHRoZSByZWd1bGFyXG4gICAgICAvLyBjYWNoZSBjeWNsZSAoaS5lLiBiZWZvcmUgZmlyZWQgZXZlbnRzKVxuICAgICAgdXNlQ2FjaGU6IGZhbHNlXG4gICAgfSk7XG4gICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uOyAvLyBpZiBjaGlsZHJlbiB0YWtlIHVwIHplcm8gYXJlYSB0aGVuIGtlZXAgcG9zaXRpb24gYW5kIGZhbGwgYmFjayBvbiBzdHlsZXNoZWV0IHcvaFxuXG4gICAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCkge1xuICAgICAgYmIgPSB7XG4gICAgICAgIHc6IHBhcmVudC5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSxcbiAgICAgICAgaDogcGFyZW50LnBzdHlsZSgnaGVpZ2h0JykucGZWYWx1ZVxuICAgICAgfTtcbiAgICAgIGJiLngxID0gcG9zLnggLSBiYi53IC8gMjtcbiAgICAgIGJiLngyID0gcG9zLnggKyBiYi53IC8gMjtcbiAgICAgIGJiLnkxID0gcG9zLnkgLSBiYi5oIC8gMjtcbiAgICAgIGJiLnkyID0gcG9zLnkgKyBiYi5oIC8gMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlQmlhc1ZhbHVlcyhwcm9wRGlmZiwgcHJvcEJpYXMsIHByb3BCaWFzQ29tcGxlbWVudCkge1xuICAgICAgdmFyIGJpYXNEaWZmID0gMDtcbiAgICAgIHZhciBiaWFzQ29tcGxlbWVudERpZmYgPSAwO1xuICAgICAgdmFyIGJpYXNUb3RhbCA9IHByb3BCaWFzICsgcHJvcEJpYXNDb21wbGVtZW50O1xuXG4gICAgICBpZiAocHJvcERpZmYgPiAwICYmIGJpYXNUb3RhbCA+IDApIHtcbiAgICAgICAgYmlhc0RpZmYgPSBwcm9wQmlhcyAvIGJpYXNUb3RhbCAqIHByb3BEaWZmO1xuICAgICAgICBiaWFzQ29tcGxlbWVudERpZmYgPSBwcm9wQmlhc0NvbXBsZW1lbnQgLyBiaWFzVG90YWwgKiBwcm9wRGlmZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmlhc0RpZmY6IGJpYXNEaWZmLFxuICAgICAgICBiaWFzQ29tcGxlbWVudERpZmY6IGJpYXNDb21wbGVtZW50RGlmZlxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlUGFkZGluZ1ZhbHVlcyh3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nT2JqZWN0LCByZWxhdGl2ZVRvKSB7XG4gICAgICAvLyBBc3N1bWluZyBwZXJjZW50YWdlIGlzIG51bWJlciBmcm9tIDAgdG8gMVxuICAgICAgaWYgKHBhZGRpbmdPYmplY3QudW5pdHMgPT09ICclJykge1xuICAgICAgICBzd2l0Y2ggKHJlbGF0aXZlVG8pIHtcbiAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiAwO1xuXG4gICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHQgPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogaGVpZ2h0IDogMDtcblxuICAgICAgICAgIGNhc2UgJ2F2ZXJhZ2UnOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogKHdpZHRoICsgaGVpZ2h0KSAvIDIgOiAwO1xuXG4gICAgICAgICAgY2FzZSAnbWluJzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHdpZHRoID4gaGVpZ2h0ID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogaGVpZ2h0IDogcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiAwO1xuXG4gICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHdpZHRoID4gaGVpZ2h0ID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiAwO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhZGRpbmdPYmplY3QudW5pdHMgPT09ICdweCcpIHtcbiAgICAgICAgcmV0dXJuIHBhZGRpbmdPYmplY3QucGZWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsZWZ0VmFsID0gbWluLndpZHRoLmxlZnQudmFsdWU7XG5cbiAgICBpZiAobWluLndpZHRoLmxlZnQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDApIHtcbiAgICAgIGxlZnRWYWwgPSBsZWZ0VmFsICogMTAwIC8gbWluLndpZHRoLnZhbDtcbiAgICB9XG5cbiAgICB2YXIgcmlnaHRWYWwgPSBtaW4ud2lkdGgucmlnaHQudmFsdWU7XG5cbiAgICBpZiAobWluLndpZHRoLnJpZ2h0LnVuaXRzID09PSAncHgnICYmIG1pbi53aWR0aC52YWwgPiAwKSB7XG4gICAgICByaWdodFZhbCA9IHJpZ2h0VmFsICogMTAwIC8gbWluLndpZHRoLnZhbDtcbiAgICB9XG5cbiAgICB2YXIgdG9wVmFsID0gbWluLmhlaWdodC50b3AudmFsdWU7XG5cbiAgICBpZiAobWluLmhlaWdodC50b3AudW5pdHMgPT09ICdweCcgJiYgbWluLmhlaWdodC52YWwgPiAwKSB7XG4gICAgICB0b3BWYWwgPSB0b3BWYWwgKiAxMDAgLyBtaW4uaGVpZ2h0LnZhbDtcbiAgICB9XG5cbiAgICB2YXIgYm90dG9tVmFsID0gbWluLmhlaWdodC5ib3R0b20udmFsdWU7XG5cbiAgICBpZiAobWluLmhlaWdodC5ib3R0b20udW5pdHMgPT09ICdweCcgJiYgbWluLmhlaWdodC52YWwgPiAwKSB7XG4gICAgICBib3R0b21WYWwgPSBib3R0b21WYWwgKiAxMDAgLyBtaW4uaGVpZ2h0LnZhbDtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGhCaWFzRGlmZnMgPSBjb21wdXRlQmlhc1ZhbHVlcyhtaW4ud2lkdGgudmFsIC0gYmIudywgbGVmdFZhbCwgcmlnaHRWYWwpO1xuICAgIHZhciBkaWZmTGVmdCA9IHdpZHRoQmlhc0RpZmZzLmJpYXNEaWZmO1xuICAgIHZhciBkaWZmUmlnaHQgPSB3aWR0aEJpYXNEaWZmcy5iaWFzQ29tcGxlbWVudERpZmY7XG4gICAgdmFyIGhlaWdodEJpYXNEaWZmcyA9IGNvbXB1dGVCaWFzVmFsdWVzKG1pbi5oZWlnaHQudmFsIC0gYmIuaCwgdG9wVmFsLCBib3R0b21WYWwpO1xuICAgIHZhciBkaWZmVG9wID0gaGVpZ2h0Qmlhc0RpZmZzLmJpYXNEaWZmO1xuICAgIHZhciBkaWZmQm90dG9tID0gaGVpZ2h0Qmlhc0RpZmZzLmJpYXNDb21wbGVtZW50RGlmZjtcbiAgICBfcC5hdXRvUGFkZGluZyA9IGNvbXB1dGVQYWRkaW5nVmFsdWVzKGJiLncsIGJiLmgsIHBhcmVudC5wc3R5bGUoJ3BhZGRpbmcnKSwgcGFyZW50LnBzdHlsZSgncGFkZGluZy1yZWxhdGl2ZS10bycpLnZhbHVlKTtcbiAgICBfcC5hdXRvV2lkdGggPSBNYXRoLm1heChiYi53LCBtaW4ud2lkdGgudmFsKTtcbiAgICBwb3MueCA9ICgtZGlmZkxlZnQgKyBiYi54MSArIGJiLngyICsgZGlmZlJpZ2h0KSAvIDI7XG4gICAgX3AuYXV0b0hlaWdodCA9IE1hdGgubWF4KGJiLmgsIG1pbi5oZWlnaHQudmFsKTtcbiAgICBwb3MueSA9ICgtZGlmZlRvcCArIGJiLnkxICsgYmIueTIgKyBkaWZmQm90dG9tKSAvIDI7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgICBpZiAoIV9wLmNvbXBvdW5kQm91bmRzQ2xlYW4pIHtcbiAgICAgIHVwZGF0ZShlbGUpO1xuXG4gICAgICBpZiAoIWN5LmJhdGNoaW5nKCkpIHtcbiAgICAgICAgX3AuY29tcG91bmRCb3VuZHNDbGVhbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgbm9uaW5mID0gZnVuY3Rpb24gbm9uaW5mKHgpIHtcbiAgaWYgKHggPT09IEluZmluaXR5IHx8IHggPT09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHg7XG59O1xuXG52YXIgdXBkYXRlQm91bmRzID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzKGIsIHgxLCB5MSwgeDIsIHkyKSB7XG4gIC8vIGRvbid0IHVwZGF0ZSB3aXRoIHplcm8gYXJlYSBib3hlc1xuICBpZiAoeDIgLSB4MSA9PT0gMCB8fCB5MiAtIHkxID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGRvbid0IHVwZGF0ZSB3aXRoIG51bGwgZGltXG5cblxuICBpZiAoeDEgPT0gbnVsbCB8fCB5MSA9PSBudWxsIHx8IHgyID09IG51bGwgfHwgeTIgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGIueDEgPSB4MSA8IGIueDEgPyB4MSA6IGIueDE7XG4gIGIueDIgPSB4MiA+IGIueDIgPyB4MiA6IGIueDI7XG4gIGIueTEgPSB5MSA8IGIueTEgPyB5MSA6IGIueTE7XG4gIGIueTIgPSB5MiA+IGIueTIgPyB5MiA6IGIueTI7XG4gIGIudyA9IGIueDIgLSBiLngxO1xuICBiLmggPSBiLnkyIC0gYi55MTtcbn07XG5cbnZhciB1cGRhdGVCb3VuZHNGcm9tQm94ID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUJveChiLCBiMikge1xuICBpZiAoYjIgPT0gbnVsbCkge1xuICAgIHJldHVybiBiO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZUJvdW5kcyhiLCBiMi54MSwgYjIueTEsIGIyLngyLCBiMi55Mik7XG59O1xuXG52YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHByZWZpeGVkUHJvcGVydHkob2JqLCBmaWVsZCwgcHJlZml4KSB7XG4gIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgZmllbGQsIHByZWZpeCk7XG59O1xuXG52YXIgdXBkYXRlQm91bmRzRnJvbUFycm93ID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCBwcmVmaXgpIHtcbiAgaWYgKGVsZS5jeSgpLmhlYWRsZXNzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBoYWxmQXJXID0gcnN0eWxlLmFycm93V2lkdGggLyAyO1xuICB2YXIgYXJyb3dUeXBlID0gZWxlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LXNoYXBlJykudmFsdWU7XG4gIHZhciB4O1xuICB2YXIgeTtcblxuICBpZiAoYXJyb3dUeXBlICE9PSAnbm9uZScpIHtcbiAgICBpZiAocHJlZml4ID09PSAnc291cmNlJykge1xuICAgICAgeCA9IHJzdHlsZS5zcmNYO1xuICAgICAgeSA9IHJzdHlsZS5zcmNZO1xuICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSAndGFyZ2V0Jykge1xuICAgICAgeCA9IHJzdHlsZS50Z3RYO1xuICAgICAgeSA9IHJzdHlsZS50Z3RZO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gcnN0eWxlLm1pZFg7XG4gICAgICB5ID0gcnN0eWxlLm1pZFk7XG4gICAgfSAvLyBhbHdheXMgc3RvcmUgdGhlIGluZGl2aWR1YWwgYXJyb3cgYm91bmRzXG5cblxuICAgIHZhciBiYnMgPSBfcC5hcnJvd0JvdW5kcyA9IF9wLmFycm93Qm91bmRzIHx8IHt9O1xuICAgIHZhciBiYiA9IGJic1twcmVmaXhdID0gYmJzW3ByZWZpeF0gfHwge307XG4gICAgYmIueDEgPSB4IC0gaGFsZkFyVztcbiAgICBiYi55MSA9IHkgLSBoYWxmQXJXO1xuICAgIGJiLngyID0geCArIGhhbGZBclc7XG4gICAgYmIueTIgPSB5ICsgaGFsZkFyVztcbiAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgICBleHBhbmRCb3VuZGluZ0JveChiYiwgMSk7XG4gICAgdXBkYXRlQm91bmRzKGJvdW5kcywgYmIueDEsIGJiLnkxLCBiYi54MiwgYmIueTIpO1xuICB9XG59O1xuXG52YXIgdXBkYXRlQm91bmRzRnJvbUxhYmVsID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCBwcmVmaXgpIHtcbiAgaWYgKGVsZS5jeSgpLmhlYWRsZXNzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJlZml4RGFzaDtcblxuICBpZiAocHJlZml4KSB7XG4gICAgcHJlZml4RGFzaCA9IHByZWZpeCArICctJztcbiAgfSBlbHNlIHtcbiAgICBwcmVmaXhEYXNoID0gJyc7XG4gIH1cblxuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICdsYWJlbCcpLnN0clZhbHVlO1xuXG4gIGlmIChsYWJlbCkge1xuICAgIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpO1xuICAgIHZhciB2YWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpO1xuICAgIHZhciBsYWJlbFdpZHRoID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFdpZHRoJywgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxIZWlnaHQgPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxYID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFgnLCBwcmVmaXgpO1xuICAgIHZhciBsYWJlbFkgPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgdmFyIG1hcmdpblggPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWU7XG4gICAgdmFyIG1hcmdpblkgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgcm90YXRpb24gPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1yb3RhdGlvbicpO1xuICAgIHZhciBvdXRsaW5lV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgaGFsZkJvcmRlcldpZHRoID0gYm9yZGVyV2lkdGggLyAyO1xuICAgIHZhciBwYWRkaW5nID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnKS5wZlZhbHVlO1xuICAgIHZhciBsaCA9IGxhYmVsSGVpZ2h0O1xuICAgIHZhciBsdyA9IGxhYmVsV2lkdGg7XG4gICAgdmFyIGx3XzIgPSBsdyAvIDI7XG4gICAgdmFyIGxoXzIgPSBsaCAvIDI7XG4gICAgdmFyIGx4MSwgbHgyLCBseTEsIGx5MjtcblxuICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICBseDIgPSBsYWJlbFggKyBsd18yO1xuICAgICAgbHkxID0gbGFiZWxZIC0gbGhfMjtcbiAgICAgIGx5MiA9IGxhYmVsWSArIGxoXzI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoaGFsaWduLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3O1xuICAgICAgICAgIGx4MiA9IGxhYmVsWDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICAgICAgbHgyID0gbGFiZWxYICsgbHdfMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbHgxID0gbGFiZWxYO1xuICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHZhbGlnbi52YWx1ZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoO1xuICAgICAgICAgIGx5MiA9IGxhYmVsWTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoXzI7XG4gICAgICAgICAgbHkyID0gbGFiZWxZICsgbGhfMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWTtcbiAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIHNoaWZ0IGJ5IG1hcmdpbiBhbmQgZXhwYW5kIGJ5IG91dGxpbmUgYW5kIGJvcmRlclxuXG5cbiAgICBseDEgKz0gbWFyZ2luWCAtIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSAtIHBhZGRpbmc7XG4gICAgbHgyICs9IG1hcmdpblggKyBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgKyBwYWRkaW5nO1xuICAgIGx5MSArPSBtYXJnaW5ZIC0gTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpIC0gcGFkZGluZztcbiAgICBseTIgKz0gbWFyZ2luWSArIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSArIHBhZGRpbmc7IC8vIGFsd2F5cyBzdG9yZSB0aGUgdW5yb3RhdGVkIGxhYmVsIGJvdW5kcyBzZXBhcmF0ZWx5XG5cbiAgICB2YXIgYmJQcmVmaXggPSBwcmVmaXggfHwgJ21haW4nO1xuICAgIHZhciBiYnMgPSBfcC5sYWJlbEJvdW5kcztcbiAgICB2YXIgYmIgPSBiYnNbYmJQcmVmaXhdID0gYmJzW2JiUHJlZml4XSB8fCB7fTtcbiAgICBiYi54MSA9IGx4MTtcbiAgICBiYi55MSA9IGx5MTtcbiAgICBiYi54MiA9IGx4MjtcbiAgICBiYi55MiA9IGx5MjtcbiAgICBiYi53ID0gbHgyIC0gbHgxO1xuICAgIGJiLmggPSBseTIgLSBseTE7XG4gICAgZXhwYW5kQm91bmRpbmdCb3goYmIsIDEpOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG5cbiAgICB2YXIgaXNBdXRvcm90YXRlID0gaXNFZGdlICYmIHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZSc7XG4gICAgdmFyIGlzUGZWYWx1ZSA9IHJvdGF0aW9uLnBmVmFsdWUgIT0gbnVsbCAmJiByb3RhdGlvbi5wZlZhbHVlICE9PSAwO1xuXG4gICAgaWYgKGlzQXV0b3JvdGF0ZSB8fCBpc1BmVmFsdWUpIHtcbiAgICAgIHZhciB0aGV0YSA9IGlzQXV0b3JvdGF0ZSA/IHByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxBbmdsZScsIHByZWZpeCkgOiByb3RhdGlvbi5wZlZhbHVlO1xuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih0aGV0YSk7IC8vIHJvdGF0aW9uIHBvaW50IChkZWZhdWx0IHZhbHVlIGZvciBjZW50ZXItY2VudGVyKVxuXG4gICAgICB2YXIgeG8gPSAobHgxICsgbHgyKSAvIDI7XG4gICAgICB2YXIgeW8gPSAobHkxICsgbHkyKSAvIDI7XG5cbiAgICAgIGlmICghaXNFZGdlKSB7XG4gICAgICAgIHN3aXRjaCAoaGFsaWduLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICB4byA9IGx4MjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgeG8gPSBseDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodmFsaWduLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIHlvID0gbHkyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgeW8gPSBseTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24gcm90YXRlKHgsIHkpIHtcbiAgICAgICAgeCA9IHggLSB4bztcbiAgICAgICAgeSA9IHkgLSB5bztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4ICogY29zIC0geSAqIHNpbiArIHhvLFxuICAgICAgICAgIHk6IHggKiBzaW4gKyB5ICogY29zICsgeW9cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBweDF5MSA9IHJvdGF0ZShseDEsIGx5MSk7XG4gICAgICB2YXIgcHgxeTIgPSByb3RhdGUobHgxLCBseTIpO1xuICAgICAgdmFyIHB4MnkxID0gcm90YXRlKGx4MiwgbHkxKTtcbiAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZShseDIsIGx5Mik7XG4gICAgICBseDEgPSBNYXRoLm1pbihweDF5MS54LCBweDF5Mi54LCBweDJ5MS54LCBweDJ5Mi54KTtcbiAgICAgIGx4MiA9IE1hdGgubWF4KHB4MXkxLngsIHB4MXkyLngsIHB4MnkxLngsIHB4MnkyLngpO1xuICAgICAgbHkxID0gTWF0aC5taW4ocHgxeTEueSwgcHgxeTIueSwgcHgyeTEueSwgcHgyeTIueSk7XG4gICAgICBseTIgPSBNYXRoLm1heChweDF5MS55LCBweDF5Mi55LCBweDJ5MS55LCBweDJ5Mi55KTtcbiAgICB9XG5cbiAgICB2YXIgYmJQcmVmaXhSb3QgPSBiYlByZWZpeCArICdSb3QnO1xuICAgIHZhciBiYlJvdCA9IGJic1tiYlByZWZpeFJvdF0gPSBiYnNbYmJQcmVmaXhSb3RdIHx8IHt9O1xuICAgIGJiUm90LngxID0gbHgxO1xuICAgIGJiUm90LnkxID0gbHkxO1xuICAgIGJiUm90LngyID0gbHgyO1xuICAgIGJiUm90LnkyID0gbHkyO1xuICAgIGJiUm90LncgPSBseDIgLSBseDE7XG4gICAgYmJSb3QuaCA9IGx5MiAtIGx5MTtcbiAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBseDEsIGx5MSwgbHgyLCBseTIpO1xuICAgIHVwZGF0ZUJvdW5kcyhfcC5sYWJlbEJvdW5kcy5hbGwsIGx4MSwgbHkxLCBseDIsIGx5Mik7XG4gIH1cblxuICByZXR1cm4gYm91bmRzO1xufTsgLy8gZ2V0IHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGVsZW1lbnRzIChpbiByYXcgbW9kZWwgcG9zaXRpb24pXG5cblxudmFyIGJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94SW1wbChlbGUsIG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG4gIHZhciBoZWFkbGVzcyA9IGN5LmhlYWRsZXNzKCk7XG4gIHZhciBib3VuZHMgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgaXNOb2RlID0gZWxlLmlzTm9kZSgpO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIgZXgxLCBleDIsIGV5MSwgZXkyOyAvLyBleHRyZW1hIG9mIGJvZHkgLyBsaW5lc1xuXG4gIHZhciB4LCB5OyAvLyBub2RlIHBvc1xuXG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBtYW51YWxFeHBhbnNpb24gPSBpc05vZGUgJiYgc3R5bGVFbmFibGVkID8gZWxlLnBzdHlsZSgnYm91bmRzLWV4cGFuc2lvbicpLnBmVmFsdWUgOiBbMF07IC8vIG11c3QgdXNlIGBkaXNwbGF5YCBwcm9wIG9ubHksIGFzIHJlYWRpbmcgYGNvbXBvdW5kLndpZHRoKClgIGNhdXNlcyByZWN1cnNpb25cbiAgLy8gKG90aGVyIGZhY3RvcnMgbGlrZSB3aWR0aCB2YWx1ZXMgd2lsbCBiZSBjb25zaWRlcmVkIGxhdGVyIGluIHRoaXMgZnVuY3Rpb24gYW55d2F5KVxuXG4gIHZhciBpc0Rpc3BsYXllZCA9IGZ1bmN0aW9uIGlzRGlzcGxheWVkKGVsZSkge1xuICAgIHJldHVybiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgIT09ICdub25lJztcbiAgfTtcblxuICB2YXIgZGlzcGxheWVkID0gIXN0eWxlRW5hYmxlZCB8fCBpc0Rpc3BsYXllZChlbGUpIC8vIG11c3QgdGFrZSBpbnRvIGFjY291bnQgY29ubmVjdGVkIG5vZGVzIGIvYyBvZiBpbXBsaWNpdCBlZGdlIGhpZGluZyBvbiBkaXNwbGF5Om5vbmUgbm9kZVxuICAmJiAoIWlzRWRnZSB8fCBpc0Rpc3BsYXllZChlbGUuc291cmNlKCkpICYmIGlzRGlzcGxheWVkKGVsZS50YXJnZXQoKSkpO1xuXG4gIGlmIChkaXNwbGF5ZWQpIHtcbiAgICAvLyBkaXNwbGF5ZWQgc3VmZmljZXMsIHNpbmNlIHdlIHdpbGwgZmluZCB6ZXJvIGFyZWEgZWxlcyBhbnl3YXlcbiAgICB2YXIgb3ZlcmxheU9wYWNpdHkgPSAwO1xuICAgIHZhciBvdmVybGF5UGFkZGluZyA9IDA7XG5cbiAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZU92ZXJsYXlzKSB7XG4gICAgICBvdmVybGF5T3BhY2l0eSA9IGVsZS5wc3R5bGUoJ292ZXJsYXktb3BhY2l0eScpLnZhbHVlO1xuXG4gICAgICBpZiAob3ZlcmxheU9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgb3ZlcmxheVBhZGRpbmcgPSBlbGUucHN0eWxlKCdvdmVybGF5LXBhZGRpbmcnKS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdyA9IDA7XG4gICAgdmFyIHdIYWxmID0gMDtcblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHcgPSBlbGUucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgICB3SGFsZiA9IHcgLyAyO1xuICAgIH1cblxuICAgIGlmIChpc05vZGUgJiYgb3B0aW9ucy5pbmNsdWRlTm9kZXMpIHtcbiAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgIHggPSBwb3MueDtcbiAgICAgIHkgPSBwb3MueTtcblxuICAgICAgdmFyIF93ID0gZWxlLm91dGVyV2lkdGgoKTtcblxuICAgICAgdmFyIGhhbGZXID0gX3cgLyAyO1xuICAgICAgdmFyIGggPSBlbGUub3V0ZXJIZWlnaHQoKTtcbiAgICAgIHZhciBoYWxmSCA9IGggLyAyOyAvLyBoYW5kbGUgbm9kZSBkaW1lbnNpb25zXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgIGV4MSA9IHggLSBoYWxmVztcbiAgICAgIGV4MiA9IHggKyBoYWxmVztcbiAgICAgIGV5MSA9IHkgLSBoYWxmSDtcbiAgICAgIGV5MiA9IHkgKyBoYWxmSDtcbiAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgfSBlbHNlIGlmIChpc0VkZ2UgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMpIHtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgIWhlYWRsZXNzKSB7XG4gICAgICAgIHZhciBjdXJ2ZVN0eWxlID0gZWxlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS5zdHJWYWx1ZTsgLy8gaGFuZGxlIGVkZ2UgZGltZW5zaW9ucyAocm91Z2ggYm94IGVzdGltYXRlKVxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgZXgxID0gTWF0aC5taW4ocnN0eWxlLnNyY1gsIHJzdHlsZS5taWRYLCByc3R5bGUudGd0WCk7XG4gICAgICAgIGV4MiA9IE1hdGgubWF4KHJzdHlsZS5zcmNYLCByc3R5bGUubWlkWCwgcnN0eWxlLnRndFgpO1xuICAgICAgICBleTEgPSBNYXRoLm1pbihyc3R5bGUuc3JjWSwgcnN0eWxlLm1pZFksIHJzdHlsZS50Z3RZKTtcbiAgICAgICAgZXkyID0gTWF0aC5tYXgocnN0eWxlLnNyY1ksIHJzdHlsZS5taWRZLCByc3R5bGUudGd0WSk7IC8vIHRha2UgaW50byBhY2NvdW50IGVkZ2Ugd2lkdGhcblxuICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICBleTIgKz0gd0hhbGY7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7IC8vIHByZWNpc2UgZWRnZXNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgICAgdmFyIGhwdHMgPSByc3R5bGUuaGF5c3RhY2tQdHM7XG5cbiAgICAgICAgICBpZiAoaHB0cyAmJiBocHRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgZXgxID0gaHB0c1swXS54O1xuICAgICAgICAgICAgZXkxID0gaHB0c1swXS55O1xuICAgICAgICAgICAgZXgyID0gaHB0c1sxXS54O1xuICAgICAgICAgICAgZXkyID0gaHB0c1sxXS55O1xuXG4gICAgICAgICAgICBpZiAoZXgxID4gZXgyKSB7XG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gZXgxO1xuICAgICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleTEgPiBleTIpIHtcbiAgICAgICAgICAgICAgdmFyIF90ZW1wID0gZXkxO1xuICAgICAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgICAgIGV5MiA9IF90ZW1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEgLSB3SGFsZiwgZXkxIC0gd0hhbGYsIGV4MiArIHdIYWxmLCBleTIgKyB3SGFsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnZlU3R5bGUgPT09ICdiZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnIHx8IGN1cnZlU3R5bGUgPT09ICd0YXhpJykge1xuICAgICAgICAgIHZhciBwdHM7XG5cbiAgICAgICAgICBzd2l0Y2ggKGN1cnZlU3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICAgICAgICBjYXNlICd1bmJ1bmRsZWQtYmV6aWVyJzpcbiAgICAgICAgICAgICAgcHRzID0gcnN0eWxlLmJlemllclB0cztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgICAgICAgIGNhc2UgJ3RheGknOlxuICAgICAgICAgICAgICBwdHMgPSByc3R5bGUubGluZVB0cztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHB0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgcHQgPSBwdHNbal07XG4gICAgICAgICAgICAgIGV4MSA9IHB0LnggLSB3SGFsZjtcbiAgICAgICAgICAgICAgZXgyID0gcHQueCArIHdIYWxmO1xuICAgICAgICAgICAgICBleTEgPSBwdC55IC0gd0hhbGY7XG4gICAgICAgICAgICAgIGV5MiA9IHB0LnkgKyB3SGFsZjtcbiAgICAgICAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gYmV6aWVyLWxpa2Ugb3Igc2VnbWVudC1saWtlIGVkZ2VcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaGVhZGxlc3Mgb3Igc3R5bGUgZGlzYWJsZWRcbiAgICAgICAgLy8gZmFsbGJhY2sgb24gc291cmNlIGFuZCB0YXJnZXQgcG9zaXRpb25zXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICB2YXIgbjEgPSBlbGUuc291cmNlKCk7XG4gICAgICAgIHZhciBuMXBvcyA9IG4xLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBuMiA9IGVsZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIG4ycG9zID0gbjIucG9zaXRpb24oKTtcbiAgICAgICAgZXgxID0gbjFwb3MueDtcbiAgICAgICAgZXgyID0gbjJwb3MueDtcbiAgICAgICAgZXkxID0gbjFwb3MueTtcbiAgICAgICAgZXkyID0gbjJwb3MueTtcblxuICAgICAgICBpZiAoZXgxID4gZXgyKSB7XG4gICAgICAgICAgdmFyIF90ZW1wMiA9IGV4MTtcbiAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgZXgyID0gX3RlbXAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV5MSA+IGV5Mikge1xuICAgICAgICAgIHZhciBfdGVtcDMgPSBleTE7XG4gICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgIGV5MiA9IF90ZW1wMztcbiAgICAgICAgfSAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG5cblxuICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICBleTIgKz0gd0hhbGY7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgICB9IC8vIGhlYWRsZXNzIG9yIHN0eWxlIGRpc2FibGVkXG5cbiAgICB9IC8vIGVkZ2VzXG4gICAgLy8gaGFuZGxlIGVkZ2UgYXJyb3cgc2l6ZVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVFZGdlcyAmJiBpc0VkZ2UpIHtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ21pZC1zb3VyY2UnKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ21pZC10YXJnZXQnKTtcbiAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ3NvdXJjZScpO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAndGFyZ2V0Jyk7XG4gICAgfSAvLyBnaG9zdFxuICAgIC8vLy8vLy8vXG5cblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHZhciBnaG9zdCA9IGVsZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gICAgICBpZiAoZ2hvc3QpIHtcbiAgICAgICAgdmFyIGd4ID0gZWxlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXgnKS5wZlZhbHVlO1xuICAgICAgICB2YXIgZ3kgPSBlbGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteScpLnBmVmFsdWU7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGJvdW5kcy54MSArIGd4LCBib3VuZHMueTEgKyBneSwgYm91bmRzLngyICsgZ3gsIGJvdW5kcy55MiArIGd5KTtcbiAgICAgIH1cbiAgICB9IC8vIGFsd2F5cyBzdG9yZSB0aGUgYm9keSBib3VuZHMgc2VwYXJhdGVseSBmcm9tIHRoZSBsYWJlbHNcblxuXG4gICAgdmFyIGJiQm9keSA9IF9wLmJvZHlCb3VuZHMgPSBfcC5ib2R5Qm91bmRzIHx8IHt9O1xuICAgIGFzc2lnbkJvdW5kaW5nQm94KGJiQm9keSwgYm91bmRzKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiQm9keSwgbWFudWFsRXhwYW5zaW9uKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveChiYkJvZHksIDEpOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG4gICAgLy8gb3ZlcmxheVxuICAgIC8vLy8vLy8vLy9cblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIGV4MSA9IGJvdW5kcy54MTtcbiAgICAgIGV4MiA9IGJvdW5kcy54MjtcbiAgICAgIGV5MSA9IGJvdW5kcy55MTtcbiAgICAgIGV5MiA9IGJvdW5kcy55MjtcbiAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSAtIG92ZXJsYXlQYWRkaW5nLCBleTEgLSBvdmVybGF5UGFkZGluZywgZXgyICsgb3ZlcmxheVBhZGRpbmcsIGV5MiArIG92ZXJsYXlQYWRkaW5nKTtcbiAgICB9IC8vIGFsd2F5cyBzdG9yZSB0aGUgYm9keSBib3VuZHMgc2VwYXJhdGVseSBmcm9tIHRoZSBsYWJlbHNcblxuXG4gICAgdmFyIGJiT3ZlcmxheSA9IF9wLm92ZXJsYXlCb3VuZHMgPSBfcC5vdmVybGF5Qm91bmRzIHx8IHt9O1xuICAgIGFzc2lnbkJvdW5kaW5nQm94KGJiT3ZlcmxheSwgYm91bmRzKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiT3ZlcmxheSwgbWFudWFsRXhwYW5zaW9uKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveChiYk92ZXJsYXksIDEpOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG4gICAgLy8gaGFuZGxlIGxhYmVsIGRpbWVuc2lvbnNcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgdmFyIGJiTGFiZWxzID0gX3AubGFiZWxCb3VuZHMgPSBfcC5sYWJlbEJvdW5kcyB8fCB7fTtcblxuICAgIGlmIChiYkxhYmVscy5hbGwgIT0gbnVsbCkge1xuICAgICAgY2xlYXJCb3VuZGluZ0JveChiYkxhYmVscy5hbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYkxhYmVscy5hbGwgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZUxhYmVscykge1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZU1haW5MYWJlbHMpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRWRnZSkge1xuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlU291cmNlTGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCAnc291cmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlVGFyZ2V0TGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCAndGFyZ2V0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHN0eWxlIGVuYWJsZWQgZm9yIGxhYmVsc1xuXG4gIH0gLy8gaWYgZGlzcGxheWVkXG5cblxuICBib3VuZHMueDEgPSBub25pbmYoYm91bmRzLngxKTtcbiAgYm91bmRzLnkxID0gbm9uaW5mKGJvdW5kcy55MSk7XG4gIGJvdW5kcy54MiA9IG5vbmluZihib3VuZHMueDIpO1xuICBib3VuZHMueTIgPSBub25pbmYoYm91bmRzLnkyKTtcbiAgYm91bmRzLncgPSBub25pbmYoYm91bmRzLngyIC0gYm91bmRzLngxKTtcbiAgYm91bmRzLmggPSBub25pbmYoYm91bmRzLnkyIC0gYm91bmRzLnkxKTtcblxuICBpZiAoYm91bmRzLncgPiAwICYmIGJvdW5kcy5oID4gMCAmJiBkaXNwbGF5ZWQpIHtcbiAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJvdW5kcywgbWFudWFsRXhwYW5zaW9uKTsgLy8gZXhwYW5kIGJvdW5kcyBieSAxIGJlY2F1c2UgYW50aWFsaWFzaW5nIGNhbiBpbmNyZWFzZSB0aGUgdmlzdWFsL2VmZmVjdGl2ZSBzaXplIGJ5IDEgb24gYWxsIHNpZGVzXG5cbiAgICBleHBhbmRCb3VuZGluZ0JveChib3VuZHMsIDEpO1xuICB9XG5cbiAgcmV0dXJuIGJvdW5kcztcbn07XG5cbnZhciBnZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkob3B0cykge1xuICB2YXIgaSA9IDA7XG5cbiAgdmFyIHRmID0gZnVuY3Rpb24gdGYodmFsKSB7XG4gICAgcmV0dXJuICh2YWwgPyAxIDogMCkgPDwgaSsrO1xuICB9O1xuXG4gIHZhciBrZXkgPSAwO1xuICBrZXkgKz0gdGYob3B0cy5pbmN1ZGVOb2Rlcyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVFZGdlcyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVMYWJlbHMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlTWFpbkxhYmVscyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVTb3VyY2VMYWJlbHMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlVGFyZ2V0TGFiZWxzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZU92ZXJsYXlzKTtcbiAgcmV0dXJuIGtleTtcbn07XG5cbnZhciBnZXRCb3VuZGluZ0JveFBvc0tleSA9IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94UG9zS2V5KGVsZSkge1xuICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgdmFyIHAxID0gZWxlLnNvdXJjZSgpLnBvc2l0aW9uKCk7XG4gICAgdmFyIHAyID0gZWxlLnRhcmdldCgpLnBvc2l0aW9uKCk7XG5cbiAgICB2YXIgciA9IGZ1bmN0aW9uIHIoeCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoeCk7XG4gICAgfTtcblxuICAgIHJldHVybiBoYXNoSW50c0FycmF5KFtyKHAxLngpLCByKHAxLnkpLCByKHAyLngpLCByKHAyLnkpXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbnZhciBjYWNoZWRCb3VuZGluZ0JveEltcGwgPSBmdW5jdGlvbiBjYWNoZWRCb3VuZGluZ0JveEltcGwoZWxlLCBvcHRzKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGJiO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIga2V5ID0gb3B0cyA9PSBudWxsID8gZGVmQmJPcHRzS2V5IDogZ2V0S2V5KG9wdHMpO1xuICB2YXIgdXNpbmdEZWZPcHRzID0ga2V5ID09PSBkZWZCYk9wdHNLZXk7XG4gIHZhciBjdXJyUG9zS2V5ID0gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKTtcbiAgdmFyIGlzUG9zS2V5U2FtZSA9IF9wLmJiQ2FjaGVQb3NLZXkgPT09IGN1cnJQb3NLZXk7XG4gIHZhciB1c2VDYWNoZSA9IG9wdHMudXNlQ2FjaGUgJiYgaXNQb3NLZXlTYW1lO1xuXG4gIHZhciBpc0RpcnR5ID0gZnVuY3Rpb24gaXNEaXJ0eShlbGUpIHtcbiAgICByZXR1cm4gZWxlLl9wcml2YXRlLmJiQ2FjaGUgPT0gbnVsbDtcbiAgfTtcblxuICB2YXIgbmVlZFJlY2FsYyA9ICF1c2VDYWNoZSB8fCBpc0RpcnR5KGVsZSkgfHwgaXNFZGdlICYmIGlzRGlydHkoZWxlLnNvdXJjZSgpKSB8fCBpc0RpcnR5KGVsZS50YXJnZXQoKSk7XG5cbiAgaWYgKG5lZWRSZWNhbGMpIHtcbiAgICBpZiAoIWlzUG9zS2V5U2FtZSkge1xuICAgICAgZWxlLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSgpO1xuICAgIH1cblxuICAgIGJiID0gYm91bmRpbmdCb3hJbXBsKGVsZSwgZGVmQmJPcHRzKTtcbiAgICBfcC5iYkNhY2hlID0gYmI7XG4gICAgX3AuYmJDYWNoZVNoaWZ0LnggPSBfcC5iYkNhY2hlU2hpZnQueSA9IDA7XG4gICAgX3AuYmJDYWNoZVBvc0tleSA9IGN1cnJQb3NLZXk7XG4gIH0gZWxzZSB7XG4gICAgYmIgPSBfcC5iYkNhY2hlO1xuICB9XG5cbiAgaWYgKCFuZWVkUmVjYWxjICYmIChfcC5iYkNhY2hlU2hpZnQueCAhPT0gMCB8fCBfcC5iYkNhY2hlU2hpZnQueSAhPT0gMCkpIHtcbiAgICB2YXIgc2hpZnQgPSBhc3NpZ25TaGlmdFRvQm91bmRpbmdCb3g7XG4gICAgdmFyIGRlbHRhID0gX3AuYmJDYWNoZVNoaWZ0O1xuXG4gICAgdmFyIHNhZmVTaGlmdCA9IGZ1bmN0aW9uIHNhZmVTaGlmdChiYiwgZGVsdGEpIHtcbiAgICAgIGlmIChiYiAhPSBudWxsKSB7XG4gICAgICAgIHNoaWZ0KGJiLCBkZWx0YSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNoaWZ0KGJiLCBkZWx0YSk7XG4gICAgdmFyIGJvZHlCb3VuZHMgPSBfcC5ib2R5Qm91bmRzLFxuICAgICAgICBvdmVybGF5Qm91bmRzID0gX3Aub3ZlcmxheUJvdW5kcyxcbiAgICAgICAgbGFiZWxCb3VuZHMgPSBfcC5sYWJlbEJvdW5kcyxcbiAgICAgICAgYXJyb3dCb3VuZHMgPSBfcC5hcnJvd0JvdW5kcztcbiAgICBzYWZlU2hpZnQoYm9keUJvdW5kcywgZGVsdGEpO1xuICAgIHNhZmVTaGlmdChvdmVybGF5Qm91bmRzLCBkZWx0YSk7XG5cbiAgICBpZiAoYXJyb3dCb3VuZHMgIT0gbnVsbCkge1xuICAgICAgc2FmZVNoaWZ0KGFycm93Qm91bmRzLnNvdXJjZSwgZGVsdGEpO1xuICAgICAgc2FmZVNoaWZ0KGFycm93Qm91bmRzLnRhcmdldCwgZGVsdGEpO1xuICAgICAgc2FmZVNoaWZ0KGFycm93Qm91bmRzWydtaWQtc291cmNlJ10sIGRlbHRhKTtcbiAgICAgIHNhZmVTaGlmdChhcnJvd0JvdW5kc1snbWlkLXRhcmdldCddLCBkZWx0YSk7XG4gICAgfVxuXG4gICAgaWYgKGxhYmVsQm91bmRzICE9IG51bGwpIHtcbiAgICAgIHNhZmVTaGlmdChsYWJlbEJvdW5kcy5tYWluLCBkZWx0YSk7XG4gICAgICBzYWZlU2hpZnQobGFiZWxCb3VuZHMuYWxsLCBkZWx0YSk7XG4gICAgICBzYWZlU2hpZnQobGFiZWxCb3VuZHMuc291cmNlLCBkZWx0YSk7XG4gICAgICBzYWZlU2hpZnQobGFiZWxCb3VuZHMudGFyZ2V0LCBkZWx0YSk7XG4gICAgfVxuICB9IC8vIGFsd2F5cyByZXNldCB0aGUgc2hpZnQsIGJlY2F1c2Ugd2UgZWl0aGVyIGFwcGxpZWQgdGhlIHNoaWZ0IG9yIGNsZWFyZWQgaXQgYnkgZG9pbmcgYSBmcmVzaCByZWNhbGNcblxuXG4gIF9wLmJiQ2FjaGVTaGlmdC54ID0gX3AuYmJDYWNoZVNoaWZ0LnkgPSAwOyAvLyBub3QgdXNpbmcgZGVmIG9wdHMgPT4gbmVlZCB0byBidWlsZCB1cCBiYiBmcm9tIGNvbWJpbmF0aW9uIG9mIHN1YiBiYnNcblxuICBpZiAoIXVzaW5nRGVmT3B0cykge1xuICAgIHZhciBpc05vZGUgPSBlbGUuaXNOb2RlKCk7XG4gICAgYmIgPSBtYWtlQm91bmRpbmdCb3goKTtcblxuICAgIGlmIChvcHRzLmluY2x1ZGVOb2RlcyAmJiBpc05vZGUgfHwgb3B0cy5pbmNsdWRlRWRnZXMgJiYgIWlzTm9kZSkge1xuICAgICAgaWYgKG9wdHMuaW5jbHVkZU92ZXJsYXlzKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLm92ZXJsYXlCb3VuZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AuYm9keUJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuaW5jbHVkZUxhYmVscykge1xuICAgICAgaWYgKG9wdHMuaW5jbHVkZU1haW5MYWJlbHMgJiYgKCFpc0VkZ2UgfHwgb3B0cy5pbmNsdWRlU291cmNlTGFiZWxzICYmIG9wdHMuaW5jbHVkZVRhcmdldExhYmVscykpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMuYWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVNYWluTGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMubWFpblJvdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5pbmNsdWRlU291cmNlTGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMuc291cmNlUm90KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVUYXJnZXRMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy50YXJnZXRSb3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gIH1cblxuICByZXR1cm4gYmI7XG59O1xuXG52YXIgZGVmQmJPcHRzID0ge1xuICBpbmNsdWRlTm9kZXM6IHRydWUsXG4gIGluY2x1ZGVFZGdlczogdHJ1ZSxcbiAgaW5jbHVkZUxhYmVsczogdHJ1ZSxcbiAgaW5jbHVkZU1haW5MYWJlbHM6IHRydWUsXG4gIGluY2x1ZGVTb3VyY2VMYWJlbHM6IHRydWUsXG4gIGluY2x1ZGVUYXJnZXRMYWJlbHM6IHRydWUsXG4gIGluY2x1ZGVPdmVybGF5czogdHJ1ZSxcbiAgdXNlQ2FjaGU6IHRydWVcbn07XG52YXIgZGVmQmJPcHRzS2V5ID0gZ2V0S2V5KGRlZkJiT3B0cyk7XG52YXIgZmlsbGVkQmJPcHRzID0gZGVmYXVsdHMoZGVmQmJPcHRzKTtcblxuZWxlc2ZuJGsuYm91bmRpbmdCb3ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgYm91bmRzOyAvLyB0aGUgbWFpbiB1c2VjYXNlIGlzIGVsZS5ib3VuZGluZ0JveCgpIGZvciBhIHNpbmdsZSBlbGVtZW50IHdpdGggbm8vZGVmIG9wdGlvbnNcbiAgLy8gc3BlY2lmaWVkIHMudC4gdGhlIGNhY2hlIGlzIHVzZWQsIHNvIGNoZWNrIGZvciB0aGlzIGNhc2UgdG8gbWFrZSBpdCBmYXN0ZXIgYnlcbiAgLy8gYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSByZXN0IG9mIHRoZSBmdW5jdGlvblxuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzWzBdLl9wcml2YXRlLmJiQ2FjaGUgIT0gbnVsbCAmJiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlQ2FjaGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnVzZUNhY2hlID09PSB0cnVlKSkge1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZCYk9wdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmaWxsZWRCYk9wdHMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgYm91bmRzID0gY2FjaGVkQm91bmRpbmdCb3hJbXBsKHRoaXNbMF0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kcyA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZkJiT3B0cztcbiAgICB2YXIgb3B0cyA9IGZpbGxlZEJiT3B0cyhvcHRpb25zKTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGN5ID0gZWxlcy5jeSgpO1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcblxuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgY3VyclBvc0tleSA9IGdldEJvdW5kaW5nQm94UG9zS2V5KGVsZSk7XG4gICAgICAgIHZhciBpc1Bvc0tleVNhbWUgPSBfcC5iYkNhY2hlUG9zS2V5ID09PSBjdXJyUG9zS2V5O1xuICAgICAgICB2YXIgdXNlQ2FjaGUgPSBvcHRzLnVzZUNhY2hlICYmIGlzUG9zS2V5U2FtZTtcbiAgICAgICAgZWxlLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh1c2VDYWNoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2VsZSA9IGVsZXNbX2ldO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChib3VuZHMsIGNhY2hlZEJvdW5kaW5nQm94SW1wbChfZWxlLCBvcHRzKSk7XG4gICAgfVxuICB9XG5cbiAgYm91bmRzLngxID0gbm9uaW5mKGJvdW5kcy54MSk7XG4gIGJvdW5kcy55MSA9IG5vbmluZihib3VuZHMueTEpO1xuICBib3VuZHMueDIgPSBub25pbmYoYm91bmRzLngyKTtcbiAgYm91bmRzLnkyID0gbm9uaW5mKGJvdW5kcy55Mik7XG4gIGJvdW5kcy53ID0gbm9uaW5mKGJvdW5kcy54MiAtIGJvdW5kcy54MSk7XG4gIGJvdW5kcy5oID0gbm9uaW5mKGJvdW5kcy55MiAtIGJvdW5kcy55MSk7XG4gIHJldHVybiBib3VuZHM7XG59O1xuXG5lbGVzZm4kay5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfcCA9IHRoaXNbaV0uX3ByaXZhdGU7XG4gICAgX3AuYmJDYWNoZSA9IG51bGw7XG4gICAgX3AuYmJDYWNoZVNoaWZ0LnggPSBfcC5iYkNhY2hlU2hpZnQueSA9IDA7XG4gICAgX3AuYmJDYWNoZVBvc0tleSA9IG51bGw7XG4gICAgX3AuYm9keUJvdW5kcyA9IG51bGw7XG4gICAgX3Aub3ZlcmxheUJvdW5kcyA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMuYWxsID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5zb3VyY2UgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLnRhcmdldCA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMubWFpbiA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMuc291cmNlUm90ID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy50YXJnZXRSb3QgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLm1haW5Sb3QgPSBudWxsO1xuICAgIF9wLmFycm93Qm91bmRzLnNvdXJjZSA9IG51bGw7XG4gICAgX3AuYXJyb3dCb3VuZHMudGFyZ2V0ID0gbnVsbDtcbiAgICBfcC5hcnJvd0JvdW5kc1snbWlkLXNvdXJjZSddID0gbnVsbDtcbiAgICBfcC5hcnJvd0JvdW5kc1snbWlkLXRhcmdldCddID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuZW1pdEFuZE5vdGlmeSgnYm91bmRzJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZWxlc2ZuJGsuc2hpZnRDYWNoZWRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGJiID0gX3AuYmJDYWNoZTtcblxuICAgIGlmIChiYiAhPSBudWxsKSB7XG4gICAgICBfcC5iYkNhY2hlU2hpZnQueCArPSBkZWx0YS54O1xuICAgICAgX3AuYmJDYWNoZVNoaWZ0LnkgKz0gZGVsdGEueTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVtaXRBbmROb3RpZnkoJ2JvdW5kcycpO1xuICByZXR1cm4gdGhpcztcbn07IC8vIHByaXZhdGUgaGVscGVyIHRvIGdldCBib3VuZGluZyBib3ggZm9yIGN1c3RvbSBub2RlIHBvc2l0aW9uc1xuLy8gLSBnb29kIGZvciBwZXJmIGluIGNlcnRhaW4gY2FzZXMgYnV0IGN1cnJlbnRseSByZXF1aXJlcyBkaXJ0eWluZyB0aGUgcmVuZGVyZWQgc3R5bGVcbi8vIC0gd291bGQgYmUgYmV0dGVyIHRvIG5vdCBtb2RpZnkgdGhlIG5vZGVzIGJ1dCB0aGUgbm9kZXMgYXJlIHJlYWQgZGlyZWN0bHkgZXZlcnl3aGVyZSBpbiB0aGUgcmVuZGVyZXIuLi5cbi8vIC0gdHJ5IHRvIHVzZSBmb3Igb25seSB0aGluZ3MgbGlrZSBkaXNjcmV0ZSBsYXlvdXRzIHdoZXJlIHRoZSBub2RlIHBvc2l0aW9uIHdvdWxkIGNoYW5nZSBhbnl3YXlcblxuXG5lbGVzZm4kay5ib3VuZGluZ0JveEF0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgIG5vZGVzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gIW5vZGUuaXNQYXJlbnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwbGFpbk9iamVjdChmbikpIHtcbiAgICB2YXIgb2JqID0gZm47XG5cbiAgICBmbiA9IGZ1bmN0aW9uIGZuKCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHN0b3JlT2xkUG9zID0gZnVuY3Rpb24gc3RvcmVPbGRQb3Mobm9kZSwgaSkge1xuICAgIHJldHVybiBub2RlLl9wcml2YXRlLmJiQXRPbGRQb3MgPSBmbihub2RlLCBpKTtcbiAgfTtcblxuICB2YXIgZ2V0T2xkUG9zID0gZnVuY3Rpb24gZ2V0T2xkUG9zKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5iYkF0T2xkUG9zO1xuICB9O1xuXG4gIGN5LnN0YXJ0QmF0Y2goKTtcbiAgbm9kZXMuZm9yRWFjaChzdG9yZU9sZFBvcykuc2lsZW50UG9zaXRpb25zKGZuKTtcblxuICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgIHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHModHJ1ZSk7IC8vIGZvcmNlIHVwZGF0ZSBiL2Mgd2UncmUgaW5zaWRlIGEgYmF0Y2ggY3ljbGVcbiAgfVxuXG4gIHZhciBiYiA9IGNvcHlCb3VuZGluZ0JveCh0aGlzLmJvdW5kaW5nQm94KHtcbiAgICB1c2VDYWNoZTogZmFsc2VcbiAgfSkpO1xuICBub2Rlcy5zaWxlbnRQb3NpdGlvbnMoZ2V0T2xkUG9zKTtcbiAgY3kuZW5kQmF0Y2goKTtcbiAgcmV0dXJuIGJiO1xufTtcblxuZm4kMy5ib3VuZGluZ2JveCA9IGZuJDMuYmIgPSBmbiQzLmJvdW5kaW5nQm94O1xuZm4kMy5yZW5kZXJlZEJvdW5kaW5nYm94ID0gZm4kMy5yZW5kZXJlZEJvdW5kaW5nQm94O1xudmFyIGJvdW5kcyA9IGVsZXNmbiRrO1xuXG52YXIgZm4kNCwgZWxlc2ZuJGw7XG5mbiQ0ID0gZWxlc2ZuJGwgPSB7fTtcblxudmFyIGRlZmluZURpbUZucyA9IGZ1bmN0aW9uIGRlZmluZURpbUZucyhvcHRzKSB7XG4gIG9wdHMudXBwZXJjYXNlTmFtZSA9IGNhcGl0YWxpemUob3B0cy5uYW1lKTtcbiAgb3B0cy5hdXRvTmFtZSA9ICdhdXRvJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy5sYWJlbE5hbWUgPSAnbGFiZWwnICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLm91dGVyTmFtZSA9ICdvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lID0gY2FwaXRhbGl6ZShvcHRzLm91dGVyTmFtZSk7XG5cbiAgZm4kNFtvcHRzLm5hbWVdID0gZnVuY3Rpb24gZGltSW1wbCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgZWxlLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgcmV0dXJuIF9wW29wdHMuYXV0b05hbWVdIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZCA9IGVsZS5wc3R5bGUob3B0cy5uYW1lKTtcblxuICAgICAgICBzd2l0Y2ggKGQuc3RyVmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdsYWJlbCc6XG4gICAgICAgICAgICBlbGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKCk7XG4gICAgICAgICAgICByZXR1cm4gX3AucnN0eWxlW29wdHMubGFiZWxOYW1lXSB8fCAwO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkLnBmVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmbiQ0WydvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWVdID0gZnVuY3Rpb24gb3V0ZXJEaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICB2YXIgZGltID0gZWxlW29wdHMubmFtZV0oKTtcbiAgICAgICAgdmFyIGJvcmRlciA9IGVsZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnBmVmFsdWU7IC8vIG4uYi4gMS8yIGVhY2ggc2lkZVxuXG4gICAgICAgIHZhciBwYWRkaW5nID0gMiAqIGVsZS5wYWRkaW5nKCk7XG4gICAgICAgIHJldHVybiBkaW0gKyBib3JkZXIgKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZuJDRbJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlTmFtZV0gPSBmdW5jdGlvbiByZW5kZXJlZERpbUltcGwoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgZCA9IGVsZVtvcHRzLm5hbWVdKCk7XG4gICAgICByZXR1cm4gZCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgfVxuICB9O1xuXG4gIGZuJDRbJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lXSA9IGZ1bmN0aW9uIHJlbmRlcmVkT3V0ZXJEaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIG9kID0gZWxlW29wdHMub3V0ZXJOYW1lXSgpO1xuICAgICAgcmV0dXJuIG9kICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG59O1xuXG5kZWZpbmVEaW1GbnMoe1xuICBuYW1lOiAnd2lkdGgnXG59KTtcbmRlZmluZURpbUZucyh7XG4gIG5hbWU6ICdoZWlnaHQnXG59KTtcblxuZWxlc2ZuJGwucGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcblxuICAgIGlmIChfcC5hdXRvUGFkZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX3AuYXV0b1BhZGRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKCdwYWRkaW5nJykucGZWYWx1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZS5wc3R5bGUoJ3BhZGRpbmcnKS5wZlZhbHVlO1xuICB9XG59O1xuXG5lbGVzZm4kbC5wYWRkZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlLmhlaWdodCgpICsgMiAqIGVsZS5wYWRkaW5nKCk7XG59O1xuXG5lbGVzZm4kbC5wYWRkZWRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUud2lkdGgoKSArIDIgKiBlbGUucGFkZGluZygpO1xufTtcblxudmFyIHdpZHRoSGVpZ2h0ID0gZWxlc2ZuJGw7XG5cbnZhciBpZkVkZ2UgPSBmdW5jdGlvbiBpZkVkZ2UoZWxlLCBnZXRWYWx1ZSkge1xuICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlKGVsZSk7XG4gIH1cbn07XG5cbnZhciBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uID0gZnVuY3Rpb24gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbihlbGUsIGdldFBvaW50KSB7XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICByZXR1cm4gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24oZ2V0UG9pbnQoZWxlKSwgY3kuem9vbSgpLCBjeS5wYW4oKSk7XG4gIH1cbn07XG5cbnZhciBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zKGVsZSwgZ2V0UG9pbnRzKSB7XG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgcmV0dXJuIGdldFBvaW50cyhlbGUpLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHAsIHpvb20sIHBhbik7XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBjb250cm9sUG9pbnRzID0gZnVuY3Rpb24gY29udHJvbFBvaW50cyhlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldENvbnRyb2xQb2ludHMoZWxlKTtcbn07XG5cbnZhciBzZWdtZW50UG9pbnRzID0gZnVuY3Rpb24gc2VnbWVudFBvaW50cyhlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldFNlZ21lbnRQb2ludHMoZWxlKTtcbn07XG5cbnZhciBzb3VyY2VFbmRwb2ludCA9IGZ1bmN0aW9uIHNvdXJjZUVuZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0U291cmNlRW5kcG9pbnQoZWxlKTtcbn07XG5cbnZhciB0YXJnZXRFbmRwb2ludCA9IGZ1bmN0aW9uIHRhcmdldEVuZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0VGFyZ2V0RW5kcG9pbnQoZWxlKTtcbn07XG5cbnZhciBtaWRwb2ludCA9IGZ1bmN0aW9uIG1pZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0RWRnZU1pZHBvaW50KGVsZSk7XG59O1xuXG52YXIgcHRzID0ge1xuICBjb250cm9sUG9pbnRzOiB7XG4gICAgZ2V0OiBjb250cm9sUG9pbnRzLFxuICAgIG11bHQ6IHRydWVcbiAgfSxcbiAgc2VnbWVudFBvaW50czoge1xuICAgIGdldDogc2VnbWVudFBvaW50cyxcbiAgICBtdWx0OiB0cnVlXG4gIH0sXG4gIHNvdXJjZUVuZHBvaW50OiB7XG4gICAgZ2V0OiBzb3VyY2VFbmRwb2ludFxuICB9LFxuICB0YXJnZXRFbmRwb2ludDoge1xuICAgIGdldDogdGFyZ2V0RW5kcG9pbnRcbiAgfSxcbiAgbWlkcG9pbnQ6IHtcbiAgICBnZXQ6IG1pZHBvaW50XG4gIH1cbn07XG5cbnZhciByZW5kZXJlZE5hbWUgPSBmdW5jdGlvbiByZW5kZXJlZE5hbWUobmFtZSkge1xuICByZXR1cm4gJ3JlbmRlcmVkJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpO1xufTtcblxudmFyIGVkZ2VQb2ludHMgPSBPYmplY3Qua2V5cyhwdHMpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gIHZhciBzcGVjID0gcHRzW25hbWVdO1xuICB2YXIgck5hbWUgPSByZW5kZXJlZE5hbWUobmFtZSk7XG5cbiAgb2JqW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpZkVkZ2UodGhpcywgc3BlYy5nZXQpO1xuICB9O1xuXG4gIGlmIChzcGVjLm11bHQpIHtcbiAgICBvYmpbck5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zKHRoaXMsIHNwZWMuZ2V0KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG9ialtyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbih0aGlzLCBzcGVjLmdldCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbnZhciBkaW1lbnNpb25zID0gZXh0ZW5kKHt9LCBwb3NpdGlvbiwgYm91bmRzLCB3aWR0aEhlaWdodCwgZWRnZVBvaW50cyk7XG5cbi8qIVxuRXZlbnQgb2JqZWN0IGJhc2VkIG9uIGpRdWVyeSBldmVudHMsIE1JVCBsaWNlbnNlXG5cbmh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlL1xuaHR0cHM6Ly90bGRybGVnYWwuY29tL2xpY2Vuc2UvbWl0LWxpY2Vuc2Vcbmh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuKi9cbnZhciBFdmVudCA9IGZ1bmN0aW9uIEV2ZW50KHNyYywgcHJvcHMpIHtcbiAgdGhpcy5yZWN5Y2xlKHNyYywgcHJvcHMpO1xufTtcblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59IC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuXG5cbkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgIHJldHVybiAnZXZlbnQnO1xuICB9LFxuICByZWN5Y2xlOiBmdW5jdGlvbiByZWN5Y2xlKHNyYywgcHJvcHMpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuRmFsc2U7XG5cbiAgICBpZiAoc3JjICE9IG51bGwgJiYgc3JjLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAvLyBCcm93c2VyIEV2ZW50IG9iamVjdFxuICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7IC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG4gICAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblxuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCA/IHJldHVyblRydWUgOiByZXR1cm5GYWxzZTtcbiAgICB9IGVsc2UgaWYgKHNyYyAhPSBudWxsICYmIHNyYy50eXBlKSB7XG4gICAgICAvLyBQbGFpbiBvYmplY3QgY29udGFpbmluZyBhbGwgZXZlbnQgZGV0YWlsc1xuICAgICAgcHJvcHMgPSBzcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW50IHN0cmluZ1xuICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgIH0gLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcblxuXG4gICAgaWYgKHByb3BzICE9IG51bGwpIHtcbiAgICAgIC8vIG1vcmUgZWZmaWNpZW50IHRvIG1hbnVhbGx5IGNvcHkgZmllbGRzIHdlIHVzZVxuICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gcHJvcHMub3JpZ2luYWxFdmVudDtcbiAgICAgIHRoaXMudHlwZSA9IHByb3BzLnR5cGUgIT0gbnVsbCA/IHByb3BzLnR5cGUgOiB0aGlzLnR5cGU7XG4gICAgICB0aGlzLmN5ID0gcHJvcHMuY3k7XG4gICAgICB0aGlzLnRhcmdldCA9IHByb3BzLnRhcmdldDtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBwcm9wcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHByb3BzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICB0aGlzLm5hbWVzcGFjZSA9IHByb3BzLm5hbWVzcGFjZTtcbiAgICAgIHRoaXMubGF5b3V0ID0gcHJvcHMubGF5b3V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmN5ICE9IG51bGwgJiYgdGhpcy5wb3NpdGlvbiAhPSBudWxsICYmIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9PSBudWxsKSB7XG4gICAgICAvLyBjcmVhdGUgYSByZW5kZXJlZCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgcGFzc2VkIHBvc2l0aW9uXG4gICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHZhciB6b29tID0gdGhpcy5jeS56b29tKCk7XG4gICAgICB2YXIgcGFuID0gdGhpcy5jeS5wYW4oKTtcbiAgICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogcG9zLnggKiB6b29tICsgcGFuLngsXG4gICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICB9O1xuICAgIH0gLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblxuXG4gICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgaWYgKCFlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXG5cbiAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICBpZiAoIWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGlmIHN0b3BQcm9wYWdhdGlvbiBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXG5cbiAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9LFxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZVxufTtcblxudmFyIGV2ZW50UmVnZXggPSAvXihbXi5dKykoXFwuKD86W14uXSspKT8kLzsgLy8gcmVnZXggZm9yIG1hdGNoaW5nIGV2ZW50IHN0cmluZ3MgKGUuZy4gXCJjbGljay5uYW1lc3BhY2VcIilcblxudmFyIHVuaXZlcnNhbE5hbWVzcGFjZSA9ICcuKic7IC8vIG1hdGNoZXMgYXMgaWYgbm8gbmFtZXNwYWNlIHNwZWNpZmllZCBhbmQgcHJldmVudHMgdXNlcnMgZnJvbSB1bmJpbmRpbmcgYWNjaWRlbnRhbGx5XG5cbnZhciBkZWZhdWx0cyQ4ID0ge1xuICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHExLCBxMikge1xuICAgIHJldHVybiBxMSA9PT0gcTI7XG4gIH0sXG4gIGV2ZW50TWF0Y2hlczogZnVuY3Rpb24gZXZlbnRNYXRjaGVzKClcbiAgLypjb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmoqL1xuICB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvbiBhZGRFdmVudEZpZWxkcygpXG4gIC8qY29udGV4dCwgZXZ0Ki9cbiAge30sXG4gIGNhbGxiYWNrQ29udGV4dDogZnVuY3Rpb24gY2FsbGJhY2tDb250ZXh0KGNvbnRleHRcbiAgLyosIGxpc3RlbmVyLCBldmVudE9iaiovXG4gICkge1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9LFxuICBiZWZvcmVFbWl0OiBmdW5jdGlvbiBiZWZvcmVFbWl0KClcbiAgLyogY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqICovXG4gIHt9LFxuICBhZnRlckVtaXQ6IGZ1bmN0aW9uIGFmdGVyRW1pdCgpXG4gIC8qIGNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiAqL1xuICB7fSxcbiAgYnViYmxlOiBmdW5jdGlvbiBidWJibGUoKVxuICAvKmNvbnRleHQqL1xuICB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCgpXG4gIC8qY29udGV4dCovXG4gIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgY29udGV4dDogbnVsbFxufTtcbnZhciBkZWZhdWx0c0tleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cyQ4KTtcbnZhciBlbXB0eU9wdHMgPSB7fTtcblxuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVtcHR5T3B0cztcbiAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcblxuICAvLyBtaWNyby1vcHRpbWlzYXRpb24gdnMgT2JqZWN0LmFzc2lnbigpIC0tIHJlZHVjZXMgRWxlbWVudCBpbnN0YW50aWF0aW9uIHRpbWVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZhdWx0c0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gZGVmYXVsdHNLZXlzW2ldO1xuICAgIHRoaXNba2V5XSA9IG9wdHNba2V5XSB8fCBkZWZhdWx0cyQ4W2tleV07XG4gIH1cblxuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuY29udGV4dDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5lbWl0dGluZyA9IDA7XG59XG5cbnZhciBwID0gRW1pdHRlci5wcm90b3R5cGU7XG5cbnZhciBmb3JFYWNoRXZlbnQgPSBmdW5jdGlvbiBmb3JFYWNoRXZlbnQoc2VsZiwgaGFuZGxlciwgZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKSB7XG4gIGlmIChmbihxdWFsaWZpZXIpKSB7XG4gICAgY2FsbGJhY2sgPSBxdWFsaWZpZXI7XG4gICAgcXVhbGlmaWVyID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjb25mT3ZlcnJpZGVzKSB7XG4gICAgaWYgKGNvbmYgPT0gbnVsbCkge1xuICAgICAgY29uZiA9IGNvbmZPdmVycmlkZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmYgPSBleHRlbmQoe30sIGNvbmYsIGNvbmZPdmVycmlkZXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudExpc3QgPSBhcnJheShldmVudHMpID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KC9cXHMrLyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXZ0ID0gZXZlbnRMaXN0W2ldO1xuXG4gICAgaWYgKGVtcHR5U3RyaW5nKGV2dCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaChldmVudFJlZ2V4KTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiBudWxsO1xuICAgICAgdmFyIHJldCA9IGhhbmRsZXIoc2VsZiwgZXZ0LCB0eXBlLCBuYW1lc3BhY2UsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpO1xuXG4gICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gYWxsb3cgZXhpdGluZyBlYXJseVxuXG4gICAgfVxuICB9XG59O1xuXG52YXIgbWFrZUV2ZW50T2JqID0gZnVuY3Rpb24gbWFrZUV2ZW50T2JqKHNlbGYsIG9iaikge1xuICBzZWxmLmFkZEV2ZW50RmllbGRzKHNlbGYuY29udGV4dCwgb2JqKTtcbiAgcmV0dXJuIG5ldyBFdmVudChvYmoudHlwZSwgb2JqKTtcbn07XG5cbnZhciBmb3JFYWNoRXZlbnRPYmogPSBmdW5jdGlvbiBmb3JFYWNoRXZlbnRPYmooc2VsZiwgaGFuZGxlciwgZXZlbnRzKSB7XG4gIGlmIChldmVudChldmVudHMpKSB7XG4gICAgaGFuZGxlcihzZWxmLCBldmVudHMpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChldmVudHMpKSB7XG4gICAgaGFuZGxlcihzZWxmLCBtYWtlRXZlbnRPYmooc2VsZiwgZXZlbnRzKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGV2ZW50TGlzdCA9IGFycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoL1xccysvKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBldnQgPSBldmVudExpc3RbaV07XG5cbiAgICBpZiAoZW1wdHlTdHJpbmcoZXZ0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKGV2ZW50UmVnZXgpOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IG51bGw7XG4gICAgICB2YXIgZXZlbnRPYmogPSBtYWtlRXZlbnRPYmooc2VsZiwge1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgICAgdGFyZ2V0OiBzZWxmLmNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaGFuZGxlcihzZWxmLCBldmVudE9iaik7XG4gICAgfVxuICB9XG59O1xuXG5wLm9uID0gcC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIGNvbmZPdmVycmlkZXMpIHtcbiAgZm9yRWFjaEV2ZW50KHRoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudCwgdHlwZSwgbmFtZXNwYWNlLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKSB7XG4gICAgaWYgKGZuKGNhbGxiYWNrKSkge1xuICAgICAgc2VsZi5saXN0ZW5lcnMucHVzaCh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgLy8gZnVsbCBldmVudCBzdHJpbmdcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAvLyBjYWxsYmFjayB0byBydW5cbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgLy8gdGhlIGV2ZW50IHR5cGUgKGUuZy4gJ2NsaWNrJylcbiAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICAgIC8vIHRoZSBldmVudCBuYW1lc3BhY2UgKGUuZy4gXCIuZm9vXCIpXG4gICAgICAgIHF1YWxpZmllcjogcXVhbGlmaWVyLFxuICAgICAgICAvLyBhIHJlc3RyaWN0aW9uIG9uIHdoZXRoZXIgdG8gbWF0Y2ggdGhpcyBlbWl0dGVyXG4gICAgICAgIGNvbmY6IGNvbmYgLy8gYWRkaXRpb25hbCBjb25maWd1cmF0aW9uXG5cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wLm9uZSA9IGZ1bmN0aW9uIChldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpIHtcbiAgcmV0dXJuIHRoaXMub24oZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCB7XG4gICAgb25lOiB0cnVlXG4gIH0pO1xufTtcblxucC5yZW1vdmVMaXN0ZW5lciA9IHAub2ZmID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmVtaXR0aW5nICE9PSAwKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBjb3B5QXJyYXkodGhpcy5saXN0ZW5lcnMpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgZm9yRWFjaEV2ZW50KF90aGlzLCBmdW5jdGlvbiAoc2VsZiwgZXZlbnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFja1xuICAgIC8qLCBjb25mKi9cbiAgICApIHtcbiAgICAgIGlmICgobGlzdGVuZXIudHlwZSA9PT0gdHlwZSB8fCBldmVudHMgPT09ICcqJykgJiYgKCFuYW1lc3BhY2UgJiYgbGlzdGVuZXIubmFtZXNwYWNlICE9PSAnLionIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlKSAmJiAoIXF1YWxpZmllciB8fCBzZWxmLnF1YWxpZmllckNvbXBhcmUobGlzdGVuZXIucXVhbGlmaWVyLCBxdWFsaWZpZXIpKSAmJiAoIWNhbGxiYWNrIHx8IGxpc3RlbmVyLmNhbGxiYWNrID09PSBjYWxsYmFjaykpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZik7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIF9sb29wKGkpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoJyonKTtcbn07XG5cbnAuZW1pdCA9IHAudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudHMsIGV4dHJhUGFyYW1zLCBtYW51YWxDYWxsYmFjaykge1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnM7XG4gIHZhciBudW1MaXN0ZW5lcnNCZWZvcmVFbWl0ID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgdGhpcy5lbWl0dGluZysrO1xuXG4gIGlmICghYXJyYXkoZXh0cmFQYXJhbXMpKSB7XG4gICAgZXh0cmFQYXJhbXMgPSBbZXh0cmFQYXJhbXNdO1xuICB9XG5cbiAgZm9yRWFjaEV2ZW50T2JqKHRoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudE9iaikge1xuICAgIGlmIChtYW51YWxDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBbe1xuICAgICAgICBldmVudDogZXZlbnRPYmouZXZlbnQsXG4gICAgICAgIHR5cGU6IGV2ZW50T2JqLnR5cGUsXG4gICAgICAgIG5hbWVzcGFjZTogZXZlbnRPYmoubmFtZXNwYWNlLFxuICAgICAgICBjYWxsYmFjazogbWFudWFsQ2FsbGJhY2tcbiAgICAgIH1dO1xuICAgICAgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihpKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG5cbiAgICAgIGlmIChsaXN0ZW5lci50eXBlID09PSBldmVudE9iai50eXBlICYmICghbGlzdGVuZXIubmFtZXNwYWNlIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gZXZlbnRPYmoubmFtZXNwYWNlIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gdW5pdmVyc2FsTmFtZXNwYWNlKSAmJiBzZWxmLmV2ZW50TWF0Y2hlcyhzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaikpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbZXZlbnRPYmpdO1xuXG4gICAgICAgIGlmIChleHRyYVBhcmFtcyAhPSBudWxsKSB7XG4gICAgICAgICAgcHVzaChhcmdzLCBleHRyYVBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmJlZm9yZUVtaXQoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lci5jb25mICYmIGxpc3RlbmVyLmNvbmYub25lKSB7XG4gICAgICAgICAgc2VsZi5saXN0ZW5lcnMgPSBzZWxmLmxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsICE9PSBsaXN0ZW5lcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZXh0ID0gc2VsZi5jYWxsYmFja0NvbnRleHQoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopO1xuICAgICAgICB2YXIgcmV0ID0gbGlzdGVuZXIuY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIHNlbGYuYWZ0ZXJFbWl0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcblxuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGV2ZW50T2JqLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGV2ZW50T2JqLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaWYgbGlzdGVuZXIgbWF0Y2hlc1xuXG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdDsgaSsrKSB7XG4gICAgICBfbG9vcDIoaSk7XG4gICAgfSAvLyBmb3IgbGlzdGVuZXJcblxuXG4gICAgaWYgKHNlbGYuYnViYmxlKHNlbGYuY29udGV4dCkgJiYgIWV2ZW50T2JqLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgIHNlbGYucGFyZW50KHNlbGYuY29udGV4dCkuZW1pdChldmVudE9iaiwgZXh0cmFQYXJhbXMpO1xuICAgIH1cbiAgfSwgZXZlbnRzKTtcbiAgdGhpcy5lbWl0dGluZy0tO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBlbWl0dGVyT3B0aW9ucyA9IHtcbiAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShzZWxlY3RvcjEsIHNlbGVjdG9yMikge1xuICAgIGlmIChzZWxlY3RvcjEgPT0gbnVsbCB8fCBzZWxlY3RvcjIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMSA9PSBudWxsICYmIHNlbGVjdG9yMiA9PSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxLnNhbWVUZXh0KHNlbGVjdG9yMik7XG4gICAgfVxuICB9LFxuICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uIGV2ZW50TWF0Y2hlcyhlbGUsIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHZhciBzZWxlY3RvciA9IGxpc3RlbmVyLnF1YWxpZmllcjtcblxuICAgIGlmIChzZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlICE9PSBldmVudE9iai50YXJnZXQgJiYgZWxlbWVudChldmVudE9iai50YXJnZXQpICYmIHNlbGVjdG9yLm1hdGNoZXMoZXZlbnRPYmoudGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGFkZEV2ZW50RmllbGRzKGVsZSwgZXZ0KSB7XG4gICAgZXZ0LmN5ID0gZWxlLmN5KCk7XG4gICAgZXZ0LnRhcmdldCA9IGVsZTtcbiAgfSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoZWxlLCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICByZXR1cm4gbGlzdGVuZXIucXVhbGlmaWVyICE9IG51bGwgPyBldmVudE9iai50YXJnZXQgOiBlbGU7XG4gIH0sXG4gIGJlZm9yZUVtaXQ6IGZ1bmN0aW9uIGJlZm9yZUVtaXQoY29udGV4dCwgbGlzdGVuZXJcbiAgLyosIGV2ZW50T2JqKi9cbiAgKSB7XG4gICAgaWYgKGxpc3RlbmVyLmNvbmYgJiYgbGlzdGVuZXIuY29uZi5vbmNlKSB7XG4gICAgICBsaXN0ZW5lci5jb25mLm9uY2VDb2xsZWN0aW9uLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyLmV2ZW50LCBsaXN0ZW5lci5xdWFsaWZpZXIsIGxpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG4gIGJ1YmJsZTogZnVuY3Rpb24gYnViYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKSA/IGVsZS5wYXJlbnQoKSA6IGVsZS5jeSgpO1xuICB9XG59O1xuXG52YXIgYXJnU2VsZWN0b3IgPSBmdW5jdGlvbiBhcmdTZWxlY3RvcihhcmcpIHtcbiAgaWYgKHN0cmluZyhhcmcpKSB7XG4gICAgcmV0dXJuIG5ldyBTZWxlY3RvcihhcmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhcmc7XG4gIH1cbn07XG5cbnZhciBlbGVzZm4kbSA9IHtcbiAgY3JlYXRlRW1pdHRlcjogZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gICAgICBpZiAoIV9wLmVtaXR0ZXIpIHtcbiAgICAgICAgX3AuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRpb25zLCBlbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0dGVyOiBmdW5jdGlvbiBlbWl0dGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gIH0sXG4gIG9uOiBmdW5jdGlvbiBvbihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvcihzZWxlY3Rvcik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3Ioc2VsZWN0b3IpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkucmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBhcmdTZWwsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9uZTogZnVuY3Rpb24gb25lKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLm9uKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjaywge1xuICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICBvbmNlQ29sbGVjdGlvbjogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5lbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0QW5kTm90aWZ5OiBmdW5jdGlvbiBlbWl0QW5kTm90aWZ5KGV2ZW50LCBleHRyYVBhcmFtcykge1xuICAgIC8vIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZW1wdHkgY29sbGVjdGlvbnMgZG9uJ3QgbmVlZCB0byBub3RpZnkgYW55dGhpbmdcbiAgICAvLyBub3RpZnkgcmVuZGVyZXJcblxuXG4gICAgdGhpcy5jeSgpLm5vdGlmeShldmVudCwgdGhpcyk7XG4gICAgdGhpcy5lbWl0KGV2ZW50LCBleHRyYVBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5kZWZpbmUkMy5ldmVudEFsaWFzZXNPbihlbGVzZm4kbSk7XG5cbnZhciBlbGVzZm4kbiA9IHtcbiAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNFZGdlKCk7XG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgLy8gaW50ZXJuYWwgaGVscGVyIHRvIGdldCBub2RlcyBhbmQgZWRnZXMgYXMgc2VwYXJhdGUgY29sbGVjdGlvbnMgd2l0aCBzaW5nbGUgaXRlcmF0aW9uIG92ZXIgZWxlbWVudHNcbiAgYnlHcm91cDogZnVuY3Rpb24gYnlHcm91cCgpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5zcGF3bigpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICBub2Rlcy5tZXJnZShlbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZXMubWVyZ2UoZWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgZWRnZXM6IGVkZ2VzXG4gICAgfTtcbiAgfSxcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoX2ZpbHRlciwgdGhpc0FyZykge1xuICAgIGlmIChfZmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNoZWNrIHRoaXMgZmlyc3QgYi9jIGl0J3MgdGhlIG1vc3QgY29tbW9uL3BlcmZvcm1hbnQgY2FzZVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoX2ZpbHRlcikgfHwgZWxlbWVudE9yQ29sbGVjdGlvbihfZmlsdGVyKSkge1xuICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvcihfZmlsdGVyKS5maWx0ZXIodGhpcyk7XG4gICAgfSBlbHNlIGlmIChmbihfZmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlckVsZXMgPSB0aGlzLnNwYXduKCk7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIGluY2x1ZGUgPSB0aGlzQXJnID8gX2ZpbHRlci5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiBfZmlsdGVyKGVsZSwgaSwgZWxlcyk7XG5cbiAgICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICBmaWx0ZXJFbGVzLm1lcmdlKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbHRlckVsZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oKTsgLy8gaWYgbm90IGhhbmRsZWQgYnkgYWJvdmUsIGdpdmUgJ2VtIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgfSxcbiAgbm90OiBmdW5jdGlvbiBub3QodG9SZW1vdmUpIHtcbiAgICBpZiAoIXRvUmVtb3ZlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0cmluZyh0b1JlbW92ZSkpIHtcbiAgICAgICAgdG9SZW1vdmUgPSB0aGlzLmZpbHRlcih0b1JlbW92ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIHJNYXAgPSB0b1JlbW92ZS5fcHJpdmF0ZS5tYXA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbaV07XG4gICAgICAgIHZhciByZW1vdmUgPSByTWFwLmhhcyhlbGVtZW50LmlkKCkpO1xuXG4gICAgICAgIGlmICghcmVtb3ZlKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cyk7XG4gICAgfVxuICB9LFxuICBhYnNvbHV0ZUNvbXBsZW1lbnQ6IGZ1bmN0aW9uIGFic29sdXRlQ29tcGxlbWVudCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgcmV0dXJuIGN5Lm11dGFibGVFbGVtZW50cygpLm5vdCh0aGlzKTtcbiAgfSxcbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiBpbnRlcnNlY3Qob3RoZXIpIHtcbiAgICAvLyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZCwgdGhlbiBmaWx0ZXIgYnkgaXQgaW5zdGVhZFxuICAgIGlmIChzdHJpbmcob3RoZXIpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBvdGhlcjtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG4gICAgdmFyIGNvbDFTbWFsbGVyID0gdGhpcy5sZW5ndGggPCBvdGhlci5sZW5ndGg7XG4gICAgdmFyIG1hcDIgPSBjb2wxU21hbGxlciA/IGNvbDIuX3ByaXZhdGUubWFwIDogY29sMS5fcHJpdmF0ZS5tYXA7XG4gICAgdmFyIGNvbCA9IGNvbDFTbWFsbGVyID8gY29sMSA6IGNvbDI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkID0gY29sW2ldLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgZW50cnkgPSBtYXAyLmdldChpZCk7XG5cbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVudHJ5LmVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMpO1xuICB9LFxuICB4b3I6IGZ1bmN0aW9uIHhvcihvdGhlcikge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiAoc3RyaW5nKG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBjeS4kKG90aGVyKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcblxuICAgIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoY29sLCBvdGhlcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuaGFzRWxlbWVudFdpdGhJZChpZCk7XG5cbiAgICAgICAgaWYgKCFpbk90aGVyKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGFkZChjb2wxLCBjb2wyKTtcbiAgICBhZGQoY29sMiwgY29sMSk7XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMpO1xuICB9LFxuICBkaWZmOiBmdW5jdGlvbiBkaWZmKG90aGVyKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmIChzdHJpbmcob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IGN5LiQob3RoZXIpO1xuICAgIH1cblxuICAgIHZhciBsZWZ0ID0gW107XG4gICAgdmFyIHJpZ2h0ID0gW107XG4gICAgdmFyIGJvdGggPSBbXTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcblxuICAgIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoY29sLCBvdGhlciwgcmV0RWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuaGFzRWxlbWVudFdpdGhJZChpZCk7XG5cbiAgICAgICAgaWYgKGluT3RoZXIpIHtcbiAgICAgICAgICBib3RoLnB1c2goZWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRFbGVzLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBhZGQoY29sMSwgY29sMiwgbGVmdCk7XG4gICAgYWRkKGNvbDIsIGNvbDEsIHJpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5zcGF3bihsZWZ0LCB7XG4gICAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgICAgfSksXG4gICAgICByaWdodDogdGhpcy5zcGF3bihyaWdodCwge1xuICAgICAgICB1bmlxdWU6IHRydWVcbiAgICAgIH0pLFxuICAgICAgYm90aDogdGhpcy5zcGF3bihib3RoLCB7XG4gICAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9O1xuICB9LFxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh0b0FkZCkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiAoIXRvQWRkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoc3RyaW5nKHRvQWRkKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICB0b0FkZCA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVsZW1lbnRzLnB1c2godGhpc1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1hcCA9IHRoaXMuX3ByaXZhdGUubWFwO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRvQWRkLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGFkZCA9ICFtYXAuaGFzKHRvQWRkW19pXS5pZCgpKTtcblxuICAgICAgaWYgKGFkZCkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKHRvQWRkW19pXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMpO1xuICB9LFxuICAvLyBpbiBwbGFjZSBtZXJnZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKHRvQWRkKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcblxuICAgIGlmICghdG9BZGQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0b0FkZCAmJiBzdHJpbmcodG9BZGQpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgIHRvQWRkID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICB2YXIgbWFwID0gX3AubWFwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRvQWRkRWxlID0gdG9BZGRbaV07XG4gICAgICB2YXIgaWQgPSB0b0FkZEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdmFyIGFkZCA9ICFtYXAuaGFzKGlkKTtcblxuICAgICAgaWYgKGFkZCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxlbmd0aCsrO1xuICAgICAgICB0aGlzW2luZGV4XSA9IHRvQWRkRWxlO1xuICAgICAgICBtYXAuc2V0KGlkLCB7XG4gICAgICAgICAgZWxlOiB0b0FkZEVsZSxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXBsYWNlXG4gICAgICAgIHZhciBfaW5kZXggPSBtYXAuZ2V0KGlkKS5pbmRleDtcbiAgICAgICAgdGhpc1tfaW5kZXhdID0gdG9BZGRFbGU7XG4gICAgICAgIG1hcC5zZXQoaWQsIHtcbiAgICAgICAgICBlbGU6IHRvQWRkRWxlLFxuICAgICAgICAgIGluZGV4OiBfaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHVubWVyZ2VBdDogZnVuY3Rpb24gdW5tZXJnZUF0KGkpIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBtYXAgPSBfcC5tYXA7IC8vIHJlbW92ZSBlbGVcblxuICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgbWFwW1wiZGVsZXRlXCJdKGlkKTtcbiAgICB2YXIgdW5tZXJnZWRMYXN0RWxlID0gaSA9PT0gdGhpcy5sZW5ndGggLSAxOyAvLyByZXBsYWNlIGVtcHR5IHNwb3Qgd2l0aCBsYXN0IGVsZSBpbiBjb2xsZWN0aW9uXG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiAxICYmICF1bm1lcmdlZExhc3RFbGUpIHtcbiAgICAgIHZhciBsYXN0RWxlSSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBsYXN0RWxlID0gdGhpc1tsYXN0RWxlSV07XG4gICAgICB2YXIgbGFzdEVsZUlkID0gbGFzdEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdGhpc1tsYXN0RWxlSV0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzW2ldID0gbGFzdEVsZTtcbiAgICAgIG1hcC5zZXQobGFzdEVsZUlkLCB7XG4gICAgICAgIGVsZTogbGFzdEVsZSxcbiAgICAgICAgaW5kZXg6IGlcbiAgICAgIH0pO1xuICAgIH0gLy8gdGhlIGNvbGxlY3Rpb24gaXMgbm93IDEgZWxlIHNtYWxsZXJcblxuXG4gICAgdGhpcy5sZW5ndGgtLTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gcmVtb3ZlIHNpbmdsZSBlbGUgaW4gcGxhY2UgaW4gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2VPbmU6IGZ1bmN0aW9uIHVubWVyZ2VPbmUoZWxlKSB7XG4gICAgZWxlID0gZWxlWzBdO1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgdmFyIG1hcCA9IF9wLm1hcDtcbiAgICB2YXIgZW50cnkgPSBtYXAuZ2V0KGlkKTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBubyBuZWVkIHRvIHJlbW92ZVxuICAgIH1cblxuICAgIHZhciBpID0gZW50cnkuaW5kZXg7XG4gICAgdGhpcy51bm1lcmdlQXQoaSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIHJlbW92ZSBlbGVzIGluIHBsYWNlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICB1bm1lcmdlOiBmdW5jdGlvbiB1bm1lcmdlKHRvUmVtb3ZlKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmICghdG9SZW1vdmUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0b1JlbW92ZSAmJiBzdHJpbmcodG9SZW1vdmUpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0b1JlbW92ZTtcbiAgICAgIHRvUmVtb3ZlID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnVubWVyZ2VPbmUodG9SZW1vdmVbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICB1bm1lcmdlQnk6IGZ1bmN0aW9uIHVubWVyZ2VCeSh0b1JtRm4pIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgIGlmICh0b1JtRm4oZWxlKSkge1xuICAgICAgICB0aGlzLnVubWVyZ2VBdChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbWFwOiBmdW5jdGlvbiBtYXAobWFwRm4sIHRoaXNBcmcpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gbWFwRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogbWFwRm4oZWxlLCBpLCBlbGVzKTtcbiAgICAgIGFyci5wdXNoKHJldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbiAgfSxcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciB2YWwgPSBpbml0aWFsVmFsdWU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWwgPSBmbih2YWwsIGVsZXNbaV0sIGksIGVsZXMpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH0sXG4gIG1heDogZnVuY3Rpb24gbWF4KHZhbEZuLCB0aGlzQXJnKSB7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4RWxlO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgdmFsID0gdGhpc0FyZyA/IHZhbEZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IHZhbEZuKGVsZSwgaSwgZWxlcyk7XG5cbiAgICAgIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICBtYXhFbGUgPSBlbGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBtYXgsXG4gICAgICBlbGU6IG1heEVsZVxuICAgIH07XG4gIH0sXG4gIG1pbjogZnVuY3Rpb24gbWluKHZhbEZuLCB0aGlzQXJnKSB7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBtaW5FbGU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogdmFsRm4oZWxlLCBpLCBlbGVzKTtcblxuICAgICAgaWYgKHZhbCA8IG1pbikge1xuICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgIG1pbkVsZSA9IGVsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG1pbixcbiAgICAgIGVsZTogbWluRWxlXG4gICAgfTtcbiAgfVxufTsgLy8gYWxpYXNlc1xuXG52YXIgZm4kNSA9IGVsZXNmbiRuO1xuZm4kNVsndSddID0gZm4kNVsnfCddID0gZm4kNVsnKyddID0gZm4kNS51bmlvbiA9IGZuJDUub3IgPSBmbiQ1LmFkZDtcbmZuJDVbJ1xcXFwnXSA9IGZuJDVbJyEnXSA9IGZuJDVbJy0nXSA9IGZuJDUuZGlmZmVyZW5jZSA9IGZuJDUucmVsYXRpdmVDb21wbGVtZW50ID0gZm4kNS5zdWJ0cmFjdCA9IGZuJDUubm90O1xuZm4kNVsnbiddID0gZm4kNVsnJiddID0gZm4kNVsnLiddID0gZm4kNS5hbmQgPSBmbiQ1LmludGVyc2VjdGlvbiA9IGZuJDUuaW50ZXJzZWN0O1xuZm4kNVsnXiddID0gZm4kNVsnKCspJ10gPSBmbiQ1WycoLSknXSA9IGZuJDUuc3ltbWV0cmljRGlmZmVyZW5jZSA9IGZuJDUuc3ltZGlmZiA9IGZuJDUueG9yO1xuZm4kNS5mbkZpbHRlciA9IGZuJDUuZmlsdGVyRm4gPSBmbiQ1LnN0ZEZpbHRlciA9IGZuJDUuZmlsdGVyO1xuZm4kNS5jb21wbGVtZW50ID0gZm4kNS5hYnNjb21wID0gZm4kNS5hYnNvbHV0ZUNvbXBsZW1lbnQ7XG5cbnZhciBlbGVzZm4kbyA9IHtcbiAgaXNOb2RlOiBmdW5jdGlvbiBpc05vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ25vZGVzJztcbiAgfSxcbiAgaXNFZGdlOiBmdW5jdGlvbiBpc0VkZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ2VkZ2VzJztcbiAgfSxcbiAgaXNMb29wOiBmdW5jdGlvbiBpc0xvb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKVswXSA9PT0gdGhpcy50YXJnZXQoKVswXTtcbiAgfSxcbiAgaXNTaW1wbGU6IGZ1bmN0aW9uIGlzU2ltcGxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKClbMF0gIT09IHRoaXMudGFyZ2V0KClbMF07XG4gIH0sXG4gIGdyb3VwOiBmdW5jdGlvbiBncm91cCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JvdXA7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqICBFbGVtZW50cyBhcmUgZHJhd24gaW4gYSBzcGVjaWZpYyBvcmRlciBiYXNlZCBvbiBjb21wb3VuZCBkZXB0aCAobG93IHRvIGhpZ2gpLCB0aGUgZWxlbWVudCB0eXBlIChub2RlcyBhYm92ZSBlZGdlcyksXG4gKiAgYW5kIHotaW5kZXggKGxvdyB0byBoaWdoKS4gIFRoZXNlIHN0eWxlcyBhZmZlY3QgaG93IHRoaXMgYXBwbGllczpcbiAqXG4gKiAgei1jb21wb3VuZC1kZXB0aDogTWF5IGJlIGBib3R0b20gfCBvcnBoYW4gfCBhdXRvIHwgdG9wYC4gIFRoZSBmaXJzdCBkcmF3biBpcyBgYm90dG9tYCwgdGhlbiBgb3JwaGFuYCB3aGljaCBpcyB0aGVcbiAqICAgICAgc2FtZSBkZXB0aCBhcyB0aGUgcm9vdCBvZiB0aGUgY29tcG91bmQgZ3JhcGgsIGZvbGxvd2VkIGJ5IHRoZSBkZWZhdWx0IHZhbHVlIGBhdXRvYCB3aGljaCBkcmF3cyBpbiBvcmRlciBmcm9tXG4gKiAgICAgIHJvb3QgdG8gbGVhdmVzIG9mIHRoZSBjb21wb3VuZCBncmFwaC4gIFRoZSBsYXN0IGRyYXduIGlzIGB0b3BgLlxuICogIHotaW5kZXgtY29tcGFyZTogTWF5IGJlIGBhdXRvIHwgbWFudWFsYC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBhdXRvYCB3aGljaCBhbHdheXMgZHJhd3MgZWRnZXMgdW5kZXIgbm9kZXMuXG4gKiAgICAgIGBtYW51YWxgIGlnbm9yZXMgdGhpcyBjb252ZW50aW9uIGFuZCBkcmF3cyBiYXNlZCBvbiB0aGUgYHotaW5kZXhgIHZhbHVlIHNldHRpbmcuXG4gKiAgei1pbmRleDogQW4gaW50ZWdlciB2YWx1ZSB0aGF0IGFmZmVjdHMgdGhlIHJlbGF0aXZlIGRyYXcgb3JkZXIgb2YgZWxlbWVudHMuICBJbiBnZW5lcmFsLCBhbiBlbGVtZW50IHdpdGggYSBoaWdoZXJcbiAqICAgICAgYHotaW5kZXhgIHdpbGwgYmUgZHJhd24gb24gdG9wIG9mIGFuIGVsZW1lbnQgd2l0aCBhIGxvd2VyIGB6LWluZGV4YC5cbiAqL1xuXG52YXIgekluZGV4U29ydCA9IGZ1bmN0aW9uIHpJbmRleFNvcnQoYSwgYikge1xuICB2YXIgY3kgPSBhLmN5KCk7XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gIGZ1bmN0aW9uIGdldERlcHRoKGVsZSkge1xuICAgIHZhciBzdHlsZSA9IGVsZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKTtcblxuICAgIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gaGFzQ29tcG91bmROb2RlcyA/IGVsZS56RGVwdGgoKSA6IDA7XG4gICAgfSBlbHNlIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLnZhbHVlID09PSAndG9wJykge1xuICAgICAgcmV0dXJuIE1BWF9JTlQ7XG4gICAgfSAvLyAnb3JwaGFuJ1xuXG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBkZXB0aERpZmYgPSBnZXREZXB0aChhKSAtIGdldERlcHRoKGIpO1xuXG4gIGlmIChkZXB0aERpZmYgIT09IDApIHtcbiAgICByZXR1cm4gZGVwdGhEaWZmO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RWxlRGVwdGgoZWxlKSB7XG4gICAgdmFyIHN0eWxlID0gZWxlLnBzdHlsZSgnei1pbmRleC1jb21wYXJlJyk7XG5cbiAgICBpZiAoc3R5bGUudmFsdWUgPT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSA/IDEgOiAwO1xuICAgIH0gLy8gJ21hbnVhbCdcblxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgZWxlRGlmZiA9IGdldEVsZURlcHRoKGEpIC0gZ2V0RWxlRGVwdGgoYik7XG5cbiAgaWYgKGVsZURpZmYgIT09IDApIHtcbiAgICByZXR1cm4gZWxlRGlmZjtcbiAgfVxuXG4gIHZhciB6RGlmZiA9IGEucHN0eWxlKCd6LWluZGV4JykudmFsdWUgLSBiLnBzdHlsZSgnei1pbmRleCcpLnZhbHVlO1xuXG4gIGlmICh6RGlmZiAhPT0gMCkge1xuICAgIHJldHVybiB6RGlmZjtcbiAgfSAvLyBjb21wYXJlIGluZGljZXMgaW4gdGhlIGNvcmUgKG9yZGVyIGFkZGVkIHRvIGdyYXBoIHcvIGxhc3Qgb24gdG9wKVxuXG5cbiAgcmV0dXJuIGEucG9vbEluZGV4KCkgLSBiLnBvb2xJbmRleCgpO1xufTtcblxudmFyIGVsZXNmbiRwID0ge1xuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZuJDEsIHRoaXNBcmcpIHtcbiAgICBpZiAoZm4oZm4kMSkpIHtcbiAgICAgIHZhciBOID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IGZuJDEuYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgdGhpc10pIDogZm4kMShlbGUsIGksIHRoaXMpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gZXhpdCBlYWNoIGVhcmx5IG9uIHJldHVybiBmYWxzZVxuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2godGhpc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciB0aGlzU2l6ZSA9IHRoaXMubGVuZ3RoO1xuXG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSB0aGlzU2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgIHN0YXJ0ID0gdGhpc1NpemUgKyBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgZW5kID0gdGhpc1NpemUgKyBlbmQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpID49IDAgJiYgaSA8IGVuZCAmJiBpIDwgdGhpc1NpemU7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihhcnJheSk7XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICB9LFxuICBlcTogZnVuY3Rpb24gZXEoaSkge1xuICAgIHJldHVybiB0aGlzW2ldIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzWzBdIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcbiAgbGFzdDogZnVuY3Rpb24gbGFzdCgpIHtcbiAgICByZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcbiAgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcbiAgfSxcbiAgbm9uZW1wdHk6IGZ1bmN0aW9uIG5vbmVtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy5lbXB0eSgpO1xuICB9LFxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KHNvcnRGbikge1xuICAgIGlmICghZm4oc29ydEZuKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNvcnRlZCA9IHRoaXMudG9BcnJheSgpLnNvcnQoc29ydEZuKTtcbiAgICByZXR1cm4gdGhpcy5zcGF3bihzb3J0ZWQpO1xuICB9LFxuICBzb3J0QnlaSW5kZXg6IGZ1bmN0aW9uIHNvcnRCeVpJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3J0KHpJbmRleFNvcnQpO1xuICB9LFxuICB6RGVwdGg6IGZ1bmN0aW9uIHpEZXB0aCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmICghZWxlKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy8gbGV0IGN5ID0gZWxlLmN5KCk7XG5cblxuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgZ3JvdXAgPSBfcC5ncm91cDtcblxuICAgIGlmIChncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgdmFyIGRlcHRoID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpLnNpemUoKSA6IDA7XG5cbiAgICAgIGlmICghZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgcmV0dXJuIE1BWF9JTlQgLSAxOyAvLyBjaGlsZGxlc3Mgbm9kZXMgYWx3YXlzIG9uIHRvcFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgdmFyIHNyY0RlcHRoID0gc3JjLnpEZXB0aCgpO1xuICAgICAgdmFyIHRndERlcHRoID0gdGd0LnpEZXB0aCgpO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHNyY0RlcHRoLCB0Z3REZXB0aCwgMCk7IC8vIGRlcHRoIG9mIGRlZXBlc3QgcGFyZW50XG4gICAgfVxuICB9XG59O1xuZWxlc2ZuJHAuZWFjaCA9IGVsZXNmbiRwLmZvckVhY2g7XG5cbnZhciBnZXRMYXlvdXREaW1lbnNpb25PcHRpb25zID0gZGVmYXVsdHMoe1xuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kcSA9IHtcbiAgLy8gQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyBub2RlIGRpbWVuc2lvbnMgeyB4LCB5IH0gYmFzZWQgb24gb3B0aW9ucyBnaXZlblxuICBsYXlvdXREaW1lbnNpb25zOiBmdW5jdGlvbiBsYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZ2V0TGF5b3V0RGltZW5zaW9uT3B0aW9ucyhvcHRpb25zKTtcbiAgICB2YXIgZGltcztcblxuICAgIGlmICghdGhpcy50YWtlc1VwU3BhY2UoKSkge1xuICAgICAgZGltcyA9IHtcbiAgICAgICAgdzogMCxcbiAgICAgICAgaDogMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICB2YXIgYmJEaW0gPSB0aGlzLmJvdW5kaW5nQm94KCk7XG4gICAgICBkaW1zID0ge1xuICAgICAgICB3OiBiYkRpbS53LFxuICAgICAgICBoOiBiYkRpbS5oXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkaW1zID0ge1xuICAgICAgICB3OiB0aGlzLm91dGVyV2lkdGgoKSxcbiAgICAgICAgaDogdGhpcy5vdXRlckhlaWdodCgpXG4gICAgICB9O1xuICAgIH0gLy8gc2FuaXRpc2UgdGhlIGRpbWVuc2lvbnMgZm9yIGV4dGVybmFsIGxheW91dHMgKGF2b2lkIGRpdmlzaW9uIGJ5IHplcm8pXG5cblxuICAgIGlmIChkaW1zLncgPT09IDAgfHwgZGltcy5oID09PSAwKSB7XG4gICAgICBkaW1zLncgPSBkaW1zLmggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBkaW1zO1xuICB9LFxuICAvLyB1c2luZyBzdGFuZGFyZCBsYXlvdXQgb3B0aW9ucywgYXBwbHkgcG9zaXRpb24gZnVuY3Rpb24gKHcvIG9yIHcvbyBhbmltYXRpb24pXG4gIGxheW91dFBvc2l0aW9uczogZnVuY3Rpb24gbGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZm4pIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBsYXlvdXRFbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBub2RlcyAmIGVkZ2VzXG5cbiAgICB2YXIgZ2V0TWVtb2l6ZUtleSA9IGZ1bmN0aW9uIGdldE1lbW9pemVLZXkobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuaWQoKTtcbiAgICB9O1xuXG4gICAgdmFyIGZuTWVtID0gbWVtb2l6ZShmbiwgZ2V0TWVtb2l6ZUtleSk7IC8vIG1lbW9pemVkIHZlcnNpb24gb2YgcG9zaXRpb24gZnVuY3Rpb25cblxuICAgIGxheW91dC5lbWl0KHtcbiAgICAgIHR5cGU6ICdsYXlvdXRzdGFydCcsXG4gICAgICBsYXlvdXQ6IGxheW91dFxuICAgIH0pO1xuICAgIGxheW91dC5hbmltYXRpb25zID0gW107XG5cbiAgICB2YXIgY2FsY3VsYXRlU3BhY2luZyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcoc3BhY2luZywgbm9kZXNCYiwgcG9zKSB7XG4gICAgICB2YXIgY2VudGVyID0ge1xuICAgICAgICB4OiBub2Rlc0JiLngxICsgbm9kZXNCYi53IC8gMixcbiAgICAgICAgeTogbm9kZXNCYi55MSArIG5vZGVzQmIuaCAvIDJcbiAgICAgIH07XG4gICAgICB2YXIgc3BhY2luZ1ZlY3RvciA9IHtcbiAgICAgICAgLy8gc2NhbGUgZnJvbSBjZW50ZXIgb2YgYm91bmRpbmcgYm94IChub3QgbmVjZXNzYXJpbHkgMCwwKVxuICAgICAgICB4OiAocG9zLnggLSBjZW50ZXIueCkgKiBzcGFjaW5nLFxuICAgICAgICB5OiAocG9zLnkgLSBjZW50ZXIueSkgKiBzcGFjaW5nXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2VudGVyLnggKyBzcGFjaW5nVmVjdG9yLngsXG4gICAgICAgIHk6IGNlbnRlci55ICsgc3BhY2luZ1ZlY3Rvci55XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgdXNlU3BhY2luZ0ZhY3RvciA9IG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAmJiBvcHRpb25zLnNwYWNpbmdGYWN0b3IgIT09IDE7XG5cbiAgICB2YXIgc3BhY2luZ0JiID0gZnVuY3Rpb24gc3BhY2luZ0JiKCkge1xuICAgICAgaWYgKCF1c2VTcGFjaW5nRmFjdG9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgcG9zID0gZm5NZW0obm9kZSwgaSk7XG4gICAgICAgIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludChiYiwgcG9zLngsIHBvcy55KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJiO1xuICAgIH07XG5cbiAgICB2YXIgYmIgPSBzcGFjaW5nQmIoKTtcbiAgICB2YXIgZ2V0RmluYWxQb3MgPSBtZW1vaXplKGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICB2YXIgbmV3UG9zID0gZm5NZW0obm9kZSwgaSk7XG5cbiAgICAgIGlmICh1c2VTcGFjaW5nRmFjdG9yKSB7XG4gICAgICAgIHZhciBzcGFjaW5nID0gTWF0aC5hYnMob3B0aW9ucy5zcGFjaW5nRmFjdG9yKTtcbiAgICAgICAgbmV3UG9zID0gY2FsY3VsYXRlU3BhY2luZyhzcGFjaW5nLCBiYiwgbmV3UG9zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudHJhbnNmb3JtICE9IG51bGwpIHtcbiAgICAgICAgbmV3UG9zID0gb3B0aW9ucy50cmFuc2Zvcm0obm9kZSwgbmV3UG9zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICB9LCBnZXRNZW1vaXplS2V5KTtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIG5ld1BvcyA9IGdldEZpbmFsUG9zKG5vZGUsIGkpO1xuICAgICAgICB2YXIgYW5pbWF0ZU5vZGUgPSBvcHRpb25zLmFuaW1hdGVGaWx0ZXIgPT0gbnVsbCB8fCBvcHRpb25zLmFuaW1hdGVGaWx0ZXIobm9kZSwgaSk7XG5cbiAgICAgICAgaWYgKGFuaW1hdGVOb2RlKSB7XG4gICAgICAgICAgdmFyIGFuaSA9IG5vZGUuYW5pbWF0aW9uKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdQb3MsXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKGFuaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5wb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZpdCkge1xuICAgICAgICB2YXIgZml0QW5pID0gY3kuYW5pbWF0aW9uKHtcbiAgICAgICAgICBmaXQ6IHtcbiAgICAgICAgICAgIGJvdW5kaW5nQm94OiBsYXlvdXRFbGVzLmJvdW5kaW5nQm94QXQoZ2V0RmluYWxQb3MpLFxuICAgICAgICAgICAgcGFkZGluZzogb3B0aW9ucy5wYWRkaW5nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgIH0pO1xuICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKGZpdEFuaSk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucGFuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHpvb21QYW5BbmkgPSBjeS5hbmltYXRpb24oe1xuICAgICAgICAgIHpvb206IG9wdGlvbnMuem9vbSxcbiAgICAgICAgICBwYW46IG9wdGlvbnMucGFuLFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgfSk7XG4gICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goem9vbVBhbkFuaSk7XG4gICAgICB9XG5cbiAgICAgIGxheW91dC5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFuaSkge1xuICAgICAgICByZXR1cm4gYW5pLnBsYXkoKTtcbiAgICAgIH0pO1xuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2xheW91dHJlYWR5JyxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgIH0pO1xuICAgICAgUHJvbWlzZSQxLmFsbChsYXlvdXQuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaSkge1xuICAgICAgICByZXR1cm4gYW5pLnByb21pc2UoKTtcbiAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZXMucG9zaXRpb25zKGdldEZpbmFsUG9zKTtcblxuICAgICAgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICAgIGN5LmZpdChvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnpvb20gIT0gbnVsbCkge1xuICAgICAgICBjeS56b29tKG9wdGlvbnMuem9vbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnBhbikge1xuICAgICAgICBjeS5wYW4ob3B0aW9ucy5wYW4pO1xuICAgICAgfVxuXG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2xheW91dHN0b3AnLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgcmV0dXJuIGN5Lm1ha2VMYXlvdXQoZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICBlbGVzOiB0aGlzXG4gICAgfSkpO1xuICB9XG59OyAvLyBhbGlhc2VzOlxuXG5lbGVzZm4kcS5jcmVhdGVMYXlvdXQgPSBlbGVzZm4kcS5tYWtlTGF5b3V0ID0gZWxlc2ZuJHEubGF5b3V0O1xuXG5mdW5jdGlvbiBzdHlsZUNhY2hlKGtleSwgZm4sIGVsZSkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBjYWNoZSA9IF9wLnN0eWxlQ2FjaGUgPSBfcC5zdHlsZUNhY2hlIHx8IFtdO1xuICB2YXIgdmFsO1xuXG4gIGlmICgodmFsID0gY2FjaGVba2V5XSkgIT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gY2FjaGVba2V5XSA9IGZuKGVsZSk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWNoZVN0eWxlRnVuY3Rpb24oa2V5LCBmbikge1xuICBrZXkgPSBoYXNoU3RyaW5nKGtleSk7XG4gIHJldHVybiBmdW5jdGlvbiBjYWNoZWRTdHlsZUZ1bmN0aW9uKGVsZSkge1xuICAgIHJldHVybiBzdHlsZUNhY2hlKGtleSwgZm4sIGVsZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbihrZXksIGZuKSB7XG4gIGtleSA9IGhhc2hTdHJpbmcoa2V5KTtcblxuICB2YXIgc2VsZkZuID0gZnVuY3Rpb24gc2VsZkZuKGVsZSkge1xuICAgIHJldHVybiBmbi5jYWxsKGVsZSk7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZFByb3RvdHlwZVN0eWxlRnVuY3Rpb24oKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gc3R5bGVDYWNoZShrZXksIHNlbGZGbiwgZWxlKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBlbGVzZm4kciA9IHtcbiAgcmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlOiBmdW5jdGlvbiByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodXNlQ2FjaGUpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHJlbmRlcmVyID0gY3kucmVuZGVyZXIoKTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuc3R5bGVFbmFibGVkKCk7XG5cbiAgICBpZiAocmVuZGVyZXIgJiYgc3R5bGVFbmFibGVkKSB7XG4gICAgICByZW5kZXJlci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodGhpcywgdXNlQ2FjaGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkaXJ0eVN0eWxlQ2FjaGU6IGZ1bmN0aW9uIGRpcnR5U3R5bGVDYWNoZSgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICB2YXIgZGlydHkgPSBmdW5jdGlvbiBkaXJ0eShlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuc3R5bGVDYWNoZSA9IG51bGw7XG4gICAgfTtcblxuICAgIGlmIChjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgIHZhciBlbGVzO1xuICAgICAgZWxlcyA9IHRoaXMuc3Bhd25TZWxmKCkubWVyZ2UodGhpcy5kZXNjZW5kYW50cygpKS5tZXJnZSh0aGlzLnBhcmVudHMoKSk7XG4gICAgICBlbGVzLm1lcmdlKGVsZXMuY29ubmVjdGVkRWRnZXMoKSk7XG4gICAgICBlbGVzLmZvckVhY2goZGlydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBkaXJ0eShlbGUpO1xuICAgICAgICBlbGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGRpcnR5KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBmdWxseSB1cGRhdGVzIChyZWNhbGN1bGF0ZXMpIHRoZSBzdHlsZSBmb3IgdGhlIGVsZW1lbnRzXG4gIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiB1cGRhdGVTdHlsZShub3RpZnlSZW5kZXJlcikge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoY3kuYmF0Y2hpbmcoKSkge1xuICAgICAgdmFyIGJFbGVzID0gY3kuX3ByaXZhdGUuYmF0Y2hTdHlsZUVsZXM7XG4gICAgICBiRWxlcy5tZXJnZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZyBhbmQgZXhpdCBlYXJseSB3aGVuIGJhdGNoaW5nXG4gICAgfVxuXG4gICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIHZhciB1cGRhdGVkRWxlcyA9IHRoaXM7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSBub3RpZnlSZW5kZXJlciB8fCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgaWYgKGhhc0NvbXBvdW5kcykge1xuICAgICAgLy8gdGhlbiBhZGQgZXZlcnl0aGluZyB1cCBhbmQgZG93biBmb3IgY29tcG91bmQgc2VsZWN0b3IgY2hlY2tzXG4gICAgICB1cGRhdGVkRWxlcyA9IHRoaXMuc3Bhd25TZWxmKCkubWVyZ2UodGhpcy5kZXNjZW5kYW50cygpKS5tZXJnZSh0aGlzLnBhcmVudHMoKSk7XG4gICAgfVxuXG4gICAgdmFyIGNoYW5nZWRFbGVzID0gc3R5bGUuYXBwbHkodXBkYXRlZEVsZXMpO1xuXG4gICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICBjaGFuZ2VkRWxlcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgcmVuZGVyZXIga25vdyB3ZSBjaGFuZ2VkIHN0eWxlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5nZWRFbGVzLmVtaXQoJ3N0eWxlJyk7IC8vIGp1c3QgZmlyZSB0aGUgZXZlbnRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgLy8gZ2V0IHRoZSBpbnRlcm5hbCBwYXJzZWQgc3R5bGUgb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5XG4gIHBhcnNlZFN0eWxlOiBmdW5jdGlvbiBwYXJzZWRTdHlsZShwcm9wZXJ0eSkge1xuICAgIHZhciBpbmNsdWRlTm9uRGVmYXVsdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgb3ZlcnJpZGRlblN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlW3Byb3BlcnR5XTtcblxuICAgICAgaWYgKG92ZXJyaWRkZW5TdHlsZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZGVuU3R5bGU7XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVOb25EZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBjeS5zdHlsZSgpLmdldERlZmF1bHRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG51bWVyaWNTdHlsZTogZnVuY3Rpb24gbnVtZXJpY1N0eWxlKHByb3BlcnR5KSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIHBzdHlsZSA9IGVsZS5wc3R5bGUocHJvcGVydHkpO1xuICAgICAgcmV0dXJuIHBzdHlsZS5wZlZhbHVlICE9PSB1bmRlZmluZWQgPyBwc3R5bGUucGZWYWx1ZSA6IHBzdHlsZS52YWx1ZTtcbiAgICB9XG4gIH0sXG4gIG51bWVyaWNTdHlsZVVuaXRzOiBmdW5jdGlvbiBudW1lcmljU3R5bGVVbml0cyhwcm9wZXJ0eSkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKCFlbGUuY3koKS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKHByb3BlcnR5KS51bml0cztcbiAgICB9XG4gIH0sXG4gIC8vIGdldCB0aGUgc3BlY2lmaWVkIGNzcyBwcm9wZXJ0eSBhcyBhIHJlbmRlcmVkIHZhbHVlIChpLmUuIG9uLXNjcmVlbiB2YWx1ZSlcbiAgLy8gb3IgZ2V0IHRoZSB3aG9sZSByZW5kZXJlZCBzdHlsZSBpZiBubyBwcm9wZXJ0eSBzcGVjaWZpZWQgKE5CIGRvZXNuJ3QgYWxsb3cgc2V0dGluZylcbiAgcmVuZGVyZWRTdHlsZTogZnVuY3Rpb24gcmVuZGVyZWRTdHlsZShwcm9wZXJ0eSkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGN5LnN0eWxlKCkuZ2V0UmVuZGVyZWRTdHlsZShlbGUsIHByb3BlcnR5KTtcbiAgICB9XG4gIH0sXG4gIC8vIHJlYWQgdGhlIGNhbGN1bGF0ZWQgY3NzIHN0eWxlIG9mIHRoZSBlbGVtZW50IG9yIG92ZXJyaWRlIHRoZSBzdHlsZSAodmlhIGEgYnlwYXNzKVxuICBzdHlsZTogZnVuY3Rpb24gc3R5bGUobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuXG4gICAgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICAvLyB0aGVuIGV4dGVuZCB0aGUgYnlwYXNzXG4gICAgICB2YXIgcHJvcHMgPSBuYW1lO1xuICAgICAgc3R5bGUuYXBwbHlCeXBhc3ModGhpcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVuIHNldCB0aGUgYnlwYXNzIHdpdGggdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKHRoaXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIF9lbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoX2VsZSkge1xuICAgICAgICByZXR1cm4gc3R5bGUuZ2V0UmF3U3R5bGUoX2VsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbXB0eSBjb2xsZWN0aW9uID0+IGNhbid0IGdldCBhbnkgdmFsdWVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICByZW1vdmVTdHlsZTogZnVuY3Rpb24gcmVtb3ZlU3R5bGUobmFtZXMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGlmIChuYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHN0eWxlLnJlbW92ZUFsbEJ5cGFzc2VzKGVsZSwgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lcyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX2VsZTIgPSBlbGVzW19pXTtcbiAgICAgICAgc3R5bGUucmVtb3ZlQnlwYXNzZXMoX2VsZTIsIG5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnZWxlbWVudCcpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgZWZmZWN0aXZlT3BhY2l0eTogZnVuY3Rpb24gZWZmZWN0aXZlT3BhY2l0eSgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuXG4gICAgICBpZiAoIWhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnRzID0gIV9wLmRhdGEucGFyZW50ID8gbnVsbCA6IGVsZS5wYXJlbnRzKCk7XG5cbiAgICAgIGlmIChwYXJlbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgIHZhciBvcGFjaXR5ID0gcGFyZW50LnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuICAgICAgICAgIHBhcmVudE9wYWNpdHkgPSBvcGFjaXR5ICogcGFyZW50T3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50T3BhY2l0eTtcbiAgICB9XG4gIH0sXG4gIHRyYW5zcGFyZW50OiBmdW5jdGlvbiB0cmFuc3BhcmVudCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBlbGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAoIWhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZSA9PT0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpID09PSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmFja2dyb3VuZGluZzogZnVuY3Rpb24gYmFja2dyb3VuZGluZygpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5iYWNrZ3JvdW5kaW5nID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvdW5kKGVsZSwgcGFyZW50T2spIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcGFyZW50cyA9IF9wLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKSA6IG51bGw7XG5cbiAgaWYgKHBhcmVudHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuXG4gICAgICBpZiAoIXBhcmVudE9rKHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbihzcGVjcykge1xuICB2YXIgb2sgPSBzcGVjcy5vaztcbiAgdmFyIGVkZ2VPa1ZpYU5vZGUgPSBzcGVjcy5lZGdlT2tWaWFOb2RlIHx8IHNwZWNzLm9rO1xuICB2YXIgcGFyZW50T2sgPSBzcGVjcy5wYXJlbnRPayB8fCBzcGVjcy5vaztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgICAgaWYgKCFvayhlbGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICByZXR1cm4gIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZChlbGUsIHBhcmVudE9rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICAgIHJldHVybiBlZGdlT2tWaWFOb2RlKHNyYykgJiYgKCFoYXNDb21wb3VuZE5vZGVzIHx8IGNoZWNrQ29tcG91bmQoc3JjLCBlZGdlT2tWaWFOb2RlKSkgJiYgKHNyYyA9PT0gdGd0IHx8IGVkZ2VPa1ZpYU5vZGUodGd0KSAmJiAoIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZCh0Z3QsIGVkZ2VPa1ZpYU5vZGUpKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZWxlVGFrZXNVcFNwYWNlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVUYWtlc1VwU3BhY2UnLCBmdW5jdGlvbiAoZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdlbGVtZW50JyAmJiBlbGUud2lkdGgoKSAhPT0gMCAmJiAoZWxlLmlzTm9kZSgpID8gZWxlLmhlaWdodCgpICE9PSAwIDogdHJ1ZSk7XG59KTtcbmVsZXNmbiRyLnRha2VzVXBTcGFjZSA9IGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbigndGFrZXNVcFNwYWNlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlVGFrZXNVcFNwYWNlXG59KSk7XG52YXIgZWxlSW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZUludGVyYWN0aXZlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgnZXZlbnRzJykudmFsdWUgPT09ICd5ZXMnICYmIGVsZS5wc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PT0gJ3Zpc2libGUnICYmIGVsZVRha2VzVXBTcGFjZShlbGUpO1xufSk7XG52YXIgcGFyZW50SW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ3BhcmVudEludGVyYWN0aXZlJywgZnVuY3Rpb24gKHBhcmVudCkge1xuICByZXR1cm4gcGFyZW50LnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlVGFrZXNVcFNwYWNlKHBhcmVudCk7XG59KTtcbmVsZXNmbiRyLmludGVyYWN0aXZlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCdpbnRlcmFjdGl2ZScsIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHtcbiAgb2s6IGVsZUludGVyYWN0aXZlLFxuICBwYXJlbnRPazogcGFyZW50SW50ZXJhY3RpdmUsXG4gIGVkZ2VPa1ZpYU5vZGU6IGVsZVRha2VzVXBTcGFjZVxufSkpO1xuXG5lbGVzZm4kci5ub25pbnRlcmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmludGVyYWN0aXZlKCk7XG4gIH1cbn07XG5cbnZhciBlbGVWaXNpYmxlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVWaXNpYmxlJywgZnVuY3Rpb24gKGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlLnBzdHlsZSgnb3BhY2l0eScpLnBmVmFsdWUgIT09IDAgJiYgZWxlVGFrZXNVcFNwYWNlKGVsZSk7XG59KTtcbnZhciBlZGdlVmlzaWJsZVZpYU5vZGUgPSBlbGVUYWtlc1VwU3BhY2U7XG5lbGVzZm4kci52aXNpYmxlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCd2aXNpYmxlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlVmlzaWJsZSxcbiAgZWRnZU9rVmlhTm9kZTogZWRnZVZpc2libGVWaWFOb2RlXG59KSk7XG5cbmVsZXNmbiRyLmhpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnZpc2libGUoKTtcbiAgfVxufTtcblxuZWxlc2ZuJHIuaXNCdW5kbGVkQmV6aWVyID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCdpc0J1bmRsZWRCZXppZXInLCBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICF0aGlzLnJlbW92ZWQoKSAmJiB0aGlzLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZSA9PT0gJ2JlemllcicgJiYgdGhpcy50YWtlc1VwU3BhY2UoKTtcbn0pO1xuZWxlc2ZuJHIuYnlwYXNzID0gZWxlc2ZuJHIuY3NzID0gZWxlc2ZuJHIuc3R5bGU7XG5lbGVzZm4kci5yZW5kZXJlZENzcyA9IGVsZXNmbiRyLnJlbmRlcmVkU3R5bGU7XG5lbGVzZm4kci5yZW1vdmVCeXBhc3MgPSBlbGVzZm4kci5yZW1vdmVDc3MgPSBlbGVzZm4kci5yZW1vdmVTdHlsZTtcbmVsZXNmbiRyLnBzdHlsZSA9IGVsZXNmbiRyLnBhcnNlZFN0eWxlO1xuXG52YXIgZWxlc2ZuJHMgPSB7fTtcblxuZnVuY3Rpb24gZGVmaW5lU3dpdGNoRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGNoYW5nZWRFbGVzID0gW107IC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGRhdGEsIGhhbmRsZXIgKVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgZGF0YSA9IGFyZ3NbMF07XG4gICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMV07XG4gICAgICB0aGlzLm9uKHBhcmFtcy5ldmVudCwgZGF0YSwgaGFuZGxlcik7XG4gICAgfSAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBoYW5kbGVyIClcbiAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBmbihhcmdzWzBdKSkge1xuICAgICAgICB2YXIgX2hhbmRsZXIgPSBhcmdzWzBdO1xuICAgICAgICB0aGlzLm9uKHBhcmFtcy5ldmVudCwgX2hhbmRsZXIpO1xuICAgICAgfSAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KClcbiAgICAgIC8vIGUuZy4gKHByaXZhdGUpIGN5Lm5vZGVzKCkuc2VsZWN0KFsndGFwc2VsZWN0J10pXG4gICAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMCB8fCBhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgIHZhciBhZGRsRXZlbnRzID0gYXJncy5sZW5ndGggPT09IDEgPyBhcmdzWzBdIDogbnVsbDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgICB2YXIgYWJsZSA9ICFwYXJhbXMuYWJsZUZpZWxkIHx8IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYWJsZUZpZWxkXTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gIT0gcGFyYW1zLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLm92ZXJyaWRlQWJsZSkge1xuICAgICAgICAgICAgICB2YXIgb3ZlcnJpZGVBYmxlID0gcGFyYW1zLm92ZXJyaWRlQWJsZShlbGUpO1xuXG4gICAgICAgICAgICAgIGlmIChvdmVycmlkZUFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFibGUgPSBvdmVycmlkZUFibGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW92ZXJyaWRlQWJsZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSAvLyB0byBzYXZlIGN5Y2xlcyBhc3N1bWUgbm90IGFibGUgZm9yIGFsbCBvbiBvdmVycmlkZVxuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFibGUpIHtcbiAgICAgICAgICAgICAgZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gPSBwYXJhbXMudmFsdWU7XG5cbiAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRWxlcy5wdXNoKGVsZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2hhbmdlZENvbGwgPSB0aGlzLnNwYXduKGNoYW5nZWRFbGVzKTtcbiAgICAgICAgICBjaGFuZ2VkQ29sbC51cGRhdGVTdHlsZSgpOyAvLyBjaGFuZ2Ugb2Ygc3RhdGUgPT4gcG9zc2libGUgY2hhbmdlIG9mIHN0eWxlXG5cbiAgICAgICAgICBjaGFuZ2VkQ29sbC5lbWl0KHBhcmFtcy5ldmVudCk7XG5cbiAgICAgICAgICBpZiAoYWRkbEV2ZW50cykge1xuICAgICAgICAgICAgY2hhbmdlZENvbGwuZW1pdChhZGRsRXZlbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZpbmVTd2l0Y2hTZXQocGFyYW1zKSB7XG4gIGVsZXNmbiRzW3BhcmFtcy5maWVsZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAocGFyYW1zLm92ZXJyaWRlRmllbGQpIHtcbiAgICAgICAgdmFyIHZhbCA9IHBhcmFtcy5vdmVycmlkZUZpZWxkKGVsZSk7XG5cbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF07XG4gICAgfVxuICB9O1xuXG4gIGVsZXNmbiRzW3BhcmFtcy5vbl0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgZXZlbnQ6IHBhcmFtcy5vbixcbiAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGVsZXNmbiRzW3BhcmFtcy5vZmZdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgIGV2ZW50OiBwYXJhbXMub2ZmLFxuICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICB2YWx1ZTogZmFsc2VcbiAgfSk7XG59XG5cbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnbG9ja2VkJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24gb3ZlcnJpZGVGaWVsZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b2xvY2soKSA/IHRydWUgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnbG9jaycsXG4gIG9mZjogJ3VubG9jaydcbn0pO1xuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdncmFiYmFibGUnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5ncmFiaWZ5KCkgfHwgZWxlLnBhbm5hYmxlKCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdncmFiaWZ5JyxcbiAgb2ZmOiAndW5ncmFiaWZ5J1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3NlbGVjdGVkJyxcbiAgYWJsZUZpZWxkOiAnc2VsZWN0YWJsZScsXG4gIG92ZXJyaWRlQWJsZTogZnVuY3Rpb24gb3ZlcnJpZGVBYmxlKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ3NlbGVjdCcsXG4gIG9mZjogJ3Vuc2VsZWN0J1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3NlbGVjdGFibGUnLFxuICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ3NlbGVjdGlmeScsXG4gIG9mZjogJ3Vuc2VsZWN0aWZ5J1xufSk7XG5lbGVzZm4kcy5kZXNlbGVjdCA9IGVsZXNmbiRzLnVuc2VsZWN0O1xuXG5lbGVzZm4kcy5ncmFiYmVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcblxuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncmFiYmVkO1xuICB9XG59O1xuXG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ2FjdGl2ZScsXG4gIG9uOiAnYWN0aXZhdGUnLFxuICBvZmY6ICd1bmFjdGl2YXRlJ1xufSk7XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ3Bhbm5hYmxlJyxcbiAgb246ICdwYW5pZnknLFxuICBvZmY6ICd1bnBhbmlmeSdcbn0pO1xuXG5lbGVzZm4kcy5pbmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLl9wcml2YXRlLmFjdGl2ZTtcbiAgfVxufTtcblxudmFyIGVsZXNmbiR0ID0ge307IC8vIERBRyBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy9cblxudmFyIGRlZmluZURhZ0V4dHJlbWl0eSA9IGZ1bmN0aW9uIGRlZmluZURhZ0V4dHJlbWl0eShwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRhZ0V4dHJlbWl0eUltcGwoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXNxdWFsaWZpZWQgPSBmYWxzZTtcbiAgICAgIHZhciBlZGdlcyA9IGVsZS5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcblxuICAgICAgICBpZiAocGFyYW1zLm5vSW5jb21pbmdFZGdlcyAmJiB0Z3QgPT09IGVsZSAmJiBzcmMgIT09IGVsZSB8fCBwYXJhbXMubm9PdXRnb2luZ0VkZ2VzICYmIHNyYyA9PT0gZWxlICYmIHRndCAhPT0gZWxlKSB7XG4gICAgICAgICAgZGlzcXVhbGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRpc3F1YWxpZmllZCkge1xuICAgICAgICByZXQucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKHJldCwge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn07XG5cbnZhciBkZWZpbmVEYWdPbmVIb3AgPSBmdW5jdGlvbiBkZWZpbmVEYWdPbmVIb3AocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIG9FbGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VzID0gZWxlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuXG4gICAgICAgIGlmIChwYXJhbXMub3V0Z29pbmcgJiYgc3JjID09PSBlbGUpIHtcbiAgICAgICAgICBvRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgIG9FbGVzLnB1c2godGd0KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuaW5jb21pbmcgJiYgdGd0ID09PSBlbGUpIHtcbiAgICAgICAgICBvRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgIG9FbGVzLnB1c2goc3JjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKG9FbGVzLCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufTtcblxudmFyIGRlZmluZURhZ0FsbEhvcHMgPSBmdW5jdGlvbiBkZWZpbmVEYWdBbGxIb3BzKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBzRWxlcyA9IFtdO1xuICAgIHZhciBzRWxlc0lkcyA9IHt9O1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIG5leHQgPSBwYXJhbXMub3V0Z29pbmcgPyBlbGVzLm91dGdvZXJzKCkgOiBlbGVzLmluY29tZXJzKCk7XG5cbiAgICAgIGlmIChuZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gZG9uZSBpZiBub25lIGxlZnRcblxuXG4gICAgICB2YXIgbmV3TmV4dCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG4gPSBuZXh0W2ldO1xuICAgICAgICB2YXIgbmlkID0gbi5pZCgpO1xuXG4gICAgICAgIGlmICghc0VsZXNJZHNbbmlkXSkge1xuICAgICAgICAgIHNFbGVzSWRzW25pZF0gPSB0cnVlO1xuICAgICAgICAgIHNFbGVzLnB1c2gobik7XG4gICAgICAgICAgbmV3TmV4dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXdOZXh0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBkb25lIGlmIHRvdWNoZWQgYWxsIG91dGdvZXJzIGFscmVhZHlcblxuXG4gICAgICBlbGVzID0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3bihzRWxlcywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn07XG5cbmVsZXNmbiR0LmNsZWFyVHJhdmVyc2FsQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXNbaV0uX3ByaXZhdGUudHJhdmVyc2FsQ2FjaGUgPSBudWxsO1xuICB9XG59O1xuXG5leHRlbmQoZWxlc2ZuJHQsIHtcbiAgLy8gZ2V0IHRoZSByb290IG5vZGVzIGluIHRoZSBEQUdcbiAgcm9vdHM6IGRlZmluZURhZ0V4dHJlbWl0eSh7XG4gICAgbm9JbmNvbWluZ0VkZ2VzOiB0cnVlXG4gIH0pLFxuICAvLyBnZXQgdGhlIGxlYWYgbm9kZXMgaW4gdGhlIERBR1xuICBsZWF2ZXM6IGRlZmluZURhZ0V4dHJlbWl0eSh7XG4gICAgbm9PdXRnb2luZ0VkZ2VzOiB0cnVlXG4gIH0pLFxuICAvLyBub3JtYWxseSBjYWxsZWQgY2hpbGRyZW4gaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzID1lZGdlcz0+IG91dGdvaW5nIG5vZGVzXG4gIG91dGdvZXJzOiBjYWNoZShkZWZpbmVEYWdPbmVIb3Aoe1xuICAgIG91dGdvaW5nOiB0cnVlXG4gIH0pLCAnb3V0Z29lcnMnKSxcbiAgLy8gYWthIERBRyBkZXNjZW5kYW50c1xuICBzdWNjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHtcbiAgICBvdXRnb2luZzogdHJ1ZVxuICB9KSxcbiAgLy8gbm9ybWFsbHkgY2FsbGVkIHBhcmVudHMgaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzIDw9ZWRnZXM9IGluY29taW5nIG5vZGVzXG4gIGluY29tZXJzOiBjYWNoZShkZWZpbmVEYWdPbmVIb3Aoe1xuICAgIGluY29taW5nOiB0cnVlXG4gIH0pLCAnaW5jb21lcnMnKSxcbiAgLy8gYWthIERBRyBhbmNlc3RvcnNcbiAgcHJlZGVjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHtcbiAgICBpbmNvbWluZzogdHJ1ZVxuICB9KVxufSk7IC8vIE5laWdoYm91cmhvb2QgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHRlbmQoZWxlc2ZuJHQsIHtcbiAgbmVpZ2hib3Job29kOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBmb3IgYWxsIG5vZGVzXG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpOyAvLyBmb3IgZWFjaCBjb25uZWN0ZWQgZWRnZSwgYWRkIHRoZSBlZGdlIGFuZCB0aGUgb3RoZXIgbm9kZVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIG90aGVyTm9kZSA9IG5vZGUgPT09IHNyYyA/IHRndCA6IHNyYzsgLy8gbmVlZCBjaGVjayBpbiBjYXNlIG9mIGxvb3BcblxuICAgICAgICBpZiAob3RoZXJOb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKG90aGVyTm9kZVswXSk7IC8vIGFkZCBub2RlIDEgaG9wIGF3YXlcbiAgICAgICAgfSAvLyBhZGQgY29ubmVjdGVkIGVkZ2VcblxuXG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZVswXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sICduZWlnaGJvcmhvb2QnKSxcbiAgY2xvc2VkTmVpZ2hib3Job29kOiBmdW5jdGlvbiBjbG9zZWROZWlnaGJvcmhvb2Qoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoKS5hZGQodGhpcykuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSxcbiAgb3Blbk5laWdoYm9yaG9vZDogZnVuY3Rpb24gb3Blbk5laWdoYm9yaG9vZChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZChzZWxlY3Rvcik7XG4gIH1cbn0pOyAvLyBhbGlhc2VzXG5cbmVsZXNmbiR0Lm5laWdoYm91cmhvb2QgPSBlbGVzZm4kdC5uZWlnaGJvcmhvb2Q7XG5lbGVzZm4kdC5jbG9zZWROZWlnaGJvdXJob29kID0gZWxlc2ZuJHQuY2xvc2VkTmVpZ2hib3Job29kO1xuZWxlc2ZuJHQub3Blbk5laWdoYm91cmhvb2QgPSBlbGVzZm4kdC5vcGVuTmVpZ2hib3Job29kOyAvLyBFZGdlIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy9cblxuZXh0ZW5kKGVsZXNmbiR0LCB7XG4gIHNvdXJjZTogY2FjaGUoZnVuY3Rpb24gc291cmNlSW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBzcmM7XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlIHx8IGVsZS5jeSgpLmNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3JjICYmIHNlbGVjdG9yID8gc3JjLmZpbHRlcihzZWxlY3RvcikgOiBzcmM7XG4gIH0sICdzb3VyY2UnKSxcbiAgdGFyZ2V0OiBjYWNoZShmdW5jdGlvbiB0YXJnZXRJbXBsKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIHRndDtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHRndCA9IGVsZS5fcHJpdmF0ZS50YXJnZXQgfHwgZWxlLmN5KCkuY29sbGVjdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0Z3QgJiYgc2VsZWN0b3IgPyB0Z3QuZmlsdGVyKHNlbGVjdG9yKSA6IHRndDtcbiAgfSwgJ3RhcmdldCcpLFxuICBzb3VyY2VzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgYXR0cjogJ3NvdXJjZSdcbiAgfSksXG4gIHRhcmdldHM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICBhdHRyOiAndGFyZ2V0J1xuICB9KVxufSk7XG5cbmZ1bmN0aW9uIGRlZmluZVNvdXJjZUZ1bmN0aW9uKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gc291cmNlSW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBzb3VyY2VzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYXR0cl07XG5cbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHNyYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oc291cmNlcywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZXh0ZW5kKGVsZXNmbiR0LCB7XG4gIGVkZ2VzV2l0aDogY2FjaGUoZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oKSwgJ2VkZ2VzV2l0aCcpLFxuICBlZGdlc1RvOiBjYWNoZShkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbih7XG4gICAgdGhpc0lzU3JjOiB0cnVlXG4gIH0pLCAnZWRnZXNUbycpXG59KTtcblxuZnVuY3Rpb24gZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBlZGdlc1dpdGhJbXBsKG90aGVyTm9kZXMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBwID0gcGFyYW1zIHx8IHt9OyAvLyBnZXQgZWxlbWVudHMgaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWRcblxuICAgIGlmIChzdHJpbmcob3RoZXJOb2RlcykpIHtcbiAgICAgIG90aGVyTm9kZXMgPSBjeS4kKG90aGVyTm9kZXMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGggPSAwOyBoIDwgb3RoZXJOb2Rlcy5sZW5ndGg7IGgrKykge1xuICAgICAgdmFyIGVkZ2VzID0gb3RoZXJOb2Rlc1toXS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgZWRnZURhdGEgPSBlZGdlLl9wcml2YXRlLmRhdGE7XG4gICAgICAgIHZhciB0aGlzVG9PdGhlciA9IHRoaXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS5zb3VyY2UpICYmIG90aGVyTm9kZXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS50YXJnZXQpO1xuICAgICAgICB2YXIgb3RoZXJUb1RoaXMgPSBvdGhlck5vZGVzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEuc291cmNlKSAmJiB0aGlzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEudGFyZ2V0KTtcbiAgICAgICAgdmFyIGVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciA9IHRoaXNUb090aGVyIHx8IG90aGVyVG9UaGlzO1xuXG4gICAgICAgIGlmICghZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocC50aGlzSXNTcmMgfHwgcC50aGlzSXNUZ3QpIHtcbiAgICAgICAgICBpZiAocC50aGlzSXNTcmMgJiYgIXRoaXNUb090aGVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocC50aGlzSXNUZ3QgJiYgIW90aGVyVG9UaGlzKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KTtcbiAgfTtcbn1cblxuZXh0ZW5kKGVsZXNmbiR0LCB7XG4gIGNvbm5lY3RlZEVkZ2VzOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgcmV0RWxlcyA9IFtdO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiAoIW5vZGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgcmV0RWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKHJldEVsZXMsIHtcbiAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sICdjb25uZWN0ZWRFZGdlcycpLFxuICBjb25uZWN0ZWROb2RlczogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIHJldEVsZXMgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWxlc1tpXTtcblxuICAgICAgaWYgKCFlZGdlLmlzRWRnZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXRFbGVzLnB1c2goZWRnZS5zb3VyY2UoKVswXSk7XG4gICAgICByZXRFbGVzLnB1c2goZWRnZS50YXJnZXQoKVswXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ocmV0RWxlcywge1xuICAgICAgdW5pcXVlOiB0cnVlXG4gICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ2Nvbm5lY3RlZE5vZGVzJyksXG4gIHBhcmFsbGVsRWRnZXM6IGNhY2hlKGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbigpLCAncGFyYWxsZWxFZGdlcycpLFxuICBjb2RpcmVjdGVkRWRnZXM6IGNhY2hlKGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbih7XG4gICAgY29kaXJlY3RlZDogdHJ1ZVxuICB9KSwgJ2NvZGlyZWN0ZWRFZGdlcycpXG59KTtcblxuZnVuY3Rpb24gZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgY29kaXJlY3RlZDogZmFsc2VcbiAgfTtcbiAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBhcmFsbGVsRWRnZXNJbXBsKHNlbGVjdG9yKSB7XG4gICAgLy8gbWljcm8tb3B0aW1pc2VkIGZvciByZW5kZXJlclxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICB2YXIgcCA9IHBhcmFtczsgLy8gbG9vayBhdCBhbGwgdGhlIGVkZ2VzIGluIHRoZSBjb2xsZWN0aW9uXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWRnZTEgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBlZGdlMV9wID0gZWRnZTEuX3ByaXZhdGU7XG4gICAgICB2YXIgc3JjMSA9IGVkZ2UxX3Auc291cmNlO1xuICAgICAgdmFyIHNyY2lkMSA9IHNyYzEuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciB0Z3RpZDEgPSBlZGdlMV9wLmRhdGEudGFyZ2V0O1xuICAgICAgdmFyIHNyY0VkZ2VzMSA9IHNyYzEuX3ByaXZhdGUuZWRnZXM7IC8vIGxvb2sgYXQgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBzcmMgbm9kZSBvZiB0aGlzIGVkZ2VcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzcmNFZGdlczEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UyID0gc3JjRWRnZXMxW2pdO1xuICAgICAgICB2YXIgZWRnZTJkYXRhID0gZWRnZTIuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgdmFyIHRndGlkMiA9IGVkZ2UyZGF0YS50YXJnZXQ7XG4gICAgICAgIHZhciBzcmNpZDIgPSBlZGdlMmRhdGEuc291cmNlO1xuICAgICAgICB2YXIgY29kaXJlY3RlZCA9IHRndGlkMiA9PT0gdGd0aWQxICYmIHNyY2lkMiA9PT0gc3JjaWQxO1xuICAgICAgICB2YXIgb3BwZGlyZWN0ZWQgPSBzcmNpZDEgPT09IHRndGlkMiAmJiB0Z3RpZDEgPT09IHNyY2lkMjtcblxuICAgICAgICBpZiAocC5jb2RpcmVjdGVkICYmIGNvZGlyZWN0ZWQgfHwgIXAuY29kaXJlY3RlZCAmJiAoY29kaXJlY3RlZCB8fCBvcHBkaXJlY3RlZCkpIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2UyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB7XG4gICAgICB1bmlxdWU6IHRydWVcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufSAvLyBNaXNjIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy9cblxuXG5leHRlbmQoZWxlc2ZuJHQsIHtcbiAgY29tcG9uZW50czogZnVuY3Rpb24gY29tcG9uZW50cyhyb290KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeSA9IHNlbGYuY3koKTtcbiAgICB2YXIgdmlzaXRlZCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB2YXIgdW52aXNpdGVkID0gcm9vdCA9PSBudWxsID8gc2VsZi5ub2RlcygpIDogcm9vdC5ub2RlcygpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG5cbiAgICBpZiAocm9vdCAhPSBudWxsICYmIHVudmlzaXRlZC5lbXB0eSgpKSB7XG4gICAgICAvLyByb290IG1heSBjb250YWluIG9ubHkgZWRnZXNcbiAgICAgIHVudmlzaXRlZCA9IHJvb3Quc291cmNlcygpOyAvLyBkb2Vzbid0IG1hdHRlciB3aGljaCBub2RlIHRvIHVzZSAodW5kaXJlY3RlZCksIHNvIGp1c3QgdXNlIHRoZSBzb3VyY2Ugc2lkZXNcbiAgICB9XG5cbiAgICB2YXIgdmlzaXRJbkNvbXBvbmVudCA9IGZ1bmN0aW9uIHZpc2l0SW5Db21wb25lbnQobm9kZSwgY29tcG9uZW50KSB7XG4gICAgICB2aXNpdGVkLm1lcmdlKG5vZGUpO1xuICAgICAgdW52aXNpdGVkLnVubWVyZ2Uobm9kZSk7XG4gICAgICBjb21wb25lbnQubWVyZ2Uobm9kZSk7XG4gICAgfTtcblxuICAgIGlmICh1bnZpc2l0ZWQuZW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHNlbGYuc3Bhd24oKTtcbiAgICB9XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIC8vIGVhY2ggaXRlcmF0aW9uIHlpZWxkcyBhIGNvbXBvbmVudFxuICAgICAgdmFyIGNtcHQgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICBjb21wb25lbnRzLnB1c2goY21wdCk7XG4gICAgICB2YXIgcm9vdCA9IHVudmlzaXRlZFswXTtcbiAgICAgIHZpc2l0SW5Db21wb25lbnQocm9vdCwgY21wdCk7XG4gICAgICBzZWxmLmJmcyh7XG4gICAgICAgIGRpcmVjdGVkOiBmYWxzZSxcbiAgICAgICAgcm9vdHM6IHJvb3QsXG4gICAgICAgIHZpc2l0OiBmdW5jdGlvbiB2aXNpdCh2KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0SW5Db21wb25lbnQodiwgY21wdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY21wdC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgLy8gY29ubmVjdGVkRWRnZXMoKSB1c3VhbGx5IGNhY2hlZFxuICAgICAgICAgIGlmIChzZWxmLmhhcyhlKSAmJiBjbXB0LmhhcyhlLnNvdXJjZSgpKSAmJiBjbXB0LmhhcyhlLnRhcmdldCgpKSkge1xuICAgICAgICAgICAgLy8gaGFzKCkgaXMgY2hlYXBcbiAgICAgICAgICAgIGNtcHQubWVyZ2UoZSk7IC8vIGZvckVhY2goKSBvbmx5IGNvbnNpZGVycyBub2RlcyAtLSBzZXRzIE4gYXQgY2FsbCB0aW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBkbyB7XG4gICAgICBfbG9vcCgpO1xuICAgIH0gd2hpbGUgKHVudmlzaXRlZC5sZW5ndGggPiAwKTtcblxuICAgIHJldHVybiBjb21wb25lbnRzO1xuICB9LFxuICBjb21wb25lbnQ6IGZ1bmN0aW9uIGNvbXBvbmVudCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlLmN5KCkubXV0YWJsZUVsZW1lbnRzKCkuY29tcG9uZW50cyhlbGUpWzBdO1xuICB9XG59KTtcbmVsZXNmbiR0LmNvbXBvbmVudHNPZiA9IGVsZXNmbiR0LmNvbXBvbmVudHM7XG5cbnZhciBpZEZhY3RvcnkgPSB7XG4gIGdlbmVyYXRlOiBmdW5jdGlvbiBnZW5lcmF0ZShjeSwgZWxlbWVudCwgdHJ5VGhpc0lkKSB7XG4gICAgdmFyIGlkID0gdHJ5VGhpc0lkICE9IG51bGwgPyB0cnlUaGlzSWQgOiB1dWlkKCk7XG5cbiAgICB3aGlsZSAoY3kuaGFzRWxlbWVudFdpdGhJZChpZCkpIHtcbiAgICAgIGlkID0gdXVpZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBpZDtcbiAgfVxufTsgLy8gcmVwcmVzZW50cyBhIHNldCBvZiBub2RlcywgZWRnZXMsIG9yIGJvdGggdG9nZXRoZXJcblxudmFyIENvbGxlY3Rpb24gPSBmdW5jdGlvbiBDb2xsZWN0aW9uKGN5LCBlbGVtZW50cywgb3B0aW9ucykge1xuICBpZiAoY3kgPT09IHVuZGVmaW5lZCB8fCAhY29yZShjeSkpIHtcbiAgICBlcnJvcignQSBjb2xsZWN0aW9uIG11c3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29yZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXAgPSBuZXcgTWFwJDEoKTtcbiAgdmFyIGNyZWF0ZWRFbGVtZW50cyA9IGZhbHNlO1xuXG4gIGlmICghZWxlbWVudHMpIHtcbiAgICBlbGVtZW50cyA9IFtdO1xuICB9IGVsc2UgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgcGxhaW5PYmplY3QoZWxlbWVudHNbMF0pICYmICFlbGVtZW50KGVsZW1lbnRzWzBdKSkge1xuICAgIGNyZWF0ZWRFbGVtZW50cyA9IHRydWU7IC8vIG1ha2UgZWxlbWVudHMgZnJvbSBqc29uIGFuZCByZXN0b3JlIGFsbCBhdCBvbmNlIGxhdGVyXG5cbiAgICB2YXIgZWxlcyA9IFtdO1xuICAgIHZhciBlbGVzSWRzID0gbmV3IFNldCQxKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGpzb24gPSBlbGVtZW50c1tpXTtcblxuICAgICAgaWYgKGpzb24uZGF0YSA9PSBudWxsKSB7XG4gICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgX2RhdGEgPSBqc29uLmRhdGE7IC8vIG1ha2Ugc3VyZSBuZXdseSBjcmVhdGVkIGVsZW1lbnRzIGhhdmUgdmFsaWQgaWRzXG5cbiAgICAgIGlmIChfZGF0YS5pZCA9PSBudWxsKSB7XG4gICAgICAgIF9kYXRhLmlkID0gaWRGYWN0b3J5LmdlbmVyYXRlKGN5LCBqc29uKTtcbiAgICAgIH0gZWxzZSBpZiAoY3kuaGFzRWxlbWVudFdpdGhJZChfZGF0YS5pZCkgfHwgZWxlc0lkcy5oYXMoX2RhdGEuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBwcmlvciBpZCBhbHJlYWR5IGV4aXN0c1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gbmV3IEVsZW1lbnQoY3ksIGpzb24sIGZhbHNlKTtcbiAgICAgIGVsZXMucHVzaChlbGUpO1xuICAgICAgZWxlc0lkcy5hZGQoX2RhdGEuaWQpO1xuICAgIH1cblxuICAgIGVsZW1lbnRzID0gZWxlcztcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICBmb3IgKHZhciBfaSA9IDAsIF9sID0gZWxlbWVudHMubGVuZ3RoOyBfaSA8IF9sOyBfaSsrKSB7XG4gICAgdmFyIGVsZW1lbnQkMSA9IGVsZW1lbnRzW19pXVswXTsgLy8gWzBdIGluIGNhc2UgZWxlbWVudHMgaXMgYW4gYXJyYXkgb2YgY29sbGVjdGlvbnMsIHJhdGhlciB0aGFuIGFycmF5IG9mIGVsZW1lbnRzXG5cbiAgICBpZiAoZWxlbWVudCQxID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpZCA9IGVsZW1lbnQkMS5fcHJpdmF0ZS5kYXRhLmlkO1xuXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCB8fCBvcHRpb25zLnVuaXF1ZSAmJiAhbWFwLmhhcyhpZCkpIHtcbiAgICAgIG1hcC5zZXQoaWQsIHtcbiAgICAgICAgaW5kZXg6IHRoaXMubGVuZ3RoLFxuICAgICAgICBlbGU6IGVsZW1lbnQkMVxuICAgICAgfSk7XG4gICAgICB0aGlzW3RoaXMubGVuZ3RoXSA9IGVsZW1lbnQkMTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgbWFwOiBtYXBcbiAgfTsgLy8gcmVzdG9yZSB0aGUgZWxlbWVudHMgaWYgd2UgY3JlYXRlZCB0aGVtIGZyb20ganNvblxuXG4gIGlmIChjcmVhdGVkRWxlbWVudHMpIHtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTsgLy8gRnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBrZWVwIHRoZSBwcm90b3R5cGVzIGluIHN5bmMgKGFuIGVsZW1lbnQgaGFzIHRoZSBzYW1lIGZ1bmN0aW9ucyBhcyBhIGNvbGxlY3Rpb24pXG4vLyBhbmQgdXNlIGVsZWZuIGFuZCBlbGVzZm4gYXMgc2hvcnRoYW5kcyB0byB0aGUgcHJvdG90eXBlc1xuXG5cbnZhciBlbGVzZm4kdSA9IEVsZW1lbnQucHJvdG90eXBlID0gQ29sbGVjdGlvbi5wcm90b3R5cGU7XG5cbmVsZXNmbiR1Lmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ2NvbGxlY3Rpb24nO1xufTtcblxuZWxlc2ZuJHUuc3Bhd24gPSBmdW5jdGlvbiAoY3ksIGVsZXMsIG9wdHMpIHtcbiAgaWYgKCFjb3JlKGN5KSkge1xuICAgIC8vIGN5IGlzIG9wdGlvbmFsXG4gICAgb3B0cyA9IGVsZXM7XG4gICAgZWxlcyA9IGN5O1xuICAgIGN5ID0gdGhpcy5jeSgpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKGN5LCBlbGVzLCBvcHRzKTtcbn07XG5cbmVsZXNmbiR1LnNwYXduU2VsZiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc3Bhd24odGhpcyk7XG59O1xuXG5lbGVzZm4kdS5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG59O1xuXG5lbGVzZm4kdS5yZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3kucmVuZGVyZXIoKTtcbn07XG5cbmVsZXNmbiR1LmVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzWzBdO1xufTtcblxuZWxlc2ZuJHUuY29sbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbGxlY3Rpb24odGhpcykpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICAvLyBhbiBlbGVtZW50XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIFt0aGlzXSk7XG4gIH1cbn07XG5cbmVsZXNmbiR1LnVuaXF1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIHRoaXMsIHtcbiAgICB1bmlxdWU6IHRydWVcbiAgfSk7XG59O1xuXG5lbGVzZm4kdS5oYXNFbGVtZW50V2l0aElkID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlkID0gJycgKyBpZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuaGFzKGlkKTtcbn07XG5cbmVsZXNmbiR1LmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlkID0gJycgKyBpZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gIHZhciBlbnRyeSA9IHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCk7XG5cbiAgcmV0dXJuIGVudHJ5ID8gZW50cnkuZWxlIDogbmV3IENvbGxlY3Rpb24oY3kpOyAvLyBnZXQgZWxlIG9yIGVtcHR5IGNvbGxlY3Rpb25cbn07XG5cbmVsZXNmbiR1LiRpZCA9IGVsZXNmbiR1LmdldEVsZW1lbnRCeUlkO1xuXG5lbGVzZm4kdS5wb29sSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gIHZhciBpZCA9IHRoaXNbMF0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgcmV0dXJuIGVsZXMuX3ByaXZhdGUubWFwLmdldChpZCkuaW5kZXg7XG59O1xuXG5lbGVzZm4kdS5pbmRleE9mID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgaWQgPSBlbGVbMF0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWFwLmdldChpZCkuaW5kZXg7XG59O1xuXG5lbGVzZm4kdS5pbmRleE9mSWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gIHJldHVybiB0aGlzLl9wcml2YXRlLm1hcC5nZXQoaWQpLmluZGV4O1xufTtcblxuZWxlc2ZuJHUuanNvbiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGVsZSA9IHRoaXMuZWxlbWVudCgpO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgaWYgKGVsZSA9PSBudWxsICYmIG9iaikge1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIGNhbid0IHNldCB0byBubyBlbGVzXG5cblxuICBpZiAoZWxlID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IC8vIGNhbid0IGdldCBmcm9tIG5vIGVsZXNcblxuXG4gIHZhciBwID0gZWxlLl9wcml2YXRlO1xuXG4gIGlmIChwbGFpbk9iamVjdChvYmopKSB7XG4gICAgLy8gc2V0XG4gICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgaWYgKG9iai5kYXRhKSB7XG4gICAgICBlbGUuZGF0YShvYmouZGF0YSk7XG4gICAgICB2YXIgX2RhdGEyID0gcC5kYXRhO1xuXG4gICAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICAgIC8vIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBpbW11dGFibGUgdmlhIGRhdGEoKVxuICAgICAgICB2YXIgbW92ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgc3BlYyA9IHt9O1xuICAgICAgICB2YXIgc3JjID0gb2JqLmRhdGEuc291cmNlO1xuICAgICAgICB2YXIgdGd0ID0gb2JqLmRhdGEudGFyZ2V0O1xuXG4gICAgICAgIGlmIChzcmMgIT0gbnVsbCAmJiBzcmMgIT0gX2RhdGEyLnNvdXJjZSkge1xuICAgICAgICAgIHNwZWMuc291cmNlID0gJycgKyBzcmM7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgICAgICAgICBtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0Z3QgIT0gbnVsbCAmJiB0Z3QgIT0gX2RhdGEyLnRhcmdldCkge1xuICAgICAgICAgIHNwZWMudGFyZ2V0ID0gJycgKyB0Z3Q7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgICAgICAgICBtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3ZlKSB7XG4gICAgICAgICAgZWxlID0gZWxlLm1vdmUoc3BlYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhcmVudCBpcyBpbW11dGFibGUgdmlhIGRhdGEoKVxuICAgICAgICB2YXIgcGFyZW50ID0gb2JqLmRhdGEucGFyZW50O1xuXG4gICAgICAgIGlmICgocGFyZW50ICE9IG51bGwgfHwgX2RhdGEyLnBhcmVudCAhPSBudWxsKSAmJiBwYXJlbnQgIT0gX2RhdGEyLnBhcmVudCkge1xuICAgICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gY2FuJ3Qgc2V0IHVuZGVmaW5lZCBpbXBlcmF0aXZlbHksIHNvIHVzZSBudWxsXG4gICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50ID0gJycgKyBwYXJlbnQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlID0gZWxlLm1vdmUoe1xuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvYmoucG9zaXRpb24pIHtcbiAgICAgIGVsZS5wb3NpdGlvbihvYmoucG9zaXRpb24pO1xuICAgIH0gLy8gaWdub3JlIGdyb3VwIC0tIGltbXV0YWJsZVxuXG5cbiAgICB2YXIgY2hlY2tTd2l0Y2ggPSBmdW5jdGlvbiBjaGVja1N3aXRjaChrLCB0cnVlRm5OYW1lLCBmYWxzZUZuTmFtZSkge1xuICAgICAgdmFyIG9ial9rID0gb2JqW2tdO1xuXG4gICAgICBpZiAob2JqX2sgIT0gbnVsbCAmJiBvYmpfayAhPT0gcFtrXSkge1xuICAgICAgICBpZiAob2JqX2spIHtcbiAgICAgICAgICBlbGVbdHJ1ZUZuTmFtZV0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVbZmFsc2VGbk5hbWVdKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2hlY2tTd2l0Y2goJ3JlbW92ZWQnLCAncmVtb3ZlJywgJ3Jlc3RvcmUnKTtcbiAgICBjaGVja1N3aXRjaCgnc2VsZWN0ZWQnLCAnc2VsZWN0JywgJ3Vuc2VsZWN0Jyk7XG4gICAgY2hlY2tTd2l0Y2goJ3NlbGVjdGFibGUnLCAnc2VsZWN0aWZ5JywgJ3Vuc2VsZWN0aWZ5Jyk7XG4gICAgY2hlY2tTd2l0Y2goJ2xvY2tlZCcsICdsb2NrJywgJ3VubG9jaycpO1xuICAgIGNoZWNrU3dpdGNoKCdncmFiYmFibGUnLCAnZ3JhYmlmeScsICd1bmdyYWJpZnknKTtcbiAgICBjaGVja1N3aXRjaCgncGFubmFibGUnLCAncGFuaWZ5JywgJ3VucGFuaWZ5Jyk7XG5cbiAgICBpZiAob2JqLmNsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgZWxlLmNsYXNzZXMob2JqLmNsYXNzZXMpO1xuICAgIH1cblxuICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBnZXRcbiAgICB2YXIganNvbiA9IHtcbiAgICAgIGRhdGE6IGNvcHkocC5kYXRhKSxcbiAgICAgIHBvc2l0aW9uOiBjb3B5KHAucG9zaXRpb24pLFxuICAgICAgZ3JvdXA6IHAuZ3JvdXAsXG4gICAgICByZW1vdmVkOiBwLnJlbW92ZWQsXG4gICAgICBzZWxlY3RlZDogcC5zZWxlY3RlZCxcbiAgICAgIHNlbGVjdGFibGU6IHAuc2VsZWN0YWJsZSxcbiAgICAgIGxvY2tlZDogcC5sb2NrZWQsXG4gICAgICBncmFiYmFibGU6IHAuZ3JhYmJhYmxlLFxuICAgICAgcGFubmFibGU6IHAucGFubmFibGUsXG4gICAgICBjbGFzc2VzOiBudWxsXG4gICAgfTtcbiAgICBqc29uLmNsYXNzZXMgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgcC5jbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgcmV0dXJuIGpzb24uY2xhc3NlcyArPSBpKysgPT09IDAgPyBjbHMgOiAnICcgKyBjbHM7XG4gICAgfSk7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbn07XG5cbmVsZXNmbiR1Lmpzb25zID0gZnVuY3Rpb24gKCkge1xuICB2YXIganNvbnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG4gICAganNvbnMucHVzaChqc29uKTtcbiAgfVxuXG4gIHJldHVybiBqc29ucztcbn07XG5cbmVsZXNmbiR1LmNsb25lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBlbGVzQXJyID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgIHZhciBjbG9uZSA9IG5ldyBFbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7IC8vIE5CIG5vIHJlc3RvcmVcblxuICAgIGVsZXNBcnIucHVzaChjbG9uZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IENvbGxlY3Rpb24oY3ksIGVsZXNBcnIpO1xufTtcblxuZWxlc2ZuJHUuY29weSA9IGVsZXNmbiR1LmNsb25lO1xuXG5lbGVzZm4kdS5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm90aWZ5UmVuZGVyZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gIHZhciBhZGRUb1Bvb2wgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuICB2YXIgY3lfcCA9IGN5Ll9wcml2YXRlOyAvLyBjcmVhdGUgYXJyYXlzIG9mIG5vZGVzIGFuZCBlZGdlcywgc2luY2Ugd2UgbmVlZCB0b1xuICAvLyByZXN0b3JlIHRoZSBub2RlcyBmaXJzdFxuXG4gIHZhciBub2RlcyA9IFtdO1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgdmFyIGVsZW1lbnRzO1xuXG4gIGZvciAodmFyIF9pMiA9IDAsIGwgPSBzZWxmLmxlbmd0aDsgX2kyIDwgbDsgX2kyKyspIHtcbiAgICB2YXIgZWxlID0gc2VsZltfaTJdO1xuXG4gICAgaWYgKGFkZFRvUG9vbCAmJiAhZWxlLnJlbW92ZWQoKSkge1xuICAgICAgLy8gZG9uJ3QgbmVlZCB0byBoYW5kbGUgdGhpcyBlbGVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8ga2VlcCBub2RlcyBmaXJzdCBpbiB0aGUgYXJyYXkgYW5kIGVkZ2VzIGFmdGVyXG5cblxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIC8vIHB1dCB0byBmcm9udCBvZiBhcnJheSBpZiBub2RlXG4gICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHB1dCB0byBlbmQgb2YgYXJyYXkgaWYgZWRnZVxuICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgIH1cbiAgfVxuXG4gIGVsZW1lbnRzID0gbm9kZXMuY29uY2F0KGVkZ2VzKTtcbiAgdmFyIGk7XG5cbiAgdmFyIHJlbW92ZUZyb21FbGVtZW50cyA9IGZ1bmN0aW9uIHJlbW92ZUZyb21FbGVtZW50cygpIHtcbiAgICBlbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgaS0tO1xuICB9OyAvLyBub3csIHJlc3RvcmUgZWFjaCBlbGVtZW50XG5cblxuICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2VsZSA9IGVsZW1lbnRzW2ldO1xuICAgIHZhciBfcHJpdmF0ZSA9IF9lbGUuX3ByaXZhdGU7XG4gICAgdmFyIF9kYXRhMyA9IF9wcml2YXRlLmRhdGE7IC8vIHRoZSB0cmF2ZXJzYWwgY2FjaGUgc2hvdWxkIHN0YXJ0IGZyZXNoIHdoZW4gZWxlIGlzIGFkZGVkXG5cbiAgICBfZWxlLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTsgLy8gc2V0IGlkIGFuZCB2YWxpZGF0ZVxuXG5cbiAgICBpZiAoIWFkZFRvUG9vbCAmJiAhX3ByaXZhdGUucmVtb3ZlZCkgOyBlbHNlIGlmIChfZGF0YTMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgX2RhdGEzLmlkID0gaWRGYWN0b3J5LmdlbmVyYXRlKGN5LCBfZWxlKTtcbiAgICB9IGVsc2UgaWYgKG51bWJlcihfZGF0YTMuaWQpKSB7XG4gICAgICBfZGF0YTMuaWQgPSAnJyArIF9kYXRhMy5pZDsgLy8gbm93IGl0J3MgYSBzdHJpbmdcbiAgICB9IGVsc2UgaWYgKGVtcHR5U3RyaW5nKF9kYXRhMy5pZCkgfHwgIXN0cmluZyhfZGF0YTMuaWQpKSB7XG4gICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIGludmFsaWQgc3RyaW5nIElEIGAnICsgX2RhdGEzLmlkICsgJ2AnKTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgaXQgaGFzIGVtcHR5IHN0cmluZyBhcyBpZCBvciBub24tc3RyaW5nIGlkXG5cbiAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChjeS5oYXNFbGVtZW50V2l0aElkKF9kYXRhMy5pZCkpIHtcbiAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBzZWNvbmQgZWxlbWVudCB3aXRoIElEIGAnICsgX2RhdGEzLmlkICsgJ2AnKTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgb25lIGFscmVhZHkgaGFzIHRoYXQgaWRcblxuICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBfZGF0YTMuaWQ7IC8vIGlkIGlzIGZpbmFsaXNlZCwgbm93IGxldCdzIGtlZXAgYSByZWZcblxuICAgIGlmIChfZWxlLmlzTm9kZSgpKSB7XG4gICAgICAvLyBleHRyYSBjaGVja3MgZm9yIG5vZGVzXG4gICAgICB2YXIgcG9zID0gX3ByaXZhdGUucG9zaXRpb247IC8vIG1ha2Ugc3VyZSB0aGUgbm9kZXMgaGF2ZSBhIGRlZmluZWQgcG9zaXRpb25cblxuICAgICAgaWYgKHBvcy54ID09IG51bGwpIHtcbiAgICAgICAgcG9zLnggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zLnkgPT0gbnVsbCkge1xuICAgICAgICBwb3MueSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9lbGUuaXNFZGdlKCkpIHtcbiAgICAgIC8vIGV4dHJhIGNoZWNrcyBmb3IgZWRnZXNcbiAgICAgIHZhciBlZGdlID0gX2VsZTtcbiAgICAgIHZhciBmaWVsZHMgPSBbJ3NvdXJjZScsICd0YXJnZXQnXTtcbiAgICAgIHZhciBmaWVsZHNMZW5ndGggPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgdmFyIGJhZFNvdXJjZU9yVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2pdO1xuICAgICAgICB2YXIgdmFsID0gX2RhdGEzW2ZpZWxkXTtcblxuICAgICAgICBpZiAobnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICB2YWwgPSBfZGF0YTNbZmllbGRdID0gJycgKyBfZGF0YTNbZmllbGRdOyAvLyBub3cgc3RyaW5nXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsID09PSAnJykge1xuICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGlzIG5vdCBkZWZpbmVkIHByb3Blcmx5XG4gICAgICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggdW5zcGVjaWZpZWQgJyArIGZpZWxkKTtcbiAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWN5Lmhhc0VsZW1lbnRXaXRoSWQodmFsKSkge1xuICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBlZGdlIGlmIG9uZSBvZiBpdHMgbm9kZXMgZG9lc24ndCBleGlzdFxuICAgICAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIG5vbmV4aXN0YW50ICcgKyBmaWVsZCArICcgYCcgKyB2YWwgKyAnYCcpO1xuICAgICAgICAgIGJhZFNvdXJjZU9yVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYmFkU291cmNlT3JUYXJnZXQpIHtcbiAgICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBjYW4ndCBjcmVhdGUgdGhpc1xuXG5cbiAgICAgIHZhciBzcmMgPSBjeS5nZXRFbGVtZW50QnlJZChfZGF0YTMuc291cmNlKTtcbiAgICAgIHZhciB0Z3QgPSBjeS5nZXRFbGVtZW50QnlJZChfZGF0YTMudGFyZ2V0KTsgLy8gb25seSBvbmUgZWRnZSBpbiBub2RlIGlmIGxvb3BcblxuICAgICAgaWYgKHNyYy5zYW1lKHRndCkpIHtcbiAgICAgICAgc3JjLl9wcml2YXRlLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcmMuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcblxuICAgICAgICB0Z3QuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgIH1cblxuICAgICAgZWRnZS5fcHJpdmF0ZS5zb3VyY2UgPSBzcmM7XG4gICAgICBlZGdlLl9wcml2YXRlLnRhcmdldCA9IHRndDtcbiAgICB9IC8vIGlmIGlzIGVkZ2VcbiAgICAvLyBjcmVhdGUgbW9jayBpZHMgLyBpbmRleGVzIG1hcHMgZm9yIGVsZW1lbnQgc28gaXQgY2FuIGJlIHVzZWQgbGlrZSBjb2xsZWN0aW9uc1xuXG5cbiAgICBfcHJpdmF0ZS5tYXAgPSBuZXcgTWFwJDEoKTtcblxuICAgIF9wcml2YXRlLm1hcC5zZXQoaWQsIHtcbiAgICAgIGVsZTogX2VsZSxcbiAgICAgIGluZGV4OiAwXG4gICAgfSk7XG5cbiAgICBfcHJpdmF0ZS5yZW1vdmVkID0gZmFsc2U7XG5cbiAgICBpZiAoYWRkVG9Qb29sKSB7XG4gICAgICBjeS5hZGRUb1Bvb2woX2VsZSk7XG4gICAgfVxuICB9IC8vIGZvciBlYWNoIGVsZW1lbnRcbiAgLy8gZG8gY29tcG91bmQgbm9kZSBzYW5pdHkgY2hlY2tzXG5cblxuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBub2Rlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgLy8gZWFjaCBub2RlXG4gICAgdmFyIG5vZGUgPSBub2Rlc1tfaTNdO1xuICAgIHZhciBfZGF0YTQgPSBub2RlLl9wcml2YXRlLmRhdGE7XG5cbiAgICBpZiAobnVtYmVyKF9kYXRhNC5wYXJlbnQpKSB7XG4gICAgICAvLyB0aGVuIGF1dG9tYWtlIHN0cmluZ1xuICAgICAgX2RhdGE0LnBhcmVudCA9ICcnICsgX2RhdGE0LnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50SWQgPSBfZGF0YTQucGFyZW50O1xuICAgIHZhciBzcGVjaWZpZWRQYXJlbnQgPSBwYXJlbnRJZCAhPSBudWxsO1xuXG4gICAgaWYgKHNwZWNpZmllZFBhcmVudCkge1xuICAgICAgdmFyIHBhcmVudCA9IGN5LmdldEVsZW1lbnRCeUlkKHBhcmVudElkKTtcblxuICAgICAgaWYgKHBhcmVudC5lbXB0eSgpKSB7XG4gICAgICAgIC8vIG5vbi1leGlzdGFudCBwYXJlbnQ7IGp1c3QgcmVtb3ZlIGl0XG4gICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2VsZkFzUGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBhbmNlc3RvciA9IHBhcmVudDtcblxuICAgICAgICB3aGlsZSAoIWFuY2VzdG9yLmVtcHR5KCkpIHtcbiAgICAgICAgICBpZiAobm9kZS5zYW1lKGFuY2VzdG9yKSkge1xuICAgICAgICAgICAgLy8gbWFyayBzZWxmIGFzIHBhcmVudCBhbmQgcmVtb3ZlIGZyb20gZGF0YVxuICAgICAgICAgICAgc2VsZkFzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7IC8vIHJlbW92ZSBwYXJlbnQgcmVmZXJlbmNlXG4gICAgICAgICAgICAvLyBleGl0IG9yIHdlIGxvb3AgZm9yZXZlclxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWxmQXNQYXJlbnQpIHtcbiAgICAgICAgICAvLyBjb25uZWN0IHdpdGggY2hpbGRyZW5cbiAgICAgICAgICBwYXJlbnRbMF0uX3ByaXZhdGUuY2hpbGRyZW4ucHVzaChub2RlKTtcblxuICAgICAgICAgIG5vZGUuX3ByaXZhdGUucGFyZW50ID0gcGFyZW50WzBdOyAvLyBsZXQgdGhlIGNvcmUga25vdyB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGhcblxuICAgICAgICAgIGN5X3AuaGFzQ29tcG91bmROb2RlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZWxzZVxuXG4gICAgfSAvLyBpZiBzcGVjaWZpZWQgcGFyZW50XG5cbiAgfSAvLyBmb3IgZWFjaCBub2RlXG5cblxuICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgIHZhciByZXN0b3JlZCA9IG5ldyBDb2xsZWN0aW9uKGN5LCBlbGVtZW50cyk7XG5cbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCByZXN0b3JlZC5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgX2VsZTIgPSByZXN0b3JlZFtfaTRdO1xuXG4gICAgICBpZiAoX2VsZTIuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGFkZGluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGVzIGZvciB0aGUgcGFyYWxsZWwgZWRnZXNcblxuXG4gICAgICBfZWxlMi5wYXJhbGxlbEVkZ2VzKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpOyAvLyBhZGRpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlIGZvciB0aGUgY29ubmVjdGVkIG5vZGVzXG5cblxuICAgICAgX2VsZTIuc291cmNlKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuXG4gICAgICBfZWxlMi50YXJnZXQoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gICAgfVxuXG4gICAgdmFyIHRvVXBkYXRlU3R5bGU7XG5cbiAgICBpZiAoY3lfcC5oYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICB0b1VwZGF0ZVN0eWxlID0gY3kuY29sbGVjdGlvbigpLm1lcmdlKHJlc3RvcmVkKS5tZXJnZShyZXN0b3JlZC5jb25uZWN0ZWROb2RlcygpKS5tZXJnZShyZXN0b3JlZC5wYXJlbnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvVXBkYXRlU3R5bGUgPSByZXN0b3JlZDtcbiAgICB9XG5cbiAgICB0b1VwZGF0ZVN0eWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpLnVwZGF0ZVN0eWxlKG5vdGlmeVJlbmRlcmVyKTtcblxuICAgIGlmIChub3RpZnlSZW5kZXJlcikge1xuICAgICAgcmVzdG9yZWQuZW1pdEFuZE5vdGlmeSgnYWRkJyk7XG4gICAgfSBlbHNlIGlmIChhZGRUb1Bvb2wpIHtcbiAgICAgIHJlc3RvcmVkLmVtaXQoJ2FkZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmOyAvLyBjaGFpbmFiaWxpdHlcbn07XG5cbmVsZXNmbiR1LnJlbW92ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlICYmIGVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xufTtcblxuZWxlc2ZuJHUuaW5zaWRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgcmV0dXJuIGVsZSAmJiAhZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG59O1xuXG5lbGVzZm4kdS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub3RpZnlSZW5kZXJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgdmFyIHJlbW92ZUZyb21Qb29sID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlbGVzVG9SZW1vdmUgPSBbXTtcbiAgdmFyIGVsZXNUb1JlbW92ZUlkcyA9IHt9O1xuICB2YXIgY3kgPSBzZWxmLl9wcml2YXRlLmN5OyAvLyBhZGQgY29ubmVjdGVkIGVkZ2VzXG5cbiAgZnVuY3Rpb24gYWRkQ29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGQoZWRnZXNbaV0pO1xuICAgIH1cbiAgfSAvLyBhZGQgZGVzY2VuZGFudCBub2Rlc1xuXG5cbiAgZnVuY3Rpb24gYWRkQ2hpbGRyZW4obm9kZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGQoY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZChlbGUpIHtcbiAgICB2YXIgYWxyZWFkeUFkZGVkID0gZWxlc1RvUmVtb3ZlSWRzW2VsZS5pZCgpXTtcblxuICAgIGlmIChyZW1vdmVGcm9tUG9vbCAmJiBlbGUucmVtb3ZlZCgpIHx8IGFscmVhZHlBZGRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmVJZHNbZWxlLmlkKCldID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBlbGVzVG9SZW1vdmUucHVzaChlbGUpOyAvLyBub2RlcyBhcmUgcmVtb3ZlZCBsYXN0XG5cbiAgICAgIGFkZENvbm5lY3RlZEVkZ2VzKGVsZSk7XG4gICAgICBhZGRDaGlsZHJlbihlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmUudW5zaGlmdChlbGUpOyAvLyBlZGdlcyBhcmUgcmVtb3ZlZCBmaXJzdFxuICAgIH1cbiAgfSAvLyBtYWtlIHRoZSBsaXN0IG9mIGVsZW1lbnRzIHRvIHJlbW92ZVxuICAvLyAobWF5IGJlIHJlbW92aW5nIG1vcmUgdGhhbiBzcGVjaWZpZWQgZHVlIHRvIGNvbm5lY3RlZCBlZGdlcyBldGMpXG5cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IHNlbGZbaV07XG4gICAgYWRkKGVsZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVFZGdlUmVmKG5vZGUsIGVkZ2UpIHtcbiAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgIHJlbW92ZUZyb21BcnJheShjb25uZWN0ZWRFZGdlcywgZWRnZSk7IC8vIHJlbW92aW5nIGFuIGVkZ2VzIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGUgZm9yIGl0cyBub2Rlc1xuXG4gICAgbm9kZS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVQYXJhbGxlbFJlZihwbGxFZGdlKSB7XG4gICAgLy8gcmVtb3ZpbmcgYW4gZWRnZSBpbnZhbGlkYXRlcyB0aGUgdHJhdmVyc2FsIGNhY2hlcyBmb3IgdGhlIHBhcmFsbGVsIGVkZ2VzXG4gICAgcGxsRWRnZS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gIH1cblxuICB2YXIgYWx0ZXJlZFBhcmVudHMgPSBbXTtcbiAgYWx0ZXJlZFBhcmVudHMuaWRzID0ge307XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBlbGUpIHtcbiAgICBlbGUgPSBlbGVbMF07XG4gICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICB2YXIgcGlkID0gcGFyZW50LmlkKCk7XG4gICAgcmVtb3ZlRnJvbUFycmF5KGNoaWxkcmVuLCBlbGUpOyAvLyByZW1vdmUgcGFyZW50ID0+IGNoaWxkIHJlZlxuXG4gICAgZWxlLl9wcml2YXRlLnBhcmVudCA9IG51bGw7IC8vIHJlbW92ZSBjaGlsZCA9PiBwYXJlbnQgcmVmXG5cbiAgICBpZiAoIWFsdGVyZWRQYXJlbnRzLmlkc1twaWRdKSB7XG4gICAgICBhbHRlcmVkUGFyZW50cy5pZHNbcGlkXSA9IHRydWU7XG4gICAgICBhbHRlcmVkUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuICB9XG5cbiAgc2VsZi5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcblxuICBpZiAocmVtb3ZlRnJvbVBvb2wpIHtcbiAgICBjeS5yZW1vdmVGcm9tUG9vbChlbGVzVG9SZW1vdmUpOyAvLyByZW1vdmUgZnJvbSBjb3JlIHBvb2xcbiAgfVxuXG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IF9pNSsrKSB7XG4gICAgdmFyIF9lbGUzID0gZWxlc1RvUmVtb3ZlW19pNV07XG5cbiAgICBpZiAoX2VsZTMuaXNFZGdlKCkpIHtcbiAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2VzIHRvIHRoaXMgZWRnZSBpbiBpdHMgY29ubmVjdGVkIG5vZGVzXG4gICAgICB2YXIgc3JjID0gX2VsZTMuc291cmNlKClbMF07XG5cbiAgICAgIHZhciB0Z3QgPSBfZWxlMy50YXJnZXQoKVswXTtcblxuICAgICAgcmVtb3ZlRWRnZVJlZihzcmMsIF9lbGUzKTtcbiAgICAgIHJlbW92ZUVkZ2VSZWYodGd0LCBfZWxlMyk7XG5cbiAgICAgIHZhciBwbGxFZGdlcyA9IF9lbGUzLnBhcmFsbGVsRWRnZXMoKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwbGxFZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcGxsRWRnZSA9IHBsbEVkZ2VzW2pdO1xuICAgICAgICByZW1vdmVQYXJhbGxlbFJlZihwbGxFZGdlKTtcblxuICAgICAgICBpZiAocGxsRWRnZS5pc0J1bmRsZWRCZXppZXIoKSkge1xuICAgICAgICAgIHBsbEVkZ2UuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBwYXJlbnRcbiAgICAgIHZhciBwYXJlbnQgPSBfZWxlMy5wYXJlbnQoKTtcblxuICAgICAgaWYgKHBhcmVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBfZWxlMyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbW92ZUZyb21Qb29sKSB7XG4gICAgICAvLyBtYXJrIGFzIHJlbW92ZWRcbiAgICAgIF9lbGUzLl9wcml2YXRlLnJlbW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoIG9yIG5vdFxuXG5cbiAgdmFyIGVsZXNTdGlsbEluc2lkZSA9IGN5Ll9wcml2YXRlLmVsZW1lbnRzO1xuICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZWxlc1N0aWxsSW5zaWRlLmxlbmd0aDsgX2k2KyspIHtcbiAgICB2YXIgX2VsZTQgPSBlbGVzU3RpbGxJbnNpZGVbX2k2XTtcblxuICAgIGlmIChfZWxlNC5pc1BhcmVudCgpKSB7XG4gICAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZW1vdmVkRWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbih0aGlzLmN5KCksIGVsZXNUb1JlbW92ZSk7XG5cbiAgaWYgKHJlbW92ZWRFbGVtZW50cy5zaXplKCkgPiAwKSB7XG4gICAgLy8gbXVzdCBtYW51YWxseSBub3RpZnkgc2luY2UgdHJpZ2dlciB3b24ndCBkbyB0aGlzIGF1dG9tYXRpY2FsbHkgb25jZSByZW1vdmVkXG4gICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICByZW1vdmVkRWxlbWVudHMuZW1pdEFuZE5vdGlmeSgncmVtb3ZlJyk7XG4gICAgfSBlbHNlIGlmIChyZW1vdmVGcm9tUG9vbCkge1xuICAgICAgcmVtb3ZlZEVsZW1lbnRzLmVtaXQoJ3JlbW92ZScpO1xuICAgIH1cbiAgfSAvLyB0aGUgcGFyZW50cyB3aG8gd2VyZSBtb2RpZmllZCBieSB0aGUgcmVtb3ZhbCBuZWVkIHRoZWlyIHN0eWxlIHVwZGF0ZWRcblxuXG4gIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IGFsdGVyZWRQYXJlbnRzLmxlbmd0aDsgX2k3KyspIHtcbiAgICB2YXIgX2VsZTUgPSBhbHRlcmVkUGFyZW50c1tfaTddO1xuXG4gICAgaWYgKCFyZW1vdmVGcm9tUG9vbCB8fCAhX2VsZTUucmVtb3ZlZCgpKSB7XG4gICAgICBfZWxlNS51cGRhdGVTdHlsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZW1vdmVkRWxlbWVudHM7XG59O1xuXG5lbGVzZm4kdS5tb3ZlID0gZnVuY3Rpb24gKHN0cnVjdCkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlcyA9IHRoaXM7IC8vIGp1c3QgY2xlYW4gdXAgcmVmcywgY2FjaGVzLCBldGMuIGluIHRoZSBzYW1lIHdheSBhcyB3aGVuIHJlbW92aW5nIGFuZCB0aGVuIHJlc3RvcmluZ1xuICAvLyAob3VyIGNhbGxzIHRvIHJlbW92ZS9yZXN0b3JlIGRvIG5vdCByZW1vdmUgZnJvbSB0aGUgZ3JhcGggb3IgbWFrZSBldmVudHMpXG5cbiAgdmFyIG5vdGlmeVJlbmRlcmVyID0gZmFsc2U7XG4gIHZhciBtb2RpZnlQb29sID0gZmFsc2U7XG5cbiAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoaWQpIHtcbiAgICByZXR1cm4gaWQgPT0gbnVsbCA/IGlkIDogJycgKyBpZDtcbiAgfTsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuXG4gIGlmIChzdHJ1Y3Quc291cmNlICE9PSB1bmRlZmluZWQgfHwgc3RydWN0LnRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNyY0lkID0gdG9TdHJpbmcoc3RydWN0LnNvdXJjZSk7XG4gICAgdmFyIHRndElkID0gdG9TdHJpbmcoc3RydWN0LnRhcmdldCk7XG4gICAgdmFyIHNyY0V4aXN0cyA9IHNyY0lkICE9IG51bGwgJiYgY3kuaGFzRWxlbWVudFdpdGhJZChzcmNJZCk7XG4gICAgdmFyIHRndEV4aXN0cyA9IHRndElkICE9IG51bGwgJiYgY3kuaGFzRWxlbWVudFdpdGhJZCh0Z3RJZCk7XG5cbiAgICBpZiAoc3JjRXhpc3RzIHx8IHRndEV4aXN0cykge1xuICAgICAgY3kuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGUgc3R5bGUgdXBkYXRlc1xuICAgICAgICBlbGVzLnJlbW92ZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIGNsZWFuIHVwIHJlZnMgZXRjLlxuXG4gICAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZW91dCcpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHZhciBfZGF0YTUgPSBlbGUuX3ByaXZhdGUuZGF0YTtcblxuICAgICAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgICAgIGlmIChzcmNFeGlzdHMpIHtcbiAgICAgICAgICAgICAgX2RhdGE1LnNvdXJjZSA9IHNyY0lkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGd0RXhpc3RzKSB7XG4gICAgICAgICAgICAgIF9kYXRhNS50YXJnZXQgPSB0Z3RJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVzLnJlc3RvcmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBtYWtlIG5ldyByZWZzLCBzdHlsZSwgZXRjLlxuICAgICAgfSk7XG4gICAgICBlbGVzLmVtaXRBbmROb3RpZnkoJ21vdmUnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RydWN0LnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbW92ZSBub2RlIHRvIG5ldyBwYXJlbnRcbiAgICB2YXIgcGFyZW50SWQgPSB0b1N0cmluZyhzdHJ1Y3QucGFyZW50KTtcbiAgICB2YXIgcGFyZW50RXhpc3RzID0gcGFyZW50SWQgPT09IG51bGwgfHwgY3kuaGFzRWxlbWVudFdpdGhJZChwYXJlbnRJZCk7XG5cbiAgICBpZiAocGFyZW50RXhpc3RzKSB7XG4gICAgICB2YXIgcGlkVG9Bc3NpZ24gPSBwYXJlbnRJZCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBhcmVudElkO1xuICAgICAgY3kuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGUgc3R5bGUgdXBkYXRlc1xuICAgICAgICB2YXIgdXBkYXRlZCA9IGVsZXMucmVtb3ZlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gY2xlYW4gdXAgcmVmcyBldGMuXG5cbiAgICAgICAgdXBkYXRlZC5lbWl0QW5kTm90aWZ5KCdtb3Zlb3V0Jyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgdmFyIF9kYXRhNiA9IGVsZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgICAgX2RhdGE2LnBhcmVudCA9IHBpZFRvQXNzaWduO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZWQucmVzdG9yZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIG1ha2UgbmV3IHJlZnMsIHN0eWxlLCBldGMuXG4gICAgICB9KTtcbiAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZScpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuW2VsZXNmbiRjLCBlbGVzZm4kZCwgZWxlc2ZuJGUsIGVsZXNmbiRmLCBlbGVzZm4kZywgZGF0YSQxLCBlbGVzZm4kaSwgZGltZW5zaW9ucywgZWxlc2ZuJG0sIGVsZXNmbiRuLCBlbGVzZm4kbywgZWxlc2ZuJHAsIGVsZXNmbiRxLCBlbGVzZm4kciwgZWxlc2ZuJHMsIGVsZXNmbiR0XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoZWxlc2ZuJHUsIHByb3BzKTtcbn0pO1xuXG52YXIgY29yZWZuID0ge1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChvcHRzKSB7XG4gICAgdmFyIGVsZW1lbnRzO1xuICAgIHZhciBjeSA9IHRoaXM7IC8vIGFkZCB0aGUgZWxlbWVudHNcblxuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKG9wdHMpKSB7XG4gICAgICB2YXIgZWxlcyA9IG9wdHM7XG5cbiAgICAgIGlmIChlbGVzLl9wcml2YXRlLmN5ID09PSBjeSkge1xuICAgICAgICAvLyBzYW1lIGluc3RhbmNlID0+IGp1c3QgcmVzdG9yZVxuICAgICAgICBlbGVtZW50cyA9IGVsZXMucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBjb3B5IGZyb20ganNvblxuICAgICAgICB2YXIganNvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICBqc29ucy5wdXNoKGVsZS5qc29uKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgICAgfVxuICAgIH0gLy8gc3BlY2lmeSBhbiBhcnJheSBvZiBvcHRpb25zXG4gICAgZWxzZSBpZiAoYXJyYXkob3B0cykpIHtcbiAgICAgICAgdmFyIF9qc29ucyA9IG9wdHM7XG4gICAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oY3ksIF9qc29ucyk7XG4gICAgICB9IC8vIHNwZWNpZnkgdmlhIG9wdHMubm9kZXMgYW5kIG9wdHMuZWRnZXNcbiAgICAgIGVsc2UgaWYgKHBsYWluT2JqZWN0KG9wdHMpICYmIChhcnJheShvcHRzLm5vZGVzKSB8fCBhcnJheShvcHRzLmVkZ2VzKSkpIHtcbiAgICAgICAgICB2YXIgZWxlc0J5R3JvdXAgPSBvcHRzO1xuICAgICAgICAgIHZhciBfanNvbnMyID0gW107XG4gICAgICAgICAgdmFyIGdycyA9IFsnbm9kZXMnLCAnZWRnZXMnXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgaWwgPSBncnMubGVuZ3RoOyBfaSA8IGlsOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncnNbX2ldO1xuICAgICAgICAgICAgdmFyIGVsZXNBcnJheSA9IGVsZXNCeUdyb3VwW2dyb3VwXTtcblxuICAgICAgICAgICAgaWYgKGFycmF5KGVsZXNBcnJheSkpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsID0gZWxlc0FycmF5Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IGV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICBncm91cDogZ3JvdXBcbiAgICAgICAgICAgICAgICB9LCBlbGVzQXJyYXlbal0pO1xuXG4gICAgICAgICAgICAgICAgX2pzb25zMi5wdXNoKGpzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwgX2pzb25zMik7XG4gICAgICAgIH0gLy8gc3BlY2lmeSBvcHRpb25zIGZvciBvbmUgZWxlbWVudFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfanNvbiA9IG9wdHM7XG4gICAgICAgICAgICBlbGVtZW50cyA9IG5ldyBFbGVtZW50KGN5LCBfanNvbikuY29sbGVjdGlvbigpO1xuICAgICAgICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50cztcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY29sbGVjdGlvbikge1xuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGNvbGxlY3Rpb24pKSA7IGVsc2UgaWYgKHN0cmluZyhjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gY29sbGVjdGlvbjtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLiQoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xsZWN0aW9uLnJlbW92ZSgpO1xuICB9XG59O1xuXG4vKiBnbG9iYWwgRmxvYXQzMkFycmF5ICovXG5cbi8qISBCZXppZXIgY3VydmUgZnVuY3Rpb24gZ2VuZXJhdG9yLiBDb3B5cmlnaHQgR2FldGFuIFJlbmF1ZGVhdS4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cbmZ1bmN0aW9uIGdlbmVyYXRlQ3ViaWNCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIHZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQsXG4gICAgICBORVdUT05fTUlOX1NMT1BFID0gMC4wMDEsXG4gICAgICBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDEsXG4gICAgICBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwLFxuICAgICAga1NwbGluZVRhYmxlU2l6ZSA9IDExLFxuICAgICAga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApLFxuICAgICAgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG4gIC8qIE11c3QgY29udGFpbiBmb3VyIGFyZ3VtZW50cy4gKi9cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiBBcmd1bWVudHMgbXVzdCBiZSBudW1iZXJzLiAqL1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihhcmd1bWVudHNbaV0pIHx8ICFpc0Zpbml0ZShhcmd1bWVudHNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qIFggdmFsdWVzIG11c3QgYmUgaW4gdGhlIFswLCAxXSByYW5nZS4gKi9cblxuXG4gIG1YMSA9IE1hdGgubWluKG1YMSwgMSk7XG4gIG1YMiA9IE1hdGgubWluKG1YMiwgMSk7XG4gIG1YMSA9IE1hdGgubWF4KG1YMSwgMCk7XG4gIG1YMiA9IE1hdGgubWF4KG1YMiwgMCk7XG4gIHZhciBtU2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcblxuICBmdW5jdGlvbiBBKGFBMSwgYUEyKSB7XG4gICAgcmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEIoYUExLCBhQTIpIHtcbiAgICByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExO1xuICB9XG5cbiAgZnVuY3Rpb24gQyhhQTEpIHtcbiAgICByZXR1cm4gMy4wICogYUExO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHtcbiAgICByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcbiAgICByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NUKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK19pKSB7XG4gICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuXG4gICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBhR3Vlc3NUO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY1NhbXBsZVZhbHVlcygpIHtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBrU3BsaW5lVGFibGVTaXplOyArK19pMikge1xuICAgICAgbVNhbXBsZVZhbHVlc1tfaTJdID0gY2FsY0JlemllcihfaTIgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQikge1xuICAgIHZhciBjdXJyZW50WCxcbiAgICAgICAgY3VycmVudFQsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG5cbiAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuXG4gICAgcmV0dXJuIGN1cnJlbnRUO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcbiAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDAuMCxcbiAgICAgICAgY3VycmVudFNhbXBsZSA9IDEsXG4gICAgICAgIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcblxuICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgfVxuXG4gICAgLS1jdXJyZW50U2FtcGxlO1xuICAgIHZhciBkaXN0ID0gKGFYIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAobVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSxcbiAgICAgICAgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemUsXG4gICAgICAgIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuXG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCk7XG4gICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcmVjb21wdXRlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG4gICAgX3ByZWNvbXB1dGVkID0gdHJ1ZTtcblxuICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgICAgY2FsY1NhbXBsZVZhbHVlcygpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmID0gZnVuY3Rpb24gZihhWCkge1xuICAgIGlmICghX3ByZWNvbXB1dGVkKSB7XG4gICAgICBwcmVjb21wdXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7XG4gICAgICByZXR1cm4gYVg7XG4gICAgfVxuXG4gICAgaWYgKGFYID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoYVggPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKGFYKSwgbVkxLCBtWTIpO1xuICB9O1xuXG4gIGYuZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIHg6IG1YMSxcbiAgICAgIHk6IG1ZMVxuICAgIH0sIHtcbiAgICAgIHg6IG1YMixcbiAgICAgIHk6IG1ZMlxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBzdHIgPSBcImdlbmVyYXRlQmV6aWVyKFwiICsgW21YMSwgbVkxLCBtWDIsIG1ZMl0gKyBcIilcIjtcblxuICBmLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgcmV0dXJuIGY7XG59XG5cbi8qISBSdW5nZS1LdXR0YSBzcHJpbmcgcGh5c2ljcyBmdW5jdGlvbiBnZW5lcmF0b3IuIEFkYXB0ZWQgZnJvbSBGcmFtZXIuanMsIGNvcHlyaWdodCBLb2VuIEJvay4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cblxuLyogR2l2ZW4gYSB0ZW5zaW9uLCBmcmljdGlvbiwgYW5kIGR1cmF0aW9uLCBhIHNpbXVsYXRpb24gYXQgNjBGUFMgd2lsbCBmaXJzdCBydW4gd2l0aG91dCBhIGRlZmluZWQgZHVyYXRpb24gaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIHBhdGguIEEgc2Vjb25kIHBhc3NcbiAgIHRoZW4gYWRqdXN0cyB0aGUgdGltZSBkZWx0YSAtLSB1c2luZyB0aGUgcmVsYXRpb24gYmV0d2VlbiBhY3R1YWwgdGltZSBhbmQgZHVyYXRpb24gLS0gdG8gY2FsY3VsYXRlIHRoZSBwYXRoIGZvciB0aGUgZHVyYXRpb24tY29uc3RyYWluZWQgYW5pbWF0aW9uLiAqL1xudmFyIGdlbmVyYXRlU3ByaW5nUks0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiAtc3RhdGUudGVuc2lvbiAqIHN0YXRlLnggLSBzdGF0ZS5mcmljdGlvbiAqIHN0YXRlLnY7XG4gIH1cblxuICBmdW5jdGlvbiBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoaW5pdGlhbFN0YXRlLCBkdCwgZGVyaXZhdGl2ZSkge1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHg6IGluaXRpYWxTdGF0ZS54ICsgZGVyaXZhdGl2ZS5keCAqIGR0LFxuICAgICAgdjogaW5pdGlhbFN0YXRlLnYgKyBkZXJpdmF0aXZlLmR2ICogZHQsXG4gICAgICB0ZW5zaW9uOiBpbml0aWFsU3RhdGUudGVuc2lvbixcbiAgICAgIGZyaWN0aW9uOiBpbml0aWFsU3RhdGUuZnJpY3Rpb25cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBkeDogc3RhdGUudixcbiAgICAgIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3ByaW5nSW50ZWdyYXRlU3RhdGUoc3RhdGUsIGR0KSB7XG4gICAgdmFyIGEgPSB7XG4gICAgICBkeDogc3RhdGUudixcbiAgICAgIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcbiAgICB9LFxuICAgICAgICBiID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYSksXG4gICAgICAgIGMgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0ICogMC41LCBiKSxcbiAgICAgICAgZCA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQsIGMpLFxuICAgICAgICBkeGR0ID0gMS4wIC8gNi4wICogKGEuZHggKyAyLjAgKiAoYi5keCArIGMuZHgpICsgZC5keCksXG4gICAgICAgIGR2ZHQgPSAxLjAgLyA2LjAgKiAoYS5kdiArIDIuMCAqIChiLmR2ICsgYy5kdikgKyBkLmR2KTtcbiAgICBzdGF0ZS54ID0gc3RhdGUueCArIGR4ZHQgKiBkdDtcbiAgICBzdGF0ZS52ID0gc3RhdGUudiArIGR2ZHQgKiBkdDtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pIHtcbiAgICB2YXIgaW5pdFN0YXRlID0ge1xuICAgICAgeDogLTEsXG4gICAgICB2OiAwLFxuICAgICAgdGVuc2lvbjogbnVsbCxcbiAgICAgIGZyaWN0aW9uOiBudWxsXG4gICAgfSxcbiAgICAgICAgcGF0aCA9IFswXSxcbiAgICAgICAgdGltZV9sYXBzZWQgPSAwLFxuICAgICAgICB0b2xlcmFuY2UgPSAxIC8gMTAwMDAsXG4gICAgICAgIERUID0gMTYgLyAxMDAwLFxuICAgICAgICBoYXZlX2R1cmF0aW9uLFxuICAgICAgICBkdCxcbiAgICAgICAgbGFzdF9zdGF0ZTtcbiAgICB0ZW5zaW9uID0gcGFyc2VGbG9hdCh0ZW5zaW9uKSB8fCA1MDA7XG4gICAgZnJpY3Rpb24gPSBwYXJzZUZsb2F0KGZyaWN0aW9uKSB8fCAyMDtcbiAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IG51bGw7XG4gICAgaW5pdFN0YXRlLnRlbnNpb24gPSB0ZW5zaW9uO1xuICAgIGluaXRTdGF0ZS5mcmljdGlvbiA9IGZyaWN0aW9uO1xuICAgIGhhdmVfZHVyYXRpb24gPSBkdXJhdGlvbiAhPT0gbnVsbDtcbiAgICAvKiBDYWxjdWxhdGUgdGhlIGFjdHVhbCB0aW1lIGl0IHRha2VzIGZvciB0aGlzIGFuaW1hdGlvbiB0byBjb21wbGV0ZSB3aXRoIHRoZSBwcm92aWRlZCBjb25kaXRpb25zLiAqL1xuXG4gICAgaWYgKGhhdmVfZHVyYXRpb24pIHtcbiAgICAgIC8qIFJ1biB0aGUgc2ltdWxhdGlvbiB3aXRob3V0IGEgZHVyYXRpb24uICovXG4gICAgICB0aW1lX2xhcHNlZCA9IHNwcmluZ1JLNEZhY3RvcnkodGVuc2lvbiwgZnJpY3Rpb24pO1xuICAgICAgLyogQ29tcHV0ZSB0aGUgYWRqdXN0ZWQgdGltZSBkZWx0YS4gKi9cblxuICAgICAgZHQgPSB0aW1lX2xhcHNlZCAvIGR1cmF0aW9uICogRFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR0ID0gRFQ7XG4gICAgfVxuXG4gICAgZm9yICg7Oykge1xuICAgICAgLyogTmV4dC9zdGVwIGZ1bmN0aW9uIC4qL1xuICAgICAgbGFzdF9zdGF0ZSA9IHNwcmluZ0ludGVncmF0ZVN0YXRlKGxhc3Rfc3RhdGUgfHwgaW5pdFN0YXRlLCBkdCk7XG4gICAgICAvKiBTdG9yZSB0aGUgcG9zaXRpb24uICovXG5cbiAgICAgIHBhdGgucHVzaCgxICsgbGFzdF9zdGF0ZS54KTtcbiAgICAgIHRpbWVfbGFwc2VkICs9IDE2O1xuICAgICAgLyogSWYgdGhlIGNoYW5nZSB0aHJlc2hvbGQgaXMgcmVhY2hlZCwgYnJlYWsuICovXG5cbiAgICAgIGlmICghKE1hdGguYWJzKGxhc3Rfc3RhdGUueCkgPiB0b2xlcmFuY2UgJiYgTWF0aC5hYnMobGFzdF9zdGF0ZS52KSA+IHRvbGVyYW5jZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIGR1cmF0aW9uIGlzIG5vdCBkZWZpbmVkLCByZXR1cm4gdGhlIGFjdHVhbCB0aW1lIHJlcXVpcmVkIGZvciBjb21wbGV0aW5nIHRoaXMgYW5pbWF0aW9uLiBPdGhlcndpc2UsIHJldHVybiBhIGNsb3N1cmUgdGhhdCBob2xkcyB0aGVcbiAgICAgICBjb21wdXRlZCBwYXRoIGFuZCByZXR1cm5zIGEgc25hcHNob3Qgb2YgdGhlIHBvc2l0aW9uIGFjY29yZGluZyB0byBhIGdpdmVuIHBlcmNlbnRDb21wbGV0ZS4gKi9cblxuXG4gICAgcmV0dXJuICFoYXZlX2R1cmF0aW9uID8gdGltZV9sYXBzZWQgOiBmdW5jdGlvbiAocGVyY2VudENvbXBsZXRlKSB7XG4gICAgICByZXR1cm4gcGF0aFtwZXJjZW50Q29tcGxldGUgKiAocGF0aC5sZW5ndGggLSAxKSB8IDBdO1xuICAgIH07XG4gIH07XG59KCk7XG5cbnZhciBjdWJpY0JlemllciA9IGZ1bmN0aW9uIGN1YmljQmV6aWVyKHQxLCBwMSwgdDIsIHAyKSB7XG4gIHZhciBiZXppZXIgPSBnZW5lcmF0ZUN1YmljQmV6aWVyKHQxLCBwMSwgdDIsIHAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIGJlemllcihwZXJjZW50KTtcbiAgfTtcbn07XG5cbnZhciBlYXNpbmdzID0ge1xuICAnbGluZWFyJzogZnVuY3Rpb24gbGluZWFyKHN0YXJ0LCBlbmQsIHBlcmNlbnQpIHtcbiAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogcGVyY2VudDtcbiAgfSxcbiAgLy8gZGVmYXVsdCBlYXNpbmdzXG4gICdlYXNlJzogY3ViaWNCZXppZXIoMC4yNSwgMC4xLCAwLjI1LCAxKSxcbiAgJ2Vhc2UtaW4nOiBjdWJpY0JlemllcigwLjQyLCAwLCAxLCAxKSxcbiAgJ2Vhc2Utb3V0JzogY3ViaWNCZXppZXIoMCwgMCwgMC41OCwgMSksXG4gICdlYXNlLWluLW91dCc6IGN1YmljQmV6aWVyKDAuNDIsIDAsIDAuNTgsIDEpLFxuICAvLyBzaW5lXG4gICdlYXNlLWluLXNpbmUnOiBjdWJpY0JlemllcigwLjQ3LCAwLCAwLjc0NSwgMC43MTUpLFxuICAnZWFzZS1vdXQtc2luZSc6IGN1YmljQmV6aWVyKDAuMzksIDAuNTc1LCAwLjU2NSwgMSksXG4gICdlYXNlLWluLW91dC1zaW5lJzogY3ViaWNCZXppZXIoMC40NDUsIDAuMDUsIDAuNTUsIDAuOTUpLFxuICAvLyBxdWFkXG4gICdlYXNlLWluLXF1YWQnOiBjdWJpY0JlemllcigwLjU1LCAwLjA4NSwgMC42OCwgMC41MyksXG4gICdlYXNlLW91dC1xdWFkJzogY3ViaWNCZXppZXIoMC4yNSwgMC40NiwgMC40NSwgMC45NCksXG4gICdlYXNlLWluLW91dC1xdWFkJzogY3ViaWNCZXppZXIoMC40NTUsIDAuMDMsIDAuNTE1LCAwLjk1NSksXG4gIC8vIGN1YmljXG4gICdlYXNlLWluLWN1YmljJzogY3ViaWNCZXppZXIoMC41NSwgMC4wNTUsIDAuNjc1LCAwLjE5KSxcbiAgJ2Vhc2Utb3V0LWN1YmljJzogY3ViaWNCZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LWN1YmljJzogY3ViaWNCZXppZXIoMC42NDUsIDAuMDQ1LCAwLjM1NSwgMSksXG4gIC8vIHF1YXJ0XG4gICdlYXNlLWluLXF1YXJ0JzogY3ViaWNCZXppZXIoMC44OTUsIDAuMDMsIDAuNjg1LCAwLjIyKSxcbiAgJ2Vhc2Utb3V0LXF1YXJ0JzogY3ViaWNCZXppZXIoMC4xNjUsIDAuODQsIDAuNDQsIDEpLFxuICAnZWFzZS1pbi1vdXQtcXVhcnQnOiBjdWJpY0JlemllcigwLjc3LCAwLCAwLjE3NSwgMSksXG4gIC8vIHF1aW50XG4gICdlYXNlLWluLXF1aW50JzogY3ViaWNCZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KSxcbiAgJ2Vhc2Utb3V0LXF1aW50JzogY3ViaWNCZXppZXIoMC4yMywgMSwgMC4zMiwgMSksXG4gICdlYXNlLWluLW91dC1xdWludCc6IGN1YmljQmV6aWVyKDAuODYsIDAsIDAuMDcsIDEpLFxuICAvLyBleHBvXG4gICdlYXNlLWluLWV4cG8nOiBjdWJpY0JlemllcigwLjk1LCAwLjA1LCAwLjc5NSwgMC4wMzUpLFxuICAnZWFzZS1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKDAuMTksIDEsIDAuMjIsIDEpLFxuICAnZWFzZS1pbi1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKDEsIDAsIDAsIDEpLFxuICAvLyBjaXJjXG4gICdlYXNlLWluLWNpcmMnOiBjdWJpY0JlemllcigwLjYsIDAuMDQsIDAuOTgsIDAuMzM1KSxcbiAgJ2Vhc2Utb3V0LWNpcmMnOiBjdWJpY0JlemllcigwLjA3NSwgMC44MiwgMC4xNjUsIDEpLFxuICAnZWFzZS1pbi1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKDAuNzg1LCAwLjEzNSwgMC4xNSwgMC44NiksXG4gIC8vIHVzZXIgcGFyYW0gZWFzaW5ncy4uLlxuICAnc3ByaW5nJzogZnVuY3Rpb24gc3ByaW5nKHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgLy8gY2FuJ3QgZ2V0IGEgc3ByaW5nIHcvIGR1cmF0aW9uIDBcbiAgICAgIHJldHVybiBlYXNpbmdzLmxpbmVhcjsgLy8gZHVyYXRpb24gMCA9PiBqdW1wIHRvIGVuZCBzbyBpbXBsIGRvZXNuJ3QgbWF0dGVyXG4gICAgfVxuXG4gICAgdmFyIHNwcmluZyA9IGdlbmVyYXRlU3ByaW5nUks0KHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogc3ByaW5nKHBlcmNlbnQpO1xuICAgIH07XG4gIH0sXG4gICdjdWJpYy1iZXppZXInOiBjdWJpY0JlemllclxufTtcblxuZnVuY3Rpb24gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmdGbikge1xuICBpZiAocGVyY2VudCA9PT0gMSkge1xuICAgIHJldHVybiBlbmQ7XG4gIH1cblxuICB2YXIgdmFsID0gZWFzaW5nRm4oc3RhcnQsIGVuZCwgcGVyY2VudCk7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodHlwZS5yb3VuZFZhbHVlIHx8IHR5cGUuY29sb3IpIHtcbiAgICB2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG4gIH1cblxuICBpZiAodHlwZS5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbCA9IE1hdGgubWF4KHZhbCwgdHlwZS5taW4pO1xuICB9XG5cbiAgaWYgKHR5cGUubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSBNYXRoLm1pbih2YWwsIHR5cGUubWF4KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlKHByb3AsIHNwZWMpIHtcbiAgaWYgKHByb3AucGZWYWx1ZSAhPSBudWxsIHx8IHByb3AudmFsdWUgIT0gbnVsbCkge1xuICAgIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCAmJiAoc3BlYyA9PSBudWxsIHx8IHNwZWMudHlwZS51bml0cyAhPT0gJyUnKSkge1xuICAgICAgcmV0dXJuIHByb3AucGZWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByb3AudmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVhc2Uoc3RhcnRQcm9wLCBlbmRQcm9wLCBwZXJjZW50LCBlYXNpbmdGbiwgcHJvcFNwZWMpIHtcbiAgdmFyIHR5cGUgPSBwcm9wU3BlYyAhPSBudWxsID8gcHJvcFNwZWMudHlwZSA6IG51bGw7XG5cbiAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgcGVyY2VudCA9IDA7XG4gIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICBwZXJjZW50ID0gMTtcbiAgfVxuXG4gIHZhciBzdGFydCA9IGdldFZhbHVlKHN0YXJ0UHJvcCwgcHJvcFNwZWMpO1xuICB2YXIgZW5kID0gZ2V0VmFsdWUoZW5kUHJvcCwgcHJvcFNwZWMpO1xuXG4gIGlmIChudW1iZXIoc3RhcnQpICYmIG51bWJlcihlbmQpKSB7XG4gICAgcmV0dXJuIGdldEVhc2VkVmFsdWUodHlwZSwgc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nRm4pO1xuICB9IGVsc2UgaWYgKGFycmF5KHN0YXJ0KSAmJiBhcnJheShlbmQpKSB7XG4gICAgdmFyIGVhc2VkQXJyID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNpID0gc3RhcnRbaV07XG4gICAgICB2YXIgZWkgPSBlbmRbaV07XG5cbiAgICAgIGlmIChzaSAhPSBudWxsICYmIGVpICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHZhbCA9IGdldEVhc2VkVmFsdWUodHlwZSwgc2ksIGVpLCBwZXJjZW50LCBlYXNpbmdGbik7XG4gICAgICAgIGVhc2VkQXJyLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhc2VkQXJyLnB1c2goZWkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlYXNlZEFycjtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHN0ZXAoc2VsZiwgYW5pLCBub3csIGlzQ29yZSkge1xuICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgdmFyIF9wID0gc2VsZi5fcHJpdmF0ZTtcbiAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICB2YXIgcEVhc2luZyA9IGFuaV9wLmVhc2luZztcbiAgdmFyIHN0YXJ0VGltZSA9IGFuaV9wLnN0YXJ0VGltZTtcbiAgdmFyIGN5ID0gaXNDb3JlID8gc2VsZiA6IHNlbGYuY3koKTtcbiAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcblxuICBpZiAoIWFuaV9wLmVhc2luZ0ltcGwpIHtcbiAgICBpZiAocEVhc2luZyA9PSBudWxsKSB7XG4gICAgICAvLyB1c2UgZGVmYXVsdFxuICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbJ2xpbmVhciddO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGRlZmluZSB3LyBuYW1lXG4gICAgICB2YXIgZWFzaW5nVmFscztcblxuICAgICAgaWYgKHN0cmluZyhwRWFzaW5nKSkge1xuICAgICAgICB2YXIgZWFzaW5nUHJvcCA9IHN0eWxlLnBhcnNlKCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsIHBFYXNpbmcpO1xuICAgICAgICBlYXNpbmdWYWxzID0gZWFzaW5nUHJvcC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZW4gYXNzdW1lIHByZXBhcnNlZCBhcnJheVxuICAgICAgICBlYXNpbmdWYWxzID0gcEVhc2luZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUsIGFyZ3M7XG5cbiAgICAgIGlmIChzdHJpbmcoZWFzaW5nVmFscykpIHtcbiAgICAgICAgbmFtZSA9IGVhc2luZ1ZhbHM7XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzWzFdO1xuICAgICAgICBhcmdzID0gZWFzaW5nVmFscy5zbGljZSgyKS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gK247XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGNyZWF0ZSB3aXRoIGFyZ3NcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzcHJpbmcnKSB7XG4gICAgICAgICAgYXJncy5wdXNoKGFuaV9wLmR1cmF0aW9uKTsgLy8gbmVlZCBkdXJhdGlvbiB0byBnZW5lcmF0ZSBzcHJpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzW25hbWVdLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RhdGljIGltcGwgYnkgbmFtZVxuICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWFzaW5nID0gYW5pX3AuZWFzaW5nSW1wbDtcbiAgdmFyIHBlcmNlbnQ7XG5cbiAgaWYgKGFuaV9wLmR1cmF0aW9uID09PSAwKSB7XG4gICAgcGVyY2VudCA9IDE7XG4gIH0gZWxzZSB7XG4gICAgcGVyY2VudCA9IChub3cgLSBzdGFydFRpbWUpIC8gYW5pX3AuZHVyYXRpb247XG4gIH1cblxuICBpZiAoYW5pX3AuYXBwbHlpbmcpIHtcbiAgICBwZXJjZW50ID0gYW5pX3AucHJvZ3Jlc3M7XG4gIH1cblxuICBpZiAocGVyY2VudCA8IDApIHtcbiAgICBwZXJjZW50ID0gMDtcbiAgfSBlbHNlIGlmIChwZXJjZW50ID4gMSkge1xuICAgIHBlcmNlbnQgPSAxO1xuICB9XG5cbiAgaWYgKGFuaV9wLmRlbGF5ID09IG51bGwpIHtcbiAgICAvLyB0aGVuIHVwZGF0ZVxuICAgIHZhciBzdGFydFBvcyA9IGFuaV9wLnN0YXJ0UG9zaXRpb247XG4gICAgdmFyIGVuZFBvcyA9IGFuaV9wLnBvc2l0aW9uO1xuXG4gICAgaWYgKGVuZFBvcyAmJiBpc0VsZXMgJiYgIXNlbGYubG9ja2VkKCkpIHtcbiAgICAgIHZhciBuZXdQb3MgPSB7fTtcblxuICAgICAgaWYgKHZhbGlkKHN0YXJ0UG9zLngsIGVuZFBvcy54KSkge1xuICAgICAgICBuZXdQb3MueCA9IGVhc2Uoc3RhcnRQb3MueCwgZW5kUG9zLngsIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWxpZChzdGFydFBvcy55LCBlbmRQb3MueSkpIHtcbiAgICAgICAgbmV3UG9zLnkgPSBlYXNlKHN0YXJ0UG9zLnksIGVuZFBvcy55LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0UGFuID0gYW5pX3Auc3RhcnRQYW47XG4gICAgdmFyIGVuZFBhbiA9IGFuaV9wLnBhbjtcbiAgICB2YXIgcGFuID0gX3AucGFuO1xuICAgIHZhciBhbmltYXRpbmdQYW4gPSBlbmRQYW4gIT0gbnVsbCAmJiBpc0NvcmU7XG5cbiAgICBpZiAoYW5pbWF0aW5nUGFuKSB7XG4gICAgICBpZiAodmFsaWQoc3RhcnRQYW4ueCwgZW5kUGFuLngpKSB7XG4gICAgICAgIHBhbi54ID0gZWFzZShzdGFydFBhbi54LCBlbmRQYW4ueCwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbGlkKHN0YXJ0UGFuLnksIGVuZFBhbi55KSkge1xuICAgICAgICBwYW4ueSA9IGVhc2Uoc3RhcnRQYW4ueSwgZW5kUGFuLnksIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZW1pdCgncGFuJyk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0Wm9vbSA9IGFuaV9wLnN0YXJ0Wm9vbTtcbiAgICB2YXIgZW5kWm9vbSA9IGFuaV9wLnpvb207XG4gICAgdmFyIGFuaW1hdGluZ1pvb20gPSBlbmRab29tICE9IG51bGwgJiYgaXNDb3JlO1xuXG4gICAgaWYgKGFuaW1hdGluZ1pvb20pIHtcbiAgICAgIGlmICh2YWxpZChzdGFydFpvb20sIGVuZFpvb20pKSB7XG4gICAgICAgIF9wLnpvb20gPSBib3VuZChfcC5taW5ab29tLCBlYXNlKHN0YXJ0Wm9vbSwgZW5kWm9vbSwgcGVyY2VudCwgZWFzaW5nKSwgX3AubWF4Wm9vbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZW1pdCgnem9vbScpO1xuICAgIH1cblxuICAgIGlmIChhbmltYXRpbmdQYW4gfHwgYW5pbWF0aW5nWm9vbSkge1xuICAgICAgc2VsZi5lbWl0KCd2aWV3cG9ydCcpO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IGFuaV9wLnN0eWxlO1xuXG4gICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCA+IDAgJiYgaXNFbGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIHZhciBfbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIGVuZCA9IHByb3A7XG4gICAgICAgIHZhciBzdGFydCA9IGFuaV9wLnN0YXJ0U3R5bGVbX25hbWVdO1xuICAgICAgICB2YXIgcHJvcFNwZWMgPSBzdHlsZS5wcm9wZXJ0aWVzW3N0YXJ0Lm5hbWVdO1xuICAgICAgICB2YXIgZWFzZWRWYWwgPSBlYXNlKHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGVhc2luZywgcHJvcFNwZWMpO1xuICAgICAgICBzdHlsZS5vdmVycmlkZUJ5cGFzcyhzZWxmLCBfbmFtZSwgZWFzZWRWYWwpO1xuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuXG4gICAgICBzZWxmLmVtaXQoJ3N0eWxlJyk7XG4gICAgfSAvLyBpZlxuXG4gIH1cblxuICBhbmlfcC5wcm9ncmVzcyA9IHBlcmNlbnQ7XG4gIHJldHVybiBwZXJjZW50O1xufVxuXG5mdW5jdGlvbiB2YWxpZChzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG51bWJlcihzdGFydCkgJiYgbnVtYmVyKGVuZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oc2VsZiwgYW5pLCBub3csIGlzQ29yZSkge1xuICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG4gIGFuaV9wLnN0YXJ0ZWQgPSB0cnVlO1xuICBhbmlfcC5zdGFydFRpbWUgPSBub3cgLSBhbmlfcC5wcm9ncmVzcyAqIGFuaV9wLmR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBzdGVwQWxsKG5vdywgY3kpIHtcbiAgdmFyIGVsZXMgPSBjeS5fcHJpdmF0ZS5hbmlFbGVzO1xuICB2YXIgZG9uZUVsZXMgPSBbXTtcblxuICBmdW5jdGlvbiBzdGVwT25lKGVsZSwgaXNDb3JlKSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBjdXJyZW50ID0gX3AuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgdmFyIHF1ZXVlID0gX3AuYW5pbWF0aW9uLnF1ZXVlO1xuICAgIHZhciByYW5BbmlzID0gZmFsc2U7IC8vIGNhbmNlbCBhbGwgYW5pbWF0aW9ucyBvbiBkaXNwbGF5Om5vbmUgZWxlXG5cbiAgICBpZiAoIWlzQ29yZSAmJiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdub25lJykge1xuICAgICAgLy8gcHV0IGFsbCBjdXJyZW50IGFuZCBxdWV1ZSBhbmltYXRpb25zIGluIHRoaXMgdGljaydzIGN1cnJlbnQgbGlzdFxuICAgICAgLy8gYW5kIGVtcHR5IHRoZSBsaXN0cyBmb3IgdGhlIGVsZW1lbnRcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNwbGljZSgwLCBjdXJyZW50Lmxlbmd0aCkuY29uY2F0KHF1ZXVlLnNwbGljZSgwLCBxdWV1ZS5sZW5ndGgpKTsgLy8gc3RvcCBhbGwgYW5pbWF0aW9uc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudFtpXS5zdG9wKCk7XG4gICAgICB9XG4gICAgfSAvLyBpZiBub3RoaW5nIGN1cnJlbnRseSBhbmltYXRpbmcsIGdldCBzb21ldGhpbmcgZnJvbSB0aGUgcXVldWVcblxuXG4gICAgaWYgKGN1cnJlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgbmV4dCA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2FsbGJhY2tzID0gZnVuY3Rpb24gY2FsbGJhY2tzKF9jYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSBfY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBjYiA9IF9jYWxsYmFja3Nbal07XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG5cbiAgICAgIF9jYWxsYmFja3Muc3BsaWNlKDAsIF9jYWxsYmFja3MubGVuZ3RoKTtcbiAgICB9OyAvLyBzdGVwIGFuZCByZW1vdmUgaWYgZG9uZVxuXG5cbiAgICBmb3IgKHZhciBfaSA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2ktLSkge1xuICAgICAgdmFyIGFuaSA9IGN1cnJlbnRbX2ldO1xuICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuXG4gICAgICBpZiAoYW5pX3Auc3RvcHBlZCkge1xuICAgICAgICBjdXJyZW50LnNwbGljZShfaSwgMSk7XG4gICAgICAgIGFuaV9wLmhvb2tlZCA9IGZhbHNlO1xuICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2tzKGFuaV9wLmZyYW1lcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFuaV9wLnBsYXlpbmcgJiYgIWFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBhbiBhcHBseSgpIHdoaWxlIHBsYXlpbmcgc2hvdWxkbid0IGRvIGFueXRoaW5nXG5cblxuICAgICAgaWYgKGFuaV9wLnBsYXlpbmcgJiYgYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhbmlfcC5zdGFydGVkKSB7XG4gICAgICAgIHN0YXJ0QW5pbWF0aW9uKGVsZSwgYW5pLCBub3cpO1xuICAgICAgfVxuXG4gICAgICBzdGVwKGVsZSwgYW5pLCBub3csIGlzQ29yZSk7XG5cbiAgICAgIGlmIChhbmlfcC5hcHBseWluZykge1xuICAgICAgICBhbmlfcC5hcHBseWluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFja3MoYW5pX3AuZnJhbWVzKTtcblxuICAgICAgaWYgKGFuaV9wLnN0ZXAgIT0gbnVsbCkge1xuICAgICAgICBhbmlfcC5zdGVwKG5vdyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmkuY29tcGxldGVkKCkpIHtcbiAgICAgICAgY3VycmVudC5zcGxpY2UoX2ksIDEpO1xuICAgICAgICBhbmlfcC5ob29rZWQgPSBmYWxzZTtcbiAgICAgICAgYW5pX3AucGxheWluZyA9IGZhbHNlO1xuICAgICAgICBhbmlfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGNhbGxiYWNrcyhhbmlfcC5jb21wbGV0ZXMpO1xuICAgICAgfVxuXG4gICAgICByYW5BbmlzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQ29yZSAmJiBjdXJyZW50Lmxlbmd0aCA9PT0gMCAmJiBxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRvbmVFbGVzLnB1c2goZWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuQW5pcztcbiAgfSAvLyBzdGVwRWxlbWVudFxuICAvLyBoYW5kbGUgYWxsIGVsZXNcblxuXG4gIHZhciByYW5FbGVBbmkgPSBmYWxzZTtcblxuICBmb3IgKHZhciBlID0gMDsgZSA8IGVsZXMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tlXTtcbiAgICB2YXIgaGFuZGxlZFRoaXNFbGUgPSBzdGVwT25lKGVsZSk7XG4gICAgcmFuRWxlQW5pID0gcmFuRWxlQW5pIHx8IGhhbmRsZWRUaGlzRWxlO1xuICB9IC8vIGVhY2ggZWxlbWVudFxuXG5cbiAgdmFyIHJhbkNvcmVBbmkgPSBzdGVwT25lKGN5LCB0cnVlKTsgLy8gbm90aWZ5IHJlbmRlcmVyXG5cbiAgaWYgKHJhbkVsZUFuaSB8fCByYW5Db3JlQW5pKSB7XG4gICAgaWYgKGVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgY3kubm90aWZ5KCdkcmF3JywgZWxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN5Lm5vdGlmeSgnZHJhdycpO1xuICAgIH1cbiAgfSAvLyByZW1vdmUgZWxlbWVudHMgZnJvbSBsaXN0IG9mIGN1cnJlbnRseSBhbmltYXRpbmcgaWYgaXRzIHF1ZXVlcyBhcmUgZW1wdHlcblxuXG4gIGVsZXMudW5tZXJnZShkb25lRWxlcyk7XG4gIGN5LmVtaXQoJ3N0ZXAnKTtcbn0gLy8gc3RlcEFsbFxuXG52YXIgY29yZWZuJDEgPSB7XG4gIC8vIHB1bGwgaW4gYW5pbWF0aW9uIGZ1bmN0aW9uc1xuICBhbmltYXRlOiBkZWZpbmUkMy5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lJDMuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUkMy5hbmltYXRlZCgpLFxuICBjbGVhclF1ZXVlOiBkZWZpbmUkMy5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUkMy5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lJDMuZGVsYXlBbmltYXRpb24oKSxcbiAgc3RvcDogZGVmaW5lJDMuc3RvcCgpLFxuICBhZGRUb0FuaW1hdGlvblBvb2w6IGZ1bmN0aW9uIGFkZFRvQW5pbWF0aW9uUG9vbChlbGVzKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuXG5cbiAgICBjeS5fcHJpdmF0ZS5hbmlFbGVzLm1lcmdlKGVsZXMpO1xuICB9LFxuICBzdG9wQW5pbWF0aW9uTG9vcDogZnVuY3Rpb24gc3RvcEFuaW1hdGlvbkxvb3AoKSB7XG4gICAgdGhpcy5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZyA9IGZhbHNlO1xuICB9LFxuICBzdGFydEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uTG9vcCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGN5Ll9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nID0gdHJ1ZTtcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuICAgIC8vIE5CIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIGV4ZWMgaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzIGlmIHN0eWxlIGVuYWJsZWRcbiAgICAvLyBhbmQgZXhwbGljaXQgY3kuZGVzdHJveSgpIGlzIG5lY2Vzc2FyeSB0byBzdG9wIHRoZSBsb29wXG5cblxuICAgIGZ1bmN0aW9uIGhlYWRsZXNzU3RlcCgpIHtcbiAgICAgIGlmICghY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gYW5pbWF0aW9uU3RlcChub3cpIHtcbiAgICAgICAgc3RlcEFsbChub3csIGN5KTtcbiAgICAgICAgaGVhZGxlc3NTdGVwKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZXIgPSBjeS5yZW5kZXJlcigpO1xuXG4gICAgaWYgKHJlbmRlcmVyICYmIHJlbmRlcmVyLmJlZm9yZVJlbmRlcikge1xuICAgICAgLy8gbGV0IHRoZSByZW5kZXJlciBzY2hlZHVsZSBhbmltYXRpb25zXG4gICAgICByZW5kZXJlci5iZWZvcmVSZW5kZXIoZnVuY3Rpb24gcmVuZGVyZXJBbmltYXRpb25TdGVwKHdpbGxEcmF3LCBub3cpIHtcbiAgICAgICAgc3RlcEFsbChub3csIGN5KTtcbiAgICAgIH0sIHJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuYW5pbWF0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1hbmFnZSB0aGUgYW5pbWF0aW9uIGxvb3Agb3Vyc2VsdmVzXG4gICAgICBoZWFkbGVzc1N0ZXAoKTsgLy8gZmlyc3QgY2FsbFxuICAgIH1cbiAgfVxufTtcblxudmFyIGVtaXR0ZXJPcHRpb25zJDEgPSB7XG4gIHF1YWxpZmllckNvbXBhcmU6IGZ1bmN0aW9uIHF1YWxpZmllckNvbXBhcmUoc2VsZWN0b3IxLCBzZWxlY3RvcjIpIHtcbiAgICBpZiAoc2VsZWN0b3IxID09IG51bGwgfHwgc2VsZWN0b3IyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjEgPT0gbnVsbCAmJiBzZWxlY3RvcjIgPT0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMS5zYW1lVGV4dChzZWxlY3RvcjIpO1xuICAgIH1cbiAgfSxcbiAgZXZlbnRNYXRjaGVzOiBmdW5jdGlvbiBldmVudE1hdGNoZXMoY3ksIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHZhciBzZWxlY3RvciA9IGxpc3RlbmVyLnF1YWxpZmllcjtcblxuICAgIGlmIChzZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY3kgIT09IGV2ZW50T2JqLnRhcmdldCAmJiBlbGVtZW50KGV2ZW50T2JqLnRhcmdldCkgJiYgc2VsZWN0b3IubWF0Y2hlcyhldmVudE9iai50YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMoY3ksIGV2dCkge1xuICAgIGV2dC5jeSA9IGN5O1xuICAgIGV2dC50YXJnZXQgPSBjeTtcbiAgfSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoY3ksIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgIHJldHVybiBsaXN0ZW5lci5xdWFsaWZpZXIgIT0gbnVsbCA/IGV2ZW50T2JqLnRhcmdldCA6IGN5O1xuICB9XG59O1xuXG52YXIgYXJnU2VsZWN0b3IkMSA9IGZ1bmN0aW9uIGFyZ1NlbGVjdG9yKGFyZykge1xuICBpZiAoc3RyaW5nKGFyZykpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdG9yKGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfVxufTtcblxudmFyIGVsZXNmbiR2ID0ge1xuICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoIV9wLmVtaXR0ZXIpIHtcbiAgICAgIF9wLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcihlbWl0dGVyT3B0aW9ucyQxLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbWl0dGVyO1xuICB9LFxuICBvbjogZnVuY3Rpb24gb24oZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2ZW50cywgYXJnU2VsZWN0b3IkMShzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9uZTogZnVuY3Rpb24gb25lKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsZWN0b3IkMShzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb25jZTogZnVuY3Rpb24gb25jZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcykge1xuICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXRBbmROb3RpZnk6IGZ1bmN0aW9uIGVtaXRBbmROb3RpZnkoZXZlbnQsIGVsZXMpIHtcbiAgICB0aGlzLmVtaXQoZXZlbnQpO1xuICAgIHRoaXMubm90aWZ5KGV2ZW50LCBlbGVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbmRlZmluZSQzLmV2ZW50QWxpYXNlc09uKGVsZXNmbiR2KTtcblxudmFyIGNvcmVmbiQyID0ge1xuICBwbmc6IGZ1bmN0aW9uIHBuZyhvcHRpb25zKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gcmVuZGVyZXIucG5nKG9wdGlvbnMpO1xuICB9LFxuICBqcGc6IGZ1bmN0aW9uIGpwZyhvcHRpb25zKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmJnID0gb3B0aW9ucy5iZyB8fCAnI2ZmZic7XG4gICAgcmV0dXJuIHJlbmRlcmVyLmpwZyhvcHRpb25zKTtcbiAgfVxufTtcbmNvcmVmbiQyLmpwZWcgPSBjb3JlZm4kMi5qcGc7XG5cbnZhciBjb3JlZm4kMyA9IHtcbiAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBlcnJvcignTGF5b3V0IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5hbWUgPT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0EgYG5hbWVgIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB2YXIgTGF5b3V0ID0gY3kuZXh0ZW5zaW9uKCdsYXlvdXQnLCBuYW1lKTtcblxuICAgIGlmIChMYXlvdXQgPT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ05vIHN1Y2ggbGF5b3V0IGAnICsgbmFtZSArICdgIGZvdW5kLiAgRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IGl0IGFuZCBgY3l0b3NjYXBlLnVzZSgpYCBpdD8nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlcztcblxuICAgIGlmIChzdHJpbmcob3B0aW9ucy5lbGVzKSkge1xuICAgICAgZWxlcyA9IGN5LiQob3B0aW9ucy5lbGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcyA9IG9wdGlvbnMuZWxlcyAhPSBudWxsID8gb3B0aW9ucy5lbGVzIDogY3kuJCgpO1xuICAgIH1cblxuICAgIHZhciBsYXlvdXQgPSBuZXcgTGF5b3V0KGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgY3k6IGN5LFxuICAgICAgZWxlczogZWxlc1xuICAgIH0pKTtcbiAgICByZXR1cm4gbGF5b3V0O1xuICB9XG59O1xuY29yZWZuJDMuY3JlYXRlTGF5b3V0ID0gY29yZWZuJDMubWFrZUxheW91dCA9IGNvcmVmbiQzLmxheW91dDtcblxudmFyIGNvcmVmbiQ0ID0ge1xuICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeShldmVudE5hbWUsIGV2ZW50RWxlcykge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAodGhpcy5iYXRjaGluZygpKSB7XG4gICAgICBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgfHwge307XG4gICAgICB2YXIgZWxlcyA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zW2V2ZW50TmFtZV0gfHwgdGhpcy5jb2xsZWN0aW9uKCk7XG5cbiAgICAgIGlmIChldmVudEVsZXMgIT0gbnVsbCkge1xuICAgICAgICBlbGVzLm1lcmdlKGV2ZW50RWxlcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjsgLy8gbm90aWZpY2F0aW9ucyBhcmUgZGlzYWJsZWQgZHVyaW5nIGJhdGNoaW5nXG4gICAgfVxuXG4gICAgaWYgKCFfcC5ub3RpZmljYXRpb25zRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZXhpdCBvbiBkaXNhYmxlZFxuXG5cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7IC8vIGV4aXQgaWYgZGVzdHJveSgpIGNhbGxlZCBvbiBjb3JlIG9yIHJlbmRlcmVyIGluIGJldHdlZW4gZnJhbWVzICMxNDk5ICMxNTI4XG5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQoKSB8fCAhcmVuZGVyZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lLCBldmVudEVsZXMpO1xuICB9LFxuICBub3RpZmljYXRpb25zOiBmdW5jdGlvbiBub3RpZmljYXRpb25zKGJvb2wpIHtcbiAgICB2YXIgcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcC5ub3RpZmljYXRpb25zRW5hYmxlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5ub3RpZmljYXRpb25zRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG5vTm90aWZpY2F0aW9uczogZnVuY3Rpb24gbm9Ob3RpZmljYXRpb25zKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zKGZhbHNlKTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHRoaXMubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgfSxcbiAgYmF0Y2hpbmc6IGZ1bmN0aW9uIGJhdGNoaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJhdGNoQ291bnQgPiAwO1xuICB9LFxuICBzdGFydEJhdGNoOiBmdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PSBudWxsKSB7XG4gICAgICBfcC5iYXRjaENvdW50ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMgPSB0aGlzLmNvbGxlY3Rpb24oKTtcbiAgICAgIF9wLmJhdGNoTm90aWZpY2F0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIF9wLmJhdGNoQ291bnQrKztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW5kQmF0Y2g6IGZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX3AuYmF0Y2hDb3VudC0tO1xuXG4gICAgaWYgKF9wLmJhdGNoQ291bnQgPT09IDApIHtcbiAgICAgIC8vIHVwZGF0ZSBzdHlsZSBmb3IgZGlydHkgZWxlc1xuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMudXBkYXRlU3R5bGUoKTtcblxuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpOyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIG9mIHF1ZXVlZCBlbGVzIGFuZCBldmVudCB0eXBlc1xuXG4gICAgICBPYmplY3Qua2V5cyhfcC5iYXRjaE5vdGlmaWNhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgZWxlcyA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdO1xuXG4gICAgICAgIGlmIChlbGVzLmVtcHR5KCkpIHtcbiAgICAgICAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lLCBlbGVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGJhdGNoOiBmdW5jdGlvbiBiYXRjaChjYWxsYmFjaykge1xuICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgIGNhbGxiYWNrKCk7XG4gICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgYmF0Y2hEYXRhOiBmdW5jdGlvbiBiYXRjaERhdGEobWFwKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgZGF0YSA9IG1hcFtpZF07XG4gICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgIGVsZS5kYXRhKGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgcmVuZGVyZXJEZWZhdWx0cyA9IGRlZmF1bHRzKHtcbiAgaGlkZUVkZ2VzT25WaWV3cG9ydDogZmFsc2UsXG4gIHRleHR1cmVPblZpZXdwb3J0OiBmYWxzZSxcbiAgbW90aW9uQmx1cjogZmFsc2UsXG4gIG1vdGlvbkJsdXJPcGFjaXR5OiAwLjA1LFxuICBwaXhlbFJhdGlvOiB1bmRlZmluZWQsXG4gIGRlc2t0b3BUYXBUaHJlc2hvbGQ6IDQsXG4gIHRvdWNoVGFwVGhyZXNob2xkOiA4LFxuICB3aGVlbFNlbnNpdGl2aXR5OiAxLFxuICBkZWJ1ZzogZmFsc2UsXG4gIHNob3dGcHM6IGZhbHNlXG59KTtcbnZhciBjb3JlZm4kNSA9IHtcbiAgcmVuZGVyVG86IGZ1bmN0aW9uIHJlbmRlclRvKGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbykge1xuICAgIHZhciByID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICByLnJlbmRlclRvKGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbmRlcmVyOiBmdW5jdGlvbiByZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgfSxcbiAgZm9yY2VSZW5kZXI6IGZ1bmN0aW9uIGZvcmNlUmVuZGVyKCkge1xuICAgIHRoaXMubm90aWZ5KCdkcmF3Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgIHRoaXMuaW52YWxpZGF0ZVNpemUoKTtcbiAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3Jlc2l6ZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpbml0UmVuZGVyZXI6IGZ1bmN0aW9uIGluaXRSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICB2YXIgUmVuZGVyZXJQcm90byA9IGN5LmV4dGVuc2lvbigncmVuZGVyZXInLCBvcHRpb25zLm5hbWUpO1xuXG4gICAgaWYgKFJlbmRlcmVyUHJvdG8gPT0gbnVsbCkge1xuICAgICAgZXJyb3IoXCJDYW4gbm90IGluaXRpYWxpc2U6IE5vIHN1Y2ggcmVuZGVyZXIgYFwiLmNvbmNhdChvcHRpb25zLm5hbWUsIFwiYCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IGl0IGFuZCBgY3l0b3NjYXBlLnVzZSgpYCBpdD9cIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd2FybihcIllvdSBoYXZlIHNldCBhIGN1c3RvbSB3aGVlbCBzZW5zaXRpdml0eS4gIFRoaXMgd2lsbCBtYWtlIHlvdXIgYXBwIHpvb20gdW5uYXR1cmFsbHkgd2hlbiB1c2luZyBtYWluc3RyZWFtIG1pY2UuICBZb3Ugc2hvdWxkIGNoYW5nZSB0aGlzIHZhbHVlIGZyb20gdGhlIGRlZmF1bHQgb25seSBpZiB5b3UgY2FuIGd1YXJhbnRlZSB0aGF0IGFsbCB5b3VyIHVzZXJzIHdpbGwgdXNlIHRoZSBzYW1lIGhhcmR3YXJlIGFuZCBPUyBjb25maWd1cmF0aW9uIGFzIHlvdXIgY3VycmVudCBtYWNoaW5lLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgck9wdHMgPSByZW5kZXJlckRlZmF1bHRzKG9wdGlvbnMpO1xuICAgIHJPcHRzLmN5ID0gY3k7XG4gICAgY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJQcm90byhyT3B0cyk7XG4gICAgdGhpcy5ub3RpZnkoJ2luaXQnKTtcbiAgfSxcbiAgZGVzdHJveVJlbmRlcmVyOiBmdW5jdGlvbiBkZXN0cm95UmVuZGVyZXIoKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBjeS5ub3RpZnkoJ2Rlc3Ryb3knKTsgLy8gZGVzdHJveSB0aGUgcmVuZGVyZXJcblxuICAgIHZhciBkb21FbGUgPSBjeS5jb250YWluZXIoKTtcblxuICAgIGlmIChkb21FbGUpIHtcbiAgICAgIGRvbUVsZS5fY3lyZWcgPSBudWxsO1xuXG4gICAgICB3aGlsZSAoZG9tRWxlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBkb21FbGUucmVtb3ZlQ2hpbGQoZG9tRWxlLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN5Ll9wcml2YXRlLnJlbmRlcmVyID0gbnVsbDsgLy8gdG8gYmUgZXh0cmEgc2FmZSwgcmVtb3ZlIHRoZSByZWZcblxuICAgIGN5Lm11dGFibGVFbGVtZW50cygpLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgX3AucnNjcmF0Y2ggPSB7fTtcbiAgICAgIF9wLnJzdHlsZSA9IHt9O1xuICAgICAgX3AuYW5pbWF0aW9uLmN1cnJlbnQgPSBbXTtcbiAgICAgIF9wLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgIH0pO1xuICB9LFxuICBvblJlbmRlcjogZnVuY3Rpb24gb25SZW5kZXIoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5vbigncmVuZGVyJywgZm4pO1xuICB9LFxuICBvZmZSZW5kZXI6IGZ1bmN0aW9uIG9mZlJlbmRlcihmbikge1xuICAgIHJldHVybiB0aGlzLm9mZigncmVuZGVyJywgZm4pO1xuICB9XG59O1xuY29yZWZuJDUuaW52YWxpZGF0ZURpbWVuc2lvbnMgPSBjb3JlZm4kNS5yZXNpemU7XG5cbnZhciBjb3JlZm4kNiA9IHtcbiAgLy8gZ2V0IGEgY29sbGVjdGlvblxuICAvLyAtIGVtcHR5IGNvbGxlY3Rpb24gb24gbm8gYXJnc1xuICAvLyAtIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMgaW4gdGhlIGdyYXBoIG9uIHNlbGVjdG9yIGFyZ1xuICAvLyAtIGd1YXJhbnRlZSBhIHJldHVybmVkIGNvbGxlY3Rpb24gd2hlbiBlbGVtZW50cyBvciBjb2xsZWN0aW9uIHNwZWNpZmllZFxuICBjb2xsZWN0aW9uOiBmdW5jdGlvbiBjb2xsZWN0aW9uKGVsZXMsIG9wdHMpIHtcbiAgICBpZiAoc3RyaW5nKGVsZXMpKSB7XG4gICAgICByZXR1cm4gdGhpcy4kKGVsZXMpO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihlbGVzKSkge1xuICAgICAgcmV0dXJuIGVsZXMuY29sbGVjdGlvbigpO1xuICAgIH0gZWxzZSBpZiAoYXJyYXkoZWxlcykpIHtcbiAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLCBlbGVzLCBvcHRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcyk7XG4gIH0sXG4gIG5vZGVzOiBmdW5jdGlvbiBub2RlcyhzZWxlY3Rvcikge1xuICAgIHZhciBub2RlcyA9IHRoaXMuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gbm9kZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH0sXG4gIGVkZ2VzOiBmdW5jdGlvbiBlZGdlcyhzZWxlY3Rvcikge1xuICAgIHZhciBlZGdlcyA9IHRoaXMuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzRWRnZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZWRnZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWRnZXM7XG4gIH0sXG4gIC8vIHNlYXJjaCB0aGUgZ3JhcGggbGlrZSBqUXVlcnlcbiAgJDogZnVuY3Rpb24gJChzZWxlY3Rvcikge1xuICAgIHZhciBlbGVzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGVsZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZXMuc3Bhd25TZWxmKCk7XG4gICAgfVxuICB9LFxuICBtdXRhYmxlRWxlbWVudHM6IGZ1bmN0aW9uIG11dGFibGVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgfVxufTsgLy8gYWxpYXNlc1xuXG5jb3JlZm4kNi5lbGVtZW50cyA9IGNvcmVmbiQ2LmZpbHRlciA9IGNvcmVmbiQ2LiQ7XG5cbnZhciBzdHlmbiA9IHt9OyAvLyBrZXlzIGZvciBzdHlsZSBibG9ja3MsIGUuZy4gdHRmZnR0XG5cbnZhciBUUlVFID0gJ3QnO1xudmFyIEZBTFNFID0gJ2YnOyAvLyAocG90ZW50aWFsbHkgZXhwZW5zaXZlIGNhbGN1bGF0aW9uKVxuLy8gYXBwbHkgdGhlIHN0eWxlIHRvIHRoZSBlbGVtZW50IGJhc2VkIG9uXG4vLyAtIGl0cyBieXBhc3Ncbi8vIC0gd2hhdCBzZWxlY3RvcnMgbWF0Y2ggaXRcblxuc3R5Zm4uYXBwbHkgPSBmdW5jdGlvbiAoZWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gIHZhciBjeSA9IF9wLmN5O1xuICB2YXIgdXBkYXRlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgaWYgKF9wLm5ld1N0eWxlKSB7XG4gICAgLy8gY2xlYXIgc3R5bGUgY2FjaGVzXG4gICAgX3AuY29udGV4dFN0eWxlcyA9IHt9O1xuICAgIF9wLnByb3BEaWZmcyA9IHt9O1xuICAgIHNlbGYuY2xlYW5FbGVtZW50cyhlbGVzLCB0cnVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGllID0gMDsgaWUgPCBlbGVzLmxlbmd0aDsgaWUrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2llXTtcbiAgICB2YXIgY3h0TWV0YSA9IHNlbGYuZ2V0Q29udGV4dE1ldGEoZWxlKTtcblxuICAgIGlmIChjeHRNZXRhLmVtcHR5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY3h0U3R5bGUgPSBzZWxmLmdldENvbnRleHRTdHlsZShjeHRNZXRhKTtcbiAgICB2YXIgYXBwID0gc2VsZi5hcHBseUNvbnRleHRTdHlsZShjeHRNZXRhLCBjeHRTdHlsZSwgZWxlKTtcblxuICAgIGlmICghX3AubmV3U3R5bGUpIHtcbiAgICAgIHNlbGYudXBkYXRlVHJhbnNpdGlvbnMoZWxlLCBhcHAuZGlmZlByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgaGludHNEaWZmID0gc2VsZi51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG5cbiAgICBpZiAoaGludHNEaWZmKSB7XG4gICAgICB1cGRhdGVkRWxlcy5tZXJnZShlbGUpO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlbWVudHNcblxuXG4gIF9wLm5ld1N0eWxlID0gZmFsc2U7XG4gIHJldHVybiB1cGRhdGVkRWxlcztcbn07XG5cbnN0eWZuLmdldFByb3BlcnRpZXNEaWZmID0gZnVuY3Rpb24gKG9sZEN4dEtleSwgbmV3Q3h0S2V5KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhY2hlID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyB8fCB7fTtcbiAgdmFyIGR1YWxDeHRLZXkgPSBvbGRDeHRLZXkgKyAnLScgKyBuZXdDeHRLZXk7XG4gIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtkdWFsQ3h0S2V5XTtcblxuICBpZiAoY2FjaGVkVmFsKSB7XG4gICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgfVxuXG4gIHZhciBkaWZmUHJvcHMgPSBbXTtcbiAgdmFyIGFkZGVkUHJvcCA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjeHQgPSBzZWxmW2ldO1xuICAgIHZhciBvbGRIYXNDeHQgPSBvbGRDeHRLZXlbaV0gPT09IFRSVUU7XG4gICAgdmFyIG5ld0hhc0N4dCA9IG5ld0N4dEtleVtpXSA9PT0gVFJVRTtcbiAgICB2YXIgY3h0SGFzRGlmZmVkID0gb2xkSGFzQ3h0ICE9PSBuZXdIYXNDeHQ7XG4gICAgdmFyIGN4dEhhc01hcHBlZFByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXMubGVuZ3RoID4gMDtcblxuICAgIGlmIChjeHRIYXNEaWZmZWQgfHwgbmV3SGFzQ3h0ICYmIGN4dEhhc01hcHBlZFByb3BzKSB7XG4gICAgICB2YXIgcHJvcHMgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChjeHRIYXNEaWZmZWQgJiYgY3h0SGFzTWFwcGVkUHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gc3VmZmljZXMgYi9jIG1hcHBlZFByb3BlcnRpZXMgaXMgYSBzdWJzZXQgb2YgcHJvcGVydGllc1xuICAgICAgfSBlbHNlIGlmIChjeHRIYXNEaWZmZWQpIHtcbiAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gbmVlZCB0byBjaGVjayB0aGVtIGFsbFxuICAgICAgfSBlbHNlIGlmIChjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgICBwcm9wcyA9IGN4dC5tYXBwZWRQcm9wZXJ0aWVzOyAvLyBvbmx5IG5lZWQgdG8gY2hlY2sgbWFwcGVkXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7IC8vIGlmIGEgbGF0ZXIgY29udGV4dCBvdmVycmlkZXMgdGhpcyBwcm9wZXJ0eSwgdGhlbiB0aGUgZmFjdCB0aGF0IHRoaXMgY29udGV4dCBoYXMgc3dpdGNoZWQvZGlmZmVkIGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgIC8vIChzZW1pIGV4cGVuc2l2ZSBjaGVjayBzaW5jZSBpdCBtYWtlcyB0aGlzIGZ1bmN0aW9uIE8obl4yKSBvbiBjb250ZXh0IGxlbmd0aCwgYnV0IHdvcnRoIGl0IHNpbmNlIG92ZXJhbGwgcmVzdWx0XG4gICAgICAgIC8vIGlzIGNhY2hlZClcblxuICAgICAgICB2YXIgbGF0ZXJDeHRPdmVycmlkZXMgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBrID0gaSArIDE7IGsgPCBzZWxmLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgdmFyIGxhdGVyQ3h0ID0gc2VsZltrXTtcbiAgICAgICAgICB2YXIgaGFzTGF0ZXJDeHQgPSBuZXdDeHRLZXlba10gPT09IFRSVUU7XG5cbiAgICAgICAgICBpZiAoIWhhc0xhdGVyQ3h0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIGNhbid0IG92ZXJyaWRlIHVubGVzcyB0aGUgY29udGV4dCBpcyBhY3RpdmVcblxuXG4gICAgICAgICAgbGF0ZXJDeHRPdmVycmlkZXMgPSBsYXRlckN4dC5wcm9wZXJ0aWVzW3Byb3AubmFtZV0gIT0gbnVsbDtcblxuICAgICAgICAgIGlmIChsYXRlckN4dE92ZXJyaWRlcykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSAvLyBleGl0IGVhcmx5IGFzIGxvbmcgYXMgb25lIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWRkZWRQcm9wW25hbWVdICYmICFsYXRlckN4dE92ZXJyaWRlcykge1xuICAgICAgICAgIGFkZGVkUHJvcFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgZGlmZlByb3BzLnB1c2gobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICB9IC8vIGlmXG5cbiAgfSAvLyBmb3IgY29udGV4dHNcblxuXG4gIGNhY2hlW2R1YWxDeHRLZXldID0gZGlmZlByb3BzO1xuICByZXR1cm4gZGlmZlByb3BzO1xufTtcblxuc3R5Zm4uZ2V0Q29udGV4dE1ldGEgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN4dEtleSA9ICcnO1xuICB2YXIgZGlmZlByb3BzO1xuICB2YXIgcHJldktleSA9IGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSB8fCAnJztcblxuICBpZiAoc2VsZi5fcHJpdmF0ZS5uZXdTdHlsZSkge1xuICAgIHByZXZLZXkgPSAnJzsgLy8gc2luY2Ugd2UgbmVlZCB0byBhcHBseSBhbGwgc3R5bGUgaWYgYSBmcmVzaCBzdHlsZXNoZWV0XG4gIH0gLy8gZ2V0IHRoZSBjeHQga2V5XG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IHNlbGZbaV07XG4gICAgdmFyIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgPSBjb250ZXh0LnNlbGVjdG9yICYmIGNvbnRleHQuc2VsZWN0b3IubWF0Y2hlcyhlbGUpOyAvLyBOQjogY29udGV4dC5zZWxlY3RvciBtYXkgYmUgbnVsbCBmb3IgJ2NvcmUnXG5cbiAgICBpZiAoY29udGV4dFNlbGVjdG9yTWF0Y2hlcykge1xuICAgICAgY3h0S2V5ICs9IFRSVUU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN4dEtleSArPSBGQUxTRTtcbiAgICB9XG4gIH0gLy8gZm9yIGNvbnRleHRcblxuXG4gIGRpZmZQcm9wcyA9IHNlbGYuZ2V0UHJvcGVydGllc0RpZmYocHJldktleSwgY3h0S2V5KTtcbiAgZWxlLl9wcml2YXRlLnN0eWxlQ3h0S2V5ID0gY3h0S2V5O1xuICByZXR1cm4ge1xuICAgIGtleTogY3h0S2V5LFxuICAgIGRpZmZQcm9wTmFtZXM6IGRpZmZQcm9wcyxcbiAgICBlbXB0eTogZGlmZlByb3BzLmxlbmd0aCA9PT0gMFxuICB9O1xufTsgLy8gZ2V0cyBhIGNvbXB1dGVkIGVsZSBzdHlsZSBvYmplY3QgYmFzZWQgb24gbWF0Y2hlZCBjb250ZXh0c1xuXG5cbnN0eWZuLmdldENvbnRleHRTdHlsZSA9IGZ1bmN0aW9uIChjeHRNZXRhKSB7XG4gIHZhciBjeHRLZXkgPSBjeHRNZXRhLmtleTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3h0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzIHx8IHt9OyAvLyBpZiBhbHJlYWR5IGNvbXB1dGVkIHN0eWxlLCByZXR1cm5lZCBjYWNoZWQgY29weVxuXG4gIGlmIChjeHRTdHlsZXNbY3h0S2V5XSkge1xuICAgIHJldHVybiBjeHRTdHlsZXNbY3h0S2V5XTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IHtcbiAgICBfcHJpdmF0ZToge1xuICAgICAga2V5OiBjeHRLZXlcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgdmFyIGhhc0N4dCA9IGN4dEtleVtpXSA9PT0gVFJVRTtcblxuICAgIGlmICghaGFzQ3h0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGN4dC5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcHJvcCA9IGN4dC5wcm9wZXJ0aWVzW2pdO1xuICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IHByb3A7XG4gICAgfVxuICB9XG5cbiAgY3h0U3R5bGVzW2N4dEtleV0gPSBzdHlsZTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuc3R5Zm4uYXBwbHlDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiAoY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBkaWZmUHJvcHMgPSBjeHRNZXRhLmRpZmZQcm9wTmFtZXM7XG4gIHZhciByZXREaWZmUHJvcHMgPSB7fTtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmZQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaWZmUHJvcE5hbWUgPSBkaWZmUHJvcHNbaV07XG4gICAgdmFyIGN4dFByb3AgPSBjeHRTdHlsZVtkaWZmUHJvcE5hbWVdO1xuICAgIHZhciBlbGVQcm9wID0gZWxlLnBzdHlsZShkaWZmUHJvcE5hbWUpO1xuXG4gICAgaWYgKCFjeHRQcm9wKSB7XG4gICAgICAvLyBubyBjb250ZXh0IHByb3AgbWVhbnMgZGVsZXRlXG4gICAgICBpZiAoIWVsZVByb3ApIHtcbiAgICAgICAgY29udGludWU7IC8vIG5vIGV4aXN0aW5nIHByb3AgbWVhbnMgbm90aGluZyBuZWVkcyB0byBiZSByZW1vdmVkXG4gICAgICAgIC8vIG5iIGFmZmVjdHMgaW5pdGlhbCBhcHBsaWNhdGlvbiBvbiBtYXBwZWQgdmFsdWVzIGxpa2UgY29udHJvbC1wb2ludC1kaXN0YW5jZXNcbiAgICAgIH0gZWxzZSBpZiAoZWxlUHJvcC5ieXBhc3MpIHtcbiAgICAgICAgY3h0UHJvcCA9IHtcbiAgICAgICAgICBuYW1lOiBkaWZmUHJvcE5hbWUsXG4gICAgICAgICAgZGVsZXRlQnlwYXNzZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN4dFByb3AgPSB7XG4gICAgICAgICAgbmFtZTogZGlmZlByb3BOYW1lLFxuICAgICAgICAgIFwiZGVsZXRlXCI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gdGhlIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuXG5cbiAgICBpZiAoZWxlUHJvcCA9PT0gY3h0UHJvcCkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIGEgbWFwcGVkIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuXG5cbiAgICBpZiAoY3h0UHJvcC5tYXBwZWQgPT09IHR5cGVzLmZuIC8vIGNvbnRleHQgcHJvcCBpcyBmdW5jdGlvbiBtYXBwZXJcbiAgICAmJiBlbGVQcm9wICE9IG51bGwgLy8gc29tZSBwcm9wcyBjYW4gYmUgbnVsbCBldmVuIGJ5IGRlZmF1bHQgKGUuZy4gYSBwcm9wIHRoYXQgb3ZlcnJpZGVzIGFub3RoZXIgb25lKVxuICAgICYmIGVsZVByb3AubWFwcGluZyAhPSBudWxsIC8vIGVsZSBwcm9wIGlzIGEgY29uY3JldGUgdmFsdWUgZnJvbSBmcm9tIGEgbWFwcGVyXG4gICAgJiYgZWxlUHJvcC5tYXBwaW5nLnZhbHVlID09PSBjeHRQcm9wLnZhbHVlIC8vIHRoZSBjdXJyZW50IHByb3Agb24gdGhlIGVsZSBpcyBhIGZsYXQgcHJvcCB2YWx1ZSBmb3IgdGhlIGZ1bmN0aW9uIG1hcHBlclxuICAgICkge1xuICAgICAgICAvLyBOQiBkb24ndCB3cml0ZSB0byBjeHRQcm9wLCBhcyBpdCdzIHNoYXJlZCBhbW9uZyBlbGVzIChzdG9yZWQgaW4gc3R5bGVzaGVldClcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBlbGVQcm9wLm1hcHBpbmc7IC8vIGNhbiB3cml0ZSB0byBtYXBwaW5nLCBhcyBpdCdzIGEgcGVyLWVsZSBjb3B5XG5cbiAgICAgICAgdmFyIGZuVmFsdWUgPSBtYXBwaW5nLmZuVmFsdWUgPSBjeHRQcm9wLnZhbHVlKGVsZSk7IC8vIHRlbXBvcmFyaWx5IGNhY2hlIHRoZSB2YWx1ZSBpbiBjYXNlIG9mIGEgbWlzc1xuXG4gICAgICAgIGlmIChmblZhbHVlID09PSBtYXBwaW5nLnByZXZGblZhbHVlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIHZhciByZXREaWZmUHJvcCA9IHJldERpZmZQcm9wc1tkaWZmUHJvcE5hbWVdID0ge1xuICAgICAgcHJldjogZWxlUHJvcFxuICAgIH07XG4gICAgc2VsZi5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgY3h0UHJvcCk7XG4gICAgcmV0RGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoZGlmZlByb3BOYW1lKTtcblxuICAgIGlmIChyZXREaWZmUHJvcC5uZXh0ICYmIHJldERpZmZQcm9wLm5leHQuYnlwYXNzKSB7XG4gICAgICByZXREaWZmUHJvcC5uZXh0ID0gcmV0RGlmZlByb3AubmV4dC5ieXBhc3NlZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRpZmZQcm9wczogcmV0RGlmZlByb3BzXG4gIH07XG59O1xuXG5zdHlmbi51cGRhdGVTdHlsZUhpbnRzID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHByb3BOYW1lcyA9IHNlbGYucHJvcGVydHlHcm91cE5hbWVzO1xuICB2YXIgcHJvcEdyS2V5cyA9IHNlbGYucHJvcGVydHlHcm91cEtleXM7XG5cbiAgdmFyIHByb3BIYXNoID0gZnVuY3Rpb24gcHJvcEhhc2goZWxlLCBwcm9wTmFtZXMsIHNlZWRLZXkpIHtcbiAgICByZXR1cm4gc2VsZi5nZXRQcm9wZXJ0aWVzSGFzaChlbGUsIHByb3BOYW1lcywgc2VlZEtleSk7XG4gIH07XG5cbiAgdmFyIG9sZFN0eWxlS2V5ID0gX3Auc3R5bGVLZXk7XG5cbiAgaWYgKGVsZS5yZW1vdmVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNOb2RlID0gX3AuZ3JvdXAgPT09ICdub2Rlcyc7IC8vIGdldCB0aGUgc3R5bGUga2V5IGhhc2hlcyBwZXIgcHJvcCBncm91cFxuICAvLyBidXQgbGF6aWx5IC0tIG9ubHkgdXNlIG5vbi1kZWZhdWx0IHByb3AgdmFsdWVzIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGhhc2hlc1xuICAvL1xuXG4gIHZhciBvdmVycmlkZGVuU3R5bGVzID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhvdmVycmlkZGVuU3R5bGVzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BHcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JLZXkgPSBwcm9wR3JLZXlzW2ldO1xuICAgIF9wLnN0eWxlS2V5c1tncktleV0gPSAwO1xuICB9XG5cbiAgdmFyIHVwZGF0ZUdyS2V5ID0gZnVuY3Rpb24gdXBkYXRlR3JLZXkodmFsLCBncktleSkge1xuICAgIHJldHVybiBfcC5zdHlsZUtleXNbZ3JLZXldID0gaGFzaEludCh2YWwsIF9wLnN0eWxlS2V5c1tncktleV0pO1xuICB9O1xuXG4gIHZhciB1cGRhdGVHcktleVdTdHIgPSBmdW5jdGlvbiB1cGRhdGVHcktleVdTdHIoc3RyVmFsLCBncktleSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RyVmFsLmxlbmd0aDsgaisrKSB7XG4gICAgICB1cGRhdGVHcktleShzdHJWYWwuY2hhckNvZGVBdChqKSwgZ3JLZXkpO1xuICAgIH1cbiAgfTsgLy8gLSBoYXNoaW5nIHdvcmtzIG9uIDMyIGJpdCBpbnRzIGIvYyB3ZSB1c2UgYml0d2lzZSBvcHNcbiAgLy8gLSBzbWFsbCBudW1iZXJzIGdldCBjdXQgb2ZmIChlLmcuIDAuMTIzIGlzIHNlZW4gYXMgMCBieSB0aGUgaGFzaGluZyBmdW5jdGlvbilcbiAgLy8gLSByYWlzZSB1cCBzbWFsbCBudW1iZXJzIHNvIG1vcmUgc2lnbmlmaWNhbnQgZGlnaXRzIGFyZSBzZWVuIGJ5IGhhc2hpbmdcbiAgLy8gLSBtYWtlIHNtYWxsIG51bWJlcnMgbGFyZ2VyIHRoYW4gYSBub3JtYWwgdmFsdWUgdG8gYXZvaWQgY29sbGlzaW9uc1xuICAvLyAtIHdvcmtzIGluIHByYWN0aWNlIGFuZCBpdCdzIHJlbGF0aXZlbHkgY2hlYXBcblxuXG4gIHZhciBOID0gMjAwMDAwMDAwMDtcblxuICB2YXIgY2xlYW5OdW0gPSBmdW5jdGlvbiBjbGVhbk51bSh2YWwpIHtcbiAgICByZXR1cm4gLTEyOCA8IHZhbCAmJiB2YWwgPCAxMjggJiYgTWF0aC5mbG9vcih2YWwpICE9PSB2YWwgPyBOIC0gKHZhbCAqIDEwMjQgfCAwKSA6IHZhbDtcbiAgfTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcHJvcE5hbWVzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBuYW1lID0gcHJvcE5hbWVzW19pXTtcbiAgICB2YXIgcGFyc2VkUHJvcCA9IG92ZXJyaWRkZW5TdHlsZXNbbmFtZV07XG5cbiAgICBpZiAocGFyc2VkUHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcEluZm8gPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gICAgdmFyIHR5cGUgPSBwcm9wSW5mby50eXBlO1xuICAgIHZhciBfZ3JLZXkgPSBwcm9wSW5mby5ncm91cEtleTtcbiAgICB2YXIgbm9ybWFsaXplZE51bWJlclZhbCA9IHZvaWQgMDtcblxuICAgIGlmIChwcm9wSW5mby5oYXNoT3ZlcnJpZGUgIT0gbnVsbCkge1xuICAgICAgbm9ybWFsaXplZE51bWJlclZhbCA9IHByb3BJbmZvLmhhc2hPdmVycmlkZShlbGUsIHBhcnNlZFByb3ApO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkUHJvcC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5vcm1hbGl6ZWROdW1iZXJWYWwgPSBwYXJzZWRQcm9wLnBmVmFsdWU7XG4gICAgfSAvLyBtaWdodCBub3QgYmUgYSBudW1iZXIgaWYgaXQgYWxsb3dzIGVudW1zXG5cblxuICAgIHZhciBudW1iZXJWYWwgPSBwcm9wSW5mby5lbnVtcyA9PSBudWxsID8gcGFyc2VkUHJvcC52YWx1ZSA6IG51bGw7XG4gICAgdmFyIGhhdmVOb3JtTnVtID0gbm9ybWFsaXplZE51bWJlclZhbCAhPSBudWxsO1xuICAgIHZhciBoYXZlVW5pdGVkTnVtID0gbnVtYmVyVmFsICE9IG51bGw7XG4gICAgdmFyIGhhdmVOdW0gPSBoYXZlTm9ybU51bSB8fCBoYXZlVW5pdGVkTnVtO1xuICAgIHZhciB1bml0cyA9IHBhcnNlZFByb3AudW5pdHM7IC8vIG51bWJlcnMgYXJlIGNoZWFwZXIgdG8gaGFzaCB0aGFuIHN0cmluZ3NcbiAgICAvLyAxIGhhc2ggb3AgdnMgbiBoYXNoIG9wcyAoZm9yIGxlbmd0aCBuIHN0cmluZylcblxuICAgIGlmICh0eXBlLm51bWJlciAmJiBoYXZlTnVtKSB7XG4gICAgICB2YXIgdiA9IGhhdmVOb3JtTnVtID8gbm9ybWFsaXplZE51bWJlclZhbCA6IG51bWJlclZhbDtcblxuICAgICAgaWYgKHR5cGUubXVsdGlwbGUpIHtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdXBkYXRlR3JLZXkoY2xlYW5OdW0odltfaTJdKSwgX2dyS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlR3JLZXkoY2xlYW5OdW0odiksIF9ncktleSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGF2ZU5vcm1OdW0gJiYgdW5pdHMgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVHcktleVdTdHIodW5pdHMsIF9ncktleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUdyS2V5V1N0cihwYXJzZWRQcm9wLnN0clZhbHVlLCBfZ3JLZXkpO1xuICAgIH1cbiAgfSAvLyBvdmVyYWxsIHN0eWxlIGtleVxuICAvL1xuXG5cbiAgdmFyIGhhc2ggPSAwO1xuXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHByb3BHcktleXMubGVuZ3RoOyBfaTMrKykge1xuICAgIHZhciBfZ3JLZXkyID0gcHJvcEdyS2V5c1tfaTNdO1xuICAgIHZhciBnckhhc2ggPSBfcC5zdHlsZUtleXNbX2dyS2V5Ml07XG4gICAgaGFzaCA9IGhhc2hJbnQoZ3JIYXNoLCBoYXNoKTtcbiAgfVxuXG4gIF9wLnN0eWxlS2V5ID0gaGFzaDsgLy8gbGFiZWwgZGltc1xuICAvL1xuXG4gIHZhciBsYWJlbERpbXNLZXkgPSBfcC5sYWJlbERpbXNLZXkgPSBfcC5zdHlsZUtleXMubGFiZWxEaW1lbnNpb25zO1xuICBfcC5sYWJlbEtleSA9IHByb3BIYXNoKGVsZSwgWydsYWJlbCddLCBsYWJlbERpbXNLZXkpO1xuICBfcC5sYWJlbFN0eWxlS2V5ID0gaGFzaEludChfcC5zdHlsZUtleXMuY29tbW9uTGFiZWwsIF9wLmxhYmVsS2V5KTtcblxuICBpZiAoIWlzTm9kZSkge1xuICAgIF9wLnNvdXJjZUxhYmVsS2V5ID0gcHJvcEhhc2goZWxlLCBbJ3NvdXJjZS1sYWJlbCddLCBsYWJlbERpbXNLZXkpO1xuICAgIF9wLnNvdXJjZUxhYmVsU3R5bGVLZXkgPSBoYXNoSW50KF9wLnN0eWxlS2V5cy5jb21tb25MYWJlbCwgX3Auc291cmNlTGFiZWxLZXkpO1xuICAgIF9wLnRhcmdldExhYmVsS2V5ID0gcHJvcEhhc2goZWxlLCBbJ3RhcmdldC1sYWJlbCddLCBsYWJlbERpbXNLZXkpO1xuICAgIF9wLnRhcmdldExhYmVsU3R5bGVLZXkgPSBoYXNoSW50KF9wLnN0eWxlS2V5cy5jb21tb25MYWJlbCwgX3AudGFyZ2V0TGFiZWxLZXkpO1xuICB9IC8vIG5vZGVcbiAgLy9cblxuXG4gIGlmIChpc05vZGUpIHtcbiAgICB2YXIgX3Akc3R5bGVLZXlzID0gX3Auc3R5bGVLZXlzLFxuICAgICAgICBub2RlQm9keSA9IF9wJHN0eWxlS2V5cy5ub2RlQm9keSxcbiAgICAgICAgbm9kZUJvcmRlciA9IF9wJHN0eWxlS2V5cy5ub2RlQm9yZGVyLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2UgPSBfcCRzdHlsZUtleXMuYmFja2dyb3VuZEltYWdlLFxuICAgICAgICBjb21wb3VuZCA9IF9wJHN0eWxlS2V5cy5jb21wb3VuZCxcbiAgICAgICAgcGllID0gX3Akc3R5bGVLZXlzLnBpZTtcbiAgICBfcC5ub2RlS2V5ID0gaGFzaEludHNBcnJheShbbm9kZUJvcmRlciwgYmFja2dyb3VuZEltYWdlLCBjb21wb3VuZCwgcGllXSwgbm9kZUJvZHkpO1xuICAgIF9wLmhhc1BpZSA9IHBpZSAhPSAwO1xuICB9XG5cbiAgcmV0dXJuIG9sZFN0eWxlS2V5ICE9PSBfcC5zdHlsZUtleTtcbn07XG5cbnN0eWZuLmNsZWFyU3R5bGVIaW50cyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICBfcC5zdHlsZUtleXMgPSB7fTtcbiAgX3Auc3R5bGVLZXkgPSBudWxsO1xuICBfcC5sYWJlbEtleSA9IG51bGw7XG4gIF9wLmxhYmVsU3R5bGVLZXkgPSBudWxsO1xuICBfcC5zb3VyY2VMYWJlbEtleSA9IG51bGw7XG4gIF9wLnNvdXJjZUxhYmVsU3R5bGVLZXkgPSBudWxsO1xuICBfcC50YXJnZXRMYWJlbEtleSA9IG51bGw7XG4gIF9wLnRhcmdldExhYmVsU3R5bGVLZXkgPSBudWxsO1xuICBfcC5ub2RlS2V5ID0gbnVsbDtcbiAgX3AuaGFzUGllID0gbnVsbDtcbn07IC8vIGFwcGx5IGEgcHJvcGVydHkgdG8gdGhlIHN0eWxlIChmb3IgaW50ZXJuYWwgdXNlKVxuLy8gcmV0dXJucyB3aGV0aGVyIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsXG4vL1xuLy8gbm93LCB0aGlzIGZ1bmN0aW9uIGZsYXR0ZW5zIHRoZSBwcm9wZXJ0eSwgYW5kIGhlcmUncyBob3c6XG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUsIGRlbGV0ZUJ5cGFzczogdHJ1ZSB9XG4vLyBubyBwcm9wZXJ0eSBpcyBnZW5lcmF0ZWQsIGluc3RlYWQgdGhlIGJ5cGFzcyBwcm9wZXJ0eSBpbiB0aGVcbi8vIGVsZW1lbnQncyBzdHlsZSBpcyByZXBsYWNlZCBieSB3aGF0J3MgcG9pbnRlZCB0byBieSB0aGUgYGJ5cGFzc2VkYFxuLy8gZmllbGQgaW4gdGhlIGJ5cGFzcyBwcm9wZXJ0eSAoaS5lLiByZXN0b3JpbmcgdGhlIHByb3BlcnR5IHRoZVxuLy8gYnlwYXNzIHdhcyBvdmVycmlkaW5nKVxuLy9cbi8vIGZvciBwYXJzZWRQcm9wOnsgbWFwcGVkOiB0cnV0aHkgfVxuLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgbWFwcGluZzogcHJvcCB9XG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUgfVxuLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgYnlwYXNzZWQ6IHBhcnNlZFByb3AgfVxuXG5cbnN0eWZuLmFwcGx5UGFyc2VkUHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlLCBwYXJzZWRQcm9wKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHByb3AgPSBwYXJzZWRQcm9wO1xuICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gIHZhciBmbGF0UHJvcDtcbiAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcbiAgdmFyIHR5cGUgPSBzZWxmLnByb3BlcnRpZXNbcHJvcC5uYW1lXS50eXBlO1xuICB2YXIgcHJvcElzQnlwYXNzID0gcHJvcC5ieXBhc3M7XG4gIHZhciBvcmlnUHJvcCA9IHN0eWxlW3Byb3AubmFtZV07XG4gIHZhciBvcmlnUHJvcElzQnlwYXNzID0gb3JpZ1Byb3AgJiYgb3JpZ1Byb3AuYnlwYXNzO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBmbGF0UHJvcE1hcHBpbmcgPSAnbWFwcGluZyc7XG5cbiAgdmFyIGdldFZhbCA9IGZ1bmN0aW9uIGdldFZhbChwKSB7XG4gICAgaWYgKHAgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChwLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHAucGZWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHAudmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjaGVja1RyaWdnZXJzID0gZnVuY3Rpb24gY2hlY2tUcmlnZ2VycygpIHtcbiAgICB2YXIgZnJvbVZhbCA9IGdldFZhbChvcmlnUHJvcCk7XG4gICAgdmFyIHRvVmFsID0gZ2V0VmFsKHByb3ApO1xuICAgIHNlbGYuY2hlY2tUcmlnZ2VycyhlbGUsIHByb3AubmFtZSwgZnJvbVZhbCwgdG9WYWwpO1xuICB9OyAvLyBlZGdlIHNhbml0eSBjaGVja3MgdG8gcHJldmVudCB0aGUgY2xpZW50IGZyb20gbWFraW5nIHNlcmlvdXMgbWlzdGFrZXNcblxuXG4gIGlmIChwYXJzZWRQcm9wLm5hbWUgPT09ICdjdXJ2ZS1zdHlsZScgJiYgZWxlLmlzRWRnZSgpICYmICggLy8gbG9vcHMgbXVzdCBiZSBidW5kbGVkIGJlemllcnNcbiAgcGFyc2VkUHJvcC52YWx1ZSAhPT0gJ2JlemllcicgJiYgZWxlLmlzTG9vcCgpIHx8IC8vIGVkZ2VzIGNvbm5lY3RlZCB0byBjb21wb3VuZCBub2RlcyBjYW4gbm90IGJlIGhheXN0YWNrc1xuICBwYXJzZWRQcm9wLnZhbHVlID09PSAnaGF5c3RhY2snICYmIChlbGUuc291cmNlKCkuaXNQYXJlbnQoKSB8fCBlbGUudGFyZ2V0KCkuaXNQYXJlbnQoKSkpKSB7XG4gICAgcHJvcCA9IHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKHBhcnNlZFByb3AubmFtZSwgJ2JlemllcicsIHByb3BJc0J5cGFzcyk7XG4gIH1cblxuICBpZiAocHJvcFtcImRlbGV0ZVwiXSkge1xuICAgIC8vIGRlbGV0ZSB0aGUgcHJvcGVydHkgYW5kIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBmYWxzZXkgdmFsdWVcbiAgICBzdHlsZVtwcm9wLm5hbWVdID0gdW5kZWZpbmVkO1xuICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwcm9wLmRlbGV0ZUJ5cGFzc2VkKSB7XG4gICAgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSB0aGF0IHRoZVxuICAgIGlmICghb3JpZ1Byb3ApIHtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBjYW4ndCBkZWxldGUgaWYgbm8gcHJvcFxuICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAvLyBkZWxldGUgYnlwYXNzZWRcbiAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gdW5kZWZpbmVkO1xuICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NlZFxuICAgIH1cbiAgfSAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBieXBhc3NcblxuXG4gIGlmIChwcm9wLmRlbGV0ZUJ5cGFzcykge1xuICAgIC8vIHRoZW4gdGhpcyBwcm9wZXJ0eSBpcyBqdXN0IGhlcmUgdG8gaW5kaWNhdGUgd2UgbmVlZCB0byBkZWxldGVcbiAgICBpZiAoIW9yaWdQcm9wKSB7XG4gICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gcHJvcGVydHkgaXMgYWxyZWFkeSBub3QgZGVmaW5lZFxuICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAvLyB0aGVuIHJlcGxhY2UgdGhlIGJ5cGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBvcmlnaW5hbFxuICAgICAgLy8gYmVjYXVzZSB0aGUgYnlwYXNzZWQgcHJvcGVydHkgd2FzIGFscmVhZHkgYXBwbGllZCAoYW5kIHRoZXJlZm9yZSBwYXJzZWQpLCB3ZSBjYW4ganVzdCByZXBsYWNlIGl0IChubyByZWFwcGx5aW5nIG5lY2Vzc2FyeSlcbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBvcmlnUHJvcC5ieXBhc3NlZDtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIHVuc3VjY2Vzc2Z1bCBkZWxldGluZyB0aGUgYnlwYXNzXG4gICAgfVxuICB9XG5cbiAgdmFyIHByaW50TWFwcGluZ0VyciA9IGZ1bmN0aW9uIHByaW50TWFwcGluZ0VycigpIHtcbiAgICB3YXJuKCdEbyBub3QgYXNzaWduIG1hcHBpbmdzIHRvIGVsZW1lbnRzIHdpdGhvdXQgY29ycmVzcG9uZGluZyBkYXRhIChpLmUuIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaGFzIG5vIG1hcHBpbmcgZm9yIHByb3BlcnR5IGAnICsgcHJvcC5uYW1lICsgJ2Agd2l0aCBkYXRhIGZpZWxkIGAnICsgcHJvcC5maWVsZCArICdgKTsgdHJ5IGEgYFsnICsgcHJvcC5maWVsZCArICddYCBzZWxlY3RvciB0byBsaW1pdCBzY29wZSB0byBlbGVtZW50cyB3aXRoIGAnICsgcHJvcC5maWVsZCArICdgIGRlZmluZWQnKTtcbiAgfTsgLy8gcHV0IHRoZSBwcm9wZXJ0eSBpbiB0aGUgc3R5bGUgb2JqZWN0c1xuXG5cbiAgc3dpdGNoIChwcm9wLm1hcHBlZCkge1xuICAgIC8vIGZsYXR0ZW4gdGhlIHByb3BlcnR5IGlmIG1hcHBlZFxuICAgIGNhc2UgdHlwZXMubWFwRGF0YTpcbiAgICAgIHtcbiAgICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgZmllbGRWYWwgPSBfcC5kYXRhO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aCAmJiBmaWVsZFZhbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgIGZpZWxkVmFsID0gZmllbGRWYWxbZmllbGRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpZWxkVmFsID09IG51bGwpIHtcbiAgICAgICAgICBwcmludE1hcHBpbmdFcnIoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGVyY2VudDtcblxuICAgICAgICBpZiAoIW51bWJlcihmaWVsZFZhbCkpIHtcbiAgICAgICAgICAvLyB0aGVuIGRvbid0IGFwcGx5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgd2FybignRG8gbm90IHVzZSBjb250aW51b3VzIG1hcHBlcnMgd2l0aG91dCBzcGVjaWZ5aW5nIG51bWVyaWMgZGF0YSAoaS5lLiBgJyArIHByb3AuZmllbGQgKyAnOiAnICsgZmllbGRWYWwgKyAnYCBmb3IgYCcgKyBlbGUuaWQoKSArICdgIGlzIG5vbi1udW1lcmljKScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZmllbGRXaWR0aCA9IHByb3AuZmllbGRNYXggLSBwcm9wLmZpZWxkTWluO1xuXG4gICAgICAgICAgaWYgKGZpZWxkV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIHNhZmV0eSBjaGVjayAtLSBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5IGFzIG5vIHByb3BzIG9mIHplcm8gcmFuZ2Ugc2hvdWxkIGJlIHBhc3NlZCBoZXJlXG4gICAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVyY2VudCA9IChmaWVsZFZhbCAtIHByb3AuZmllbGRNaW4pIC8gZmllbGRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gbWFrZSBzdXJlIHRvIGJvdW5kIHBlcmNlbnQgdmFsdWVcblxuXG4gICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZS5jb2xvcikge1xuICAgICAgICAgIHZhciByMSA9IHByb3AudmFsdWVNaW5bMF07XG4gICAgICAgICAgdmFyIHIyID0gcHJvcC52YWx1ZU1heFswXTtcbiAgICAgICAgICB2YXIgZzEgPSBwcm9wLnZhbHVlTWluWzFdO1xuICAgICAgICAgIHZhciBnMiA9IHByb3AudmFsdWVNYXhbMV07XG4gICAgICAgICAgdmFyIGIxID0gcHJvcC52YWx1ZU1pblsyXTtcbiAgICAgICAgICB2YXIgYjIgPSBwcm9wLnZhbHVlTWF4WzJdO1xuICAgICAgICAgIHZhciBhMSA9IHByb3AudmFsdWVNaW5bM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWluWzNdO1xuICAgICAgICAgIHZhciBhMiA9IHByb3AudmFsdWVNYXhbM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWF4WzNdO1xuICAgICAgICAgIHZhciBjbHIgPSBbTWF0aC5yb3VuZChyMSArIChyMiAtIHIxKSAqIHBlcmNlbnQpLCBNYXRoLnJvdW5kKGcxICsgKGcyIC0gZzEpICogcGVyY2VudCksIE1hdGgucm91bmQoYjEgKyAoYjIgLSBiMSkgKiBwZXJjZW50KSwgTWF0aC5yb3VuZChhMSArIChhMiAtIGExKSAqIHBlcmNlbnQpXTtcbiAgICAgICAgICBmbGF0UHJvcCA9IHtcbiAgICAgICAgICAgIC8vIGNvbG91cnMgYXJlIHNpbXBsZSwgc28ganVzdCBjcmVhdGUgdGhlIGZsYXQgcHJvcGVydHkgaW5zdGVhZCBvZiBleHBlbnNpdmUgc3RyaW5nIHBhcnNpbmdcbiAgICAgICAgICAgIGJ5cGFzczogcHJvcC5ieXBhc3MsXG4gICAgICAgICAgICAvLyB3ZSdyZSBhIGJ5cGFzcyBpZiB0aGUgbWFwcGluZyBwcm9wZXJ0eSBpcyBhIGJ5cGFzc1xuICAgICAgICAgICAgbmFtZTogcHJvcC5uYW1lLFxuICAgICAgICAgICAgdmFsdWU6IGNscixcbiAgICAgICAgICAgIHN0clZhbHVlOiAncmdiKCcgKyBjbHJbMF0gKyAnLCAnICsgY2xyWzFdICsgJywgJyArIGNsclsyXSArICcpJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZS5udW1iZXIpIHtcbiAgICAgICAgICB2YXIgY2FsY1ZhbHVlID0gcHJvcC52YWx1ZU1pbiArIChwcm9wLnZhbHVlTWF4IC0gcHJvcC52YWx1ZU1pbikgKiBwZXJjZW50O1xuICAgICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIGNhbGNWYWx1ZSwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBjYW4gb25seSBtYXAgdG8gY29sb3VycyBhbmQgbnVtYmVyc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIGRvbid0IGFwcGx5IHRoZSBwcm9wZXJ0eSBhbmQgZmFsbCBiYWNrIG9uIHRoZSBleGlzdGluZyBzdHlsZVxuICAgICAgICAgIHByaW50TWFwcGluZ0VycigpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG5cbiAgICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIGRpcmVjdCBtYXBwaW5nXG5cbiAgICBjYXNlIHR5cGVzLmRhdGE6XG4gICAgICB7XG4gICAgICAgIC8vIGZsYXR0ZW4gdGhlIGZpZWxkIChlLmcuIGRhdGEuZm9vLmJhcilcbiAgICAgICAgdmFyIF9maWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgdmFyIF9maWVsZFZhbCA9IF9wLmRhdGE7XG5cbiAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgX2ZpZWxkcy5sZW5ndGggJiYgX2ZpZWxkVmFsOyBfaTQrKykge1xuICAgICAgICAgIHZhciBfZmllbGQgPSBfZmllbGRzW19pNF07XG4gICAgICAgICAgX2ZpZWxkVmFsID0gX2ZpZWxkVmFsW19maWVsZF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2ZpZWxkVmFsICE9IG51bGwpIHtcbiAgICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBfZmllbGRWYWwsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIGRvbid0IGFwcGx5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcblxuICAgICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIHR5cGVzLmZuOlxuICAgICAge1xuICAgICAgICB2YXIgZm4gPSBwcm9wLnZhbHVlO1xuICAgICAgICB2YXIgZm5SZXRWYWwgPSBwcm9wLmZuVmFsdWUgIT0gbnVsbCA/IHByb3AuZm5WYWx1ZSA6IGZuKGVsZSk7IC8vIGNoZWNrIGZvciBjYWNoZWQgdmFsdWUgYmVmb3JlIGNhbGxpbmcgZnVuY3Rpb25cblxuICAgICAgICBwcm9wLnByZXZGblZhbHVlID0gZm5SZXRWYWw7XG5cbiAgICAgICAgaWYgKGZuUmV0VmFsID09IG51bGwpIHtcbiAgICAgICAgICB3YXJuKCdDdXN0b20gZnVuY3Rpb24gbWFwcGVycyBtYXkgbm90IHJldHVybiBudWxsIChpLmUuIGAnICsgcHJvcC5uYW1lICsgJ2AgZm9yIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaXMgbnVsbCknKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBmblJldFZhbCwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG5cbiAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgIHdhcm4oJ0N1c3RvbSBmdW5jdGlvbiBtYXBwZXJzIG1heSBub3QgcmV0dXJuIGludmFsaWQgdmFsdWVzIGZvciB0aGUgcHJvcGVydHkgdHlwZSAoaS5lLiBgJyArIHByb3AubmFtZSArICdgIGZvciBlbGUgYCcgKyBlbGUuaWQoKSArICdgIGlzIGludmFsaWQpJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IGNvcHkocHJvcCk7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcblxuICAgICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIGJyZWFrO1xuICAgIC8vIGp1c3Qgc2V0IHRoZSBwcm9wZXJ0eVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBub3QgYSB2YWxpZCBtYXBwaW5nXG4gIH0gLy8gaWYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5LCB0aGVuIGxpbmsgdGhlIHJlc3VsdGFudCBwcm9wZXJ0eSB0byB0aGUgb3JpZ2luYWwgb25lXG5cblxuICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgaWYgKG9yaWdQcm9wSXNCeXBhc3MpIHtcbiAgICAgIC8vIHRoZW4gdGhpcyBieXBhc3Mgb3ZlcnJpZGVzIHRoZSBleGlzdGluZyBvbmVcbiAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcC5ieXBhc3NlZDsgLy8gc3RlYWwgYnlwYXNzZWQgcHJvcCBmcm9tIG9sZCBieXBhc3NcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlbiBsaW5rIHRoZSBvcmlnIHByb3AgdG8gdGhlIG5ldyBieXBhc3NcbiAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcDtcbiAgICB9XG5cbiAgICBzdHlsZVtwcm9wLm5hbWVdID0gcHJvcDsgLy8gYW5kIHNldFxuICB9IGVsc2Uge1xuICAgIC8vIHByb3AgaXMgbm90IGJ5cGFzc1xuICAgIGlmIChvcmlnUHJvcElzQnlwYXNzKSB7XG4gICAgICAvLyB0aGVuIGtlZXAgdGhlIG9yaWcgcHJvcCAoc2luY2UgaXQncyBhIGJ5cGFzcykgYW5kIGxpbmsgdG8gdGhlIG5ldyBwcm9wXG4gICAgICBvcmlnUHJvcC5ieXBhc3NlZCA9IHByb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZW4ganVzdCByZXBsYWNlIHRoZSBvbGQgcHJvcCB3aXRoIHRoZSBuZXcgb25lXG4gICAgICBzdHlsZVtwcm9wLm5hbWVdID0gcHJvcDtcbiAgICB9XG4gIH1cblxuICBjaGVja1RyaWdnZXJzKCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuc3R5Zm4uY2xlYW5FbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzLCBrZWVwQnlwYXNzZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdGhpcy5jbGVhclN0eWxlSGludHMoZWxlKTtcbiAgICBlbGUuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgZWxlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuXG4gICAgaWYgKCFrZWVwQnlwYXNzZXMpIHtcbiAgICAgIGVsZS5fcHJpdmF0ZS5zdHlsZSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMoc3R5bGUpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BOYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wTmFtZXNbal07XG4gICAgICAgIHZhciBlbGVQcm9wID0gc3R5bGVbcHJvcE5hbWVdO1xuXG4gICAgICAgIGlmIChlbGVQcm9wICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoZWxlUHJvcC5ieXBhc3MpIHtcbiAgICAgICAgICAgIGVsZVByb3AuYnlwYXNzZWQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZVtwcm9wTmFtZV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTsgLy8gdXBkYXRlcyB0aGUgdmlzdWFsIHN0eWxlIGZvciBhbGwgZWxlbWVudHMgKHVzZWZ1bCBmb3IgbWFudWFsIHN0eWxlIG1vZGlmaWNhdGlvbiBhZnRlciBpbml0KVxuXG5cbnN0eWZuLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgZWxlcy51cGRhdGVTdHlsZSgpO1xufTsgLy8gZGlmZlByb3BzIDogeyBuYW1lID0+IHsgcHJldiwgbmV4dCB9IH1cblxuXG5zdHlmbi51cGRhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uIChlbGUsIGRpZmZQcm9wcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHByb3BzID0gZWxlLnBzdHlsZSgndHJhbnNpdGlvbi1wcm9wZXJ0eScpLnZhbHVlO1xuICB2YXIgZHVyYXRpb24gPSBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLWR1cmF0aW9uJykucGZWYWx1ZTtcbiAgdmFyIGRlbGF5ID0gZWxlLnBzdHlsZSgndHJhbnNpdGlvbi1kZWxheScpLnBmVmFsdWU7XG5cbiAgaWYgKHByb3BzLmxlbmd0aCA+IDAgJiYgZHVyYXRpb24gPiAwKSB7XG4gICAgdmFyIHN0eWxlID0ge307IC8vIGJ1aWxkIHVwIHRoZSBzdHlsZSB0byBhbmltYXRlIHRvd2FyZHNcblxuICAgIHZhciBhbnlQcmV2ID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgdmFyIHN0eVByb3AgPSBlbGUucHN0eWxlKHByb3ApO1xuICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzW3Byb3BdO1xuXG4gICAgICBpZiAoIWRpZmZQcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldlByb3AgPSBkaWZmUHJvcC5wcmV2O1xuICAgICAgdmFyIGZyb21Qcm9wID0gcHJldlByb3A7XG4gICAgICB2YXIgdG9Qcm9wID0gZGlmZlByb3AubmV4dCAhPSBudWxsID8gZGlmZlByb3AubmV4dCA6IHN0eVByb3A7XG4gICAgICB2YXIgZGlmZiA9IGZhbHNlO1xuICAgICAgdmFyIGluaXRWYWwgPSB2b2lkIDA7XG4gICAgICB2YXIgaW5pdER0ID0gMC4wMDAwMDE7IC8vIGRlbHRhIHRpbWUgJSB2YWx1ZSBmb3IgaW5pdFZhbCAoYWxsb3dzIGFuaW1hdGluZyBvdXQgb2YgaW5pdCB6ZXJvIG9wYWNpdHkpXG5cbiAgICAgIGlmICghZnJvbVByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGNvbnNpZGVyIHB4IHZhbHVlc1xuXG5cbiAgICAgIGlmIChudW1iZXIoZnJvbVByb3AucGZWYWx1ZSkgJiYgbnVtYmVyKHRvUHJvcC5wZlZhbHVlKSkge1xuICAgICAgICBkaWZmID0gdG9Qcm9wLnBmVmFsdWUgLSBmcm9tUHJvcC5wZlZhbHVlOyAvLyBub256ZXJvIGlzIHRydXRoeVxuXG4gICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC5wZlZhbHVlICsgaW5pdER0ICogZGlmZjsgLy8gY29uc2lkZXIgbnVtZXJpY2FsIHZhbHVlc1xuICAgICAgfSBlbHNlIGlmIChudW1iZXIoZnJvbVByb3AudmFsdWUpICYmIG51bWJlcih0b1Byb3AudmFsdWUpKSB7XG4gICAgICAgIGRpZmYgPSB0b1Byb3AudmFsdWUgLSBmcm9tUHJvcC52YWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcblxuICAgICAgICBpbml0VmFsID0gZnJvbVByb3AudmFsdWUgKyBpbml0RHQgKiBkaWZmOyAvLyBjb25zaWRlciBjb2xvdXIgdmFsdWVzXG4gICAgICB9IGVsc2UgaWYgKGFycmF5KGZyb21Qcm9wLnZhbHVlKSAmJiBhcnJheSh0b1Byb3AudmFsdWUpKSB7XG4gICAgICAgIGRpZmYgPSBmcm9tUHJvcC52YWx1ZVswXSAhPT0gdG9Qcm9wLnZhbHVlWzBdIHx8IGZyb21Qcm9wLnZhbHVlWzFdICE9PSB0b1Byb3AudmFsdWVbMV0gfHwgZnJvbVByb3AudmFsdWVbMl0gIT09IHRvUHJvcC52YWx1ZVsyXTtcbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnN0clZhbHVlO1xuICAgICAgfSAvLyB0aGUgcHJldmlvdXMgdmFsdWUgaXMgZ29vZCBmb3IgYW4gYW5pbWF0aW9uIG9ubHkgaWYgaXQncyBkaWZmZXJlbnRcblxuXG4gICAgICBpZiAoZGlmZikge1xuICAgICAgICBzdHlsZVtwcm9wXSA9IHRvUHJvcC5zdHJWYWx1ZTsgLy8gdG8gdmFsXG5cbiAgICAgICAgdGhpcy5hcHBseUJ5cGFzcyhlbGUsIHByb3AsIGluaXRWYWwpOyAvLyBmcm9tIHZhbFxuXG4gICAgICAgIGFueVByZXYgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gZW5kIGlmIHByb3BzIGFsbG93IGFuaVxuICAgIC8vIGNhbid0IHRyYW5zaXRpb24gaWYgdGhlcmUncyBub3RoaW5nIHByZXZpb3VzIHRvIHRyYW5zaXRpb24gZnJvbVxuXG5cbiAgICBpZiAoIWFueVByZXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfcC50cmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgIGVsZS5kZWxheUFuaW1hdGlvbihkZWxheSkucGxheSgpLnByb21pc2UoKS50aGVuKHJlc29sdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGVsZS5hbmltYXRpb24oe1xuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicpLnZhbHVlLFxuICAgICAgICBxdWV1ZTogZmFsc2VcbiAgICAgIH0pLnBsYXkoKS5wcm9taXNlKCk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpZiggIWlzQnlwYXNzICl7XG4gICAgICBzZWxmLnJlbW92ZUJ5cGFzc2VzKGVsZSwgcHJvcHMpO1xuICAgICAgZWxlLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIH1cblxuICAgICAgX3AudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKF9wLnRyYW5zaXRpb25pbmcpIHtcbiAgICB0aGlzLnJlbW92ZUJ5cGFzc2VzKGVsZSwgcHJvcHMpO1xuICAgIGVsZS5lbWl0QW5kTm90aWZ5KCdzdHlsZScpO1xuICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgfVxufTtcblxuc3R5Zm4uY2hlY2tUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBnZXRUcmlnZ2VyLCBvblRyaWdnZXIpIHtcbiAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gIHZhciB0cmlnZ2VyQ2hlY2sgPSBnZXRUcmlnZ2VyKHByb3ApO1xuXG4gIGlmICh0cmlnZ2VyQ2hlY2sgIT0gbnVsbCAmJiB0cmlnZ2VyQ2hlY2soZnJvbVZhbHVlLCB0b1ZhbHVlKSkge1xuICAgIG9uVHJpZ2dlcihwcm9wKTtcbiAgfVxufTtcblxuc3R5Zm4uY2hlY2taT3JkZXJUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5jaGVja1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AudHJpZ2dlcnNaT3JkZXI7XG4gIH0sIGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5fcHJpdmF0ZS5jeS5ub3RpZnkoJ3pvcmRlcicsIGVsZSk7XG4gIH0pO1xufTtcblxuc3R5Zm4uY2hlY2tCb3VuZHNUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gIHRoaXMuY2hlY2tUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiBwcm9wLnRyaWdnZXJzQm91bmRzO1xuICB9LCBmdW5jdGlvbiAocHJvcCkge1xuICAgIGVsZS5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICBlbGUuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7IC8vIGlmIHRoZSBwcm9wIGNoYW5nZSBtYWtlcyB0aGUgYmIgb2YgcGxsIGJlemllciBlZGdlcyBpbnZhbGlkLFxuICAgIC8vIHRoZW4gZGlydHkgdGhlIHBsbCBlZGdlIGJiIGNhY2hlIGFzIHdlbGxcblxuICAgIGlmICggLy8gb25seSBmb3IgYmV6aWVycyAtLSBzbyBwZXJmb3JtYW5jZSBvZiBvdGhlciBlZGdlcyBpc24ndCBhZmZlY3RlZFxuICAgIChlbGUucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlID09PSAnYmV6aWVyJyAvLyBhbHJlYWR5IGEgYmV6aWVyXG4gICAgLy8gd2FzIGp1c3Qgbm93IGNoYW5nZWQgdG8gb3IgZnJvbSBhIGJlemllcjpcbiAgICB8fCBuYW1lID09PSAnY3VydmUtc3R5bGUnICYmIChmcm9tVmFsdWUgPT09ICdiZXppZXInIHx8IHRvVmFsdWUgPT09ICdiZXppZXInKSkgJiYgcHJvcC50cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxCZXppZXJzKSB7XG4gICAgICBlbGUucGFyYWxsZWxFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKHBsbEVkZ2UpIHtcbiAgICAgICAgaWYgKHBsbEVkZ2UuaXNCdW5kbGVkQmV6aWVyKCkpIHtcbiAgICAgICAgICBwbGxFZGdlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuc3R5Zm4uY2hlY2tUcmlnZ2VycyA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICBlbGUuZGlydHlTdHlsZUNhY2hlKCk7XG4gIHRoaXMuY2hlY2taT3JkZXJUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKTtcbiAgdGhpcy5jaGVja0JvdW5kc1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpO1xufTtcblxudmFyIHN0eWZuJDEgPSB7fTsgLy8gYnlwYXNzZXMgYXJlIGFwcGxpZWQgdG8gYW4gZXhpc3Rpbmcgc3R5bGUgb24gYW4gZWxlbWVudCwgYW5kIGp1c3QgdGFja2VkIG9uIHRlbXBvcmFyaWx5XG4vLyByZXR1cm5zIHRydWUgaWZmIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsIGZvciBhdCBsZWFzdCAxIHNwZWNpZmllZCBwcm9wZXJ0eVxuXG5zdHlmbiQxLmFwcGx5QnlwYXNzID0gZnVuY3Rpb24gKGVsZXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wcyA9IFtdO1xuICB2YXIgaXNCeXBhc3MgPSB0cnVlOyAvLyBwdXQgYWxsIHRoZSBwcm9wZXJ0aWVzIChjYW4gc3BlY2lmeSBvbmUgb3IgbWFueSkgaW4gYW4gYXJyYXkgYWZ0ZXIgcGFyc2luZyB0aGVtXG5cbiAgaWYgKG5hbWUgPT09ICcqJyB8fCBuYW1lID09PSAnKionKSB7XG4gICAgLy8gYXBwbHkgdG8gYWxsIHByb3BlcnR5IG5hbWVzXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgX25hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShfbmFtZSwgdmFsdWUsIHRydWUpO1xuXG4gICAgICAgIGlmIChwYXJzZWRQcm9wKSB7XG4gICAgICAgICAgcHJvcHMucHVzaChwYXJzZWRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICAvLyB0aGVuIHBhcnNlIHRoZSBzaW5nbGUgcHJvcGVydHlcbiAgICB2YXIgX3BhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcblxuICAgIGlmIChfcGFyc2VkUHJvcCkge1xuICAgICAgcHJvcHMucHVzaChfcGFyc2VkUHJvcCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgLy8gdGhlbiBwYXJzZSBlYWNoIHByb3BlcnR5XG4gICAgdmFyIHNwZWNpZmllZFByb3BzID0gbmFtZTtcbiAgICB1cGRhdGVUcmFuc2l0aW9ucyA9IHZhbHVlO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHNwZWNpZmllZFByb3BzKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuYW1lcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfbmFtZTIgPSBuYW1lc1tfaV07XG4gICAgICB2YXIgX3ZhbHVlID0gc3BlY2lmaWVkUHJvcHNbX25hbWUyXTtcblxuICAgICAgaWYgKF92YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHRyeSBjYW1lbCBjYXNlIG5hbWUgdG9vXG4gICAgICAgIF92YWx1ZSA9IHNwZWNpZmllZFByb3BzW2Rhc2gyY2FtZWwoX25hbWUyKV07XG4gICAgICB9XG5cbiAgICAgIGlmIChfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX3BhcnNlZFByb3AyID0gdGhpcy5wYXJzZShfbmFtZTIsIF92YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKF9wYXJzZWRQcm9wMikge1xuICAgICAgICAgIHByb3BzLnB1c2goX3BhcnNlZFByb3AyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBjYW4ndCBkbyBhbnl0aGluZyB3aXRob3V0IHdlbGwgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIHdlJ3ZlIGZhaWxlZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgcHJvcGVydGllc1xuXG5cbiAgaWYgKHByb3BzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBub3csIGFwcGx5IHRoZSBieXBhc3MgcHJvcGVydGllcyBvbiB0aGUgZWxlbWVudHNcblxuXG4gIHZhciByZXQgPSBmYWxzZTsgLy8gcmV0dXJuIHRydWUgaWYgYXQgbGVhc3Qgb25lIHN1Y2Nlc2Z1bCBieXBhc3MgYXBwbGllZFxuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIC8vIGZvciBlYWNoIGVsZVxuICAgIHZhciBlbGUgPSBlbGVzW19pMl07XG4gICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuICAgIHZhciBkaWZmUHJvcCA9IHZvaWQgMDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIC8vIGZvciBlYWNoIHByb3BcbiAgICAgIHZhciBfcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZShfcHJvcC5uYW1lKTtcbiAgICAgICAgZGlmZlByb3AgPSBkaWZmUHJvcHNbX3Byb3AubmFtZV0gPSB7XG4gICAgICAgICAgcHJldjogcHJldlByb3BcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgX3Byb3ApIHx8IHJldDtcblxuICAgICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICAgIGRpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKF9wcm9wLm5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIHByb3BzXG5cblxuICAgIGlmIChyZXQpIHtcbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgIH1cblxuICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MpO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlc1xuXG5cbiAgcmV0dXJuIHJldDtcbn07IC8vIG9ubHkgdXNlZnVsIGluIHNwZWNpZmljIGNhc2VzIGxpa2UgYW5pbWF0aW9uXG5cblxuc3R5Zm4kMS5vdmVycmlkZUJ5cGFzcyA9IGZ1bmN0aW9uIChlbGVzLCBuYW1lLCB2YWx1ZSkge1xuICBuYW1lID0gY2FtZWwyZGFzaChuYW1lKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcHJvcCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVtuYW1lXTtcbiAgICB2YXIgdHlwZSA9IHRoaXMucHJvcGVydGllc1tuYW1lXS50eXBlO1xuICAgIHZhciBpc0NvbG9yID0gdHlwZS5jb2xvcjtcbiAgICB2YXIgaXNNdWx0aSA9IHR5cGUubXV0aXBsZTtcbiAgICB2YXIgb2xkVmFsdWUgPSAhcHJvcCA/IG51bGwgOiBwcm9wLnBmVmFsdWUgIT0gbnVsbCA/IHByb3AucGZWYWx1ZSA6IHByb3AudmFsdWU7XG5cbiAgICBpZiAoIXByb3AgfHwgIXByb3AuYnlwYXNzKSB7XG4gICAgICAvLyBuZWVkIGEgYnlwYXNzIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgICB0aGlzLmFwcGx5QnlwYXNzKGVsZSwgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwcm9wLnBmVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQ29sb3IpIHtcbiAgICAgICAgcHJvcC5zdHJWYWx1ZSA9ICdyZ2IoJyArIHZhbHVlLmpvaW4oJywnKSArICcpJztcbiAgICAgIH0gZWxzZSBpZiAoaXNNdWx0aSkge1xuICAgICAgICBwcm9wLnN0clZhbHVlID0gdmFsdWUuam9pbignICcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5zdHJWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tUcmlnZ2VycyhlbGUsIG5hbWUsIG9sZFZhbHVlLCB2YWx1ZSk7XG4gIH1cbn07XG5cbnN0eWZuJDEucmVtb3ZlQWxsQnlwYXNzZXMgPSBmdW5jdGlvbiAoZWxlcywgdXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMucmVtb3ZlQnlwYXNzZXMoZWxlcywgdGhpcy5wcm9wZXJ0eU5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG59O1xuXG5zdHlmbiQxLnJlbW92ZUJ5cGFzc2VzID0gZnVuY3Rpb24gKGVsZXMsIHByb3BzLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2pdO1xuICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gcHJvcHNbaV07XG4gICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgICAgIHZhciBwcmV2UHJvcCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcblxuICAgICAgaWYgKCFwcmV2UHJvcCB8fCAhcHJldlByb3AuYnlwYXNzKSB7XG4gICAgICAgIC8vIGlmIGEgYnlwYXNzIGRvZXNuJ3QgZXhpc3QgZm9yIHRoZSBwcm9wLCBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9ICcnOyAvLyBlbXB0eSA9PiByZW1vdmUgYnlwYXNzXG5cbiAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbcHJvcC5uYW1lXSA9IHtcbiAgICAgICAgcHJldjogcHJldlByb3BcbiAgICAgIH07XG4gICAgICB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBwYXJzZWRQcm9wKTtcbiAgICAgIGRpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKHByb3AubmFtZSk7XG4gICAgfSAvLyBmb3IgcHJvcHNcblxuXG4gICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG5cbiAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVsZXNcblxufTtcblxudmFyIHN0eWZuJDIgPSB7fTsgLy8gZ2V0cyB3aGF0IGFuIGVtIHNpemUgY29ycmVzcG9uZHMgdG8gaW4gcGl4ZWxzIHJlbGF0aXZlIHRvIGEgZG9tIGVsZW1lbnRcblxuc3R5Zm4kMi5nZXRFbVNpemVJblBpeGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHB4ID0gdGhpcy5jb250YWluZXJDc3MoJ2ZvbnQtc2l6ZScpO1xuXG4gIGlmIChweCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocHgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxOyAvLyBmb3IgaGVhZGxlc3NcbiAgfVxufTsgLy8gZ2V0cyBjc3MgcHJvcGVydHkgZnJvbSB0aGUgY29yZSBjb250YWluZXJcblxuXG5zdHlmbiQyLmNvbnRhaW5lckNzcyA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZG9tRWxlbWVudCA9IGN5LmNvbnRhaW5lcigpO1xuXG4gIGlmICh3aW5kb3ckMSAmJiBkb21FbGVtZW50ICYmIHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICByZXR1cm4gd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BOYW1lKTtcbiAgfVxufTtcblxudmFyIHN0eWZuJDMgPSB7fTsgLy8gZ2V0cyB0aGUgcmVuZGVyZWQgc3R5bGUgZm9yIGFuIGVsZW1lbnRcblxuc3R5Zm4kMy5nZXRSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgcHJvcCkge1xuICBpZiAocHJvcCkge1xuICAgIHJldHVybiB0aGlzLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIHByb3AsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmdldFJhd1N0eWxlKGVsZSwgdHJ1ZSk7XG4gIH1cbn07IC8vIGdldHMgdGhlIHJhdyBzdHlsZSBmb3IgYW4gZWxlbWVudFxuXG5cbnN0eWZuJDMuZ2V0UmF3U3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBpc1JlbmRlcmVkVmFsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgaWYgKGVsZSkge1xuICAgIHZhciByc3R5bGUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgIHZhciB2YWwgPSBzZWxmLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIHByb3AubmFtZSwgaXNSZW5kZXJlZFZhbCk7XG5cbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICByc3R5bGVbcHJvcC5uYW1lXSA9IHZhbDtcbiAgICAgICAgcnN0eWxlW2Rhc2gyY2FtZWwocHJvcC5uYW1lKV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdHlsZTtcbiAgfVxufTtcblxuc3R5Zm4kMy5nZXRJbmRleGVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wZXJ0eSwgc3VicHJvcGVydHksIGluZGV4KSB7XG4gIHZhciBwc3R5bGUgPSBlbGUucHN0eWxlKHByb3BlcnR5KVtzdWJwcm9wZXJ0eV1baW5kZXhdO1xuICByZXR1cm4gcHN0eWxlICE9IG51bGwgPyBwc3R5bGUgOiBlbGUuY3koKS5zdHlsZSgpLmdldERlZmF1bHRQcm9wZXJ0eShwcm9wZXJ0eSlbc3VicHJvcGVydHldWzBdO1xufTtcblxuc3R5Zm4kMy5nZXRTdHlsZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wTmFtZSwgaXNSZW5kZXJlZFZhbCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gIGlmIChlbGUpIHtcbiAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICBpZiAocHJvcC5hbGlhcykge1xuICAgICAgcHJvcCA9IHByb3AucG9pbnRzVG87XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcblxuICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlUHJvcC52YWx1ZSxcbiAgICAgICAgICB1bml0cyA9IHN0eWxlUHJvcC51bml0cyxcbiAgICAgICAgICBzdHJWYWx1ZSA9IHN0eWxlUHJvcC5zdHJWYWx1ZTtcblxuICAgICAgaWYgKGlzUmVuZGVyZWRWYWwgJiYgdHlwZS5udW1iZXIgJiYgdmFsdWUgIT0gbnVsbCAmJiBudW1iZXIodmFsdWUpKSB7XG4gICAgICAgIHZhciB6b29tID0gZWxlLmN5KCkuem9vbSgpO1xuXG4gICAgICAgIHZhciBnZXRSZW5kZXJlZFZhbHVlID0gZnVuY3Rpb24gZ2V0UmVuZGVyZWRWYWx1ZSh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdmFsICogem9vbTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHMgPSBmdW5jdGlvbiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2YWwsIHVuaXRzKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFJlbmRlcmVkVmFsdWUodmFsKSArIHVuaXRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpc0FycmF5VmFsdWUgPSBhcnJheSh2YWx1ZSk7XG4gICAgICAgIHZhciBoYXZlVW5pdHMgPSBpc0FycmF5VmFsdWUgPyB1bml0cy5ldmVyeShmdW5jdGlvbiAodSkge1xuICAgICAgICAgIHJldHVybiB1ICE9IG51bGw7XG4gICAgICAgIH0pIDogdW5pdHMgIT0gbnVsbDtcblxuICAgICAgICBpZiAoaGF2ZVVuaXRzKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXlWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHModiwgdW5pdHNbaV0pO1xuICAgICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHModmFsdWUsIHVuaXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXlWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nKHYpID8gdiA6ICcnICsgZ2V0UmVuZGVyZWRWYWx1ZSh2KTtcbiAgICAgICAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgZ2V0UmVuZGVyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0clZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0clZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5zdHlmbiQzLmdldEFuaW1hdGlvblN0YXJ0U3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBhbmlQcm9wcykge1xuICB2YXIgcnN0eWxlID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmlQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhbmlQcm9wID0gYW5pUHJvcHNbaV07XG4gICAgdmFyIG5hbWUgPSBhbmlQcm9wLm5hbWU7XG4gICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUobmFtZSk7XG5cbiAgICBpZiAoc3R5bGVQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoZW4gbWFrZSBhIHByb3Agb2YgaXRcbiAgICAgIGlmIChwbGFpbk9iamVjdChzdHlsZVByb3ApKSB7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgc3R5bGVQcm9wLnN0clZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgc3R5bGVQcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICByc3R5bGVbbmFtZV0gPSBzdHlsZVByb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdHlsZTtcbn07XG5cbnN0eWZuJDMuZ2V0UHJvcHNMaXN0ID0gZnVuY3Rpb24gKHByb3BzT2JqKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJzdHlsZSA9IFtdO1xuICB2YXIgc3R5bGUgPSBwcm9wc09iajtcbiAgdmFyIHByb3BzID0gc2VsZi5wcm9wZXJ0aWVzO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHN0eWxlKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICB2YXIgdmFsID0gc3R5bGVbbmFtZV07XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW25hbWVdIHx8IHByb3BzW2NhbWVsMmRhc2gobmFtZSldO1xuICAgICAgdmFyIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCB2YWwpO1xuXG4gICAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICAgIHJzdHlsZS5wdXNoKHN0eWxlUHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJzdHlsZTtcbn07XG5cbnN0eWZuJDMuZ2V0Tm9uRGVmYXVsdFByb3BlcnRpZXNIYXNoID0gZnVuY3Rpb24gKGVsZSwgcHJvcE5hbWVzLCBzZWVkKSB7XG4gIHZhciBoYXNoID0gc2VlZDtcbiAgdmFyIG5hbWUsIHZhbCwgc3RyVmFsLCBjaFZhbDtcbiAgdmFyIGksIGo7XG5cbiAgZm9yIChpID0gMDsgaSA8IHByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIG5hbWUgPSBwcm9wTmFtZXNbaV07XG4gICAgdmFsID0gZWxlLnBzdHlsZShuYW1lLCBmYWxzZSk7XG5cbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAodmFsLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgaGFzaCA9IGhhc2hJbnQoY2hWYWwsIGhhc2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJWYWwgPSB2YWwuc3RyVmFsdWU7XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBzdHJWYWwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY2hWYWwgPSBzdHJWYWwuY2hhckNvZGVBdChqKTtcbiAgICAgICAgaGFzaCA9IGhhc2hJbnQoY2hWYWwsIGhhc2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufTtcblxuc3R5Zm4kMy5nZXRQcm9wZXJ0aWVzSGFzaCA9IHN0eWZuJDMuZ2V0Tm9uRGVmYXVsdFByb3BlcnRpZXNIYXNoO1xuXG52YXIgc3R5Zm4kNCA9IHt9O1xuXG5zdHlmbiQ0LmFwcGVuZEZyb21Kc29uID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgdmFyIHN0eWxlID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IGpzb25baV07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnN0eWxlIHx8IGNvbnRleHQuY3NzO1xuICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2pdO1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbbmFtZV07XG4gICAgICBzdHlsZS5jc3MobmFtZSwgdmFsdWUpOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07IC8vIGFjY2Vzc2libGUgY3kuc3R5bGUoKSBmdW5jdGlvblxuXG5cbnN0eWZuJDQuZnJvbUpzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBlbmRGcm9tSnNvbihqc29uKTtcbiAgcmV0dXJuIHN0eWxlO1xufTsgLy8gZ2V0IGpzb24gZnJvbSBjeS5zdHlsZSgpIGFwaVxuXG5cbnN0eWZuJDQuanNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGpzb24gPSBbXTtcblxuICBmb3IgKHZhciBpID0gdGhpcy5kZWZhdWx0TGVuZ3RoOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjeHQgPSB0aGlzW2ldO1xuICAgIHZhciBzZWxlY3RvciA9IGN4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjeHQucHJvcGVydGllcztcbiAgICB2YXIgY3NzID0ge307XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgY3NzW3Byb3AubmFtZV0gPSBwcm9wLnN0clZhbHVlO1xuICAgIH1cblxuICAgIGpzb24ucHVzaCh7XG4gICAgICBzZWxlY3RvcjogIXNlbGVjdG9yID8gJ2NvcmUnIDogc2VsZWN0b3IudG9TdHJpbmcoKSxcbiAgICAgIHN0eWxlOiBjc3NcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBqc29uO1xufTtcblxudmFyIHN0eWZuJDUgPSB7fTtcblxuc3R5Zm4kNS5hcHBlbmRGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG4gIHZhciByZW1haW5pbmcgPSAnJyArIHN0cmluZztcbiAgdmFyIHNlbEFuZEJsb2NrU3RyO1xuICB2YXIgYmxvY2tSZW07XG4gIHZhciBwcm9wQW5kVmFsU3RyOyAvLyByZW1vdmUgY29tbWVudHMgZnJvbSB0aGUgc3R5bGUgc3RyaW5nXG5cbiAgcmVtYWluaW5nID0gcmVtYWluaW5nLnJlcGxhY2UoL1svXVsqXShcXHN8LikrP1sqXVsvXS9nLCAnJyk7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHNlbGVjdG9yIGFuZCBibG9jayBmcm9tIHRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICAgIGlmIChyZW1haW5pbmcubGVuZ3RoID4gc2VsQW5kQmxvY2tTdHIubGVuZ3RoKSB7XG4gICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyKHNlbEFuZEJsb2NrU3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbWFpbmluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHByb3BlcnR5IGFuZCB2YWx1ZSBmcm9tIHRoZSByZW1haW5pbmcgYmxvY2sgdGV4dCB0byBwYXJzZVxuICAgIGlmIChibG9ja1JlbS5sZW5ndGggPiBwcm9wQW5kVmFsU3RyLmxlbmd0aCkge1xuICAgICAgYmxvY2tSZW0gPSBibG9ja1JlbS5zdWJzdHIocHJvcEFuZFZhbFN0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBibG9ja1JlbSA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOzspIHtcbiAgICB2YXIgbm90aGluZ0xlZnRUb1BhcnNlID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKTtcblxuICAgIGlmIChub3RoaW5nTGVmdFRvUGFyc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBzZWxBbmRCbG9jayA9IHJlbWFpbmluZy5tYXRjaCgvXlxccyooKD86LnxcXHMpKz8pXFxzKlxceygoPzoufFxccykrPylcXH0vKTtcblxuICAgIGlmICghc2VsQW5kQmxvY2spIHtcbiAgICAgIHdhcm4oJ0hhbHRpbmcgc3R5bGVzaGVldCBwYXJzaW5nOiBTdHJpbmcgc3R5bGVzaGVldCBjb250YWlucyBtb3JlIHRvIHBhcnNlIGJ1dCBubyBzZWxlY3RvciBhbmQgYmxvY2sgZm91bmQgaW46ICcgKyByZW1haW5pbmcpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc2VsQW5kQmxvY2tTdHIgPSBzZWxBbmRCbG9ja1swXTsgLy8gcGFyc2UgdGhlIHNlbGVjdG9yXG5cbiAgICB2YXIgc2VsZWN0b3JTdHIgPSBzZWxBbmRCbG9ja1sxXTtcblxuICAgIGlmIChzZWxlY3RvclN0ciAhPT0gJ2NvcmUnKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBuZXcgU2VsZWN0b3Ioc2VsZWN0b3JTdHIpO1xuXG4gICAgICBpZiAoc2VsZWN0b3IuaW52YWxpZCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIHNlbGVjdG9yIGZvdW5kIGluIHN0cmluZyBzdHlsZXNoZWV0OiAnICsgc2VsZWN0b3JTdHIpOyAvLyBza2lwIHRoaXMgc2VsZWN0b3IgYW5kIGJsb2NrXG5cbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gLy8gcGFyc2UgdGhlIGJsb2NrIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuXG5cbiAgICB2YXIgYmxvY2tTdHIgPSBzZWxBbmRCbG9ja1syXTtcbiAgICB2YXIgaW52YWxpZEJsb2NrID0gZmFsc2U7XG4gICAgYmxvY2tSZW0gPSBibG9ja1N0cjtcbiAgICB2YXIgcHJvcHMgPSBbXTtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBfbm90aGluZ0xlZnRUb1BhcnNlID0gYmxvY2tSZW0ubWF0Y2goL15cXHMqJC8pO1xuXG4gICAgICBpZiAoX25vdGhpbmdMZWZ0VG9QYXJzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BBbmRWYWwgPSBibG9ja1JlbS5tYXRjaCgvXlxccyooLis/KVxccyo6XFxzKiguKz8pXFxzKjsvKTtcblxuICAgICAgaWYgKCFwcm9wQW5kVmFsKSB7XG4gICAgICAgIHdhcm4oJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgZm9ybWF0dGluZyBvZiBzdHlsZSBwcm9wZXJ0eSBhbmQgdmFsdWUgZGVmaW5pdGlvbnMgZm91bmQgaW46JyArIGJsb2NrU3RyKTtcbiAgICAgICAgaW52YWxpZEJsb2NrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHByb3BBbmRWYWxTdHIgPSBwcm9wQW5kVmFsWzBdO1xuICAgICAgdmFyIHByb3BTdHIgPSBwcm9wQW5kVmFsWzFdO1xuICAgICAgdmFyIHZhbFN0ciA9IHByb3BBbmRWYWxbMl07XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1twcm9wU3RyXTtcblxuICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgIHdhcm4oJ1NraXBwaW5nIHByb3BlcnR5OiBJbnZhbGlkIHByb3BlcnR5IG5hbWUgaW46ICcgKyBwcm9wQW5kVmFsU3RyKTsgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuXG4gICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyc2VkUHJvcCA9IHN0eWxlLnBhcnNlKHByb3BTdHIsIHZhbFN0cik7XG5cbiAgICAgIGlmICghcGFyc2VkUHJvcCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGluOiAnICsgcHJvcEFuZFZhbFN0cik7IC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcblxuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMucHVzaCh7XG4gICAgICAgIG5hbWU6IHByb3BTdHIsXG4gICAgICAgIHZhbDogdmFsU3RyXG4gICAgICB9KTtcbiAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRCbG9jaykge1xuICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICBicmVhaztcbiAgICB9IC8vIHB1dCB0aGUgcGFyc2VkIGJsb2NrIGluIHRoZSBzdHlsZVxuXG5cbiAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3RvclN0cik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3Byb3AgPSBwcm9wc1tpXTtcbiAgICAgIHN0eWxlLmNzcyhfcHJvcC5uYW1lLCBfcHJvcC52YWwpO1xuICAgIH1cblxuICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuc3R5Zm4kNS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBlbmRGcm9tU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnZhciBzdHlmbiQ2ID0ge307XG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciBudW1iZXIgPSBudW1iZXIkMTtcbiAgdmFyIHJnYmEgPSByZ2JhTm9CYWNrUmVmcztcbiAgdmFyIGhzbGEgPSBoc2xhTm9CYWNrUmVmcztcbiAgdmFyIGhleDMkMSA9IGhleDM7XG4gIHZhciBoZXg2JDEgPSBoZXg2O1xuXG4gIHZhciBkYXRhID0gZnVuY3Rpb24gZGF0YShwcmVmaXgpIHtcbiAgICByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoXFxcXHMqKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCkkJztcbiAgfTtcblxuICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uIG1hcERhdGEocHJlZml4KSB7XG4gICAgdmFyIG1hcEFyZyA9IG51bWJlciArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMkMSArICd8JyArIGhleDYkMTtcbiAgICByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbWFwQXJnICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbWFwQXJnICsgJylcXFxcKSQnO1xuICB9O1xuXG4gIHZhciB1cmxSZWdleGVzID0gWydedXJsXFxcXHMqXFxcXChcXFxccypbXFwnXCJdPyguKz8pW1xcJ1wiXT9cXFxccypcXFxcKSQnLCAnXihub25lKSQnLCAnXiguKykkJ107IC8vIGVhY2ggdmlzdWFsIHN0eWxlIHByb3BlcnR5IGhhcyBhIHR5cGUgYW5kIG5lZWRzIHRvIGJlIHZhbGlkYXRlZCBhY2NvcmRpbmcgdG8gaXRcblxuICBzdHlmbiQ2LnR5cGVzID0ge1xuICAgIHRpbWU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIHVuaXRzOiAnc3xtcycsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAnbXMnXG4gICAgfSxcbiAgICBwZXJjZW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEwMCxcbiAgICAgIHVuaXRzOiAnJScsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAnJSdcbiAgICB9LFxuICAgIHBlcmNlbnRhZ2VzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEwMCxcbiAgICAgIHVuaXRzOiAnJScsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAnJScsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgemVyb09uZU51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIHplcm9PbmVOdW1iZXJzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEsXG4gICAgICB1bml0bGVzczogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBuT25lT25lTnVtYmVyOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IC0xLFxuICAgICAgbWF4OiAxLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIG5vbk5lZ2F0aXZlSW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBpbnRlZ2VyOiB0cnVlLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIHBvc2l0aW9uOiB7XG4gICAgICBlbnVtczogWydwYXJlbnQnLCAnb3JpZ2luJ11cbiAgICB9LFxuICAgIG5vZGVTaXplOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBlbnVtczogWydsYWJlbCddXG4gICAgfSxcbiAgICBudW1iZXI6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgfSxcbiAgICBudW1iZXJzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0bGVzczogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBwb3NpdGl2ZU51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdGxlc3M6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBzdHJpY3RNaW46IHRydWVcbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMFxuICAgIH0sXG4gICAgYmlkaXJlY3Rpb25hbFNpemU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZVxuICAgIH0sXG4gICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgYmlkaXJlY3Rpb25hbFNpemVzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgc2l6ZU1heWJlUGVyY2VudDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgYWxsb3dQZXJjZW50OiB0cnVlXG4gICAgfSxcbiAgICBheGlzRGlyZWN0aW9uOiB7XG4gICAgICBlbnVtczogWydob3Jpem9udGFsJywgJ2xlZnR3YXJkJywgJ3JpZ2h0d2FyZCcsICd2ZXJ0aWNhbCcsICd1cHdhcmQnLCAnZG93bndhcmQnLCAnYXV0byddXG4gICAgfSxcbiAgICBwYWRkaW5nUmVsYXRpdmVUbzoge1xuICAgICAgZW51bXM6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2F2ZXJhZ2UnLCAnbWluJywgJ21heCddXG4gICAgfSxcbiAgICBiZ1dIOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBhbGxvd1BlcmNlbnQ6IHRydWUsXG4gICAgICBlbnVtczogWydhdXRvJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdQb3M6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIGFsbG93UGVyY2VudDogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ1JlbGF0aXZlVG86IHtcbiAgICAgIGVudW1zOiBbJ2lubmVyJywgJ2luY2x1ZGUtcGFkZGluZyddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnUmVwZWF0OiB7XG4gICAgICBlbnVtczogWydyZXBlYXQnLCAncmVwZWF0LXgnLCAncmVwZWF0LXknLCAnbm8tcmVwZWF0J10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdGaXQ6IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnY29udGFpbicsICdjb3ZlciddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnQ3Jvc3NPcmlnaW46IHtcbiAgICAgIGVudW1zOiBbJ2Fub255bW91cycsICd1c2UtY3JlZGVudGlhbHMnXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ0NsaXA6IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnbm9kZSddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICBjb2xvcjogdHJ1ZVxuICAgIH0sXG4gICAgY29sb3JzOiB7XG4gICAgICBjb2xvcjogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBmaWxsOiB7XG4gICAgICBlbnVtczogWydzb2xpZCcsICdsaW5lYXItZ3JhZGllbnQnLCAncmFkaWFsLWdyYWRpZW50J11cbiAgICB9LFxuICAgIGJvb2w6IHtcbiAgICAgIGVudW1zOiBbJ3llcycsICdubyddXG4gICAgfSxcbiAgICBsaW5lU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnXVxuICAgIH0sXG4gICAgbGluZUNhcDoge1xuICAgICAgZW51bXM6IFsnYnV0dCcsICdyb3VuZCcsICdzcXVhcmUnXVxuICAgIH0sXG4gICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnLCAnZG91YmxlJ11cbiAgICB9LFxuICAgIGN1cnZlU3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ2JlemllcicsICd1bmJ1bmRsZWQtYmV6aWVyJywgJ2hheXN0YWNrJywgJ3NlZ21lbnRzJywgJ3N0cmFpZ2h0JywgJ3RheGknXVxuICAgIH0sXG4gICAgZm9udEZhbWlseToge1xuICAgICAgcmVnZXg6ICdeKFtcXFxcdy0gXFxcXFwiXSsoPzpcXFxccyosXFxcXHMqW1xcXFx3LSBcXFxcXCJdKykqKSQnXG4gICAgfSxcbiAgICBmb250U3R5bGU6IHtcbiAgICAgIGVudW1zOiBbJ2l0YWxpYycsICdub3JtYWwnLCAnb2JsaXF1ZSddXG4gICAgfSxcbiAgICBmb250V2VpZ2h0OiB7XG4gICAgICBlbnVtczogWydub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlcicsICcxMDAnLCAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc4MDAnLCAnOTAwJywgMTAwLCAyMDAsIDMwMCwgNDAwLCA1MDAsIDYwMCwgNzAwLCA4MDAsIDkwMF1cbiAgICB9LFxuICAgIHRleHREZWNvcmF0aW9uOiB7XG4gICAgICBlbnVtczogWydub25lJywgJ3VuZGVybGluZScsICdvdmVybGluZScsICdsaW5lLXRocm91Z2gnXVxuICAgIH0sXG4gICAgdGV4dFRyYW5zZm9ybToge1xuICAgICAgZW51bXM6IFsnbm9uZScsICd1cHBlcmNhc2UnLCAnbG93ZXJjYXNlJ11cbiAgICB9LFxuICAgIHRleHRXcmFwOiB7XG4gICAgICBlbnVtczogWydub25lJywgJ3dyYXAnLCAnZWxsaXBzaXMnXVxuICAgIH0sXG4gICAgdGV4dE92ZXJmbG93V3JhcDoge1xuICAgICAgZW51bXM6IFsnd2hpdGVzcGFjZScsICdhbnl3aGVyZSddXG4gICAgfSxcbiAgICB0ZXh0QmFja2dyb3VuZFNoYXBlOiB7XG4gICAgICBlbnVtczogWydyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJ11cbiAgICB9LFxuICAgIG5vZGVTaGFwZToge1xuICAgICAgZW51bXM6IFsncmVjdGFuZ2xlJywgJ3JvdW5kcmVjdGFuZ2xlJywgJ3JvdW5kLXJlY3RhbmdsZScsICdjdXRyZWN0YW5nbGUnLCAnY3V0LXJlY3RhbmdsZScsICdib3R0b21yb3VuZHJlY3RhbmdsZScsICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJywgJ2JhcnJlbCcsICdlbGxpcHNlJywgJ3RyaWFuZ2xlJywgJ3JvdW5kLXRyaWFuZ2xlJywgJ3NxdWFyZScsICdwZW50YWdvbicsICdyb3VuZC1wZW50YWdvbicsICdoZXhhZ29uJywgJ3JvdW5kLWhleGFnb24nLCAnY29uY2F2ZWhleGFnb24nLCAnY29uY2F2ZS1oZXhhZ29uJywgJ2hlcHRhZ29uJywgJ3JvdW5kLWhlcHRhZ29uJywgJ29jdGFnb24nLCAncm91bmQtb2N0YWdvbicsICd0YWcnLCAncm91bmQtdGFnJywgJ3N0YXInLCAnZGlhbW9uZCcsICdyb3VuZC1kaWFtb25kJywgJ3ZlZScsICdyaG9tYm9pZCcsICdwb2x5Z29uJ11cbiAgICB9LFxuICAgIGNvbXBvdW5kSW5jbHVkZUxhYmVsczoge1xuICAgICAgZW51bXM6IFsnaW5jbHVkZScsICdleGNsdWRlJ11cbiAgICB9LFxuICAgIGFycm93U2hhcGU6IHtcbiAgICAgIGVudW1zOiBbJ3RlZScsICd0cmlhbmdsZScsICd0cmlhbmdsZS10ZWUnLCAndHJpYW5nbGUtY3Jvc3MnLCAndHJpYW5nbGUtYmFja2N1cnZlJywgJ3ZlZScsICdzcXVhcmUnLCAnY2lyY2xlJywgJ2RpYW1vbmQnLCAnY2hldnJvbicsICdub25lJ11cbiAgICB9LFxuICAgIGFycm93RmlsbDoge1xuICAgICAgZW51bXM6IFsnZmlsbGVkJywgJ2hvbGxvdyddXG4gICAgfSxcbiAgICBkaXNwbGF5OiB7XG4gICAgICBlbnVtczogWydlbGVtZW50JywgJ25vbmUnXVxuICAgIH0sXG4gICAgdmlzaWJpbGl0eToge1xuICAgICAgZW51bXM6IFsnaGlkZGVuJywgJ3Zpc2libGUnXVxuICAgIH0sXG4gICAgekNvbXBvdW5kRGVwdGg6IHtcbiAgICAgIGVudW1zOiBbJ2JvdHRvbScsICdvcnBoYW4nLCAnYXV0bycsICd0b3AnXVxuICAgIH0sXG4gICAgekluZGV4Q29tcGFyZToge1xuICAgICAgZW51bXM6IFsnYXV0bycsICdtYW51YWwnXVxuICAgIH0sXG4gICAgdmFsaWduOiB7XG4gICAgICBlbnVtczogWyd0b3AnLCAnY2VudGVyJywgJ2JvdHRvbSddXG4gICAgfSxcbiAgICBoYWxpZ246IHtcbiAgICAgIGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J11cbiAgICB9LFxuICAgIGp1c3RpZmljYXRpb246IHtcbiAgICAgIGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0JywgJ2F1dG8nXVxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgc3RyaW5nOiB0cnVlXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IGRhdGEoJ2RhdGEnKVxuICAgIH0sXG4gICAgbGF5b3V0RGF0YToge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBkYXRhKCdsYXlvdXREYXRhJylcbiAgICB9LFxuICAgIHNjcmF0Y2g6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogZGF0YSgnc2NyYXRjaCcpXG4gICAgfSxcbiAgICBtYXBEYXRhOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IG1hcERhdGEoJ21hcERhdGEnKVxuICAgIH0sXG4gICAgbWFwTGF5b3V0RGF0YToge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBtYXBEYXRhKCdtYXBMYXlvdXREYXRhJylcbiAgICB9LFxuICAgIG1hcFNjcmF0Y2g6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogbWFwRGF0YSgnbWFwU2NyYXRjaCcpXG4gICAgfSxcbiAgICBmbjoge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIGZuOiB0cnVlXG4gICAgfSxcbiAgICB1cmw6IHtcbiAgICAgIHJlZ2V4ZXM6IHVybFJlZ2V4ZXMsXG4gICAgICBzaW5nbGVSZWdleE1hdGNoVmFsdWU6IHRydWVcbiAgICB9LFxuICAgIHVybHM6IHtcbiAgICAgIHJlZ2V4ZXM6IHVybFJlZ2V4ZXMsXG4gICAgICBzaW5nbGVSZWdleE1hdGNoVmFsdWU6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgcHJvcExpc3Q6IHtcbiAgICAgIHByb3BMaXN0OiB0cnVlXG4gICAgfSxcbiAgICBhbmdsZToge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdHM6ICdkZWd8cmFkJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdyYWQnXG4gICAgfSxcbiAgICB0ZXh0Um90YXRpb246IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRzOiAnZGVnfHJhZCcsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAncmFkJyxcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnYXV0b3JvdGF0ZSddXG4gICAgfSxcbiAgICBwb2x5Z29uUG9pbnRMaXN0OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIGV2ZW5NdWx0aXBsZTogdHJ1ZSxcbiAgICAgIG1pbjogLTEsXG4gICAgICBtYXg6IDEsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgZWRnZURpc3RhbmNlczoge1xuICAgICAgZW51bXM6IFsnaW50ZXJzZWN0aW9uJywgJ25vZGUtcG9zaXRpb24nXVxuICAgIH0sXG4gICAgZWRnZUVuZHBvaW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgIHVuaXRzOiAnJXxweHxlbXxkZWd8cmFkJyxcbiAgICAgIGltcGxpY2l0VW5pdHM6ICdweCcsXG4gICAgICBlbnVtczogWydpbnNpZGUtdG8tbm9kZScsICdvdXRzaWRlLXRvLW5vZGUnLCAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJywgJ291dHNpZGUtdG8tbGluZScsICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnXSxcbiAgICAgIHNpbmdsZUVudW06IHRydWUsXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsQXJyLCB1bml0c0Fycikge1xuICAgICAgICBzd2l0Y2ggKHZhbEFyci5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBjYW4gYmUgJSBvciBweCBvbmx5XG4gICAgICAgICAgICByZXR1cm4gdW5pdHNBcnJbMF0gIT09ICdkZWcnICYmIHVuaXRzQXJyWzBdICE9PSAncmFkJyAmJiB1bml0c0FyclsxXSAhPT0gJ2RlZycgJiYgdW5pdHNBcnJbMV0gIT09ICdyYWQnO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gY2FuIGJlIGVudW0sIGRlZywgb3IgcmFkIG9ubHlcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcodmFsQXJyWzBdKSB8fCB1bml0c0FyclswXSA9PT0gJ2RlZycgfHwgdW5pdHNBcnJbMF0gPT09ICdyYWQnO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZWFzaW5nOiB7XG4gICAgICByZWdleGVzOiBbJ14oc3ByaW5nKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkkJywgJ14oY3ViaWMtYmV6aWVyKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpJCddLFxuICAgICAgZW51bXM6IFsnbGluZWFyJywgJ2Vhc2UnLCAnZWFzZS1pbicsICdlYXNlLW91dCcsICdlYXNlLWluLW91dCcsICdlYXNlLWluLXNpbmUnLCAnZWFzZS1vdXQtc2luZScsICdlYXNlLWluLW91dC1zaW5lJywgJ2Vhc2UtaW4tcXVhZCcsICdlYXNlLW91dC1xdWFkJywgJ2Vhc2UtaW4tb3V0LXF1YWQnLCAnZWFzZS1pbi1jdWJpYycsICdlYXNlLW91dC1jdWJpYycsICdlYXNlLWluLW91dC1jdWJpYycsICdlYXNlLWluLXF1YXJ0JywgJ2Vhc2Utb3V0LXF1YXJ0JywgJ2Vhc2UtaW4tb3V0LXF1YXJ0JywgJ2Vhc2UtaW4tcXVpbnQnLCAnZWFzZS1vdXQtcXVpbnQnLCAnZWFzZS1pbi1vdXQtcXVpbnQnLCAnZWFzZS1pbi1leHBvJywgJ2Vhc2Utb3V0LWV4cG8nLCAnZWFzZS1pbi1vdXQtZXhwbycsICdlYXNlLWluLWNpcmMnLCAnZWFzZS1vdXQtY2lyYycsICdlYXNlLWluLW91dC1jaXJjJ11cbiAgICB9LFxuICAgIGdyYWRpZW50RGlyZWN0aW9uOiB7XG4gICAgICBlbnVtczogWyd0by1ib3R0b20nLCAndG8tdG9wJywgJ3RvLWxlZnQnLCAndG8tcmlnaHQnLCAndG8tYm90dG9tLXJpZ2h0JywgJ3RvLWJvdHRvbS1sZWZ0JywgJ3RvLXRvcC1yaWdodCcsICd0by10b3AtbGVmdCcsICd0by1yaWdodC1ib3R0b20nLCAndG8tbGVmdC1ib3R0b20nLCAndG8tcmlnaHQtdG9wJywgJ3RvLWxlZnQtdG9wJ11cbiAgICB9LFxuICAgIGJvdW5kc0V4cGFuc2lvbjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsQXJyKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB2YWxBcnIubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoID09PSAxIHx8IGxlbmd0aCA9PT0gMiB8fCBsZW5ndGggPT09IDQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgZGlmZiA9IHtcbiAgICB6ZXJvTm9uWmVybzogZnVuY3Rpb24gemVyb05vblplcm8odmFsMSwgdmFsMikge1xuICAgICAgaWYgKCh2YWwxID09IG51bGwgfHwgdmFsMiA9PSBudWxsKSAmJiB2YWwxICE9PSB2YWwyKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBudWxsIGNhc2VzIGNvdWxkIHJlcHJlc2VudCBhbnkgdmFsdWVcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbDEgPT0gMCAmJiB2YWwyICE9IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbDEgIT0gMCAmJiB2YWwyID09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBhbnk6IGZ1bmN0aW9uIGFueSh2YWwxLCB2YWwyKSB7XG4gICAgICByZXR1cm4gdmFsMSAhPSB2YWwyO1xuICAgIH1cbiAgfTsgLy8gZGVmaW5lIHZpc3VhbCBzdHlsZSBwcm9wZXJ0aWVzXG4gIC8vXG4gIC8vIC0gbi5iLiBhZGRpbmcgYSBuZXcgZ3JvdXAgb2YgcHJvcHMgbWF5IHJlcXVpcmUgdXBkYXRlcyB0byB1cGRhdGVTdHlsZUhpbnRzKClcbiAgLy8gLSBhZGRpbmcgbmV3IHByb3BzIHRvIGFuIGV4aXN0aW5nIGdyb3VwIGdldHMgaGFuZGxlZCBhdXRvbWF0aWNhbGx5XG5cbiAgdmFyIHQgPSBzdHlmbiQ2LnR5cGVzO1xuICB2YXIgbWFpbkxhYmVsID0gW3tcbiAgICBuYW1lOiAnbGFiZWwnLFxuICAgIHR5cGU6IHQudGV4dCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LXJvdGF0aW9uJyxcbiAgICB0eXBlOiB0LnRleHRSb3RhdGlvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW1hcmdpbi14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtbWFyZ2luLXknLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgc291cmNlTGFiZWwgPSBbe1xuICAgIG5hbWU6ICdzb3VyY2UtbGFiZWwnLFxuICAgIHR5cGU6IHQudGV4dCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1yb3RhdGlvbicsXG4gICAgdHlwZTogdC50ZXh0Um90YXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLXRleHQtbWFyZ2luLXgnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLXRleHQtbWFyZ2luLXknLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLXRleHQtb2Zmc2V0JyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgdGFyZ2V0TGFiZWwgPSBbe1xuICAgIG5hbWU6ICd0YXJnZXQtbGFiZWwnLFxuICAgIHR5cGU6IHQudGV4dCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1yb3RhdGlvbicsXG4gICAgdHlwZTogdC50ZXh0Um90YXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LXRleHQtbWFyZ2luLXgnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LXRleHQtbWFyZ2luLXknLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LXRleHQtb2Zmc2V0JyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgbGFiZWxEaW1lbnNpb25zID0gW3tcbiAgICBuYW1lOiAnZm9udC1mYW1pbHknLFxuICAgIHR5cGU6IHQuZm9udEZhbWlseSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdmb250LXN0eWxlJyxcbiAgICB0eXBlOiB0LmZvbnRTdHlsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdmb250LXdlaWdodCcsXG4gICAgdHlwZTogdC5mb250V2VpZ2h0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2ZvbnQtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtdHJhbnNmb3JtJyxcbiAgICB0eXBlOiB0LnRleHRUcmFuc2Zvcm0sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC13cmFwJyxcbiAgICB0eXBlOiB0LnRleHRXcmFwLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtb3ZlcmZsb3ctd3JhcCcsXG4gICAgdHlwZTogdC50ZXh0T3ZlcmZsb3dXcmFwLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtbWF4LXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vdXRsaW5lLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1oZWlnaHQnLFxuICAgIHR5cGU6IHQucG9zaXRpdmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgY29tbW9uTGFiZWwgPSBbe1xuICAgIG5hbWU6ICd0ZXh0LXZhbGlnbicsXG4gICAgdHlwZTogdC52YWxpZ24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1oYWxpZ24nLFxuICAgIHR5cGU6IHQuaGFsaWduLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vdXRsaW5lLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vdXRsaW5lLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYm9yZGVyLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYm9yZGVyLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1ib3JkZXItd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJvcmRlci1zdHlsZScsXG4gICAgdHlwZTogdC5ib3JkZXJTdHlsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnLFxuICAgIHR5cGU6IHQudGV4dEJhY2tncm91bmRTaGFwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWp1c3RpZmljYXRpb24nLFxuICAgIHR5cGU6IHQuanVzdGlmaWNhdGlvblxuICB9XTtcbiAgdmFyIGJlaGF2aW9yID0gW3tcbiAgICBuYW1lOiAnZXZlbnRzJyxcbiAgICB0eXBlOiB0LmJvb2xcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWV2ZW50cycsXG4gICAgdHlwZTogdC5ib29sXG4gIH1dO1xuICB2YXIgdmlzaWJpbGl0eSA9IFt7XG4gICAgbmFtZTogJ2Rpc3BsYXknLFxuICAgIHR5cGU6IHQuZGlzcGxheSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnksXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgIHRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEJlemllcnM6IHRydWVcbiAgfSwge1xuICAgIG5hbWU6ICd2aXNpYmlsaXR5JyxcbiAgICB0eXBlOiB0LnZpc2liaWxpdHksXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLnplcm9Ob25aZXJvXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4tem9vbWVkLWZvbnQtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplXG4gIH0sIHtcbiAgICBuYW1lOiAnei1jb21wb3VuZC1kZXB0aCcsXG4gICAgdHlwZTogdC56Q29tcG91bmREZXB0aCxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd6LWluZGV4LWNvbXBhcmUnLFxuICAgIHR5cGU6IHQuekluZGV4Q29tcGFyZSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd6LWluZGV4JyxcbiAgICB0eXBlOiB0Lm5vbk5lZ2F0aXZlSW50LFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIG92ZXJsYXkgPSBbe1xuICAgIG5hbWU6ICdvdmVybGF5LXBhZGRpbmcnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdvdmVybGF5LWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnb3ZlcmxheS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuemVyb05vblplcm9cbiAgfV07XG4gIHZhciB0cmFuc2l0aW9uID0gW3tcbiAgICBuYW1lOiAndHJhbnNpdGlvbi1wcm9wZXJ0eScsXG4gICAgdHlwZTogdC5wcm9wTGlzdFxuICB9LCB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tZHVyYXRpb24nLFxuICAgIHR5cGU6IHQudGltZVxuICB9LCB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tZGVsYXknLFxuICAgIHR5cGU6IHQudGltZVxuICB9LCB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJyxcbiAgICB0eXBlOiB0LmVhc2luZ1xuICB9XTtcblxuICB2YXIgbm9kZVNpemVIYXNoT3ZlcnJpZGUgPSBmdW5jdGlvbiBub2RlU2l6ZUhhc2hPdmVycmlkZShlbGUsIHBhcnNlZFByb3ApIHtcbiAgICBpZiAocGFyc2VkUHJvcC52YWx1ZSA9PT0gJ2xhYmVsJykge1xuICAgICAgcmV0dXJuIC1lbGUucG9vbEluZGV4KCk7IC8vIG5vIGhhc2gga2V5IGhpdHMgaXMgdXNpbmcgbGFiZWwgc2l6ZSAoaGl0cmF0ZSBmb3IgcGVyZiBwcm9iYWJseSBsb3cgYW55d2F5KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VkUHJvcC5wZlZhbHVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbm9kZUJvZHkgPSBbe1xuICAgIG5hbWU6ICdoZWlnaHQnLFxuICAgIHR5cGU6IHQubm9kZVNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgIGhhc2hPdmVycmlkZTogbm9kZVNpemVIYXNoT3ZlcnJpZGVcbiAgfSwge1xuICAgIG5hbWU6ICd3aWR0aCcsXG4gICAgdHlwZTogdC5ub2RlU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgaGFzaE92ZXJyaWRlOiBub2RlU2l6ZUhhc2hPdmVycmlkZVxuICB9LCB7XG4gICAgbmFtZTogJ3NoYXBlJyxcbiAgICB0eXBlOiB0Lm5vZGVTaGFwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzaGFwZS1wb2x5Z29uLXBvaW50cycsXG4gICAgdHlwZTogdC5wb2x5Z29uUG9pbnRMaXN0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWZpbGwnLFxuICAgIHR5cGU6IHQuZmlsbFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1ibGFja2VuJyxcbiAgICB0eXBlOiB0Lm5PbmVPbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtY29sb3JzJyxcbiAgICB0eXBlOiB0LmNvbG9yc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnLFxuICAgIHR5cGU6IHQucGVyY2VudGFnZXNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWdyYWRpZW50LWRpcmVjdGlvbicsXG4gICAgdHlwZTogdC5ncmFkaWVudERpcmVjdGlvblxuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmcnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdwYWRkaW5nLXJlbGF0aXZlLXRvJyxcbiAgICB0eXBlOiB0LnBhZGRpbmdSZWxhdGl2ZVRvLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2JvdW5kcy1leHBhbnNpb24nLFxuICAgIHR5cGU6IHQuYm91bmRzRXhwYW5zaW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIG5vZGVCb3JkZXIgPSBbe1xuICAgIG5hbWU6ICdib3JkZXItY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdib3JkZXItb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYm9yZGVyLXN0eWxlJyxcbiAgICB0eXBlOiB0LmJvcmRlclN0eWxlXG4gIH1dO1xuICB2YXIgYmFja2dyb3VuZEltYWdlID0gW3tcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZScsXG4gICAgdHlwZTogdC51cmxzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1jcm9zc29yaWdpbicsXG4gICAgdHlwZTogdC5iZ0Nyb3NzT3JpZ2luXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi14JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi15JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC13aWR0aC1yZWxhdGl2ZS10bycsXG4gICAgdHlwZTogdC5iZ1JlbGF0aXZlVG9cbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10bycsXG4gICAgdHlwZTogdC5iZ1JlbGF0aXZlVG9cbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXJlcGVhdCcsXG4gICAgdHlwZTogdC5iZ1JlcGVhdFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZml0JyxcbiAgICB0eXBlOiB0LmJnRml0XG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJyxcbiAgICB0eXBlOiB0LmJnQ2xpcFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtd2lkdGgnLFxuICAgIHR5cGU6IHQuYmdXSFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaGVpZ2h0JyxcbiAgICB0eXBlOiB0LmJnV0hcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLW9mZnNldC14JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1vZmZzZXQteScsXG4gICAgdHlwZTogdC5iZ1Bvc1xuICB9XTtcbiAgdmFyIGNvbXBvdW5kID0gW3tcbiAgICBuYW1lOiAncG9zaXRpb24nLFxuICAgIHR5cGU6IHQucG9zaXRpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnLFxuICAgIHR5cGU6IHQuY29tcG91bmRJbmNsdWRlTGFiZWxzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi13aWR0aC1iaWFzLWxlZnQnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4td2lkdGgtYmlhcy1yaWdodCcsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi1oZWlnaHQnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4taGVpZ2h0LWJpYXMtdG9wJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLWhlaWdodC1iaWFzLWJvdHRvbScsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9XTtcbiAgdmFyIGVkZ2VMaW5lID0gW3tcbiAgICBuYW1lOiAnbGluZS1zdHlsZScsXG4gICAgdHlwZTogdC5saW5lU3R5bGVcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1maWxsJyxcbiAgICB0eXBlOiB0LmZpbGxcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWNhcCcsXG4gICAgdHlwZTogdC5saW5lQ2FwXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1kYXNoLXBhdHRlcm4nLFxuICAgIHR5cGU6IHQubnVtYmVyc1xuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtZGFzaC1vZmZzZXQnLFxuICAgIHR5cGU6IHQubnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1ncmFkaWVudC1zdG9wLWNvbG9ycycsXG4gICAgdHlwZTogdC5jb2xvcnNcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJyxcbiAgICB0eXBlOiB0LnBlcmNlbnRhZ2VzXG4gIH0sIHtcbiAgICBuYW1lOiAnY3VydmUtc3R5bGUnLFxuICAgIHR5cGU6IHQuY3VydmVTdHlsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgdHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsQmV6aWVyczogdHJ1ZVxuICB9LCB7XG4gICAgbmFtZTogJ2hheXN0YWNrLXJhZGl1cycsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS1lbmRwb2ludCcsXG4gICAgdHlwZTogdC5lZGdlRW5kcG9pbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LWVuZHBvaW50JyxcbiAgICB0eXBlOiB0LmVkZ2VFbmRwb2ludCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodHMnLFxuICAgIHR5cGU6IHQubnVtYmVycyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzZWdtZW50LWRpc3RhbmNlcycsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZXMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc2VnbWVudC13ZWlnaHRzJyxcbiAgICB0eXBlOiB0Lm51bWJlcnMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGF4aS10dXJuJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGF4aS10dXJuLW1pbi1kaXN0YW5jZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RheGktZGlyZWN0aW9uJyxcbiAgICB0eXBlOiB0LmF4aXNEaXJlY3Rpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZWRnZS1kaXN0YW5jZXMnLFxuICAgIHR5cGU6IHQuZWRnZURpc3RhbmNlcyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1zY2FsZScsXG4gICAgdHlwZTogdC5wb3NpdGl2ZU51bWJlcixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdsb29wLWRpcmVjdGlvbicsXG4gICAgdHlwZTogdC5hbmdsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdsb29wLXN3ZWVwJyxcbiAgICB0eXBlOiB0LmFuZ2xlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgZ2hvc3QgPSBbe1xuICAgIG5hbWU6ICdnaG9zdCcsXG4gICAgdHlwZTogdC5ib29sLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2dob3N0LW9mZnNldC14JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2dob3N0LW9mZnNldC15JyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2dob3N0LW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9XTtcbiAgdmFyIGNvcmUgPSBbe1xuICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemVcbiAgfSwge1xuICAgIG5hbWU6ICdhY3RpdmUtYmctY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdhY3RpdmUtYmctb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAnYWN0aXZlLWJnLXNpemUnLFxuICAgIHR5cGU6IHQuc2l6ZVxuICB9LCB7XG4gICAgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfV07IC8vIHBpZSBiYWNrZ3JvdW5kcyBmb3Igbm9kZXNcblxuICB2YXIgcGllID0gW107XG4gIHN0eWZuJDYucGllQmFja2dyb3VuZE4gPSAxNjsgLy8gYmVjYXVzZSB0aGUgcGllIHByb3BlcnRpZXMgYXJlIG51bWJlcmVkLCBnaXZlIGFjY2VzcyB0byBhIGNvbnN0YW50IE4gKGZvciByZW5kZXJlciB1c2UpXG5cbiAgcGllLnB1c2goe1xuICAgIG5hbWU6ICdwaWUtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50XG4gIH0pO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0eWZuJDYucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0pO1xuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScsXG4gICAgICB0eXBlOiB0LnBlcmNlbnRcbiAgICB9KTtcbiAgICBwaWUucHVzaCh7XG4gICAgICBuYW1lOiAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSk7XG4gIH0gLy8gZWRnZSBhcnJvd3NcblxuXG4gIHZhciBlZGdlQXJyb3cgPSBbXTtcbiAgdmFyIGFycm93UHJlZml4ZXMgPSBzdHlmbiQ2LmFycm93UHJlZml4ZXMgPSBbJ3NvdXJjZScsICdtaWQtc291cmNlJywgJ3RhcmdldCcsICdtaWQtdGFyZ2V0J107XG4gIFt7XG4gICAgbmFtZTogJ2Fycm93LXNoYXBlJyxcbiAgICB0eXBlOiB0LmFycm93U2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1maWxsJyxcbiAgICB0eXBlOiB0LmFycm93RmlsbFxuICB9XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgYXJyb3dQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgJy0nICsgcHJvcC5uYW1lO1xuICAgICAgdmFyIHR5cGUgPSBwcm9wLnR5cGUsXG4gICAgICAgICAgdHJpZ2dlcnNCb3VuZHMgPSBwcm9wLnRyaWdnZXJzQm91bmRzO1xuICAgICAgZWRnZUFycm93LnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0cmlnZ2Vyc0JvdW5kczogdHJpZ2dlcnNCb3VuZHNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCB7fSk7XG4gIHZhciBwcm9wcyA9IHN0eWZuJDYucHJvcGVydGllcyA9IFtdLmNvbmNhdChiZWhhdmlvciwgdHJhbnNpdGlvbiwgdmlzaWJpbGl0eSwgb3ZlcmxheSwgZ2hvc3QsIGNvbW1vbkxhYmVsLCBsYWJlbERpbWVuc2lvbnMsIG1haW5MYWJlbCwgc291cmNlTGFiZWwsIHRhcmdldExhYmVsLCBub2RlQm9keSwgbm9kZUJvcmRlciwgYmFja2dyb3VuZEltYWdlLCBwaWUsIGNvbXBvdW5kLCBlZGdlTGluZSwgZWRnZUFycm93LCBjb3JlKTtcbiAgdmFyIHByb3BHcm91cHMgPSBzdHlmbiQ2LnByb3BlcnR5R3JvdXBzID0ge1xuICAgIC8vIGNvbW1vbiB0byBhbGwgZWxlc1xuICAgIGJlaGF2aW9yOiBiZWhhdmlvcixcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuICAgIHZpc2liaWxpdHk6IHZpc2liaWxpdHksXG4gICAgb3ZlcmxheTogb3ZlcmxheSxcbiAgICBnaG9zdDogZ2hvc3QsXG4gICAgLy8gbGFiZWxzXG4gICAgY29tbW9uTGFiZWw6IGNvbW1vbkxhYmVsLFxuICAgIGxhYmVsRGltZW5zaW9uczogbGFiZWxEaW1lbnNpb25zLFxuICAgIG1haW5MYWJlbDogbWFpbkxhYmVsLFxuICAgIHNvdXJjZUxhYmVsOiBzb3VyY2VMYWJlbCxcbiAgICB0YXJnZXRMYWJlbDogdGFyZ2V0TGFiZWwsXG4gICAgLy8gbm9kZSBwcm9wc1xuICAgIG5vZGVCb2R5OiBub2RlQm9keSxcbiAgICBub2RlQm9yZGVyOiBub2RlQm9yZGVyLFxuICAgIGJhY2tncm91bmRJbWFnZTogYmFja2dyb3VuZEltYWdlLFxuICAgIHBpZTogcGllLFxuICAgIGNvbXBvdW5kOiBjb21wb3VuZCxcbiAgICAvLyBlZGdlIHByb3BzXG4gICAgZWRnZUxpbmU6IGVkZ2VMaW5lLFxuICAgIGVkZ2VBcnJvdzogZWRnZUFycm93LFxuICAgIGNvcmU6IGNvcmVcbiAgfTtcbiAgdmFyIHByb3BHcm91cE5hbWVzID0gc3R5Zm4kNi5wcm9wZXJ0eUdyb3VwTmFtZXMgPSB7fTtcbiAgdmFyIHByb3BHcm91cEtleXMgPSBzdHlmbiQ2LnByb3BlcnR5R3JvdXBLZXlzID0gT2JqZWN0LmtleXMocHJvcEdyb3Vwcyk7XG4gIHByb3BHcm91cEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcHJvcEdyb3VwTmFtZXNba2V5XSA9IHByb3BHcm91cHNba2V5XS5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiBwcm9wLm5hbWU7XG4gICAgfSk7XG4gICAgcHJvcEdyb3Vwc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiBwcm9wLmdyb3VwS2V5ID0ga2V5O1xuICAgIH0pO1xuICB9KTsgLy8gZGVmaW5lIGFsaWFzZXNcblxuICB2YXIgYWxpYXNlcyA9IHN0eWZuJDYuYWxpYXNlcyA9IFt7XG4gICAgbmFtZTogJ2NvbnRlbnQnLFxuICAgIHBvaW50c1RvOiAnbGFiZWwnXG4gIH0sIHtcbiAgICBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZScsXG4gICAgcG9pbnRzVG86ICdjb250cm9sLXBvaW50LWRpc3RhbmNlcydcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodCcsXG4gICAgcG9pbnRzVG86ICdjb250cm9sLXBvaW50LXdlaWdodHMnXG4gIH0sIHtcbiAgICBuYW1lOiAnZWRnZS10ZXh0LXJvdGF0aW9uJyxcbiAgICBwb2ludHNUbzogJ3RleHQtcm90YXRpb24nXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1sZWZ0JyxcbiAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1yaWdodCcsXG4gICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmctdG9wJyxcbiAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1ib3R0b20nLFxuICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgfV07IC8vIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcblxuICBzdHlmbiQ2LnByb3BlcnR5TmFtZXMgPSBwcm9wcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC5uYW1lO1xuICB9KTsgLy8gYWxsb3cgYWNjZXNzIG9mIHByb3BlcnRpZXMgYnkgbmFtZSAoIGUuZy4gc3R5bGUucHJvcGVydGllcy5oZWlnaHQgKVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBwcm9wcy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW19pXTtcbiAgICBwcm9wc1twcm9wLm5hbWVdID0gcHJvcDsgLy8gYWxsb3cgbG9va3VwIGJ5IG5hbWVcbiAgfSAvLyBtYXAgYWxpYXNlc1xuXG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYWxpYXNlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIGFsaWFzID0gYWxpYXNlc1tfaTJdO1xuICAgIHZhciBwb2ludHNUb1Byb3AgPSBwcm9wc1thbGlhcy5wb2ludHNUb107XG4gICAgdmFyIGFsaWFzUHJvcCA9IHtcbiAgICAgIG5hbWU6IGFsaWFzLm5hbWUsXG4gICAgICBhbGlhczogdHJ1ZSxcbiAgICAgIHBvaW50c1RvOiBwb2ludHNUb1Byb3BcbiAgICB9OyAvLyBhZGQgYWxpYXMgcHJvcCBmb3IgcGFyc2luZ1xuXG4gICAgcHJvcHMucHVzaChhbGlhc1Byb3ApO1xuICAgIHByb3BzW2FsaWFzLm5hbWVdID0gYWxpYXNQcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICB9XG59KSgpO1xuXG5zdHlmbiQ2LmdldERlZmF1bHRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLmdldERlZmF1bHRQcm9wZXJ0aWVzKClbbmFtZV07XG59O1xuXG5zdHlmbiQ2LmdldERlZmF1bHRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gIGlmIChfcC5kZWZhdWx0UHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIF9wLmRlZmF1bHRQcm9wZXJ0aWVzO1xuICB9XG5cbiAgdmFyIHJhd1Byb3BzID0gZXh0ZW5kKHtcbiAgICAvLyBjb3JlIHByb3BzXG4gICAgJ3NlbGVjdGlvbi1ib3gtY29sb3InOiAnI2RkZCcsXG4gICAgJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSc6IDAuNjUsXG4gICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJzogJyNhYWEnLFxuICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCc6IDEsXG4gICAgJ2FjdGl2ZS1iZy1jb2xvcic6ICdibGFjaycsXG4gICAgJ2FjdGl2ZS1iZy1vcGFjaXR5JzogMC4xNSxcbiAgICAnYWN0aXZlLWJnLXNpemUnOiAzMCxcbiAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJzogJyMwMDAnLFxuICAgICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eSc6IDAuMTI1LFxuICAgIC8vIGNvbW1vbiBub2RlL2VkZ2UgcHJvcHNcbiAgICAnZXZlbnRzJzogJ3llcycsXG4gICAgJ3RleHQtZXZlbnRzJzogJ25vJyxcbiAgICAndGV4dC12YWxpZ24nOiAndG9wJyxcbiAgICAndGV4dC1oYWxpZ24nOiAnY2VudGVyJyxcbiAgICAndGV4dC1qdXN0aWZpY2F0aW9uJzogJ2F1dG8nLFxuICAgICdsaW5lLWhlaWdodCc6IDEsXG4gICAgJ2NvbG9yJzogJyMwMDAnLFxuICAgICd0ZXh0LW91dGxpbmUtY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtb3V0bGluZS13aWR0aCc6IDAsXG4gICAgJ3RleHQtb3V0bGluZS1vcGFjaXR5JzogMSxcbiAgICAndGV4dC1vcGFjaXR5JzogMSxcbiAgICAndGV4dC1kZWNvcmF0aW9uJzogJ25vbmUnLFxuICAgICd0ZXh0LXRyYW5zZm9ybSc6ICdub25lJyxcbiAgICAndGV4dC13cmFwJzogJ25vbmUnLFxuICAgICd0ZXh0LW92ZXJmbG93LXdyYXAnOiAnd2hpdGVzcGFjZScsXG4gICAgJ3RleHQtbWF4LXdpZHRoJzogOTk5OSxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJzogJyMwMDAnLFxuICAgICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSc6IDAsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1zaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZyc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLW9wYWNpdHknOiAwLFxuICAgICd0ZXh0LWJvcmRlci13aWR0aCc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAndGV4dC1ib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgJ2ZvbnQtZmFtaWx5JzogJ0hlbHZldGljYSBOZXVlLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnLFxuICAgICdmb250LXN0eWxlJzogJ25vcm1hbCcsXG4gICAgJ2ZvbnQtd2VpZ2h0JzogJ25vcm1hbCcsXG4gICAgJ2ZvbnQtc2l6ZSc6IDE2LFxuICAgICdtaW4tem9vbWVkLWZvbnQtc2l6ZSc6IDAsXG4gICAgJ3RleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgJ3NvdXJjZS10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICd0YXJnZXQtdGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAnZGlzcGxheSc6ICdlbGVtZW50JyxcbiAgICAnb3BhY2l0eSc6IDEsXG4gICAgJ3otY29tcG91bmQtZGVwdGgnOiAnYXV0bycsXG4gICAgJ3otaW5kZXgtY29tcGFyZSc6ICdhdXRvJyxcbiAgICAnei1pbmRleCc6IDAsXG4gICAgJ2xhYmVsJzogJycsXG4gICAgJ3RleHQtbWFyZ2luLXgnOiAwLFxuICAgICd0ZXh0LW1hcmdpbi15JzogMCxcbiAgICAnc291cmNlLWxhYmVsJzogJycsXG4gICAgJ3NvdXJjZS10ZXh0LW9mZnNldCc6IDAsXG4gICAgJ3NvdXJjZS10ZXh0LW1hcmdpbi14JzogMCxcbiAgICAnc291cmNlLXRleHQtbWFyZ2luLXknOiAwLFxuICAgICd0YXJnZXQtbGFiZWwnOiAnJyxcbiAgICAndGFyZ2V0LXRleHQtb2Zmc2V0JzogMCxcbiAgICAndGFyZ2V0LXRleHQtbWFyZ2luLXgnOiAwLFxuICAgICd0YXJnZXQtdGV4dC1tYXJnaW4teSc6IDAsXG4gICAgJ292ZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgJ292ZXJsYXktY29sb3InOiAnIzAwMCcsXG4gICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICd0cmFuc2l0aW9uLXByb3BlcnR5JzogJ25vbmUnLFxuICAgICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogMCxcbiAgICAndHJhbnNpdGlvbi1kZWxheSc6IDAsXG4gICAgJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJzogJ2xpbmVhcicsXG4gICAgLy8gbm9kZSBwcm9wc1xuICAgICdiYWNrZ3JvdW5kLWJsYWNrZW4nOiAwLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyM5OTknLFxuICAgICdiYWNrZ3JvdW5kLWZpbGwnOiAnc29saWQnLFxuICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ25vbmUnLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJzogJ2Fub255bW91cycsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eSc6IDEsXG4gICAgJ2JhY2tncm91bmQtcG9zaXRpb24teCc6ICc1MCUnLFxuICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiAnNTAlJyxcbiAgICAnYmFja2dyb3VuZC1vZmZzZXQteCc6IDAsXG4gICAgJ2JhY2tncm91bmQtb2Zmc2V0LXknOiAwLFxuICAgICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJzogJ2luY2x1ZGUtcGFkZGluZycsXG4gICAgJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJzogJ2luY2x1ZGUtcGFkZGluZycsXG4gICAgJ2JhY2tncm91bmQtcmVwZWF0JzogJ25vLXJlcGVhdCcsXG4gICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9kZScsXG4gICAgJ2JhY2tncm91bmQtd2lkdGgnOiAnYXV0bycsXG4gICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJ2F1dG8nLFxuICAgICdib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgJ2JvcmRlci1vcGFjaXR5JzogMSxcbiAgICAnYm9yZGVyLXdpZHRoJzogMCxcbiAgICAnYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAnaGVpZ2h0JzogMzAsXG4gICAgJ3dpZHRoJzogMzAsXG4gICAgJ3NoYXBlJzogJ2VsbGlwc2UnLFxuICAgICdzaGFwZS1wb2x5Z29uLXBvaW50cyc6ICctMSwgLTEsICAgMSwgLTEsICAgMSwgMSwgICAtMSwgMScsXG4gICAgJ2JvdW5kcy1leHBhbnNpb24nOiAwLFxuICAgIC8vIG5vZGUgZ3JhZGllbnRcbiAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nOiAndG8tYm90dG9tJyxcbiAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLWNvbG9ycyc6ICcjOTk5JyxcbiAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucyc6ICcwJScsXG4gICAgLy8gZ2hvc3QgcHJvcHNcbiAgICAnZ2hvc3QnOiAnbm8nLFxuICAgICdnaG9zdC1vZmZzZXQteSc6IDAsXG4gICAgJ2dob3N0LW9mZnNldC14JzogMCxcbiAgICAnZ2hvc3Qtb3BhY2l0eSc6IDAsXG4gICAgLy8gY29tcG91bmQgcHJvcHNcbiAgICAncGFkZGluZyc6IDAsXG4gICAgJ3BhZGRpbmctcmVsYXRpdmUtdG8nOiAnd2lkdGgnLFxuICAgICdwb3NpdGlvbic6ICdvcmlnaW4nLFxuICAgICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscyc6ICdpbmNsdWRlJyxcbiAgICAnbWluLXdpZHRoJzogMCxcbiAgICAnbWluLXdpZHRoLWJpYXMtbGVmdCc6IDAsXG4gICAgJ21pbi13aWR0aC1iaWFzLXJpZ2h0JzogMCxcbiAgICAnbWluLWhlaWdodCc6IDAsXG4gICAgJ21pbi1oZWlnaHQtYmlhcy10b3AnOiAwLFxuICAgICdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJzogMFxuICB9LCB7XG4gICAgLy8gbm9kZSBwaWUgYmdcbiAgICAncGllLXNpemUnOiAnMTAwJSdcbiAgfSwgW3tcbiAgICBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtY29sb3InLFxuICAgIHZhbHVlOiAnYmxhY2snXG4gIH0sIHtcbiAgICBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtc2l6ZScsXG4gICAgdmFsdWU6ICcwJSdcbiAgfSwge1xuICAgIG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICB2YWx1ZTogMVxuICB9XS5yZWR1Y2UoZnVuY3Rpb24gKGNzcywgcHJvcCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0eWZuJDYucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWUucmVwbGFjZSgne3tpfX0nLCBpKTtcbiAgICAgIHZhciB2YWwgPSBwcm9wLnZhbHVlO1xuICAgICAgY3NzW25hbWVdID0gdmFsO1xuICAgIH1cblxuICAgIHJldHVybiBjc3M7XG4gIH0sIHt9KSwge1xuICAgIC8vIGVkZ2UgcHJvcHNcbiAgICAnbGluZS1zdHlsZSc6ICdzb2xpZCcsXG4gICAgJ2xpbmUtY29sb3InOiAnIzk5OScsXG4gICAgJ2xpbmUtZmlsbCc6ICdzb2xpZCcsXG4gICAgJ2xpbmUtY2FwJzogJ2J1dHQnLFxuICAgICdsaW5lLWdyYWRpZW50LXN0b3AtY29sb3JzJzogJyM5OTknLFxuICAgICdsaW5lLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJzogJzAlJyxcbiAgICAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnOiA0MCxcbiAgICAnY29udHJvbC1wb2ludC13ZWlnaHRzJzogMC41LFxuICAgICdzZWdtZW50LXdlaWdodHMnOiAwLjUsXG4gICAgJ3NlZ21lbnQtZGlzdGFuY2VzJzogMjAsXG4gICAgJ3RheGktdHVybic6ICc1MCUnLFxuICAgICd0YXhpLXR1cm4tbWluLWRpc3RhbmNlJzogMTAsXG4gICAgJ3RheGktZGlyZWN0aW9uJzogJ2F1dG8nLFxuICAgICdlZGdlLWRpc3RhbmNlcyc6ICdpbnRlcnNlY3Rpb24nLFxuICAgICdjdXJ2ZS1zdHlsZSc6ICdoYXlzdGFjaycsXG4gICAgJ2hheXN0YWNrLXJhZGl1cyc6IDAsXG4gICAgJ2Fycm93LXNjYWxlJzogMSxcbiAgICAnbG9vcC1kaXJlY3Rpb24nOiAnLTQ1ZGVnJyxcbiAgICAnbG9vcC1zd2VlcCc6ICctOTBkZWcnLFxuICAgICdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJzogMCxcbiAgICAndGFyZ2V0LWRpc3RhbmNlLWZyb20tbm9kZSc6IDAsXG4gICAgJ3NvdXJjZS1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLW5vZGUnLFxuICAgICd0YXJnZXQtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1ub2RlJyxcbiAgICAnbGluZS1kYXNoLXBhdHRlcm4nOiBbNiwgM10sXG4gICAgJ2xpbmUtZGFzaC1vZmZzZXQnOiAwXG4gIH0sIFt7XG4gICAgbmFtZTogJ2Fycm93LXNoYXBlJyxcbiAgICB2YWx1ZTogJ25vbmUnXG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctY29sb3InLFxuICAgIHZhbHVlOiAnIzk5OSdcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1maWxsJyxcbiAgICB2YWx1ZTogJ2ZpbGxlZCdcbiAgfV0ucmVkdWNlKGZ1bmN0aW9uIChjc3MsIHByb3ApIHtcbiAgICBzdHlmbiQ2LmFycm93UHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICB2YXIgbmFtZSA9IHByZWZpeCArICctJyArIHByb3AubmFtZTtcbiAgICAgIHZhciB2YWwgPSBwcm9wLnZhbHVlO1xuICAgICAgY3NzW25hbWVdID0gdmFsO1xuICAgIH0pO1xuICAgIHJldHVybiBjc3M7XG4gIH0sIHt9KSk7XG4gIHZhciBwYXJzZWRQcm9wcyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbaV07XG5cbiAgICBpZiAocHJvcC5wb2ludHNUbykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgdmFyIHZhbCA9IHJhd1Byb3BzW25hbWVdO1xuICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWwpO1xuICAgIHBhcnNlZFByb3BzW25hbWVdID0gcGFyc2VkUHJvcDtcbiAgfVxuXG4gIF9wLmRlZmF1bHRQcm9wZXJ0aWVzID0gcGFyc2VkUHJvcHM7XG4gIHJldHVybiBfcC5kZWZhdWx0UHJvcGVydGllcztcbn07XG5cbnN0eWZuJDYuYWRkRGVmYXVsdFN0eWxlc2hlZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VsZWN0b3IoJzpwYXJlbnQnKS5jc3Moe1xuICAgICdzaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICdwYWRkaW5nJzogMTAsXG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnI2VlZScsXG4gICAgJ2JvcmRlci1jb2xvcic6ICcjY2NjJyxcbiAgICAnYm9yZGVyLXdpZHRoJzogMVxuICB9KS5zZWxlY3RvcignZWRnZScpLmNzcyh7XG4gICAgJ3dpZHRoJzogM1xuICB9KS5zZWxlY3RvcignOmxvb3AnKS5jc3Moe1xuICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInXG4gIH0pLnNlbGVjdG9yKCdlZGdlOmNvbXBvdW5kJykuY3NzKHtcbiAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJyxcbiAgICAnc291cmNlLWVuZHBvaW50JzogJ291dHNpZGUtdG8tbGluZScsXG4gICAgJ3RhcmdldC1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLWxpbmUnXG4gIH0pLnNlbGVjdG9yKCc6c2VsZWN0ZWQnKS5jc3Moe1xuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyMwMTY5RDknLFxuICAgICdsaW5lLWNvbG9yJzogJyMwMTY5RDknLFxuICAgICdzb3VyY2UtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ3RhcmdldC1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnbWlkLXNvdXJjZS1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnbWlkLXRhcmdldC1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5J1xuICB9KS5zZWxlY3RvcignOnBhcmVudDpzZWxlY3RlZCcpLmNzcyh7XG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnI0NDRTFGOScsXG4gICAgJ2JvcmRlci1jb2xvcic6ICcjYWVjOGU1J1xuICB9KS5zZWxlY3RvcignOmFjdGl2ZScpLmNzcyh7XG4gICAgJ292ZXJsYXktY29sb3InOiAnYmxhY2snLFxuICAgICdvdmVybGF5LXBhZGRpbmcnOiAxMCxcbiAgICAnb3ZlcmxheS1vcGFjaXR5JzogMC4yNVxuICB9KTtcbiAgdGhpcy5kZWZhdWx0TGVuZ3RoID0gdGhpcy5sZW5ndGg7XG59O1xuXG52YXIgc3R5Zm4kNyA9IHt9OyAvLyBhIGNhY2hpbmcgbGF5ZXIgZm9yIHByb3BlcnR5IHBhcnNpbmdcblxuc3R5Zm4kNy5wYXJzZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KSB7XG4gIHZhciBzZWxmID0gdGhpczsgLy8gZnVuY3Rpb24gdmFsdWVzIGNhbid0IGJlIGNhY2hlZCBpbiBhbGwgY2FzZXMsIGFuZCB0aGVyZSBpc24ndCBtdWNoIGJlbmVmaXQgb2YgY2FjaGluZyB0aGVtIGFueXdheVxuXG4gIGlmIChmbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gc2VsZi5wYXJzZUltcGxXYXJuKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuICB9XG5cbiAgdmFyIGZsYXRLZXkgPSBwcm9wSXNGbGF0ID09PSAnbWFwcGluZycgfHwgcHJvcElzRmxhdCA9PT0gdHJ1ZSB8fCBwcm9wSXNGbGF0ID09PSBmYWxzZSB8fCBwcm9wSXNGbGF0ID09IG51bGwgPyAnZG9udGNhcmUnIDogcHJvcElzRmxhdDtcbiAgdmFyIGJ5cGFzc0tleSA9IHByb3BJc0J5cGFzcyA/ICd0JyA6ICdmJztcbiAgdmFyIHZhbHVlS2V5ID0gJycgKyB2YWx1ZTtcbiAgdmFyIGFyZ0hhc2ggPSBoYXNoU3RyaW5ncyhuYW1lLCB2YWx1ZUtleSwgYnlwYXNzS2V5LCBmbGF0S2V5KTtcbiAgdmFyIHByb3BDYWNoZSA9IHNlbGYucHJvcENhY2hlID0gc2VsZi5wcm9wQ2FjaGUgfHwgW107XG4gIHZhciByZXQ7XG5cbiAgaWYgKCEocmV0ID0gcHJvcENhY2hlW2FyZ0hhc2hdKSkge1xuICAgIHJldCA9IHByb3BDYWNoZVthcmdIYXNoXSA9IHNlbGYucGFyc2VJbXBsV2FybihuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KTtcbiAgfSAvLyAtIGJ5cGFzc2VzIGNhbid0IGJlIHNoYXJlZCBiL2MgdGhlIHZhbHVlIGNhbiBiZSBjaGFuZ2VkIGJ5IGFuaW1hdGlvbnMgb3Igb3RoZXJ3aXNlIG92ZXJyaWRkZW5cbiAgLy8gLSBtYXBwaW5ncyBjYW4ndCBiZSBzaGFyZWQgYi9jIG1hcHBpbmdzIGFyZSBwZXItZWxlbWVudFxuXG5cbiAgaWYgKHByb3BJc0J5cGFzcyB8fCBwcm9wSXNGbGF0ID09PSAnbWFwcGluZycpIHtcbiAgICAvLyBuZWVkIGEgY29weSBzaW5jZSBwcm9wcyBhcmUgbXV0YXRlZCBsYXRlciBpbiB0aGVpciBsaWZlY3ljbGVzXG4gICAgcmV0ID0gY29weShyZXQpO1xuXG4gICAgaWYgKHJldCkge1xuICAgICAgcmV0LnZhbHVlID0gY29weShyZXQudmFsdWUpOyAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIGFuIGFycmF5LCBlLmcuIGNvbG91clxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5zdHlmbiQ3LnBhcnNlSW1wbFdhcm4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICB2YXIgcHJvcCA9IHRoaXMucGFyc2VJbXBsKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuXG4gIGlmICghcHJvcCAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgd2FybihcIlRoZSBzdHlsZSBwcm9wZXJ0eSBgXCIuY29uY2F0KG5hbWUsIFwiOiBcIikuY29uY2F0KHZhbHVlLCBcImAgaXMgaW52YWxpZFwiKSk7XG4gIH1cblxuICByZXR1cm4gcHJvcDtcbn07IC8vIHBhcnNlIGEgcHJvcGVydHk7IHJldHVybiBudWxsIG9uIGludmFsaWQ7IHJldHVybiBwYXJzZWQgcHJvcGVydHkgb3RoZXJ3aXNlXG4vLyBmaWVsZHMgOlxuLy8gLSBuYW1lIDogdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4vLyAtIHZhbHVlIDogdGhlIHBhcnNlZCwgbmF0aXZlLXR5cGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuLy8gLSBzdHJWYWx1ZSA6IGEgc3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgcHJvcGVydHkgdmFsdWUgaW4gdmFsaWQgY3NzXG4vLyAtIGJ5cGFzcyA6IHRydWUgaWZmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eVxuXG5cbnN0eWZuJDcucGFyc2VJbXBsID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBuYW1lID0gY2FtZWwyZGFzaChuYW1lKTsgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBuYW1lIGlzIGluIGRhc2ggZm9ybSAoZS5nLiAncHJvcGVydHktbmFtZScgbm90ICdwcm9wZXJ0eU5hbWUnKVxuXG4gIHZhciBwcm9wZXJ0eSA9IHNlbGYucHJvcGVydGllc1tuYW1lXTtcbiAgdmFyIHBhc3NlZFZhbHVlID0gdmFsdWU7XG4gIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG5cbiAgaWYgKCFwcm9wZXJ0eSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIHJldHVybiBudWxsIG9uIHByb3BlcnR5IG9mIHVua25vd24gbmFtZVxuXG5cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBjYW4ndCBhc3NpZ24gdW5kZWZpbmVkXG4gIC8vIHRoZSBwcm9wZXJ0eSBtYXkgYmUgYW4gYWxpYXNcblxuXG4gIGlmIChwcm9wZXJ0eS5hbGlhcykge1xuICAgIHByb3BlcnR5ID0gcHJvcGVydHkucG9pbnRzVG87XG4gICAgbmFtZSA9IHByb3BlcnR5Lm5hbWU7XG4gIH1cblxuICB2YXIgdmFsdWVJc1N0cmluZyA9IHN0cmluZyh2YWx1ZSk7XG5cbiAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAvLyB0cmltIHRoZSB2YWx1ZSB0byBtYWtlIHBhcnNpbmcgZWFzaWVyXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cblxuICB2YXIgdHlwZSA9IHByb3BlcnR5LnR5cGU7XG5cbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gbm8gdHlwZSwgbm8gbHVja1xuICAvLyBjaGVjayBpZiBieXBhc3MgaXMgbnVsbCBvciBlbXB0eSBzdHJpbmcgKGkuZS4gaW5kaWNhdGlvbiB0byBkZWxldGUgYnlwYXNzIHByb3BlcnR5KVxuXG5cbiAgaWYgKHByb3BJc0J5cGFzcyAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYnlwYXNzOiB0cnVlLFxuICAgICAgZGVsZXRlQnlwYXNzOiB0cnVlXG4gICAgfTtcbiAgfSAvLyBjaGVjayBpZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uIHVzZWQgYXMgYSBtYXBwZXJcblxuXG4gIGlmIChmbih2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnZm4nLFxuICAgICAgbWFwcGVkOiB0eXBlcy5mbixcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfSAvLyBjaGVjayBpZiB2YWx1ZSBpcyBtYXBwZWRcblxuXG4gIHZhciBkYXRhLCBtYXBEYXRhO1xuXG4gIGlmICghdmFsdWVJc1N0cmluZyB8fCBwcm9wSXNGbGF0IHx8IHZhbHVlLmxlbmd0aCA8IDcgfHwgdmFsdWVbMV0gIT09ICdhJykgOyBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPj0gNyAmJiB2YWx1ZVswXSA9PT0gJ2QnICYmIChkYXRhID0gbmV3IFJlZ0V4cCh0eXBlcy5kYXRhLnJlZ2V4KS5leGVjKHZhbHVlKSkpIHtcbiAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG5cbiAgICB2YXIgbWFwcGVkID0gdHlwZXMuZGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBtYXBwZWQ6IG1hcHBlZCxcbiAgICAgIGZpZWxkOiBkYXRhWzFdLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+PSAxMCAmJiB2YWx1ZVswXSA9PT0gJ20nICYmIChtYXBEYXRhID0gbmV3IFJlZ0V4cCh0eXBlcy5tYXBEYXRhLnJlZ2V4KS5leGVjKHZhbHVlKSkpIHtcbiAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG5cbiAgICBpZiAodHlwZS5tdWx0aXBsZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaW1wb3NzaWJsZSB0byBtYXAgdG8gbnVtXG5cblxuICAgIHZhciBfbWFwcGVkID0gdHlwZXMubWFwRGF0YTsgLy8gd2UgY2FuIG1hcCBvbmx5IGlmIHRoZSB0eXBlIGlzIGEgY29sb3VyIG9yIGEgbnVtYmVyXG5cbiAgICBpZiAoISh0eXBlLmNvbG9yIHx8IHR5cGUubnVtYmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZU1pbiA9IHRoaXMucGFyc2UobmFtZSwgbWFwRGF0YVs0XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG5cbiAgICBpZiAoIXZhbHVlTWluIHx8IHZhbHVlTWluLm1hcHBlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuXG4gICAgdmFyIHZhbHVlTWF4ID0gdGhpcy5wYXJzZShuYW1lLCBtYXBEYXRhWzVdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcblxuICAgIGlmICghdmFsdWVNYXggfHwgdmFsdWVNYXgubWFwcGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuICAgIC8vIGNoZWNrIGlmIHZhbHVlTWluIGFuZCB2YWx1ZU1heCBhcmUgdGhlIHNhbWVcblxuXG4gICAgaWYgKHZhbHVlTWluLnBmVmFsdWUgPT09IHZhbHVlTWF4LnBmVmFsdWUgfHwgdmFsdWVNaW4uc3RyVmFsdWUgPT09IHZhbHVlTWF4LnN0clZhbHVlKSB7XG4gICAgICB3YXJuKCdgJyArIG5hbWUgKyAnOiAnICsgdmFsdWUgKyAnYCBpcyBub3QgYSB2YWxpZCBtYXBwZXIgYmVjYXVzZSB0aGUgb3V0cHV0IHJhbmdlIGlzIHplcm87IGNvbnZlcnRpbmcgdG8gYCcgKyBuYW1lICsgJzogJyArIHZhbHVlTWluLnN0clZhbHVlICsgJ2AnKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlTWluLnN0clZhbHVlKTsgLy8gY2FuJ3QgbWFrZSBtdWNoIG9mIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuICAgIH0gZWxzZSBpZiAodHlwZS5jb2xvcikge1xuICAgICAgdmFyIGMxID0gdmFsdWVNaW4udmFsdWU7XG4gICAgICB2YXIgYzIgPSB2YWx1ZU1heC52YWx1ZTtcbiAgICAgIHZhciBzYW1lID0gYzFbMF0gPT09IGMyWzBdIC8vIHJlZFxuICAgICAgJiYgYzFbMV0gPT09IGMyWzFdIC8vIGdyZWVuXG4gICAgICAmJiBjMVsyXSA9PT0gYzJbMl0gLy8gYmx1ZVxuICAgICAgJiYgKCAvLyBvcHRpb25hbCBhbHBoYVxuICAgICAgYzFbM10gPT09IGMyWzNdIC8vIHNhbWUgYWxwaGEgb3V0cmlnaHRcbiAgICAgIHx8IChjMVszXSA9PSBudWxsIHx8IGMxWzNdID09PSAxKSAmJiAoIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDE/XG4gICAgICBjMlszXSA9PSBudWxsIHx8IGMyWzNdID09PSAxKSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAyP1xuICAgICAgKTtcblxuICAgICAgaWYgKHNhbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBjYW4ndCBtYWtlIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogbWFwRGF0YSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgbWFwcGVkOiBfbWFwcGVkLFxuICAgICAgZmllbGQ6IG1hcERhdGFbMV0sXG4gICAgICBmaWVsZE1pbjogcGFyc2VGbG9hdChtYXBEYXRhWzJdKSxcbiAgICAgIC8vIG1pbiAmIG1heCBhcmUgbnVtZXJpY1xuICAgICAgZmllbGRNYXg6IHBhcnNlRmxvYXQobWFwRGF0YVszXSksXG4gICAgICB2YWx1ZU1pbjogdmFsdWVNaW4udmFsdWUsXG4gICAgICB2YWx1ZU1heDogdmFsdWVNYXgudmFsdWUsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZS5tdWx0aXBsZSAmJiBwcm9wSXNGbGF0ICE9PSAnbXVsdGlwbGUnKSB7XG4gICAgdmFyIHZhbHM7XG5cbiAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgdmFscyA9IHZhbHVlLnNwbGl0KC9cXHMrLyk7XG4gICAgfSBlbHNlIGlmIChhcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHMgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFscyA9IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuZXZlbk11bHRpcGxlICYmIHZhbHMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHZhbEFyciA9IFtdO1xuICAgIHZhciB1bml0c0FyciA9IFtdO1xuICAgIHZhciBwZlZhbEFyciA9IFtdO1xuICAgIHZhciBzdHJWYWwgPSAnJztcbiAgICB2YXIgaGFzRW51bSA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHNlbGYucGFyc2UobmFtZSwgdmFsc1tpXSwgcHJvcElzQnlwYXNzLCAnbXVsdGlwbGUnKTtcbiAgICAgIGhhc0VudW0gPSBoYXNFbnVtIHx8IHN0cmluZyhwLnZhbHVlKTtcbiAgICAgIHZhbEFyci5wdXNoKHAudmFsdWUpO1xuICAgICAgcGZWYWxBcnIucHVzaChwLnBmVmFsdWUgIT0gbnVsbCA/IHAucGZWYWx1ZSA6IHAudmFsdWUpO1xuICAgICAgdW5pdHNBcnIucHVzaChwLnVuaXRzKTtcbiAgICAgIHN0clZhbCArPSAoaSA+IDAgPyAnICcgOiAnJykgKyBwLnN0clZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnZhbGlkYXRlICYmICF0eXBlLnZhbGlkYXRlKHZhbEFyciwgdW5pdHNBcnIpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5zaW5nbGVFbnVtICYmIGhhc0VudW0pIHtcbiAgICAgIGlmICh2YWxBcnIubGVuZ3RoID09PSAxICYmIHN0cmluZyh2YWxBcnJbMF0pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsQXJyWzBdLFxuICAgICAgICAgIHN0clZhbHVlOiB2YWxBcnJbMF0sXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbEFycixcbiAgICAgIHBmVmFsdWU6IHBmVmFsQXJyLFxuICAgICAgc3RyVmFsdWU6IHN0clZhbCxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgdW5pdHM6IHVuaXRzQXJyXG4gICAgfTtcbiAgfSAvLyBzZXZlcmFsIHR5cGVzIGFsc28gYWxsb3cgZW51bXNcblxuXG4gIHZhciBjaGVja0VudW1zID0gZnVuY3Rpb24gY2hlY2tFbnVtcygpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHlwZS5lbnVtcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbX2ldO1xuXG4gICAgICBpZiAoZW4gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTsgLy8gY2hlY2sgdGhlIHR5cGUgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0XG5cblxuICBpZiAodHlwZS5udW1iZXIpIHtcbiAgICB2YXIgdW5pdHM7XG4gICAgdmFyIGltcGxpY2l0VW5pdHMgPSAncHgnOyAvLyBub3Qgc2V0ID0+IHB4XG5cbiAgICBpZiAodHlwZS51bml0cykge1xuICAgICAgLy8gdXNlIHNwZWNpZmllZCB1bml0cyBpZiBzZXRcbiAgICAgIHVuaXRzID0gdHlwZS51bml0cztcbiAgICB9XG5cbiAgICBpZiAodHlwZS5pbXBsaWNpdFVuaXRzKSB7XG4gICAgICBpbXBsaWNpdFVuaXRzID0gdHlwZS5pbXBsaWNpdFVuaXRzO1xuICAgIH1cblxuICAgIGlmICghdHlwZS51bml0bGVzcykge1xuICAgICAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHVuaXRzUmVnZXggPSAncHh8ZW0nICsgKHR5cGUuYWxsb3dQZXJjZW50ID8gJ3xcXFxcJScgOiAnJyk7XG5cbiAgICAgICAgaWYgKHVuaXRzKSB7XG4gICAgICAgICAgdW5pdHNSZWdleCA9IHVuaXRzO1xuICAgICAgICB9IC8vIG9ubHkgYWxsb3cgZXhwbGljaXQgdW5pdHMgaWYgc28gc2V0XG5cblxuICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgnXignICsgbnVtYmVyJDEgKyAnKSgnICsgdW5pdHNSZWdleCArICcpPycgKyAnJCcpO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgICAgdW5pdHMgPSBtYXRjaFsyXSB8fCBpbXBsaWNpdFVuaXRzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF1bml0cyB8fCB0eXBlLmltcGxpY2l0VW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBpbXBsaWNpdFVuaXRzOyAvLyBpbXBsaWNpdGx5IHB4IGlmIHVuc3BlY2lmaWVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTsgLy8gaWYgbm90IGEgbnVtYmVyIGFuZCBlbnVtcyBub3QgYWxsb3dlZCwgdGhlbiB0aGUgdmFsdWUgaXMgaW52YWxpZFxuXG4gICAgaWYgKGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gY2hlY2sgaWYgdGhpcyBudW1iZXIgdHlwZSBhbHNvIGFjY2VwdHMgc3BlY2lhbCBrZXl3b3JkcyBpbiBwbGFjZSBvZiBudW1iZXJzXG4gICAgLy8gKGkuZS4gYGxlZnRgLCBgYXV0b2AsIGV0YylcblxuXG4gICAgaWYgKGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gcGFzc2VkVmFsdWU7XG4gICAgICByZXR1cm4gY2hlY2tFbnVtcygpO1xuICAgIH0gLy8gY2hlY2sgaWYgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyXG5cblxuICAgIGlmICh0eXBlLmludGVnZXIgJiYgIWludGVnZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIGNoZWNrIHZhbHVlIGlzIHdpdGhpbiByYW5nZVxuXG5cbiAgICBpZiAodHlwZS5taW4gIT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPCB0eXBlLm1pbiB8fCB0eXBlLnN0cmljdE1pbiAmJiB2YWx1ZSA9PT0gdHlwZS5taW4pIHx8IHR5cGUubWF4ICE9PSB1bmRlZmluZWQgJiYgKHZhbHVlID4gdHlwZS5tYXggfHwgdHlwZS5zdHJpY3RNYXggJiYgdmFsdWUgPT09IHR5cGUubWF4KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSArICh1bml0cyA/IHVuaXRzIDogJycpLFxuICAgICAgdW5pdHM6IHVuaXRzLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9OyAvLyBub3JtYWxpc2UgdmFsdWUgaW4gcGl4ZWxzXG5cbiAgICBpZiAodHlwZS51bml0bGVzcyB8fCB1bml0cyAhPT0gJ3B4JyAmJiB1bml0cyAhPT0gJ2VtJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ3B4JyB8fCAhdW5pdHMgPyB2YWx1ZSA6IHRoaXMuZ2V0RW1TaXplSW5QaXhlbHMoKSAqIHZhbHVlO1xuICAgIH0gLy8gbm9ybWFsaXNlIHZhbHVlIGluIG1zXG5cblxuICAgIGlmICh1bml0cyA9PT0gJ21zJyB8fCB1bml0cyA9PT0gJ3MnKSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAnbXMnID8gdmFsdWUgOiAxMDAwICogdmFsdWU7XG4gICAgfSAvLyBub3JtYWxpc2UgdmFsdWUgaW4gcmFkXG5cblxuICAgIGlmICh1bml0cyA9PT0gJ2RlZycgfHwgdW5pdHMgPT09ICdyYWQnKSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAncmFkJyA/IHZhbHVlIDogZGVnMnJhZCh2YWx1ZSk7XG4gICAgfSAvLyBub3JtYWxpemUgdmFsdWUgaW4gJVxuXG5cbiAgICBpZiAodW5pdHMgPT09ICclJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB2YWx1ZSAvIDEwMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9IGVsc2UgaWYgKHR5cGUucHJvcExpc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICB2YXIgcHJvcHNTdHIgPSAnJyArIHZhbHVlO1xuXG4gICAgaWYgKHByb3BzU3RyID09PSAnbm9uZScpIDsgZWxzZSB7XG4gICAgICAvLyBnbyBvdmVyIGVhY2ggcHJvcFxuICAgICAgdmFyIHByb3BzU3BsaXQgPSBwcm9wc1N0ci5zcGxpdCgvXFxzKixcXHMqfFxccysvKTtcblxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcHJvcHNTcGxpdC5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BzU3BsaXRbX2kyXS50cmltKCk7XG5cbiAgICAgICAgaWYgKHNlbGYucHJvcGVydGllc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKCdgJyArIHByb3BOYW1lICsgJ2AgaXMgbm90IGEgdmFsaWQgcHJvcGVydHkgbmFtZScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogcHJvcHMsXG4gICAgICBzdHJWYWx1ZTogcHJvcHMubGVuZ3RoID09PSAwID8gJ25vbmUnIDogcHJvcHMuam9pbignICcpLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGUuY29sb3IpIHtcbiAgICB2YXIgdHVwbGUgPSBjb2xvcjJ0dXBsZSh2YWx1ZSk7XG5cbiAgICBpZiAoIXR1cGxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB0dXBsZSxcbiAgICAgIHBmVmFsdWU6IHR1cGxlLFxuICAgICAgc3RyVmFsdWU6ICdyZ2IoJyArIHR1cGxlWzBdICsgJywnICsgdHVwbGVbMV0gKyAnLCcgKyB0dXBsZVsyXSArICcpJyxcbiAgICAgIC8vIG4uYi4gbm8gc3BhY2VzIGIvYyBvZiBtdWx0aXBsZSBzdXBwb3J0XG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZS5yZWdleCB8fCB0eXBlLnJlZ2V4ZXMpIHtcbiAgICAvLyBmaXJzdCBjaGVjayBlbnVtc1xuICAgIGlmICh0eXBlLmVudW1zKSB7XG4gICAgICB2YXIgZW51bVByb3AgPSBjaGVja0VudW1zKCk7XG5cbiAgICAgIGlmIChlbnVtUHJvcCkge1xuICAgICAgICByZXR1cm4gZW51bVByb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2V4ZXMgPSB0eXBlLnJlZ2V4ZXMgPyB0eXBlLnJlZ2V4ZXMgOiBbdHlwZS5yZWdleF07XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCByZWdleGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhlc1tfaTNdKTsgLy8gbWFrZSBhIHJlZ2V4IGZyb20gdGhlIHR5cGUgc3RyaW5nXG5cbiAgICAgIHZhciBtID0gcmVnZXguZXhlYyh2YWx1ZSk7XG5cbiAgICAgIGlmIChtKSB7XG4gICAgICAgIC8vIHJlZ2V4IG1hdGNoZXNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB0eXBlLnNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZSA/IG1bMV0gOiBtLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7IC8vIGRpZG4ndCBtYXRjaCBhbnlcbiAgfSBlbHNlIGlmICh0eXBlLnN0cmluZykge1xuICAgIC8vIGp1c3QgcmV0dXJuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGUuZW51bXMpIHtcbiAgICAvLyBjaGVjayBlbnVtcyBsYXN0IGJlY2F1c2UgaXQncyBhIGNvbWJvIHR5cGUgaW4gb3RoZXJzXG4gICAgcmV0dXJuIGNoZWNrRW51bXMoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm90IGEgdHlwZSB3ZSBjYW4gaGFuZGxlXG4gIH1cbn07XG5cbnZhciBTdHlsZSA9IGZ1bmN0aW9uIFN0eWxlKGN5KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHlsZSkpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlKGN5KTtcbiAgfVxuXG4gIGlmICghY29yZShjeSkpIHtcbiAgICBlcnJvcignQSBzdHlsZSBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIGNvcmVTdHlsZToge31cbiAgfTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnJlc2V0VG9EZWZhdWx0KCk7XG59O1xuXG52YXIgc3R5Zm4kOCA9IFN0eWxlLnByb3RvdHlwZTtcblxuc3R5Zm4kOC5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdzdHlsZSc7XG59OyAvLyByZW1vdmUgYWxsIGNvbnRleHRzXG5cblxuc3R5Zm4kOC5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgX3AubmV3U3R5bGUgPSB0cnVlO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnN0eWZuJDgucmVzZXRUb0RlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuICByZXR1cm4gdGhpcztcbn07IC8vIGJ1aWxkcyBhIHN0eWxlIG9iamVjdCBmb3IgdGhlICdjb3JlJyBzZWxlY3RvclxuXG5cbnN0eWZuJDguY29yZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbcHJvcE5hbWVdIHx8IHRoaXMuZ2V0RGVmYXVsdFByb3BlcnR5KHByb3BOYW1lKTtcbn07IC8vIGNyZWF0ZSBhIG5ldyBjb250ZXh0IGZyb20gdGhlIHNwZWNpZmllZCBzZWxlY3RvciBzdHJpbmcgYW5kIHN3aXRjaCB0byB0aGF0IGNvbnRleHRcblxuXG5zdHlmbiQ4LnNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yU3RyKSB7XG4gIC8vICdjb3JlJyBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgZG9lcyBub3QgbmVlZCBhIHNlbGVjdG9yXG4gIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yU3RyID09PSAnY29yZScgPyBudWxsIDogbmV3IFNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrOyAvLyBuZXcgY29udGV4dCBtZWFucyBuZXcgaW5kZXhcblxuICB0aGlzW2ldID0ge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBwcm9wZXJ0aWVzOiBbXSxcbiAgICBtYXBwZWRQcm9wZXJ0aWVzOiBbXSxcbiAgICBpbmRleDogaVxuICB9O1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07IC8vIGFkZCBvbmUgb3IgbWFueSBjc3MgcnVsZXMgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuXG5cbnN0eWZuJDguY3NzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBtYXAgPSBhcmdzWzBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgdmFyIG1hcFZhbCA9IG1hcFtwcm9wLm5hbWVdO1xuXG4gICAgICBpZiAobWFwVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWFwVmFsID0gbWFwW2Rhc2gyY2FtZWwocHJvcC5uYW1lKV07XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXBWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNzc1J1bGUocHJvcC5uYW1lLCBtYXBWYWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIHRoaXMuY3NzUnVsZShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfSAvLyBkbyBub3RoaW5nIGlmIGFyZ3MgYXJlIGludmFsaWRcblxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc3R5Zm4kOC5zdHlsZSA9IHN0eWZuJDguY3NzOyAvLyBhZGQgYSBzaW5nbGUgY3NzIHJ1bGUgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuXG5zdHlmbiQ4LmNzc1J1bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgLy8gbmFtZS12YWx1ZSBwYWlyXG4gIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUpOyAvLyBhZGQgcHJvcGVydHkgdG8gY3VycmVudCBjb250ZXh0IGlmIHZhbGlkXG5cbiAgaWYgKHByb3BlcnR5KSB7XG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgIHRoaXNbaV0ucHJvcGVydGllc1twcm9wZXJ0eS5uYW1lXSA9IHByb3BlcnR5OyAvLyBhbGxvdyBhY2Nlc3MgYnkgbmFtZSBhcyB3ZWxsXG5cbiAgICBpZiAocHJvcGVydHkubmFtZS5tYXRjaCgvcGllLShcXGQrKS1iYWNrZ3JvdW5kLXNpemUvKSAmJiBwcm9wZXJ0eS52YWx1ZSkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5oYXNQaWUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eS5tYXBwZWQpIHtcbiAgICAgIHRoaXNbaV0ubWFwcGVkUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICB9IC8vIGFkZCB0byBjb3JlIHN0eWxlIGlmIG5lY2Vzc2FyeVxuXG5cbiAgICB2YXIgY3VycmVudFNlbGVjdG9ySXNDb3JlID0gIXRoaXNbaV0uc2VsZWN0b3I7XG5cbiAgICBpZiAoY3VycmVudFNlbGVjdG9ySXNDb3JlKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZVtwcm9wZXJ0eS5uYW1lXSA9IHByb3BlcnR5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc3R5Zm4kOC5hcHBlbmQgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgaWYgKHN0eWxlc2hlZXQoc3R5bGUpKSB7XG4gICAgc3R5bGUuYXBwZW5kVG9TdHlsZSh0aGlzKTtcbiAgfSBlbHNlIGlmIChhcnJheShzdHlsZSkpIHtcbiAgICB0aGlzLmFwcGVuZEZyb21Kc29uKHN0eWxlKTtcbiAgfSBlbHNlIGlmIChzdHJpbmcoc3R5bGUpKSB7XG4gICAgdGhpcy5hcHBlbmRGcm9tU3RyaW5nKHN0eWxlKTtcbiAgfSAvLyB5b3UgcHJvYmFibHkgd291bGRuJ3Qgd2FudCB0byBhcHBlbmQgYSBTdHlsZSwgc2luY2UgeW91J2QgZHVwbGljYXRlIHRoZSBkZWZhdWx0IHBhcnRzXG5cblxuICByZXR1cm4gdGhpcztcbn07IC8vIHN0YXRpYyBmdW5jdGlvblxuXG5cblN0eWxlLmZyb21Kc29uID0gZnVuY3Rpb24gKGN5LCBqc29uKSB7XG4gIHZhciBzdHlsZSA9IG5ldyBTdHlsZShjeSk7XG4gIHN0eWxlLmZyb21Kc29uKGpzb24pO1xuICByZXR1cm4gc3R5bGU7XG59O1xuXG5TdHlsZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKGN5LCBzdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBTdHlsZShjeSkuZnJvbVN0cmluZyhzdHJpbmcpO1xufTtcblxuW3N0eWZuLCBzdHlmbiQxLCBzdHlmbiQyLCBzdHlmbiQzLCBzdHlmbiQ0LCBzdHlmbiQ1LCBzdHlmbiQ2LCBzdHlmbiQ3XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoc3R5Zm4kOCwgcHJvcHMpO1xufSk7XG5TdHlsZS50eXBlcyA9IHN0eWZuJDgudHlwZXM7XG5TdHlsZS5wcm9wZXJ0aWVzID0gc3R5Zm4kOC5wcm9wZXJ0aWVzO1xuU3R5bGUucHJvcGVydHlHcm91cHMgPSBzdHlmbiQ4LnByb3BlcnR5R3JvdXBzO1xuU3R5bGUucHJvcGVydHlHcm91cE5hbWVzID0gc3R5Zm4kOC5wcm9wZXJ0eUdyb3VwTmFtZXM7XG5TdHlsZS5wcm9wZXJ0eUdyb3VwS2V5cyA9IHN0eWZuJDgucHJvcGVydHlHcm91cEtleXM7XG5cbnZhciBjb3JlZm4kNyA9IHtcbiAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKG5ld1N0eWxlKSB7XG4gICAgaWYgKG5ld1N0eWxlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuc2V0U3R5bGUobmV3U3R5bGUpO1xuICAgICAgcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdHlsZTtcbiAgfSxcbiAgc2V0U3R5bGU6IGZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmIChzdHlsZXNoZWV0KHN0eWxlKSkge1xuICAgICAgX3Auc3R5bGUgPSBzdHlsZS5nZW5lcmF0ZVN0eWxlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoYXJyYXkoc3R5bGUpKSB7XG4gICAgICBfcC5zdHlsZSA9IFN0eWxlLmZyb21Kc29uKHRoaXMsIHN0eWxlKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhzdHlsZSkpIHtcbiAgICAgIF9wLnN0eWxlID0gU3R5bGUuZnJvbVN0cmluZyh0aGlzLCBzdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wLnN0eWxlID0gU3R5bGUodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wLnN0eWxlO1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFNlbGVjdGlvblR5cGUgPSAnc2luZ2xlJztcbnZhciBjb3JlZm4kOCA9IHtcbiAgYXV0b2xvY2s6IGZ1bmN0aW9uIGF1dG9sb2NrKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG9sb2NrID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGF1dG91bmdyYWJpZnk6IGZ1bmN0aW9uIGF1dG91bmdyYWJpZnkoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGF1dG91bnNlbGVjdGlmeTogZnVuY3Rpb24gYXV0b3Vuc2VsZWN0aWZ5KGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgc2VsZWN0aW9uVHlwZTogZnVuY3Rpb24gc2VsZWN0aW9uVHlwZShzZWxUeXBlKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmIChfcC5zZWxlY3Rpb25UeXBlID09IG51bGwpIHtcbiAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSBkZWZhdWx0U2VsZWN0aW9uVHlwZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoc2VsVHlwZSA9PT0gJ2FkZGl0aXZlJyB8fCBzZWxUeXBlID09PSAnc2luZ2xlJykge1xuICAgICAgICBfcC5zZWxlY3Rpb25UeXBlID0gc2VsVHlwZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9wLnNlbGVjdGlvblR5cGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBhbm5pbmdFbmFibGVkOiBmdW5jdGlvbiBwYW5uaW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICB1c2VyUGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHVzZXJQYW5uaW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiB6b29taW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHVzZXJab29taW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uIGJveFNlbGVjdGlvbkVuYWJsZWQoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHBhbjogZnVuY3Rpb24gcGFuKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG5cbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8vIC5wYW4oKVxuICAgICAgICByZXR1cm4gcGFuO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChzdHJpbmcoYXJnc1swXSkpIHtcbiAgICAgICAgICAvLyAucGFuKCd4JylcbiAgICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICAgIHJldHVybiBwYW5bZGltXTtcbiAgICAgICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChhcmdzWzBdKSkge1xuICAgICAgICAgIC8vIC5wYW4oeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICAgIGlmIChudW1iZXIoeCkpIHtcbiAgICAgICAgICAgIHBhbi54ID0geDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobnVtYmVyKHkpKSB7XG4gICAgICAgICAgICBwYW4ueSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIC5wYW4oJ3gnLCAxMDApXG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgICAgdmFsID0gYXJnc1sxXTtcblxuICAgICAgICBpZiAoKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiBudW1iZXIodmFsKSkge1xuICAgICAgICAgIHBhbltkaW1dID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gaW52YWxpZFxuICAgIH1cblxuICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBwYW5CeTogZnVuY3Rpb24gcGFuQnkoYXJnMCwgYXJnMSkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG5cbiAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKHBsYWluT2JqZWN0KGFyZzApKSB7XG4gICAgICAgICAgLy8gLnBhbkJ5KHsgeDogMCwgeTogMTAwIH0pXG4gICAgICAgICAgZGltcyA9IGFyZ3NbMF07XG4gICAgICAgICAgeCA9IGRpbXMueDtcbiAgICAgICAgICB5ID0gZGltcy55O1xuXG4gICAgICAgICAgaWYgKG51bWJlcih4KSkge1xuICAgICAgICAgICAgcGFuLnggKz0geDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobnVtYmVyKHkpKSB7XG4gICAgICAgICAgICBwYW4ueSArPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICAvLyAucGFuQnkoJ3gnLCAxMDApXG4gICAgICAgIGRpbSA9IGFyZzA7XG4gICAgICAgIHZhbCA9IGFyZzE7XG5cbiAgICAgICAgaWYgKChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgbnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICBwYW5bZGltXSArPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBpbnZhbGlkXG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGZpdDogZnVuY3Rpb24gZml0KGVsZW1lbnRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIHZpZXdwb3J0U3RhdGUgPSB0aGlzLmdldEZpdFZpZXdwb3J0KGVsZW1lbnRzLCBwYWRkaW5nKTtcblxuICAgIGlmICh2aWV3cG9ydFN0YXRlKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgX3Auem9vbSA9IHZpZXdwb3J0U3RhdGUuem9vbTtcbiAgICAgIF9wLnBhbiA9IHZpZXdwb3J0U3RhdGUucGFuO1xuICAgICAgdGhpcy5lbWl0KCdwYW4gem9vbSB2aWV3cG9ydCcpO1xuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGdldEZpdFZpZXdwb3J0OiBmdW5jdGlvbiBnZXRGaXRWaWV3cG9ydChlbGVtZW50cywgcGFkZGluZykge1xuICAgIGlmIChudW1iZXIoZWxlbWVudHMpICYmIHBhZGRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZWxlbWVudHMgaXMgb3B0aW9uYWxcbiAgICAgIHBhZGRpbmcgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiYjtcblxuICAgIGlmIChzdHJpbmcoZWxlbWVudHMpKSB7XG4gICAgICB2YXIgc2VsID0gZWxlbWVudHM7XG4gICAgICBlbGVtZW50cyA9IHRoaXMuJChzZWwpO1xuICAgIH0gZWxzZSBpZiAoYm91bmRpbmdCb3goZWxlbWVudHMpKSB7XG4gICAgICAvLyBhc3N1bWUgYmJcbiAgICAgIHZhciBiYmUgPSBlbGVtZW50cztcbiAgICAgIGJiID0ge1xuICAgICAgICB4MTogYmJlLngxLFxuICAgICAgICB5MTogYmJlLnkxLFxuICAgICAgICB4MjogYmJlLngyLFxuICAgICAgICB5MjogYmJlLnkyXG4gICAgICB9O1xuICAgICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgICB9IGVsc2UgaWYgKCFlbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSAmJiBlbGVtZW50cy5lbXB0eSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBjYW4ndCBmaXQgdG8gbm90aGluZ1xuXG5cbiAgICBiYiA9IGJiIHx8IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgIHZhciB6b29tO1xuICAgIHBhZGRpbmcgPSBudW1iZXIocGFkZGluZykgPyBwYWRkaW5nIDogMDtcblxuICAgIGlmICghaXNOYU4odykgJiYgIWlzTmFOKGgpICYmIHcgPiAwICYmIGggPiAwICYmICFpc05hTihiYi53KSAmJiAhaXNOYU4oYmIuaCkgJiYgYmIudyA+IDAgJiYgYmIuaCA+IDApIHtcbiAgICAgIHpvb20gPSBNYXRoLm1pbigodyAtIDIgKiBwYWRkaW5nKSAvIGJiLncsIChoIC0gMiAqIHBhZGRpbmcpIC8gYmIuaCk7IC8vIGNyb3Agem9vbVxuXG4gICAgICB6b29tID0gem9vbSA+IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA/IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA6IHpvb207XG4gICAgICB6b29tID0gem9vbSA8IHRoaXMuX3ByaXZhdGUubWluWm9vbSA/IHRoaXMuX3ByaXZhdGUubWluWm9vbSA6IHpvb207XG4gICAgICB2YXIgcGFuID0ge1xuICAgICAgICAvLyBub3cgcGFuIHRvIG1pZGRsZVxuICAgICAgICB4OiAodyAtIHpvb20gKiAoYmIueDEgKyBiYi54MikpIC8gMixcbiAgICAgICAgeTogKGggLSB6b29tICogKGJiLnkxICsgYmIueTIpKSAvIDJcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwYW46IHBhblxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0sXG4gIHpvb21SYW5nZTogZnVuY3Rpb24gem9vbVJhbmdlKG1pbiwgbWF4KSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgdmFyIG9wdHMgPSBtaW47XG4gICAgICBtaW4gPSBvcHRzLm1pbjtcbiAgICAgIG1heCA9IG9wdHMubWF4O1xuICAgIH1cblxuICAgIGlmIChudW1iZXIobWluKSAmJiBudW1iZXIobWF4KSAmJiBtaW4gPD0gbWF4KSB7XG4gICAgICBfcC5taW5ab29tID0gbWluO1xuICAgICAgX3AubWF4Wm9vbSA9IG1heDtcbiAgICB9IGVsc2UgaWYgKG51bWJlcihtaW4pICYmIG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA8PSBfcC5tYXhab29tKSB7XG4gICAgICBfcC5taW5ab29tID0gbWluO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyKG1heCkgJiYgbWluID09PSB1bmRlZmluZWQgJiYgbWF4ID49IF9wLm1pblpvb20pIHtcbiAgICAgIF9wLm1heFpvb20gPSBtYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG1pblpvb206IGZ1bmN0aW9uIG1pblpvb20oem9vbSkge1xuICAgIGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1pblpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnpvb21SYW5nZSh7XG4gICAgICAgIG1pbjogem9vbVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBtYXhab29tOiBmdW5jdGlvbiBtYXhab29tKHpvb20pIHtcbiAgICBpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXhab29tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy56b29tUmFuZ2Uoe1xuICAgICAgICBtYXg6IHpvb21cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZ2V0Wm9vbWVkVmlld3BvcnQ6IGZ1bmN0aW9uIGdldFpvb21lZFZpZXdwb3J0KHBhcmFtcykge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGN1cnJlbnRQYW4gPSBfcC5wYW47XG4gICAgdmFyIGN1cnJlbnRab29tID0gX3Auem9vbTtcbiAgICB2YXIgcG9zOyAvLyBpbiByZW5kZXJlZCBweFxuXG4gICAgdmFyIHpvb207XG4gICAgdmFyIGJhaWwgPSBmYWxzZTtcblxuICAgIGlmICghX3Auem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgIC8vIHpvb21pbmcgZGlzYWJsZWRcbiAgICAgIGJhaWwgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChudW1iZXIocGFyYW1zKSkge1xuICAgICAgLy8gdGhlbiBzZXQgdGhlIHpvb21cbiAgICAgIHpvb20gPSBwYXJhbXM7XG4gICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChwYXJhbXMpKSB7XG4gICAgICAvLyB0aGVuIHpvb20gYWJvdXQgYSBwb2ludFxuICAgICAgem9vbSA9IHBhcmFtcy5sZXZlbDtcblxuICAgICAgaWYgKHBhcmFtcy5wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHBvcyA9IG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHBhcmFtcy5wb3NpdGlvbiwgY3VycmVudFpvb20sIGN1cnJlbnRQYW4pO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXMucmVuZGVyZWRQb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zICE9IG51bGwgJiYgIV9wLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICAgIC8vIHBhbm5pbmcgZGlzYWJsZWRcbiAgICAgICAgYmFpbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBjcm9wIHpvb21cblxuXG4gICAgem9vbSA9IHpvb20gPiBfcC5tYXhab29tID8gX3AubWF4Wm9vbSA6IHpvb207XG4gICAgem9vbSA9IHpvb20gPCBfcC5taW5ab29tID8gX3AubWluWm9vbSA6IHpvb207IC8vIGNhbid0IHpvb20gd2l0aCBpbnZhbGlkIHBhcmFtc1xuXG4gICAgaWYgKGJhaWwgfHwgIW51bWJlcih6b29tKSB8fCB6b29tID09PSBjdXJyZW50Wm9vbSB8fCBwb3MgIT0gbnVsbCAmJiAoIW51bWJlcihwb3MueCkgfHwgIW51bWJlcihwb3MueSkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocG9zICE9IG51bGwpIHtcbiAgICAgIC8vIHNldCB6b29tIGFib3V0IHBvc2l0aW9uXG4gICAgICB2YXIgcGFuMSA9IGN1cnJlbnRQYW47XG4gICAgICB2YXIgem9vbTEgPSBjdXJyZW50Wm9vbTtcbiAgICAgIHZhciB6b29tMiA9IHpvb207XG4gICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgeDogLXpvb20yIC8gem9vbTEgKiAocG9zLnggLSBwYW4xLngpICsgcG9zLngsXG4gICAgICAgIHk6IC16b29tMiAvIHpvb20xICogKHBvcy55IC0gcGFuMS55KSArIHBvcy55XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgem9vbWVkOiB0cnVlLFxuICAgICAgICBwYW5uZWQ6IHRydWUsXG4gICAgICAgIHpvb206IHpvb20yLFxuICAgICAgICBwYW46IHBhbjJcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGp1c3Qgc2V0IHRoZSB6b29tXG4gICAgICByZXR1cm4ge1xuICAgICAgICB6b29tZWQ6IHRydWUsXG4gICAgICAgIHBhbm5lZDogZmFsc2UsXG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIHBhbjogY3VycmVudFBhblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIHpvb206IGZ1bmN0aW9uIHpvb20ocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBnZXRcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNldFxuICAgICAgdmFyIHZwID0gdGhpcy5nZXRab29tZWRWaWV3cG9ydChwYXJhbXMpO1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKHZwID09IG51bGwgfHwgIXZwLnpvb21lZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgX3Auem9vbSA9IHZwLnpvb207XG5cbiAgICAgIGlmICh2cC5wYW5uZWQpIHtcbiAgICAgICAgX3AucGFuLnggPSB2cC5wYW4ueDtcbiAgICAgICAgX3AucGFuLnkgPSB2cC5wYW4ueTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0KCd6b29tJyArICh2cC5wYW5uZWQgPyAnIHBhbicgOiAnJykgKyAnIHZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH1cbiAgfSxcbiAgdmlld3BvcnQ6IGZ1bmN0aW9uIHZpZXdwb3J0KG9wdHMpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB6b29tRGVmZCA9IHRydWU7XG4gICAgdmFyIHBhbkRlZmQgPSB0cnVlO1xuICAgIHZhciBldmVudHMgPSBbXTsgLy8gdG8gdHJpZ2dlclxuXG4gICAgdmFyIHpvb21GYWlsZWQgPSBmYWxzZTtcbiAgICB2YXIgcGFuRmFpbGVkID0gZmFsc2U7XG5cbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghbnVtYmVyKG9wdHMuem9vbSkpIHtcbiAgICAgIHpvb21EZWZkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFwbGFpbk9iamVjdChvcHRzLnBhbikpIHtcbiAgICAgIHBhbkRlZmQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXpvb21EZWZkICYmICFwYW5EZWZkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoem9vbURlZmQpIHtcbiAgICAgIHZhciB6ID0gb3B0cy56b29tO1xuXG4gICAgICBpZiAoeiA8IF9wLm1pblpvb20gfHwgeiA+IF9wLm1heFpvb20gfHwgIV9wLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICAgIHpvb21GYWlsZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Auem9vbSA9IHo7XG4gICAgICAgIGV2ZW50cy5wdXNoKCd6b29tJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhbkRlZmQgJiYgKCF6b29tRmFpbGVkIHx8ICFvcHRzLmNhbmNlbE9uRmFpbGVkWm9vbSkgJiYgX3AucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgIHZhciBwID0gb3B0cy5wYW47XG5cbiAgICAgIGlmIChudW1iZXIocC54KSkge1xuICAgICAgICBfcC5wYW4ueCA9IHAueDtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1iZXIocC55KSkge1xuICAgICAgICBfcC5wYW4ueSA9IHAueTtcbiAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFuRmFpbGVkKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKCdwYW4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGV2ZW50cy5wdXNoKCd2aWV3cG9ydCcpO1xuICAgICAgdGhpcy5lbWl0KGV2ZW50cy5qb2luKCcgJykpO1xuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGNlbnRlcjogZnVuY3Rpb24gY2VudGVyKGVsZW1lbnRzKSB7XG4gICAgdmFyIHBhbiA9IHRoaXMuZ2V0Q2VudGVyUGFuKGVsZW1lbnRzKTtcblxuICAgIGlmIChwYW4pIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUucGFuID0gcGFuO1xuICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBnZXRDZW50ZXJQYW46IGZ1bmN0aW9uIGdldENlbnRlclBhbihlbGVtZW50cywgem9vbSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzdHJpbmcoZWxlbWVudHMpKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0gZWxzZSBpZiAoIWVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gY2FuJ3QgY2VudHJlIHBhbiB0byBub3RoaW5nXG5cblxuICAgIHZhciBiYiA9IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgIHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9wcml2YXRlLnpvb20gOiB6b29tO1xuICAgIHZhciBwYW4gPSB7XG4gICAgICAvLyBtaWRkbGVcbiAgICAgIHg6ICh3IC0gem9vbSAqIChiYi54MSArIGJiLngyKSkgLyAyLFxuICAgICAgeTogKGggLSB6b29tICogKGJiLnkxICsgYmIueTIpKSAvIDJcbiAgICB9O1xuICAgIHJldHVybiBwYW47XG4gIH0sXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMudmlld3BvcnQoe1xuICAgICAgcGFuOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICB6b29tOiAxXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGludmFsaWRhdGVTaXplOiBmdW5jdGlvbiBpbnZhbGlkYXRlU2l6ZSgpIHtcbiAgICB0aGlzLl9wcml2YXRlLnNpemVDYWNoZSA9IG51bGw7XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY29udGFpbmVyID0gX3AuY29udGFpbmVyO1xuICAgIHJldHVybiBfcC5zaXplQ2FjaGUgPSBfcC5zaXplQ2FjaGUgfHwgKGNvbnRhaW5lciA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdHlsZSA9IHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcblxuICAgICAgdmFyIHZhbCA9IGZ1bmN0aW9uIHZhbChuYW1lKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGNvbnRhaW5lci5jbGllbnRXaWR0aCAtIHZhbCgncGFkZGluZy1sZWZ0JykgLSB2YWwoJ3BhZGRpbmctcmlnaHQnKSxcbiAgICAgICAgaGVpZ2h0OiBjb250YWluZXIuY2xpZW50SGVpZ2h0IC0gdmFsKCdwYWRkaW5nLXRvcCcpIC0gdmFsKCdwYWRkaW5nLWJvdHRvbScpXG4gICAgICB9O1xuICAgIH0oKSA6IHtcbiAgICAgIC8vIGZhbGxiYWNrIGlmIG5vIGNvbnRhaW5lciAobm90IDAgYi9jIGNhbiBiZSB1c2VkIGZvciBkaXZpZGluZyBldGMpXG4gICAgICB3aWR0aDogMSxcbiAgICAgIGhlaWdodDogMVxuICAgIH0pO1xuICB9LFxuICB3aWR0aDogZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSgpLndpZHRoO1xuICB9LFxuICBoZWlnaHQ6IGZ1bmN0aW9uIGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplKCkuaGVpZ2h0O1xuICB9LFxuICBleHRlbnQ6IGZ1bmN0aW9uIGV4dGVudCgpIHtcbiAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgdmFyIHpvb20gPSB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgdmFyIHJiID0gdGhpcy5yZW5kZXJlZEV4dGVudCgpO1xuICAgIHZhciBiID0ge1xuICAgICAgeDE6IChyYi54MSAtIHBhbi54KSAvIHpvb20sXG4gICAgICB4MjogKHJiLngyIC0gcGFuLngpIC8gem9vbSxcbiAgICAgIHkxOiAocmIueTEgLSBwYW4ueSkgLyB6b29tLFxuICAgICAgeTI6IChyYi55MiAtIHBhbi55KSAvIHpvb21cbiAgICB9O1xuICAgIGIudyA9IGIueDIgLSBiLngxO1xuICAgIGIuaCA9IGIueTIgLSBiLnkxO1xuICAgIHJldHVybiBiO1xuICB9LFxuICByZW5kZXJlZEV4dGVudDogZnVuY3Rpb24gcmVuZGVyZWRFeHRlbnQoKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCgpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuICAgIHJldHVybiB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgeDI6IHdpZHRoLFxuICAgICAgeTI6IGhlaWdodCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0XG4gICAgfTtcbiAgfVxufTsgLy8gYWxpYXNlc1xuXG5jb3JlZm4kOC5jZW50cmUgPSBjb3JlZm4kOC5jZW50ZXI7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbmNvcmVmbiQ4LmF1dG9sb2NrTm9kZXMgPSBjb3JlZm4kOC5hdXRvbG9jaztcbmNvcmVmbiQ4LmF1dG91bmdyYWJpZnlOb2RlcyA9IGNvcmVmbiQ4LmF1dG91bmdyYWJpZnk7XG5cbnZhciBmbiQ2ID0ge1xuICBkYXRhOiBkZWZpbmUkMy5kYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlRGF0YTogZGVmaW5lJDMucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBldmVudDogJ2RhdGEnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWVcbiAgfSksXG4gIHNjcmF0Y2g6IGRlZmluZSQzLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gIH0pLFxuICByZW1vdmVTY3JhdGNoOiBkZWZpbmUkMy5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZVxuICB9KVxufTsgLy8gYWxpYXNlc1xuXG5mbiQ2LmF0dHIgPSBmbiQ2LmRhdGE7XG5mbiQ2LnJlbW92ZUF0dHIgPSBmbiQ2LnJlbW92ZURhdGE7XG5cbnZhciBDb3JlID0gZnVuY3Rpb24gQ29yZShvcHRzKSB7XG4gIHZhciBjeSA9IHRoaXM7XG4gIG9wdHMgPSBleHRlbmQoe30sIG9wdHMpO1xuICB2YXIgY29udGFpbmVyID0gb3B0cy5jb250YWluZXI7IC8vIGFsbG93IGZvciBwYXNzaW5nIGEgd3JhcHBlZCBqcXVlcnkgb2JqZWN0XG4gIC8vIGUuZy4gY3l0b3NjYXBlKHsgY29udGFpbmVyOiAkKCcjY3knKSB9KVxuXG4gIGlmIChjb250YWluZXIgJiYgIWh0bWxFbGVtZW50KGNvbnRhaW5lcikgJiYgaHRtbEVsZW1lbnQoY29udGFpbmVyWzBdKSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclswXTtcbiAgfVxuXG4gIHZhciByZWcgPSBjb250YWluZXIgPyBjb250YWluZXIuX2N5cmVnIDogbnVsbDsgLy8gZS5nLiBhbHJlYWR5IHJlZ2lzdGVyZWQgc29tZSBpbmZvIChlLmcuIHJlYWRpZXMpIHZpYSBqcXVlcnlcblxuICByZWcgPSByZWcgfHwge307XG5cbiAgaWYgKHJlZyAmJiByZWcuY3kpIHtcbiAgICByZWcuY3kuZGVzdHJveSgpO1xuICAgIHJlZyA9IHt9OyAvLyBvbGQgaW5zdGFuY2UgPT4gcmVwbGFjZSByZWcgY29tcGxldGVseVxuICB9XG5cbiAgdmFyIHJlYWRpZXMgPSByZWcucmVhZGllcyA9IHJlZy5yZWFkaWVzIHx8IFtdO1xuXG4gIGlmIChjb250YWluZXIpIHtcbiAgICBjb250YWluZXIuX2N5cmVnID0gcmVnO1xuICB9IC8vIG1ha2Ugc3VyZSBjb250YWluZXIgYXNzb2MnZCByZWcgcG9pbnRzIHRvIHRoaXMgY3lcblxuXG4gIHJlZy5jeSA9IGN5O1xuICB2YXIgaGVhZCA9IHdpbmRvdyQxICE9PSB1bmRlZmluZWQgJiYgY29udGFpbmVyICE9PSB1bmRlZmluZWQgJiYgIW9wdHMuaGVhZGxlc3M7XG4gIHZhciBvcHRpb25zID0gb3B0cztcbiAgb3B0aW9ucy5sYXlvdXQgPSBleHRlbmQoe1xuICAgIG5hbWU6IGhlYWQgPyAnZ3JpZCcgOiAnbnVsbCdcbiAgfSwgb3B0aW9ucy5sYXlvdXQpO1xuICBvcHRpb25zLnJlbmRlcmVyID0gZXh0ZW5kKHtcbiAgICBuYW1lOiBoZWFkID8gJ2NhbnZhcycgOiAnbnVsbCdcbiAgfSwgb3B0aW9ucy5yZW5kZXJlcik7XG5cbiAgdmFyIGRlZlZhbCA9IGZ1bmN0aW9uIGRlZlZhbChkZWYsIHZhbCwgYWx0VmFsKSB7XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gZWxzZSBpZiAoYWx0VmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBhbHRWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZWY7XG4gICAgfVxuICB9O1xuXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgLy8gaHRtbCBkb20gZWxlIGNvbnRhaW5lclxuICAgIHJlYWR5OiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHJlYWR5IGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgLy8gY2FjaGVkIG9wdGlvbnNcbiAgICBlbGVtZW50czogbmV3IENvbGxlY3Rpb24odGhpcyksXG4gICAgLy8gZWxlbWVudHMgaW4gdGhlIGdyYXBoXG4gICAgbGlzdGVuZXJzOiBbXSxcbiAgICAvLyBsaXN0IG9mIGxpc3RlbmVyc1xuICAgIGFuaUVsZXM6IG5ldyBDb2xsZWN0aW9uKHRoaXMpLFxuICAgIC8vIGVsZW1lbnRzIGJlaW5nIGFuaW1hdGVkXG4gICAgZGF0YToge30sXG4gICAgLy8gZGF0YSBmb3IgdGhlIGNvcmVcbiAgICBzY3JhdGNoOiB7fSxcbiAgICAvLyBzY3JhdGNoIG9iamVjdCBmb3IgY29yZVxuICAgIGxheW91dDogbnVsbCxcbiAgICByZW5kZXJlcjogbnVsbCxcbiAgICBkZXN0cm95ZWQ6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgZGVzdHJveSB3YXMgY2FsbGVkXG4gICAgbm90aWZpY2F0aW9uc0VuYWJsZWQ6IHRydWUsXG4gICAgLy8gd2hldGhlciBub3RpZmljYXRpb25zIGFyZSBzZW50IHRvIHRoZSByZW5kZXJlclxuICAgIG1pblpvb206IDFlLTUwLFxuICAgIG1heFpvb206IDFlNTAsXG4gICAgem9vbWluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnpvb21pbmdFbmFibGVkKSxcbiAgICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnVzZXJab29taW5nRW5hYmxlZCksXG4gICAgcGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnBhbm5pbmdFbmFibGVkKSxcbiAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnVzZXJQYW5uaW5nRW5hYmxlZCksXG4gICAgYm94U2VsZWN0aW9uRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuYm94U2VsZWN0aW9uRW5hYmxlZCksXG4gICAgYXV0b2xvY2s6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvbG9jaywgb3B0aW9ucy5hdXRvbG9ja05vZGVzKSxcbiAgICBhdXRvdW5ncmFiaWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5Tm9kZXMpLFxuICAgIGF1dG91bnNlbGVjdGlmeTogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG91bnNlbGVjdGlmeSksXG4gICAgc3R5bGVFbmFibGVkOiBvcHRpb25zLnN0eWxlRW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gaGVhZCA6IG9wdGlvbnMuc3R5bGVFbmFibGVkLFxuICAgIHpvb206IG51bWJlcihvcHRpb25zLnpvb20pID8gb3B0aW9ucy56b29tIDogMSxcbiAgICBwYW46IHtcbiAgICAgIHg6IHBsYWluT2JqZWN0KG9wdGlvbnMucGFuKSAmJiBudW1iZXIob3B0aW9ucy5wYW4ueCkgPyBvcHRpb25zLnBhbi54IDogMCxcbiAgICAgIHk6IHBsYWluT2JqZWN0KG9wdGlvbnMucGFuKSAmJiBudW1iZXIob3B0aW9ucy5wYW4ueSkgPyBvcHRpb25zLnBhbi55IDogMFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAvLyBvYmplY3QgZm9yIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgcXVldWU6IFtdXG4gICAgfSxcbiAgICBoYXNDb21wb3VuZE5vZGVzOiBmYWxzZVxuICB9O1xuXG4gIHRoaXMuY3JlYXRlRW1pdHRlcigpOyAvLyBzZXQgc2VsZWN0aW9uIHR5cGVcblxuICB0aGlzLnNlbGVjdGlvblR5cGUob3B0aW9ucy5zZWxlY3Rpb25UeXBlKTsgLy8gaW5pdCB6b29tIGJvdW5kc1xuXG4gIHRoaXMuem9vbVJhbmdlKHtcbiAgICBtaW46IG9wdGlvbnMubWluWm9vbSxcbiAgICBtYXg6IG9wdGlvbnMubWF4Wm9vbVxuICB9KTtcblxuICB2YXIgbG9hZEV4dERhdGEgPSBmdW5jdGlvbiBsb2FkRXh0RGF0YShleHREYXRhLCBuZXh0KSB7XG4gICAgdmFyIGFueUlzUHJvbWlzZSA9IGV4dERhdGEuc29tZShwcm9taXNlKTtcblxuICAgIGlmIChhbnlJc1Byb21pc2UpIHtcbiAgICAgIHJldHVybiBQcm9taXNlJDEuYWxsKGV4dERhdGEpLnRoZW4obmV4dCk7IC8vIGxvYWQgYWxsIGRhdGEgYXN5bmNocm9ub3VzbHksIHRoZW4gZXhlYyByZXN0IG9mIGluaXRcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dChleHREYXRhKTsgLy8gZXhlYyBzeW5jaHJvbm91c2x5IGZvciBjb252ZW5pZW5jZVxuICAgIH1cbiAgfTsgLy8gc3RhcnQgd2l0aCB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0IHNvIHdlIGhhdmUgc29tZXRoaW5nIGJlZm9yZSBsb2FkaW5nIGFuIGV4dGVybmFsIHN0eWxlc2hlZXRcblxuXG4gIGlmIChfcC5zdHlsZUVuYWJsZWQpIHtcbiAgICBjeS5zZXRTdHlsZShbXSk7XG4gIH0gLy8gY3JlYXRlIHRoZSByZW5kZXJlclxuXG5cbiAgdmFyIHJlbmRlcmVyT3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucywgb3B0aW9ucy5yZW5kZXJlcik7IC8vIGFsbG93IHJlbmRlcmluZyBoaW50cyBpbiB0b3AgbGV2ZWwgb3B0aW9uc1xuXG4gIGN5LmluaXRSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xuXG4gIHZhciBzZXRFbGVzQW5kTGF5b3V0ID0gZnVuY3Rpb24gc2V0RWxlc0FuZExheW91dChlbGVtZW50cywgb25sb2FkLCBvbmRvbmUpIHtcbiAgICBjeS5ub3RpZmljYXRpb25zKGZhbHNlKTsgLy8gcmVtb3ZlIG9sZCBlbGVtZW50c1xuXG4gICAgdmFyIG9sZEVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcblxuICAgIGlmIChvbGRFbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG9sZEVsZXMucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnRzICE9IG51bGwpIHtcbiAgICAgIGlmIChwbGFpbk9iamVjdChlbGVtZW50cykgfHwgYXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgIGN5LmFkZChlbGVtZW50cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3kub25lKCdsYXlvdXRyZWFkeScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBjeS5ub3RpZmljYXRpb25zKHRydWUpO1xuICAgICAgY3kuZW1pdChlKTsgLy8gd2UgbWlzc2VkIHRoaXMgZXZlbnQgYnkgdHVybmluZyBub3RpZmljYXRpb25zIG9mZiwgc28gcGFzcyBpdCBvblxuXG4gICAgICBjeS5vbmUoJ2xvYWQnLCBvbmxvYWQpO1xuICAgICAgY3kuZW1pdEFuZE5vdGlmeSgnbG9hZCcpO1xuICAgIH0pLm9uZSgnbGF5b3V0c3RvcCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGN5Lm9uZSgnZG9uZScsIG9uZG9uZSk7XG4gICAgICBjeS5lbWl0KCdkb25lJyk7XG4gICAgfSk7XG4gICAgdmFyIGxheW91dE9wdHMgPSBleHRlbmQoe30sIGN5Ll9wcml2YXRlLm9wdGlvbnMubGF5b3V0KTtcbiAgICBsYXlvdXRPcHRzLmVsZXMgPSBjeS5lbGVtZW50cygpO1xuICAgIGN5LmxheW91dChsYXlvdXRPcHRzKS5ydW4oKTtcbiAgfTtcblxuICBsb2FkRXh0RGF0YShbb3B0aW9ucy5zdHlsZSwgb3B0aW9ucy5lbGVtZW50c10sIGZ1bmN0aW9uICh0aGVucykge1xuICAgIHZhciBpbml0U3R5bGUgPSB0aGVuc1swXTtcbiAgICB2YXIgaW5pdEVsZXMgPSB0aGVuc1sxXTsgLy8gaW5pdCBzdHlsZVxuXG4gICAgaWYgKF9wLnN0eWxlRW5hYmxlZCkge1xuICAgICAgY3kuc3R5bGUoKS5hcHBlbmQoaW5pdFN0eWxlKTtcbiAgICB9IC8vIGluaXRpYWwgbG9hZFxuXG5cbiAgICBzZXRFbGVzQW5kTGF5b3V0KGluaXRFbGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBvbnJlYWR5XG4gICAgICBjeS5zdGFydEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgIF9wLnJlYWR5ID0gdHJ1ZTsgLy8gaWYgYSByZWFkeSBjYWxsYmFjayBpcyBzcGVjaWZpZWQgYXMgYW4gb3B0aW9uLCB0aGUgYmluZCBpdFxuXG4gICAgICBpZiAoZm4ob3B0aW9ucy5yZWFkeSkpIHtcbiAgICAgICAgY3kub24oJ3JlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICB9IC8vIGJpbmQgYWxsIHRoZSByZWFkeSBoYW5kbGVycyByZWdpc3RlcmVkIGJlZm9yZSBjcmVhdGluZyB0aGlzIGluc3RhbmNlXG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWFkaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmbiQxID0gcmVhZGllc1tpXTtcbiAgICAgICAgY3kub24oJ3JlYWR5JywgZm4kMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWcpIHtcbiAgICAgICAgcmVnLnJlYWRpZXMgPSBbXTtcbiAgICAgIH0gLy8gY2xlYXIgYi9jIHdlJ3ZlIGJvdW5kIHRoZW0gYWxsIGFuZCBkb24ndCB3YW50IHRvIGtlZXAgaXQgYXJvdW5kIGluIGNhc2UgYSBuZXcgY29yZSB1c2VzIHRoZSBzYW1lIGRpdiBldGNcblxuXG4gICAgICBjeS5lbWl0KCdyZWFkeScpO1xuICAgIH0sIG9wdGlvbnMuZG9uZSk7XG4gIH0pO1xufTtcblxudmFyIGNvcmVmbiQ5ID0gQ29yZS5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbmV4dGVuZChjb3JlZm4kOSwge1xuICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdjb3JlJztcbiAgfSxcbiAgaXNSZWFkeTogZnVuY3Rpb24gaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZWFkeTtcbiAgfSxcbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZGVzdHJveWVkO1xuICB9LFxuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoZm4pIHtcbiAgICBpZiAodGhpcy5pc1JlYWR5KCkpIHtcbiAgICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoJ3JlYWR5JywgW10sIGZuKTsgLy8ganVzdCBjYWxscyBmbiBhcyB0aG91Z2ggdHJpZ2dlcmVkIHZpYSByZWFkeSBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCdyZWFkeScsIGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGlmIChjeS5kZXN0cm95ZWQoKSkgcmV0dXJuO1xuICAgIGN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG4gICAgY3kuZGVzdHJveVJlbmRlcmVyKCk7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95Jyk7XG4gICAgY3kuX3ByaXZhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICByZXR1cm4gY3k7XG4gIH0sXG4gIGhhc0VsZW1lbnRXaXRoSWQ6IGZ1bmN0aW9uIGhhc0VsZW1lbnRXaXRoSWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5oYXNFbGVtZW50V2l0aElkKGlkKTtcbiAgfSxcbiAgZ2V0RWxlbWVudEJ5SWQ6IGZ1bmN0aW9uIGdldEVsZW1lbnRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICB9LFxuICBoYXNDb21wb3VuZE5vZGVzOiBmdW5jdGlvbiBoYXNDb21wb3VuZE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXM7XG4gIH0sXG4gIGhlYWRsZXNzOiBmdW5jdGlvbiBoZWFkbGVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlci5pc0hlYWRsZXNzKCk7XG4gIH0sXG4gIHN0eWxlRW5hYmxlZDogZnVuY3Rpb24gc3R5bGVFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgfSxcbiAgYWRkVG9Qb29sOiBmdW5jdGlvbiBhZGRUb1Bvb2woZWxlcykge1xuICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMubWVyZ2UoZWxlcyk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgcmVtb3ZlRnJvbVBvb2w6IGZ1bmN0aW9uIHJlbW92ZUZyb21Qb29sKGVsZXMpIHtcbiAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLnVubWVyZ2UoZWxlcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29udGFpbmVyOiBmdW5jdGlvbiBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29udGFpbmVyIHx8IG51bGw7XG4gIH0sXG4gIG1vdW50OiBmdW5jdGlvbiBtb3VudChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHZhciBfcCA9IGN5Ll9wcml2YXRlO1xuICAgIHZhciBvcHRpb25zID0gX3Aub3B0aW9ucztcblxuICAgIGlmICghaHRtbEVsZW1lbnQoY29udGFpbmVyKSAmJiBodG1sRWxlbWVudChjb250YWluZXJbMF0pKSB7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXJbMF07XG4gICAgfVxuXG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICBfcC5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgX3Auc3R5bGVFbmFibGVkID0gdHJ1ZTtcbiAgICBjeS5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIGN5LmluaXRSZW5kZXJlcihleHRlbmQoe30sIG9wdGlvbnMsIG9wdGlvbnMucmVuZGVyZXIsIHtcbiAgICAgIC8vIGFsbG93IGN1c3RvbSByZW5kZXJlciBuYW1lIHRvIGJlIHJlLXVzZWQsIG90aGVyd2lzZSB1c2UgY2FudmFzXG4gICAgICBuYW1lOiBvcHRpb25zLnJlbmRlcmVyLm5hbWUgPT09ICdudWxsJyA/ICdjYW52YXMnIDogb3B0aW9ucy5yZW5kZXJlci5uYW1lXG4gICAgfSkpO1xuICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgIGN5LnN0eWxlKG9wdGlvbnMuc3R5bGUpO1xuICAgIGN5LmVtaXQoJ21vdW50Jyk7XG4gICAgcmV0dXJuIGN5O1xuICB9LFxuICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICBjeS5pbml0UmVuZGVyZXIoe1xuICAgICAgbmFtZTogJ251bGwnXG4gICAgfSk7XG4gICAgY3kuZW1pdCgndW5tb3VudCcpO1xuICAgIHJldHVybiBjeTtcbiAgfSxcbiAgb3B0aW9uczogZnVuY3Rpb24gb3B0aW9ucygpIHtcbiAgICByZXR1cm4gY29weSh0aGlzLl9wcml2YXRlLm9wdGlvbnMpO1xuICB9LFxuICBqc29uOiBmdW5jdGlvbiBqc29uKG9iaikge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcblxuICAgIHZhciBnZXRGcmVzaFJlZiA9IGZ1bmN0aW9uIGdldEZyZXNoUmVmKGVsZSkge1xuICAgICAgcmV0dXJuIGN5LmdldEVsZW1lbnRCeUlkKGVsZS5pZCgpKTtcbiAgICB9O1xuXG4gICAgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgIC8vIHNldFxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICBpZiAob2JqLmVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBpZEluSnNvbiA9IHt9O1xuXG4gICAgICAgIHZhciB1cGRhdGVFbGVzID0gZnVuY3Rpb24gdXBkYXRlRWxlcyhqc29ucywgZ3IpIHtcbiAgICAgICAgICB2YXIgdG9BZGQgPSBbXTtcbiAgICAgICAgICB2YXIgdG9Nb2QgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwganNvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG4gICAgICAgICAgICB2YXIgaWQgPSAnJyArIGpzb24uZGF0YS5pZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgICAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgIGlkSW5Kc29uW2lkXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChlbGUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGV4aXN0aW5nIGVsZW1lbnQgc2hvdWxkIGJlIHVwZGF0ZWRcbiAgICAgICAgICAgICAgdG9Nb2QucHVzaCh7XG4gICAgICAgICAgICAgICAgZWxlOiBlbGUsXG4gICAgICAgICAgICAgICAganNvbjoganNvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgICAgICAgaWYgKGdyKSB7XG4gICAgICAgICAgICAgICAganNvbi5ncm91cCA9IGdyO1xuICAgICAgICAgICAgICAgIHRvQWRkLnB1c2goanNvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9BZGQucHVzaChqc29uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN5LmFkZCh0b0FkZCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdG9Nb2QubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX3RvTW9kJF9pID0gdG9Nb2RbX2ldLFxuICAgICAgICAgICAgICAgIF9lbGUgPSBfdG9Nb2QkX2kuZWxlLFxuICAgICAgICAgICAgICAgIF9qc29uID0gX3RvTW9kJF9pLmpzb247XG5cbiAgICAgICAgICAgIF9lbGUuanNvbihfanNvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChhcnJheShvYmouZWxlbWVudHMpKSB7XG4gICAgICAgICAgLy8gZWxlbWVudHM6IFtdXG4gICAgICAgICAgdXBkYXRlRWxlcyhvYmouZWxlbWVudHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVsZW1lbnRzOiB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdIH1cbiAgICAgICAgICB2YXIgZ3JzID0gWydub2RlcycsICdlZGdlcyddO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBnciA9IGdyc1tpXTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IG9iai5lbGVtZW50c1tncl07XG5cbiAgICAgICAgICAgIGlmIChhcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgICAgICAgdXBkYXRlRWxlcyhlbGVtZW50cywgZ3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnRzVG9SZW1vdmUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gIWlkSW5Kc29uW2VsZS5pZCgpXTtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICBwYXJlbnRzVG9SZW1vdmUubWVyZ2UoZWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIHNvIHRoYXQgY2hpbGRyZW4gYXJlIG5vdCByZW1vdmVkIHcvcGFyZW50XG5cbiAgICAgICAgcGFyZW50c1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuY2hpbGRyZW4oKS5tb3ZlKHtcbiAgICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgLy8gaW50ZXJtZWRpYXRlIHBhcmVudHMgbWF5IGJlIG1vdmVkIGJ5IHByaW9yIGxpbmUsIHNvIG1ha2Ugc3VyZSB3ZSByZW1vdmUgYnkgZnJlc2ggcmVmc1xuXG4gICAgICAgIHBhcmVudHNUb1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0RnJlc2hSZWYoZWxlKS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmouc3R5bGUpIHtcbiAgICAgICAgY3kuc3R5bGUob2JqLnN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iai56b29tICE9IG51bGwgJiYgb2JqLnpvb20gIT09IF9wLnpvb20pIHtcbiAgICAgICAgY3kuem9vbShvYmouem9vbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmoucGFuKSB7XG4gICAgICAgIGlmIChvYmoucGFuLnggIT09IF9wLnBhbi54IHx8IG9iai5wYW4ueSAhPT0gX3AucGFuLnkpIHtcbiAgICAgICAgICBjeS5wYW4ob2JqLnBhbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iai5kYXRhKSB7XG4gICAgICAgIGN5LmRhdGEob2JqLmRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmllbGRzID0gWydtaW5ab29tJywgJ21heFpvb20nLCAnem9vbWluZ0VuYWJsZWQnLCAndXNlclpvb21pbmdFbmFibGVkJywgJ3Bhbm5pbmdFbmFibGVkJywgJ3VzZXJQYW5uaW5nRW5hYmxlZCcsICdib3hTZWxlY3Rpb25FbmFibGVkJywgJ2F1dG9sb2NrJywgJ2F1dG91bmdyYWJpZnknLCAnYXV0b3Vuc2VsZWN0aWZ5J107XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGZpZWxkcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBmID0gZmllbGRzW19pMl07XG5cbiAgICAgICAgaWYgKG9ialtmXSAhPSBudWxsKSB7XG4gICAgICAgICAgY3lbZl0ob2JqW2ZdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdldFxuICAgICAgdmFyIGZsYXQgPSAhIW9iajtcbiAgICAgIHZhciBqc29uID0ge307XG5cbiAgICAgIGlmIChmbGF0KSB7XG4gICAgICAgIGpzb24uZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCkubWFwKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmpzb24oKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uLmVsZW1lbnRzID0ge307XG4gICAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgdmFyIGdyb3VwID0gZWxlLmdyb3VwKCk7XG5cbiAgICAgICAgICBpZiAoIWpzb24uZWxlbWVudHNbZ3JvdXBdKSB7XG4gICAgICAgICAgICBqc29uLmVsZW1lbnRzW2dyb3VwXSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdLnB1c2goZWxlLmpzb24oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQpIHtcbiAgICAgICAganNvbi5zdHlsZSA9IGN5LnN0eWxlKCkuanNvbigpO1xuICAgICAgfVxuXG4gICAgICBqc29uLmRhdGEgPSBjb3B5KGN5LmRhdGEoKSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IF9wLm9wdGlvbnM7XG4gICAgICBqc29uLnpvb21pbmdFbmFibGVkID0gX3Auem9vbWluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnVzZXJab29taW5nRW5hYmxlZCA9IF9wLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24uem9vbSA9IF9wLnpvb207XG4gICAgICBqc29uLm1pblpvb20gPSBfcC5taW5ab29tO1xuICAgICAganNvbi5tYXhab29tID0gX3AubWF4Wm9vbTtcbiAgICAgIGpzb24ucGFubmluZ0VuYWJsZWQgPSBfcC5wYW5uaW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclBhbm5pbmdFbmFibGVkID0gX3AudXNlclBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi5wYW4gPSBjb3B5KF9wLnBhbik7XG4gICAgICBqc29uLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBfcC5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgICAganNvbi5yZW5kZXJlciA9IGNvcHkob3B0aW9ucy5yZW5kZXJlcik7XG4gICAgICBqc29uLmhpZGVFZGdlc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gICAgICBqc29uLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgICAgIGpzb24ud2hlZWxTZW5zaXRpdml0eSA9IG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgICAgIGpzb24ubW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1cjtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgfVxufSk7XG5jb3JlZm4kOS4kaWQgPSBjb3JlZm4kOS5nZXRFbGVtZW50QnlJZDtcbltjb3JlZm4sIGNvcmVmbiQxLCBlbGVzZm4kdiwgY29yZWZuJDIsIGNvcmVmbiQzLCBjb3JlZm4kNCwgY29yZWZuJDUsIGNvcmVmbiQ2LCBjb3JlZm4kNywgY29yZWZuJDgsIGZuJDZdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChjb3JlZm4kOSwgcHJvcHMpO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbnZhciBkZWZhdWx0cyQ5ID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRoZSB0cmVlIGlzIGRpcmVjdGVkIGRvd253YXJkcyAob3IgZWRnZXMgY2FuIHBvaW50IGluIGFueSBkaXJlY3Rpb24gaWYgZmFsc2UpXG4gIHBhZGRpbmc6IDMwLFxuICAvLyBwYWRkaW5nIG9uIGZpdFxuICBjaXJjbGU6IGZhbHNlLFxuICAvLyBwdXQgZGVwdGhzIGluIGNvbmNlbnRyaWMgY2lyY2xlcyBpZiB0cnVlLCBwdXQgZGVwdGhzIHRvcCBkb3duIGlmIGZhbHNlXG4gIGdyaWQ6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIGNyZWF0ZSBhbiBldmVuIGdyaWQgaW50byB3aGljaCB0aGUgREFHIGlzIHBsYWNlZCAoY2lyY2xlOmZhbHNlIG9ubHkpXG4gIHNwYWNpbmdGYWN0b3I6IDEuNzUsXG4gIC8vIHBvc2l0aXZlIHNwYWNpbmcgZmFjdG9yLCBsYXJnZXIgPT4gbW9yZSBzcGFjZSBiZXR3ZWVuIG5vZGVzIChOLkIuIG4vYSBpZiBjYXVzZXMgb3ZlcmxhcClcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICByb290czogdW5kZWZpbmVkLFxuICAvLyB0aGUgcm9vdHMgb2YgdGhlIHRyZWVzXG4gIG1heGltYWw6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHNoaWZ0IG5vZGVzIGRvd24gdGhlaXIgbmF0dXJhbCBCRlMgZGVwdGhzIGluIG9yZGVyIHRvIGF2b2lkIHVwd2FyZHMgZWRnZXMgKERBR1Mgb25seSlcbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZCxcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0c1xuXG59O1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG52YXIgZ2V0SW5mbyA9IGZ1bmN0aW9uIGdldEluZm8oZWxlKSB7XG4gIHJldHVybiBlbGUuc2NyYXRjaCgnYnJlYWR0aGZpcnN0Jyk7XG59O1xuXG52YXIgc2V0SW5mbyA9IGZ1bmN0aW9uIHNldEluZm8oZWxlLCBvYmopIHtcbiAgcmV0dXJuIGVsZS5zY3JhdGNoKCdicmVhZHRoZmlyc3QnLCBvYmopO1xufTtcblxuZnVuY3Rpb24gQnJlYWR0aEZpcnN0TGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ5LCBvcHRpb25zKTtcbn1cblxuQnJlYWR0aEZpcnN0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuICFuLmlzUGFyZW50KCk7XG4gIH0pO1xuICB2YXIgZ3JhcGggPSBlbGVzO1xuICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICB2YXIgbWF4aW1hbCA9IG9wdGlvbnMubWF4aW1hbCB8fCBvcHRpb25zLm1heGltYWxBZGp1c3RtZW50cyA+IDA7IC8vIG1heGltYWxBZGp1c3RtZW50cyBmb3IgY29tcGF0LiB3LyBvbGQgY29kZVxuXG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICB2YXIgcm9vdHM7XG5cbiAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24ob3B0aW9ucy5yb290cykpIHtcbiAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gIH0gZWxzZSBpZiAoYXJyYXkob3B0aW9ucy5yb290cykpIHtcbiAgICB2YXIgcm9vdHNBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSBvcHRpb25zLnJvb3RzW2ldO1xuICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgIHJvb3RzQXJyYXkucHVzaChlbGUpO1xuICAgIH1cblxuICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbihyb290c0FycmF5KTtcbiAgfSBlbHNlIGlmIChzdHJpbmcob3B0aW9ucy5yb290cykpIHtcbiAgICByb290cyA9IGN5LiQob3B0aW9ucy5yb290cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICByb290cyA9IG5vZGVzLnJvb3RzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb21wb25lbnRzID0gZWxlcy5jb21wb25lbnRzKCk7XG4gICAgICByb290cyA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgICAgdmFyIGNvbXAgPSBjb21wb25lbnRzW19pXTtcbiAgICAgICAgdmFyIG1heERlZ3JlZSA9IGNvbXAubWF4RGVncmVlKGZhbHNlKTtcbiAgICAgICAgdmFyIGNvbXBSb290cyA9IGNvbXAuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmRlZ3JlZShmYWxzZSkgPT09IG1heERlZ3JlZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb3RzID0gcm9vdHMuYWRkKGNvbXBSb290cyk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY29tcG9uZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgX2xvb3AoX2kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZXB0aHMgPSBbXTtcbiAgdmFyIGZvdW5kQnlCZnMgPSB7fTtcblxuICB2YXIgYWRkVG9EZXB0aCA9IGZ1bmN0aW9uIGFkZFRvRGVwdGgoZWxlLCBkKSB7XG4gICAgaWYgKGRlcHRoc1tkXSA9PSBudWxsKSB7XG4gICAgICBkZXB0aHNbZF0gPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGRlcHRoc1tkXS5sZW5ndGg7XG4gICAgZGVwdGhzW2RdLnB1c2goZWxlKTtcbiAgICBzZXRJbmZvKGVsZSwge1xuICAgICAgaW5kZXg6IGksXG4gICAgICBkZXB0aDogZFxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBjaGFuZ2VEZXB0aCA9IGZ1bmN0aW9uIGNoYW5nZURlcHRoKGVsZSwgbmV3RGVwdGgpIHtcbiAgICB2YXIgX2dldEluZm8gPSBnZXRJbmZvKGVsZSksXG4gICAgICAgIGRlcHRoID0gX2dldEluZm8uZGVwdGgsXG4gICAgICAgIGluZGV4ID0gX2dldEluZm8uaW5kZXg7XG5cbiAgICBkZXB0aHNbZGVwdGhdW2luZGV4XSA9IG51bGw7XG4gICAgYWRkVG9EZXB0aChlbGUsIG5ld0RlcHRoKTtcbiAgfTsgLy8gZmluZCB0aGUgZGVwdGhzIG9mIHRoZSBub2Rlc1xuXG5cbiAgZ3JhcGguYmZzKHtcbiAgICByb290czogcm9vdHMsXG4gICAgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQsXG4gICAgdmlzaXQ6IGZ1bmN0aW9uIHZpc2l0KG5vZGUsIGVkZ2UsIHBOb2RlLCBpLCBkZXB0aCkge1xuICAgICAgdmFyIGVsZSA9IG5vZGVbMF07XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIGFkZFRvRGVwdGgoZWxlLCBkZXB0aCk7XG4gICAgICBmb3VuZEJ5QmZzW2lkXSA9IHRydWU7XG4gICAgfVxuICB9KTsgLy8gY2hlY2sgZm9yIG5vZGVzIG5vdCBmb3VuZCBieSBiZnNcblxuICB2YXIgb3JwaGFuTm9kZXMgPSBbXTtcblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2Rlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9lbGUgPSBub2Rlc1tfaTJdO1xuXG4gICAgaWYgKGZvdW5kQnlCZnNbX2VsZS5pZCgpXSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ycGhhbk5vZGVzLnB1c2goX2VsZSk7XG4gICAgfVxuICB9IC8vIGFzc2lnbiB0aGUgbm9kZXMgYSBkZXB0aCBhbmQgaW5kZXhcblxuXG4gIHZhciBhc3NpZ25EZXB0aHNBdCA9IGZ1bmN0aW9uIGFzc2lnbkRlcHRoc0F0KGkpIHtcbiAgICB2YXIgZWxlcyA9IGRlcHRoc1tpXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIF9lbGUyID0gZWxlc1tqXTtcblxuICAgICAgaWYgKF9lbGUyID09IG51bGwpIHtcbiAgICAgICAgZWxlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgIGotLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNldEluZm8oX2VsZTIsIHtcbiAgICAgICAgZGVwdGg6IGksXG4gICAgICAgIGluZGV4OiBqXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFzc2lnbkRlcHRocyA9IGZ1bmN0aW9uIGFzc2lnbkRlcHRocygpIHtcbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBkZXB0aHMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgYXNzaWduRGVwdGhzQXQoX2kzKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFkanVzdE1heGltYWxseSA9IGZ1bmN0aW9uIGFkanVzdE1heGltYWxseShlbGUsIHNoaWZ0ZWQpIHtcbiAgICB2YXIgZUluZm8gPSBnZXRJbmZvKGVsZSk7XG4gICAgdmFyIGluY29tZXJzID0gZWxlLmluY29tZXJzKCkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVsLmlzTm9kZSgpICYmIGVsZXMuaGFzKGVsKTtcbiAgICB9KTtcbiAgICB2YXIgbWF4RGVwdGggPSAtMTtcbiAgICB2YXIgaWQgPSBlbGUuaWQoKTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaW5jb21lcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBpbmNtciA9IGluY29tZXJzW2tdO1xuICAgICAgdmFyIGlJbmZvID0gZ2V0SW5mbyhpbmNtcik7XG4gICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBpSW5mby5kZXB0aCk7XG4gICAgfVxuXG4gICAgaWYgKGVJbmZvLmRlcHRoIDw9IG1heERlcHRoKSB7XG4gICAgICBpZiAoc2hpZnRlZFtpZF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNoYW5nZURlcHRoKGVsZSwgbWF4RGVwdGggKyAxKTtcbiAgICAgIHNoaWZ0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTsgLy8gZm9yIHRoZSBkaXJlY3RlZCBjYXNlLCB0cnkgdG8gbWFrZSB0aGUgZWRnZXMgYWxsIGdvIGRvd24gKGkuZS4gZGVwdGggaSA9PiBkZXB0aCBpICsgMSlcblxuXG4gIGlmIChkaXJlY3RlZCAmJiBtYXhpbWFsKSB7XG4gICAgdmFyIFEgPSBbXTtcbiAgICB2YXIgc2hpZnRlZCA9IHt9O1xuXG4gICAgdmFyIGVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKG4pIHtcbiAgICAgIHJldHVybiBRLnB1c2gobik7XG4gICAgfTtcblxuICAgIHZhciBkZXF1ZXVlID0gZnVuY3Rpb24gZGVxdWV1ZSgpIHtcbiAgICAgIHJldHVybiBRLnNoaWZ0KCk7XG4gICAgfTtcblxuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBRLnB1c2gobik7XG4gICAgfSk7XG5cbiAgICB3aGlsZSAoUS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgX2VsZTMgPSBkZXF1ZXVlKCk7XG5cbiAgICAgIHZhciBkaWRTaGlmdCA9IGFkanVzdE1heGltYWxseShfZWxlMywgc2hpZnRlZCk7XG5cbiAgICAgIGlmIChkaWRTaGlmdCkge1xuICAgICAgICBfZWxlMy5vdXRnb2VycygpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICByZXR1cm4gZWwuaXNOb2RlKCkgJiYgZWxlcy5oYXMoZWwpO1xuICAgICAgICB9KS5mb3JFYWNoKGVucXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChkaWRTaGlmdCA9PT0gbnVsbCkge1xuICAgICAgICB3YXJuKCdEZXRlY3RlZCBkb3VibGUgbWF4aW1hbCBzaGlmdCBmb3Igbm9kZSBgJyArIF9lbGUzLmlkKCkgKyAnYC4gIEJhaWxpbmcgbWF4aW1hbCBhZGp1c3RtZW50IGR1ZSB0byBjeWNsZS4gIFVzZSBgb3B0aW9ucy5tYXhpbWFsOiB0cnVlYCBvbmx5IG9uIERBR3MuJyk7XG4gICAgICAgIGJyZWFrOyAvLyBleGl0IG9uIGZhaWx1cmVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3NpZ25EZXB0aHMoKTsgLy8gY2xlYXIgaG9sZXNcbiAgLy8gZmluZCBtaW4gZGlzdGFuY2Ugd2UgbmVlZCB0byBsZWF2ZSBiZXR3ZWVuIG5vZGVzXG5cbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcblxuICBpZiAob3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2Rlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgbiA9IG5vZGVzW19pNF07XG4gICAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIHcgPSBuYmIudztcbiAgICAgIHZhciBoID0gbmJiLmg7XG4gICAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgICB9XG4gIH0gLy8gZ2V0IHRoZSB3ZWlnaHRlZCBwZXJjZW50IGZvciBhbiBlbGVtZW50IGJhc2VkIG9uIGl0cyBjb25uZWN0aXZpdHkgdG8gb3RoZXIgbGV2ZWxzXG5cblxuICB2YXIgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50ID0ge307XG5cbiAgdmFyIGdldFdlaWdodGVkUGVyY2VudCA9IGZ1bmN0aW9uIGdldFdlaWdodGVkUGVyY2VudChlbGUpIHtcbiAgICBpZiAoY2FjaGVkV2VpZ2h0ZWRQZXJjZW50W2VsZS5pZCgpXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV07XG4gICAgfVxuXG4gICAgdmFyIGVsZURlcHRoID0gZ2V0SW5mbyhlbGUpLmRlcHRoO1xuICAgIHZhciBuZWlnaGJvcnMgPSBlbGUubmVpZ2hib3Job29kKCk7XG4gICAgdmFyIHBlcmNlbnQgPSAwO1xuICAgIHZhciBzYW1wbGVzID0gMDtcblxuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG5laWdoYm9ycy5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbX2k1XTtcblxuICAgICAgaWYgKG5laWdoYm9yLmlzRWRnZSgpIHx8IG5laWdoYm9yLmlzUGFyZW50KCkgfHwgIW5vZGVzLmhhcyhuZWlnaGJvcikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBiZiA9IGdldEluZm8obmVpZ2hib3IpO1xuICAgICAgdmFyIGluZGV4ID0gYmYuaW5kZXg7XG4gICAgICB2YXIgZGVwdGggPSBiZi5kZXB0aDsgLy8gdW5hc3NpZ25lZCBuZWlnaGJvdXJzIHNob3VsZG4ndCBhZmZlY3QgdGhlIG9yZGVyaW5nXG5cbiAgICAgIGlmIChpbmRleCA9PSBudWxsIHx8IGRlcHRoID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuRGVwdGggPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcblxuICAgICAgaWYgKGRlcHRoIDwgZWxlRGVwdGgpIHtcbiAgICAgICAgLy8gb25seSBnZXQgaW5mbHVlbmNlZCBieSBlbGVtZW50cyBhYm92ZVxuICAgICAgICBwZXJjZW50ICs9IGluZGV4IC8gbkRlcHRoO1xuICAgICAgICBzYW1wbGVzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2FtcGxlcyA9IE1hdGgubWF4KDEsIHNhbXBsZXMpO1xuICAgIHBlcmNlbnQgPSBwZXJjZW50IC8gc2FtcGxlcztcblxuICAgIGlmIChzYW1wbGVzID09PSAwKSB7XG4gICAgICAvLyBwdXQgbG9uZSBub2RlcyBhdCB0aGUgc3RhcnRcbiAgICAgIHBlcmNlbnQgPSAwO1xuICAgIH1cblxuICAgIGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV0gPSBwZXJjZW50O1xuICAgIHJldHVybiBwZXJjZW50O1xuICB9OyAvLyByZWFycmFuZ2UgdGhlIGluZGljZXMgaW4gZWFjaCBkZXB0aCBsZXZlbCBiYXNlZCBvbiBjb25uZWN0aXZpdHlcblxuXG4gIHZhciBzb3J0Rm4gPSBmdW5jdGlvbiBzb3J0Rm4oYSwgYikge1xuICAgIHZhciBhcGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KGEpO1xuICAgIHZhciBicGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KGIpO1xuICAgIHZhciBkaWZmID0gYXBjdCAtIGJwY3Q7XG5cbiAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFzY2VuZGluZyhhLmlkKCksIGIuaWQoKSk7IC8vIG1ha2Ugc3VyZSBzb3J0IGRvZXNuJ3QgaGF2ZSBkb24ndC1jYXJlIGNvbXBhcmlzb25zXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cbiAgfTsgLy8gc29ydCBlYWNoIGxldmVsIHRvIG1ha2UgY29ubmVjdGVkIG5vZGVzIGNsb3NlclxuXG5cbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZGVwdGhzLmxlbmd0aDsgX2k2KyspIHtcbiAgICBkZXB0aHNbX2k2XS5zb3J0KHNvcnRGbik7XG5cbiAgICBhc3NpZ25EZXB0aHNBdChfaTYpO1xuICB9IC8vIGFzc2lnbiBvcnBoYW4gbm9kZXMgdG8gYSBuZXcgdG9wLWxldmVsIGRlcHRoXG5cblxuICB2YXIgb3JwaGFuRGVwdGggPSBbXTtcblxuICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBvcnBoYW5Ob2Rlcy5sZW5ndGg7IF9pNysrKSB7XG4gICAgb3JwaGFuRGVwdGgucHVzaChvcnBoYW5Ob2Rlc1tfaTddKTtcbiAgfVxuXG4gIGRlcHRocy51bnNoaWZ0KG9ycGhhbkRlcHRoKTtcbiAgYXNzaWduRGVwdGhzKCk7XG4gIHZhciBiaWdnZXN0RGVwdGhTaXplID0gMDtcblxuICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBkZXB0aHMubGVuZ3RoOyBfaTgrKykge1xuICAgIGJpZ2dlc3REZXB0aFNpemUgPSBNYXRoLm1heChkZXB0aHNbX2k4XS5sZW5ndGgsIGJpZ2dlc3REZXB0aFNpemUpO1xuICB9XG5cbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLngxICsgYmIuaCAvIDJcbiAgfTtcbiAgdmFyIG1heERlcHRoU2l6ZSA9IGRlcHRocy5yZWR1Y2UoZnVuY3Rpb24gKG1heCwgZWxlcykge1xuICAgIHJldHVybiBNYXRoLm1heChtYXgsIGVsZXMubGVuZ3RoKTtcbiAgfSwgMCk7XG5cbiAgdmFyIGdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24oZWxlKSB7XG4gICAgdmFyIF9nZXRJbmZvMiA9IGdldEluZm8oZWxlKSxcbiAgICAgICAgZGVwdGggPSBfZ2V0SW5mbzIuZGVwdGgsXG4gICAgICAgIGluZGV4ID0gX2dldEluZm8yLmluZGV4O1xuXG4gICAgdmFyIGRlcHRoU2l6ZSA9IGRlcHRoc1tkZXB0aF0ubGVuZ3RoO1xuICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLm1heChiYi53IC8gKChvcHRpb25zLmdyaWQgPyBtYXhEZXB0aFNpemUgOiBkZXB0aFNpemUpICsgMSksIG1pbkRpc3RhbmNlKTtcbiAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5tYXgoYmIuaCAvIChkZXB0aHMubGVuZ3RoICsgMSksIG1pbkRpc3RhbmNlKTtcbiAgICB2YXIgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1pbihiYi53IC8gMiAvIGRlcHRocy5sZW5ndGgsIGJiLmggLyAyIC8gZGVwdGhzLmxlbmd0aCk7XG4gICAgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1heChyYWRpdXNTdGVwU2l6ZSwgbWluRGlzdGFuY2UpO1xuXG4gICAgaWYgKCFvcHRpb25zLmNpcmNsZSkge1xuICAgICAgdmFyIGVwb3MgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgKGluZGV4ICsgMSAtIChkZXB0aFNpemUgKyAxKSAvIDIpICogZGlzdGFuY2VYLFxuICAgICAgICB5OiAoZGVwdGggKyAxKSAqIGRpc3RhbmNlWVxuICAgICAgfTtcbiAgICAgIHJldHVybiBlcG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmFkaXVzID0gcmFkaXVzU3RlcFNpemUgKiBkZXB0aCArIHJhZGl1c1N0ZXBTaXplIC0gKGRlcHRocy5sZW5ndGggPiAwICYmIGRlcHRoc1swXS5sZW5ndGggPD0gMyA/IHJhZGl1c1N0ZXBTaXplIC8gMiA6IDApO1xuICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBkZXB0aHNbZGVwdGhdLmxlbmd0aCAqIGluZGV4O1xuXG4gICAgICBpZiAoZGVwdGggPT09IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByYWRpdXMgPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBjZW50ZXIueCArIHJhZGl1cyAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgeTogY2VudGVyLnkgKyByYWRpdXMgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3NpdGlvbik7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGRlZmF1bHRzJGEgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGFuZCByYWRpdXMgaWYgbm90IGVub3VnaCBzcGFjZVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIHJhZGl1czogdW5kZWZpbmVkLFxuICAvLyB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgc3RhcnRBbmdsZTogMyAvIDIgKiBNYXRoLlBJLFxuICAvLyB3aGVyZSBub2RlcyBzdGFydCBpbiByYWRpYW5zXG4gIHN3ZWVwOiB1bmRlZmluZWQsXG4gIC8vIGhvdyBtYW55IHJhZGlhbnMgc2hvdWxkIGJlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IG5vZGUgKGRlZmF1bHRzIHRvIGZ1bGwgY2lyY2xlKVxuICBjbG9ja3dpc2U6IHRydWUsXG4gIC8vIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgZ28gY2xvY2t3aXNlICh0cnVlKSBvciBjb3VudGVyY2xvY2t3aXNlL2FudGljbG9ja3dpc2UgKGZhbHNlKVxuICBzb3J0OiB1bmRlZmluZWQsXG4gIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0cyBcblxufTtcblxuZnVuY3Rpb24gQ2lyY2xlTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyRhLCBvcHRpb25zKTtcbn1cblxuQ2lyY2xlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcblxuICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgbm9kZXMgPSBub2Rlcy5zb3J0KG9wdGlvbnMuc29ydCk7XG4gIH1cblxuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgdzogY3kud2lkdGgoKSxcbiAgICBoOiBjeS5oZWlnaHQoKVxuICB9KTtcbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgfTtcbiAgdmFyIHN3ZWVwID0gb3B0aW9ucy5zd2VlcCA9PT0gdW5kZWZpbmVkID8gMiAqIE1hdGguUEkgLSAyICogTWF0aC5QSSAvIG5vZGVzLmxlbmd0aCA6IG9wdGlvbnMuc3dlZXA7XG4gIHZhciBkVGhldGEgPSBzd2VlcCAvIE1hdGgubWF4KDEsIG5vZGVzLmxlbmd0aCAtIDEpO1xuICB2YXIgcjtcbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIHZhciB3ID0gbmJiLnc7XG4gICAgdmFyIGggPSBuYmIuaDtcbiAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgfVxuXG4gIGlmIChudW1iZXIob3B0aW9ucy5yYWRpdXMpKSB7XG4gICAgciA9IG9wdGlvbnMucmFkaXVzO1xuICB9IGVsc2UgaWYgKG5vZGVzLmxlbmd0aCA8PSAxKSB7XG4gICAgciA9IDA7XG4gIH0gZWxzZSB7XG4gICAgciA9IE1hdGgubWluKGJiLmgsIGJiLncpIC8gMiAtIG1pbkRpc3RhbmNlO1xuICB9IC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG5cblxuICBpZiAobm9kZXMubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgIC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICBtaW5EaXN0YW5jZSAqPSAxLjc1OyAvLyBqdXN0IHRvIGhhdmUgc29tZSBuaWNlIHNwYWNpbmdcblxuICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgIHZhciBkc2luID0gTWF0aC5zaW4oZFRoZXRhKSAtIE1hdGguc2luKDApO1xuICAgIHZhciByTWluID0gTWF0aC5zcXJ0KG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2UgLyAoZGNvcyAqIGRjb3MgKyBkc2luICogZHNpbikpOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG5cbiAgICByID0gTWF0aC5tYXgock1pbiwgcik7XG4gIH1cblxuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24gZ2V0UG9zKGVsZSwgaSkge1xuICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIGkgKiBkVGhldGEgKiAoY2xvY2t3aXNlID8gMSA6IC0xKTtcbiAgICB2YXIgcnggPSByICogTWF0aC5jb3ModGhldGEpO1xuICAgIHZhciByeSA9IHIgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgdmFyIHBvcyA9IHtcbiAgICAgIHg6IGNlbnRlci54ICsgcngsXG4gICAgICB5OiBjZW50ZXIueSArIHJ5XG4gICAgfTtcbiAgICByZXR1cm4gcG9zO1xuICB9O1xuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyRiID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsXG4gIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICBzdGFydEFuZ2xlOiAzIC8gMiAqIE1hdGguUEksXG4gIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgc3dlZXA6IHVuZGVmaW5lZCxcbiAgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gIGNsb2Nrd2lzZTogdHJ1ZSxcbiAgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gIGVxdWlkaXN0YW50OiBmYWxzZSxcbiAgLy8gd2hldGhlciBsZXZlbHMgaGF2ZSBhbiBlcXVhbCByYWRpYWwgZGlzdGFuY2UgYmV0d2VuIHRoZW0sIG1heSBjYXVzZSBib3VuZGluZyBib3ggb3ZlcmZsb3dcbiAgbWluTm9kZVNwYWNpbmc6IDEwLFxuICAvLyBtaW4gc3BhY2luZyBiZXR3ZWVuIG91dHNpZGUgb2Ygbm9kZXMgKHVzZWQgZm9yIHJhZGl1cyBhZGp1c3RtZW50KVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gIGhlaWdodDogdW5kZWZpbmVkLFxuICAvLyBoZWlnaHQgb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgaGVpZ2h0KVxuICB3aWR0aDogdW5kZWZpbmVkLFxuICAvLyB3aWR0aCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciB3aWR0aClcbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBjb25jZW50cmljOiBmdW5jdGlvbiBjb25jZW50cmljKG5vZGUpIHtcbiAgICAvLyByZXR1cm5zIG51bWVyaWMgdmFsdWUgZm9yIGVhY2ggbm9kZSwgcGxhY2luZyBoaWdoZXIgbm9kZXMgaW4gbGV2ZWxzIHRvd2FyZHMgdGhlIGNlbnRyZVxuICAgIHJldHVybiBub2RlLmRlZ3JlZSgpO1xuICB9LFxuICBsZXZlbFdpZHRoOiBmdW5jdGlvbiBsZXZlbFdpZHRoKG5vZGVzKSB7XG4gICAgLy8gdGhlIGxldGlhdGlvbiBvZiBjb25jZW50cmljIHZhbHVlcyBpbiBlYWNoIGxldmVsXG4gICAgcmV0dXJuIG5vZGVzLm1heERlZ3JlZSgpIC8gNDtcbiAgfSxcbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG5cbn07XG5cbmZ1bmN0aW9uIENvbmNlbnRyaWNMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJGIsIG9wdGlvbnMpO1xufVxuXG5Db25jZW50cmljTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG4gIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICB5OiBiYi55MSArIGJiLmggLyAyXG4gIH07XG4gIHZhciBub2RlVmFsdWVzID0gW107IC8vIHsgbm9kZSwgdmFsdWUgfVxuXG4gIHZhciBtYXhOb2RlU2l6ZSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIHZhbHVlID0gdm9pZCAwOyAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgdmFsdWVcblxuICAgIHZhbHVlID0gb3B0aW9ucy5jb25jZW50cmljKG5vZGUpO1xuICAgIG5vZGVWYWx1ZXMucHVzaCh7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBub2RlOiBub2RlXG4gICAgfSk7IC8vIGZvciBzdHlsZSBtYXBwaW5nXG5cbiAgICBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29uY2VudHJpYyA9IHZhbHVlO1xuICB9IC8vIGluIGNhc2Ugd2UgdXNlZCB0aGUgYGNvbmNlbnRyaWNgIGluIHN0eWxlXG5cblxuICBub2Rlcy51cGRhdGVTdHlsZSgpOyAvLyBjYWxjdWxhdGUgbWF4IHNpemUgbm93IGJhc2VkIG9uIHBvdGVudGlhbGx5IHVwZGF0ZWQgbWFwcGVyc1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG5cbiAgICB2YXIgbmJiID0gX25vZGUubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcblxuICAgIG1heE5vZGVTaXplID0gTWF0aC5tYXgobWF4Tm9kZVNpemUsIG5iYi53LCBuYmIuaCk7XG4gIH0gLy8gc29ydCBub2RlIHZhbHVlcyBpbiBkZXNjcmVhc2luZyBvcmRlclxuXG5cbiAgbm9kZVZhbHVlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICB9KTtcbiAgdmFyIGxldmVsV2lkdGggPSBvcHRpb25zLmxldmVsV2lkdGgobm9kZXMpOyAvLyBwdXQgdGhlIHZhbHVlcyBpbnRvIGxldmVsc1xuXG4gIHZhciBsZXZlbHMgPSBbW11dO1xuICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzWzBdO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVWYWx1ZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciB2YWwgPSBub2RlVmFsdWVzW19pMl07XG5cbiAgICBpZiAoY3VycmVudExldmVsLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoY3VycmVudExldmVsWzBdLnZhbHVlIC0gdmFsLnZhbHVlKTtcblxuICAgICAgaWYgKGRpZmYgPj0gbGV2ZWxXaWR0aCkge1xuICAgICAgICBjdXJyZW50TGV2ZWwgPSBbXTtcbiAgICAgICAgbGV2ZWxzLnB1c2goY3VycmVudExldmVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50TGV2ZWwucHVzaCh2YWwpO1xuICB9IC8vIGNyZWF0ZSBwb3NpdGlvbnMgZnJvbSBsZXZlbHNcblxuXG4gIHZhciBtaW5EaXN0ID0gbWF4Tm9kZVNpemUgKyBvcHRpb25zLm1pbk5vZGVTcGFjaW5nOyAvLyBtaW4gZGlzdCBiZXR3ZWVuIG5vZGVzXG5cbiAgaWYgKCFvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgIC8vIHRoZW4gc3RyaWN0bHkgY29uc3RyYWluIHRvIGJiXG4gICAgdmFyIGZpcnN0THZsSGFzTXVsdGkgPSBsZXZlbHMubGVuZ3RoID4gMCAmJiBsZXZlbHNbMF0ubGVuZ3RoID4gMTtcbiAgICB2YXIgbWF4UiA9IE1hdGgubWluKGJiLncsIGJiLmgpIC8gMiAtIG1pbkRpc3Q7XG4gICAgdmFyIHJTdGVwID0gbWF4UiAvIChsZXZlbHMubGVuZ3RoICsgZmlyc3RMdmxIYXNNdWx0aSA/IDEgOiAwKTtcbiAgICBtaW5EaXN0ID0gTWF0aC5taW4obWluRGlzdCwgclN0ZXApO1xuICB9IC8vIGZpbmQgdGhlIG1ldHJpY3MgZm9yIGVhY2ggbGV2ZWxcblxuXG4gIHZhciByID0gMDtcblxuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBsZXZlbHMubGVuZ3RoOyBfaTMrKykge1xuICAgIHZhciBsZXZlbCA9IGxldmVsc1tfaTNdO1xuICAgIHZhciBzd2VlcCA9IG9wdGlvbnMuc3dlZXAgPT09IHVuZGVmaW5lZCA/IDIgKiBNYXRoLlBJIC0gMiAqIE1hdGguUEkgLyBsZXZlbC5sZW5ndGggOiBvcHRpb25zLnN3ZWVwO1xuICAgIHZhciBkVGhldGEgPSBsZXZlbC5kVGhldGEgPSBzd2VlcCAvIE1hdGgubWF4KDEsIGxldmVsLmxlbmd0aCAtIDEpOyAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuXG4gICAgaWYgKGxldmVsLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgIC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgICB2YXIgck1pbiA9IE1hdGguc3FydChtaW5EaXN0ICogbWluRGlzdCAvIChkY29zICogZGNvcyArIGRzaW4gKiBkc2luKSk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcblxuICAgICAgciA9IE1hdGgubWF4KHJNaW4sIHIpO1xuICAgIH1cblxuICAgIGxldmVsLnIgPSByO1xuICAgIHIgKz0gbWluRGlzdDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmVxdWlkaXN0YW50KSB7XG4gICAgdmFyIHJEZWx0YU1heCA9IDA7XG4gICAgdmFyIF9yID0gMDtcblxuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGxldmVscy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgX2xldmVsID0gbGV2ZWxzW19pNF07XG4gICAgICB2YXIgckRlbHRhID0gX2xldmVsLnIgLSBfcjtcbiAgICAgIHJEZWx0YU1heCA9IE1hdGgubWF4KHJEZWx0YU1heCwgckRlbHRhKTtcbiAgICB9XG5cbiAgICBfciA9IDA7XG5cbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBsZXZlbHMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIF9sZXZlbDIgPSBsZXZlbHNbX2k1XTtcblxuICAgICAgaWYgKF9pNSA9PT0gMCkge1xuICAgICAgICBfciA9IF9sZXZlbDIucjtcbiAgICAgIH1cblxuICAgICAgX2xldmVsMi5yID0gX3I7XG4gICAgICBfciArPSByRGVsdGFNYXg7XG4gICAgfVxuICB9IC8vIGNhbGN1bGF0ZSB0aGUgbm9kZSBwb3NpdGlvbnNcblxuXG4gIHZhciBwb3MgPSB7fTsgLy8gaWQgPT4gcG9zaXRpb25cblxuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBsZXZlbHMubGVuZ3RoOyBfaTYrKykge1xuICAgIHZhciBfbGV2ZWwzID0gbGV2ZWxzW19pNl07XG4gICAgdmFyIF9kVGhldGEgPSBfbGV2ZWwzLmRUaGV0YTtcbiAgICB2YXIgX3IyID0gX2xldmVsMy5yO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBfbGV2ZWwzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgX3ZhbCA9IF9sZXZlbDNbal07XG4gICAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGUgKyAoY2xvY2t3aXNlID8gMSA6IC0xKSAqIF9kVGhldGEgKiBqO1xuICAgICAgdmFyIHAgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgX3IyICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICB5OiBjZW50ZXIueSArIF9yMiAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgfTtcbiAgICAgIHBvc1tfdmFsLm5vZGUuaWQoKV0gPSBwO1xuICAgIH1cbiAgfSAvLyBwb3NpdGlvbiB0aGUgbm9kZXNcblxuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgcmV0dXJuIHBvc1tpZF07XG4gIH0pO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8qXG5UaGUgQ29TRSBsYXlvdXQgd2FzIHdyaXR0ZW4gYnkgR2VyYXJkbyBIdWNrLlxuaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2dlcmFyZG9odWNrL1xuXG5CYXNlZCBvbiB0aGUgZm9sbG93aW5nIGFydGljbGU6XG5odHRwOi8vZGwuYWNtLm9yZy9jaXRhdGlvbi5jZm0/aWQ9MTQ5ODA0N1xuXG5Nb2RpZmljYXRpb25zIHRyYWNrZWQgb24gR2l0aHViLlxuKi9cbnZhciBERUJVRztcbi8qKlxuICogQGJyaWVmIDogIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAqL1xuXG52YXIgZGVmYXVsdHMkYyA9IHtcbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRyZWFkeWBcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0c3RvcGBcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9LFxuICAvLyBXaGV0aGVyIHRvIGFuaW1hdGUgd2hpbGUgcnVubmluZyB0aGUgbGF5b3V0XG4gIC8vIHRydWUgOiBBbmltYXRlIGNvbnRpbnVvdXNseSBhcyB0aGUgbGF5b3V0IGlzIHJ1bm5pbmdcbiAgLy8gZmFsc2UgOiBKdXN0IHNob3cgdGhlIGVuZCByZXN1bHRcbiAgLy8gJ2VuZCcgOiBBbmltYXRlIHdpdGggdGhlIGVuZCByZXN1bHQsIGZyb20gdGhlIGluaXRpYWwgcG9zaXRpb25zIHRvIHRoZSBlbmQgcG9zaXRpb25zXG4gIGFuaW1hdGU6IHRydWUsXG4gIC8vIEVhc2luZyBvZiB0aGUgYW5pbWF0aW9uIGZvciBhbmltYXRlOidlbmQnXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBmb3IgYW5pbWF0ZTonZW5kJ1xuICBhbmltYXRpb25EdXJhdGlvbjogdW5kZWZpbmVkLFxuICAvLyBBIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZFxuICAvLyBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWRcbiAgLy8gTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIFRoZSBsYXlvdXQgYW5pbWF0ZXMgb25seSBhZnRlciB0aGlzIG1hbnkgbWlsbGlzZWNvbmRzIGZvciBhbmltYXRlOnRydWVcbiAgLy8gKHByZXZlbnRzIGZsYXNoaW5nIG9uIGZhc3QgcnVucylcbiAgYW5pbWF0aW9uVGhyZXNob2xkOiAyNTAsXG4gIC8vIE51bWJlciBvZiBpdGVyYXRpb25zIGJldHdlZW4gY29uc2VjdXRpdmUgc2NyZWVuIHBvc2l0aW9ucyB1cGRhdGVcbiAgcmVmcmVzaDogMjAsXG4gIC8vIFdoZXRoZXIgdG8gZml0IHRoZSBuZXR3b3JrIHZpZXcgYWZ0ZXIgd2hlbiBkb25lXG4gIGZpdDogdHJ1ZSxcbiAgLy8gUGFkZGluZyBvbiBmaXRcbiAgcGFkZGluZzogMzAsXG4gIC8vIENvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBSYW5kb21pemUgdGhlIGluaXRpYWwgcG9zaXRpb25zIG9mIHRoZSBub2RlcyAodHJ1ZSkgb3IgdXNlIGV4aXN0aW5nIHBvc2l0aW9ucyAoZmFsc2UpXG4gIHJhbmRvbWl6ZTogZmFsc2UsXG4gIC8vIEV4dHJhIHNwYWNpbmcgYmV0d2VlbiBjb21wb25lbnRzIGluIG5vbi1jb21wb3VuZCBncmFwaHNcbiAgY29tcG9uZW50U3BhY2luZzogNDAsXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZVJlcHVsc2lvbjogZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIDIwNDg7XG4gIH0sXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChvdmVybGFwcGluZykgbXVsdGlwbGllclxuICBub2RlT3ZlcmxhcDogNCxcbiAgLy8gSWRlYWwgZWRnZSAobm9uIG5lc3RlZCkgbGVuZ3RoXG4gIGlkZWFsRWRnZUxlbmd0aDogZnVuY3Rpb24gaWRlYWxFZGdlTGVuZ3RoKGVkZ2UpIHtcbiAgICByZXR1cm4gMzI7XG4gIH0sXG4gIC8vIERpdmlzb3IgdG8gY29tcHV0ZSBlZGdlIGZvcmNlc1xuICBlZGdlRWxhc3RpY2l0eTogZnVuY3Rpb24gZWRnZUVsYXN0aWNpdHkoZWRnZSkge1xuICAgIHJldHVybiAzMjtcbiAgfSxcbiAgLy8gTmVzdGluZyBmYWN0b3IgKG11bHRpcGxpZXIpIHRvIGNvbXB1dGUgaWRlYWwgZWRnZSBsZW5ndGggZm9yIG5lc3RlZCBlZGdlc1xuICBuZXN0aW5nRmFjdG9yOiAxLjIsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KVxuICBncmF2aXR5OiAxLFxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgbnVtSXRlcjogMTAwMCxcbiAgLy8gSW5pdGlhbCB0ZW1wZXJhdHVyZSAobWF4aW11bSBub2RlIGRpc3BsYWNlbWVudClcbiAgaW5pdGlhbFRlbXA6IDEwMDAsXG4gIC8vIENvb2xpbmcgZmFjdG9yIChob3cgdGhlIHRlbXBlcmF0dXJlIGlzIHJlZHVjZWQgYmV0d2VlbiBjb25zZWN1dGl2ZSBpdGVyYXRpb25zXG4gIGNvb2xpbmdGYWN0b3I6IDAuOTksXG4gIC8vIExvd2VyIHRlbXBlcmF0dXJlIHRocmVzaG9sZCAoYmVsb3cgdGhpcyBwb2ludCB0aGUgbGF5b3V0IHdpbGwgZW5kKVxuICBtaW5UZW1wOiAxLjBcbn07XG4vKipcbiAqIEBicmllZiAgICAgICA6IGNvbnN0cnVjdG9yXG4gKiBAYXJnIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIENvc2VMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJGMsIG9wdGlvbnMpO1xuICB0aGlzLm9wdGlvbnMubGF5b3V0ID0gdGhpcztcbn1cbi8qKlxuICogQGJyaWVmIDogcnVucyB0aGUgbGF5b3V0XG4gKi9cblxuXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgbGF5b3V0ID0gdGhpcztcbiAgbGF5b3V0LnN0b3BwZWQgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucy5hbmltYXRlID09PSB0cnVlIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICBsYXlvdXQuZW1pdCh7XG4gICAgICB0eXBlOiAnbGF5b3V0c3RhcnQnLFxuICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICB9KTtcbiAgfSAvLyBTZXQgREVCVUcgLSBHbG9iYWwgdmFyaWFibGVcblxuXG4gIGlmICh0cnVlID09PSBvcHRpb25zLmRlYnVnKSB7XG4gICAgREVCVUcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIERFQlVHID0gZmFsc2U7XG4gIH0gLy8gSW5pdGlhbGl6ZSBsYXlvdXQgaW5mb1xuXG5cbiAgdmFyIGxheW91dEluZm8gPSBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpOyAvLyBTaG93IExheW91dEluZm8gY29udGVudHMgaWYgZGVidWdnaW5nXG5cbiAgaWYgKERFQlVHKSB7XG4gICAgcHJpbnRMYXlvdXRJbmZvKGxheW91dEluZm8pO1xuICB9IC8vIElmIHJlcXVpcmVkLCByYW5kb21pemUgbm9kZSBwb3NpdGlvbnNcblxuXG4gIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgIHJhbmRvbWl6ZVBvc2l0aW9ucyhsYXlvdXRJbmZvKTtcbiAgfVxuXG4gIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuXG4gIHZhciByZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTsgLy8gRml0IHRoZSBncmFwaCBpZiBuZWNlc3NhcnlcblxuICAgIGlmICh0cnVlID09PSBvcHRpb25zLmZpdCkge1xuICAgICAgY3kuZml0KG9wdGlvbnMucGFkZGluZyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBtYWluTG9vcCA9IGZ1bmN0aW9uIG1haW5Mb29wKGkpIHtcbiAgICBpZiAobGF5b3V0LnN0b3BwZWQgfHwgaSA+PSBvcHRpb25zLm51bUl0ZXIpIHtcbiAgICAgIC8vIGxvZ0RlYnVnKFwiTGF5b3V0IG1hbnVhbGx5IHN0b3BwZWQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIERvIG9uZSBzdGVwIGluIHRoZSBwaGlzaWNhbCBzaW11bGF0aW9uXG5cblxuICAgIHN0ZXAkMShsYXlvdXRJbmZvLCBvcHRpb25zKTsgLy8gVXBkYXRlIHRlbXBlcmF0dXJlXG5cbiAgICBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlID0gbGF5b3V0SW5mby50ZW1wZXJhdHVyZSAqIG9wdGlvbnMuY29vbGluZ0ZhY3RvcjsgLy8gbG9nRGVidWcoXCJOZXcgdGVtcGVyYXR1cmU6IFwiICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG5cbiAgICBpZiAobGF5b3V0SW5mby50ZW1wZXJhdHVyZSA8IG9wdGlvbnMubWluVGVtcCkge1xuICAgICAgLy8gbG9nRGVidWcoXCJUZW1wZXJhdHVyZSBkcm9wIGJlbG93IG1pbmltdW0gdGhyZXNob2xkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKCkge1xuICAgIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkge1xuICAgICAgcmVmcmVzaCgpOyAvLyBMYXlvdXQgaGFzIGZpbmlzaGVkXG5cbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gICAgICB2YXIgZ2V0U2NhbGVkUG9zID0gZ2V0U2NhbGVJbkJvdW5kc0ZuKGxheW91dEluZm8sIG9wdGlvbnMsIG5vZGVzKTtcbiAgICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGdldFNjYWxlZFBvcyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpID0gMDtcbiAgdmFyIGxvb3BSZXQgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUpIHtcbiAgICB2YXIgZnJhbWUgPSBmdW5jdGlvbiBmcmFtZSgpIHtcbiAgICAgIHZhciBmID0gMDtcblxuICAgICAgd2hpbGUgKGxvb3BSZXQgJiYgZiA8IG9wdGlvbnMucmVmcmVzaCkge1xuICAgICAgICBsb29wUmV0ID0gbWFpbkxvb3AoaSk7XG4gICAgICAgIGkrKztcbiAgICAgICAgZisrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxvb3BSZXQpIHtcbiAgICAgICAgLy8gaXQncyBkb25lXG4gICAgICAgIHNlcGFyYXRlQ29tcG9uZW50cyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlTm93KCk7XG5cbiAgICAgICAgaWYgKG5vdyAtIHN0YXJ0VGltZSA+PSBvcHRpb25zLmFuaW1hdGlvblRocmVzaG9sZCkge1xuICAgICAgICAgIHJlZnJlc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZyYW1lKCk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGxvb3BSZXQpIHtcbiAgICAgIGxvb3BSZXQgPSBtYWluTG9vcChpKTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICBzZXBhcmF0ZUNvbXBvbmVudHMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuLyoqXG4gKiBAYnJpZWYgOiBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbiAqL1xuXG5cbkNvc2VMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc3RvcHBlZCA9IHRydWU7XG5cbiAgaWYgKHRoaXMudGhyZWFkKSB7XG4gICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICB9XG5cbiAgdGhpcy5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuQ29zZUxheW91dC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMudGhyZWFkKSB7XG4gICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuLyoqXG4gKiBAYnJpZWYgICAgIDogQ3JlYXRlcyBhbiBvYmplY3Qgd2hpY2ggaXMgY29udGFpbnMgYWxsIHRoZSBkYXRhXG4gKiAgICAgICAgICAgICAgdXNlZCBpbiB0aGUgbGF5b3V0IHByb2Nlc3NcbiAqIEBhcmcgY3kgICAgOiBjeXRvc2NhcGUuanMgb2JqZWN0XG4gKiBAcmV0dXJuICAgIDogbGF5b3V0SW5mbyBvYmplY3QgaW5pdGlhbGl6ZWRcbiAqL1xuXG5cbnZhciBjcmVhdGVMYXlvdXRJbmZvID0gZnVuY3Rpb24gY3JlYXRlTGF5b3V0SW5mbyhjeSwgbGF5b3V0LCBvcHRpb25zKSB7XG4gIC8vIFNob3J0Y3V0XG4gIHZhciBlZGdlcyA9IG9wdGlvbnMuZWxlcy5lZGdlcygpO1xuICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgdmFyIGxheW91dEluZm8gPSB7XG4gICAgaXNDb21wb3VuZDogY3kuaGFzQ29tcG91bmROb2RlcygpLFxuICAgIGxheW91dE5vZGVzOiBbXSxcbiAgICBpZFRvSW5kZXg6IHt9LFxuICAgIG5vZGVTaXplOiBub2Rlcy5zaXplKCksXG4gICAgZ3JhcGhTZXQ6IFtdLFxuICAgIGluZGV4VG9HcmFwaDogW10sXG4gICAgbGF5b3V0RWRnZXM6IFtdLFxuICAgIGVkZ2VTaXplOiBlZGdlcy5zaXplKCksXG4gICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMuaW5pdGlhbFRlbXAsXG4gICAgY2xpZW50V2lkdGg6IGN5LndpZHRoKCksXG4gICAgY2xpZW50SGVpZ2h0OiBjeS53aWR0aCgpLFxuICAgIGJvdW5kaW5nQm94OiBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgdzogY3kud2lkdGgoKSxcbiAgICAgIGg6IGN5LmhlaWdodCgpXG4gICAgfSlcbiAgfTtcbiAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmVsZXMuY29tcG9uZW50cygpO1xuICB2YXIgaWQyY21wdElkID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRbal07XG4gICAgICBpZDJjbXB0SWRbbm9kZS5pZCgpXSA9IGk7XG4gICAgfVxuICB9IC8vIEl0ZXJhdGUgb3ZlciBhbGwgbm9kZXMsIGNyZWF0aW5nIGxheW91dCBub2Rlc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgIHZhciBuYmIgPSBuLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgdmFyIHRlbXBOb2RlID0ge307XG4gICAgdGVtcE5vZGUuaXNMb2NrZWQgPSBuLmxvY2tlZCgpO1xuICAgIHRlbXBOb2RlLmlkID0gbi5kYXRhKCdpZCcpO1xuICAgIHRlbXBOb2RlLnBhcmVudElkID0gbi5kYXRhKCdwYXJlbnQnKTtcbiAgICB0ZW1wTm9kZS5jbXB0SWQgPSBpZDJjbXB0SWRbbi5pZCgpXTtcbiAgICB0ZW1wTm9kZS5jaGlsZHJlbiA9IFtdO1xuICAgIHRlbXBOb2RlLnBvc2l0aW9uWCA9IG4ucG9zaXRpb24oJ3gnKTtcbiAgICB0ZW1wTm9kZS5wb3NpdGlvblkgPSBuLnBvc2l0aW9uKCd5Jyk7XG4gICAgdGVtcE5vZGUub2Zmc2V0WCA9IDA7XG4gICAgdGVtcE5vZGUub2Zmc2V0WSA9IDA7XG4gICAgdGVtcE5vZGUuaGVpZ2h0ID0gbmJiLnc7XG4gICAgdGVtcE5vZGUud2lkdGggPSBuYmIuaDtcbiAgICB0ZW1wTm9kZS5tYXhYID0gdGVtcE5vZGUucG9zaXRpb25YICsgdGVtcE5vZGUud2lkdGggLyAyO1xuICAgIHRlbXBOb2RlLm1pblggPSB0ZW1wTm9kZS5wb3NpdGlvblggLSB0ZW1wTm9kZS53aWR0aCAvIDI7XG4gICAgdGVtcE5vZGUubWF4WSA9IHRlbXBOb2RlLnBvc2l0aW9uWSArIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgdGVtcE5vZGUubWluWSA9IHRlbXBOb2RlLnBvc2l0aW9uWSAtIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgdGVtcE5vZGUucGFkTGVmdCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICB0ZW1wTm9kZS5wYWRSaWdodCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICB0ZW1wTm9kZS5wYWRUb3AgPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7XG4gICAgdGVtcE5vZGUucGFkQm90dG9tID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpOyAvLyBmb3JjZXNcblxuICAgIHRlbXBOb2RlLm5vZGVSZXB1bHNpb24gPSBmbihvcHRpb25zLm5vZGVSZXB1bHNpb24pID8gb3B0aW9ucy5ub2RlUmVwdWxzaW9uKG4pIDogb3B0aW9ucy5ub2RlUmVwdWxzaW9uOyAvLyBBZGQgbmV3IG5vZGVcblxuICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXMucHVzaCh0ZW1wTm9kZSk7IC8vIEFkZCBlbnRyeSB0byBpZC1pbmRleCBtYXBcblxuICAgIGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLmlkXSA9IGk7XG4gIH0gLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuXG5cbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBzdGFydCA9IDA7IC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG5cbiAgdmFyIGVuZCA9IC0xOyAvLyBQb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcblxuICB2YXIgdGVtcEdyYXBoID0gW107IC8vIFNlY29uZCBwYXNzIHRvIGFkZCBjaGlsZCBpbmZvcm1hdGlvbiBhbmRcbiAgLy8gaW5pdGlhbGl6ZSBxdWV1ZSBmb3IgaGllcmFyY2hpY2FsIHRyYXZlcnNhbFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgIHZhciBwX2lkID0gbi5wYXJlbnRJZDsgLy8gQ2hlY2sgaWYgbm9kZSBuIGhhcyBhIHBhcmVudCBub2RlXG5cbiAgICBpZiAobnVsbCAhPSBwX2lkKSB7XG4gICAgICAvLyBBZGQgbm9kZSBJZCB0byBwYXJlbnQncyBsaXN0IG9mIGNoaWxkcmVuXG4gICAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BfaWRdXS5jaGlsZHJlbi5wdXNoKG4uaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBhIG5vZGUgZG9lc24ndCBoYXZlIGEgcGFyZW50LCB0aGVuIGl0J3MgaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICAgIHF1ZXVlWysrZW5kXSA9IG4uaWQ7XG4gICAgICB0ZW1wR3JhcGgucHVzaChuLmlkKTtcbiAgICB9XG4gIH0gLy8gQWRkIHJvb3QgZ3JhcGggdG8gZ3JhcGhTZXRcblxuXG4gIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaCh0ZW1wR3JhcGgpOyAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLFxuXG4gIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgdmFyIG5vZGVfaWQgPSBxdWV1ZVtzdGFydCsrXTtcbiAgICB2YXIgbm9kZV9peCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVfaWRdO1xuICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlX2l4XTtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiBub2RlcyBhcyBhIG5ldyBncmFwaCB0byBncmFwaCBzZXRcbiAgICAgIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaChjaGlsZHJlbik7IC8vIEFkZCBjaGlsZHJlbiB0byBxdWUgcXVldWUgdG8gYmUgdmlzaXRlZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDcmVhdGUgaW5kZXhUb0dyYXBoIG1hcFxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JhcGgubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXTtcbiAgICAgIGxheW91dEluZm8uaW5kZXhUb0dyYXBoW2luZGV4XSA9IGk7XG4gICAgfVxuICB9IC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXMsIGNyZWF0aW5nIExheW91dCBFZGdlc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKyspIHtcbiAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgIHZhciB0ZW1wRWRnZSA9IHt9O1xuICAgIHRlbXBFZGdlLmlkID0gZS5kYXRhKCdpZCcpO1xuICAgIHRlbXBFZGdlLnNvdXJjZUlkID0gZS5kYXRhKCdzb3VyY2UnKTtcbiAgICB0ZW1wRWRnZS50YXJnZXRJZCA9IGUuZGF0YSgndGFyZ2V0Jyk7IC8vIENvbXB1dGUgaWRlYWwgbGVuZ3RoXG5cbiAgICB2YXIgaWRlYWxMZW5ndGggPSBmbihvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCkgPyBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aChlKSA6IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoO1xuICAgIHZhciBlbGFzdGljaXR5ID0gZm4ob3B0aW9ucy5lZGdlRWxhc3RpY2l0eSkgPyBvcHRpb25zLmVkZ2VFbGFzdGljaXR5KGUpIDogb3B0aW9ucy5lZGdlRWxhc3RpY2l0eTsgLy8gQ2hlY2sgaWYgaXQncyBhbiBpbnRlciBncmFwaCBlZGdlXG5cbiAgICB2YXIgc291cmNlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wRWRnZS5zb3VyY2VJZF07XG4gICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2UudGFyZ2V0SWRdO1xuICAgIHZhciBzb3VyY2VHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3NvdXJjZUl4XTtcbiAgICB2YXIgdGFyZ2V0R3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFt0YXJnZXRJeF07XG5cbiAgICBpZiAoc291cmNlR3JhcGggIT0gdGFyZ2V0R3JhcGgpIHtcbiAgICAgIC8vIEZpbmQgbG93ZXN0IGNvbW1vbiBncmFwaCBhbmNlc3RvclxuICAgICAgdmFyIGxjYSA9IGZpbmRMQ0EodGVtcEVkZ2Uuc291cmNlSWQsIHRlbXBFZGdlLnRhcmdldElkLCBsYXlvdXRJbmZvKTsgLy8gQ29tcHV0ZSBzdW0gb2Ygbm9kZSBkZXB0aHMsIHJlbGF0aXZlIHRvIGxjYSBncmFwaFxuXG4gICAgICB2YXIgbGNhR3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2xjYV07XG4gICAgICB2YXIgZGVwdGggPSAwOyAvLyBTb3VyY2UgZGVwdGhcblxuICAgICAgdmFyIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tzb3VyY2VJeF07XG5cbiAgICAgIHdoaWxlICgtMSA9PT0gbGNhR3JhcGguaW5kZXhPZih0ZW1wTm9kZS5pZCkpIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9IC8vIFRhcmdldCBkZXB0aFxuXG5cbiAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1t0YXJnZXRJeF07XG5cbiAgICAgIHdoaWxlICgtMSA9PT0gbGNhR3JhcGguaW5kZXhPZih0ZW1wTm9kZS5pZCkpIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9IC8vIGxvZ0RlYnVnKCdMQ0Egb2Ygbm9kZXMgJyArIHRlbXBFZGdlLnNvdXJjZUlkICsgJyBhbmQgJyArIHRlbXBFZGdlLnRhcmdldElkICtcbiAgICAgIC8vICBcIi4gSW5kZXg6IFwiICsgbGNhICsgXCIgQ29udGVudHM6IFwiICsgbGNhR3JhcGgudG9TdHJpbmcoKSArXG4gICAgICAvLyAgXCIuIERlcHRoOiBcIiArIGRlcHRoKTtcbiAgICAgIC8vIFVwZGF0ZSBpZGVhbExlbmd0aFxuXG5cbiAgICAgIGlkZWFsTGVuZ3RoICo9IGRlcHRoICogb3B0aW9ucy5uZXN0aW5nRmFjdG9yO1xuICAgIH1cblxuICAgIHRlbXBFZGdlLmlkZWFsTGVuZ3RoID0gaWRlYWxMZW5ndGg7XG4gICAgdGVtcEVkZ2UuZWxhc3RpY2l0eSA9IGVsYXN0aWNpdHk7XG4gICAgbGF5b3V0SW5mby5sYXlvdXRFZGdlcy5wdXNoKHRlbXBFZGdlKTtcbiAgfSAvLyBGaW5hbGx5LCByZXR1cm4gbGF5b3V0SW5mbyBvYmplY3RcblxuXG4gIHJldHVybiBsYXlvdXRJbmZvO1xufTtcbi8qKlxuICogQGJyaWVmIDogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxvd2VzdCBjb21tb25cbiAqICAgICAgICAgIGdyYXBoIGFuY2VzdG9yIGJldHdlZW4gMiBub2RlcyBpbiB0aGUgc3VidHJlZVxuICogICAgICAgICAgKGZyb20gdGhlIGdyYXBoIGhpZXJhcmNoeSBpbmR1Y2VkIHRyZWUpIHdob3NlXG4gKiAgICAgICAgICByb290IGlzIGdyYXBoSXhcbiAqXG4gKiBAYXJnIG5vZGUxOiBub2RlMSdzIElEXG4gKiBAYXJnIG5vZGUyOiBub2RlMidzIElEXG4gKiBAYXJnIGxheW91dEluZm86IGxheW91dEluZm8gb2JqZWN0XG4gKlxuICovXG5cblxudmFyIGZpbmRMQ0EgPSBmdW5jdGlvbiBmaW5kTENBKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbykge1xuICAvLyBGaW5kIHRoZWlyIGNvbW1vbiBhbmNlc3Rlciwgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCBncmFwaFxuICB2YXIgcmVzID0gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCAwLCBsYXlvdXRJbmZvKTtcblxuICBpZiAoMiA+IHJlcy5jb3VudCkge1xuICAgIC8vIElmIGF1eCBmdW5jdGlvbiBjb3VsZG4ndCBmaW5kIHRoZSBjb21tb24gYW5jZXN0ZXIsXG4gICAgLy8gdGhlbiBpdCBpcyB0aGUgcm9vdCBncmFwaFxuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXMuZ3JhcGg7XG4gIH1cbn07XG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IEF1eGlsaWFyeSBmdW5jdGlvbiB1c2VkIGZvciBMQ0EgY29tcHV0YXRpb25cbiAqXG4gKiBAYXJnIG5vZGUxICAgICAgOiBub2RlMSdzIElEXG4gKiBAYXJnIG5vZGUyICAgICAgOiBub2RlMidzIElEXG4gKiBAYXJnIGdyYXBoSXggICAgOiBzdWJncmFwaCBpbmRleFxuICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBvYmplY3RcbiAqXG4gKiBAcmV0dXJuICAgICAgICAgOiBvYmplY3Qgb2YgdGhlIGZvcm0ge2NvdW50OiBYLCBncmFwaDogWX0sIHdoZXJlOlxuICogICAgICAgICAgICAgICAgICAgWCBpcyB0aGUgbnVtYmVyIG9mIGFuY2VzdGVycyAobWF4OiAyKSBmb3VuZCBpblxuICogICAgICAgICAgICAgICAgICAgZ3JhcGhJeCAoYW5kIGl0J3Mgc3ViZ3JhcGhzKSxcbiAqICAgICAgICAgICAgICAgICAgIFkgaXMgdGhlIGdyYXBoIGluZGV4IG9mIHRoZSBsb3dlc3QgZ3JhcGggY29udGFpbmluZ1xuICogICAgICAgICAgICAgICAgICAgYWxsIFggbm9kZXNcbiAqL1xuXG5cbnZhciBmaW5kTENBX2F1eCA9IGZ1bmN0aW9uIGZpbmRMQ0FfYXV4KG5vZGUxLCBub2RlMiwgZ3JhcGhJeCwgbGF5b3V0SW5mbykge1xuICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2dyYXBoSXhdOyAvLyBJZiBib3RoIG5vZGVzIGJlbG9uZ3MgdG8gZ3JhcGhJeFxuXG4gIGlmICgtMSA8IGdyYXBoLmluZGV4T2Yobm9kZTEpICYmIC0xIDwgZ3JhcGguaW5kZXhPZihub2RlMikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY291bnQ6IDIsXG4gICAgICBncmFwaDogZ3JhcGhJeFxuICAgIH07XG4gIH0gLy8gTWFrZSByZWN1cnNpdmUgY2FsbHMgZm9yIGFsbCBzdWJncmFwaHNcblxuXG4gIHZhciBjID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGVJZCA9IGdyYXBoW2ldO1xuICAgIHZhciBub2RlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgIHZhciBjaGlsZHJlbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUl4XS5jaGlsZHJlbjsgLy8gSWYgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBza2lwIGl0XG5cbiAgICBpZiAoMCA9PT0gY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRHcmFwaEl4ID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5bMF1dXTtcbiAgICB2YXIgcmVzdWx0ID0gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCBjaGlsZEdyYXBoSXgsIGxheW91dEluZm8pO1xuXG4gICAgaWYgKDAgPT09IHJlc3VsdC5jb3VudCkge1xuICAgICAgLy8gTmVpdGhlciBub2RlMSBub3Igbm9kZTIgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICgxID09PSByZXN1bHQuY291bnQpIHtcbiAgICAgIC8vIE9uZSBvZiAobm9kZTEsIG5vZGUyKSBpcyBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIGMrKztcblxuICAgICAgaWYgKDIgPT09IGMpIHtcbiAgICAgICAgLy8gV2UndmUgYWxyZWFkeSBmb3VuZCBib3RoIG5vZGVzLCBubyBuZWVkIHRvIGtlZXAgc2VhcmNoaW5nXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIG5vZGVzIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb3VudDogYyxcbiAgICBncmFwaDogZ3JhcGhJeFxuICB9O1xufTtcbi8qKlxuICogQGJyaWVmOiBwcmludHNMYXlvdXRJbmZvIGludG8ganMgY29uc29sZVxuICogICAgICAgICBPbmx5IHVzZWQgZm9yIGRlYmJ1Z2luZ1xuICovXG5cblxuaWYgKGZhbHNlKSB7XG4gIHZhciBwcmludExheW91dEluZm87XG59XG4vKipcbiAqIEBicmllZiA6IFJhbmRvbWl6ZXMgdGhlIHBvc2l0aW9uIG9mIGFsbCBub2Rlc1xuICovXG5cblxudmFyIHJhbmRvbWl6ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uIHJhbmRvbWl6ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSkge1xuICB2YXIgd2lkdGggPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07IC8vIE5vIG5lZWQgdG8gcmFuZG9taXplIGNvbXBvdW5kIG5vZGVzIG9yIGxvY2tlZCBub2Rlc1xuXG4gICAgaWYgKDAgPT09IG4uY2hpbGRyZW4ubGVuZ3RoICYmICFuLmlzTG9ja2VkKSB7XG4gICAgICBuLnBvc2l0aW9uWCA9IE1hdGgucmFuZG9tKCkgKiB3aWR0aDtcbiAgICAgIG4ucG9zaXRpb25ZID0gTWF0aC5yYW5kb20oKSAqIGhlaWdodDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBnZXRTY2FsZUluQm91bmRzRm4gPSBmdW5jdGlvbiBnZXRTY2FsZUluQm91bmRzRm4obGF5b3V0SW5mbywgb3B0aW9ucywgbm9kZXMpIHtcbiAgdmFyIGJiID0gbGF5b3V0SW5mby5ib3VuZGluZ0JveDtcbiAgdmFyIGNvc2VCQiA9IHtcbiAgICB4MTogSW5maW5pdHksXG4gICAgeDI6IC1JbmZpbml0eSxcbiAgICB5MTogSW5maW5pdHksXG4gICAgeTI6IC1JbmZpbml0eVxuICB9O1xuXG4gIGlmIChvcHRpb25zLmJvdW5kaW5nQm94KSB7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlLmRhdGEoJ2lkJyldXTtcbiAgICAgIGNvc2VCQi54MSA9IE1hdGgubWluKGNvc2VCQi54MSwgbG5vZGUucG9zaXRpb25YKTtcbiAgICAgIGNvc2VCQi54MiA9IE1hdGgubWF4KGNvc2VCQi54MiwgbG5vZGUucG9zaXRpb25YKTtcbiAgICAgIGNvc2VCQi55MSA9IE1hdGgubWluKGNvc2VCQi55MSwgbG5vZGUucG9zaXRpb25ZKTtcbiAgICAgIGNvc2VCQi55MiA9IE1hdGgubWF4KGNvc2VCQi55MiwgbG5vZGUucG9zaXRpb25ZKTtcbiAgICB9KTtcbiAgICBjb3NlQkIudyA9IGNvc2VCQi54MiAtIGNvc2VCQi54MTtcbiAgICBjb3NlQkIuaCA9IGNvc2VCQi55MiAtIGNvc2VCQi55MTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtlbGUuZGF0YSgnaWQnKV1dO1xuXG4gICAgaWYgKG9wdGlvbnMuYm91bmRpbmdCb3gpIHtcbiAgICAgIC8vIHRoZW4gYWRkIGV4dHJhIGJvdW5kaW5nIGJveCBjb25zdHJhaW50XG4gICAgICB2YXIgcGN0WCA9IChsbm9kZS5wb3NpdGlvblggLSBjb3NlQkIueDEpIC8gY29zZUJCLnc7XG4gICAgICB2YXIgcGN0WSA9IChsbm9kZS5wb3NpdGlvblkgLSBjb3NlQkIueTEpIC8gY29zZUJCLmg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSArIHBjdFggKiBiYi53LFxuICAgICAgICB5OiBiYi55MSArIHBjdFkgKiBiYi5oXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBsbm9kZS5wb3NpdGlvblgsXG4gICAgICAgIHk6IGxub2RlLnBvc2l0aW9uWVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBVcGRhdGVzIHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgaW4gdGhlIG5ldHdvcmtcbiAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0XG4gKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICovXG5cblxudmFyIHJlZnJlc2hQb3NpdGlvbnMgPSBmdW5jdGlvbiByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gJ1JlZnJlc2hpbmcgcG9zaXRpb25zJztcbiAgLy8gbG9nRGVidWcocyk7XG4gIHZhciBsYXlvdXQgPSBvcHRpb25zLmxheW91dDtcbiAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gIHZhciBnZXRTY2FsZWRQb3MgPSBnZXRTY2FsZUluQm91bmRzRm4obGF5b3V0SW5mbywgb3B0aW9ucywgbm9kZXMpO1xuICBub2Rlcy5wb3NpdGlvbnMoZ2V0U2NhbGVkUG9zKTsgLy8gVHJpZ2dlciBsYXlvdXRSZWFkeSBvbmx5IG9uIGZpcnN0IGNhbGxcblxuICBpZiAodHJ1ZSAhPT0gbGF5b3V0SW5mby5yZWFkeSkge1xuICAgIC8vIHMgPSAnVHJpZ2dlcmluZyBsYXlvdXRyZWFkeSc7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgbGF5b3V0SW5mby5yZWFkeSA9IHRydWU7XG4gICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICBsYXlvdXQuZW1pdCh7XG4gICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgbGF5b3V0OiB0aGlzXG4gICAgfSk7XG4gIH1cbn07XG4vKipcbiAqIEBicmllZiA6IExvZ3MgYSBkZWJ1ZyBtZXNzYWdlIGluIEpTIGNvbnNvbGUsIGlmIERFQlVHIGlzIE9OXG4gKi9cbi8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKHRleHQpIHtcbi8vICAgaWYgKERFQlVHKSB7XG4vLyAgICAgY29uc29sZS5kZWJ1Zyh0ZXh0KTtcbi8vICAgfVxuLy8gfTtcblxuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRoZSBwaHlzaWNhbCBzaW11bGF0aW9uXG4gKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkXG4gKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICovXG5cblxudmFyIHN0ZXAkMSA9IGZ1bmN0aW9uIHN0ZXAobGF5b3V0SW5mbywgb3B0aW9ucywgX3N0ZXApIHtcbiAgLy8gdmFyIHMgPSBcIlxcblxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcIjtcbiAgLy8gcyArPSBcIlxcblNURVA6IFwiICsgc3RlcDtcbiAgLy8gcyArPSBcIlxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcXG5cIjtcbiAgLy8gbG9nRGVidWcocyk7XG4gIC8vIENhbGN1bGF0ZSBub2RlIHJlcHVsc2lvbnNcbiAgY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTsgLy8gQ2FsY3VsYXRlIGVkZ2UgZm9yY2VzXG5cbiAgY2FsY3VsYXRlRWRnZUZvcmNlcyhsYXlvdXRJbmZvKTsgLy8gQ2FsY3VsYXRlIGdyYXZpdHkgZm9yY2VzXG5cbiAgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTsgLy8gUHJvcGFnYXRlIGZvcmNlcyBmcm9tIHBhcmVudCB0byBjaGlsZFxuXG4gIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvKTsgLy8gVXBkYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiBjYWxjdWxhdGVkIGZvcmNlc1xuXG4gIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvKTtcbn07XG4vKipcbiAqIEBicmllZiA6IENvbXB1dGVzIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXNcbiAqL1xuXG5cbnZhciBjYWxjdWxhdGVOb2RlRm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIEdvIHRocm91Z2ggZWFjaCBvZiB0aGUgZ3JhcGhzIGluIGdyYXBoU2V0XG4gIC8vIE5vZGVzIG9ubHkgcmVwZWwgZWFjaCBvdGhlciBpZiB0aGV5IGJlbG9uZyB0byB0aGUgc2FtZSBncmFwaFxuICAvLyB2YXIgcyA9ICdjYWxjdWxhdGVOb2RlRm9yY2VzJztcbiAgLy8gbG9nRGVidWcocyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoOyAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAvLyBOb3cgZ2V0IGFsbCB0aGUgcGFpcnMgb2Ygbm9kZXNcbiAgICAvLyBPbmx5IGdldCBlYWNoIHBhaXIgb25jZSwgKEEsIEIpID0gKEIsIEEpXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgIHZhciBub2RlMSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcblxuICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgbnVtTm9kZXM7IGsrKykge1xuICAgICAgICB2YXIgbm9kZTIgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2tdXV07XG4gICAgICAgIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciByYW5kb21EaXN0YW5jZSA9IGZ1bmN0aW9uIHJhbmRvbURpc3RhbmNlKG1heCkge1xuICByZXR1cm4gLW1heCArIDIgKiBtYXggKiBNYXRoLnJhbmRvbSgpO1xufTtcbi8qKlxuICogQGJyaWVmIDogQ29tcHV0ZSB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gYSBwYWlyIG9mIG5vZGVzXG4gKi9cblxuXG52YXIgbm9kZVJlcHVsc2lvbiA9IGZ1bmN0aW9uIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gXCJOb2RlIHJlcHVsc2lvbi4gTm9kZTE6IFwiICsgbm9kZTEuaWQgKyBcIiBOb2RlMjogXCIgKyBub2RlMi5pZDtcbiAgdmFyIGNtcHRJZDEgPSBub2RlMS5jbXB0SWQ7XG4gIHZhciBjbXB0SWQyID0gbm9kZTIuY21wdElkO1xuXG4gIGlmIChjbXB0SWQxICE9PSBjbXB0SWQyICYmICFsYXlvdXRJbmZvLmlzQ29tcG91bmQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcblxuXG4gIHZhciBkaXJlY3Rpb25YID0gbm9kZTIucG9zaXRpb25YIC0gbm9kZTEucG9zaXRpb25YO1xuICB2YXIgZGlyZWN0aW9uWSA9IG5vZGUyLnBvc2l0aW9uWSAtIG5vZGUxLnBvc2l0aW9uWTtcbiAgdmFyIG1heFJhbmREaXN0ID0gMTsgLy8gcyArPSBcIlxcbmRpcmVjdGlvblg6IFwiICsgZGlyZWN0aW9uWCArIFwiLCBkaXJlY3Rpb25ZOiBcIiArIGRpcmVjdGlvblk7XG4gIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGFwcGx5IGEgcmFuZG9tIGZvcmNlXG5cbiAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgIGRpcmVjdGlvblggPSByYW5kb21EaXN0YW5jZShtYXhSYW5kRGlzdCk7XG4gICAgZGlyZWN0aW9uWSA9IHJhbmRvbURpc3RhbmNlKG1heFJhbmREaXN0KTtcbiAgfVxuXG4gIHZhciBvdmVybGFwID0gbm9kZXNPdmVybGFwKG5vZGUxLCBub2RlMiwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG5cbiAgaWYgKG92ZXJsYXAgPiAwKSB7XG4gICAgLy8gcyArPSBcIlxcbk5vZGVzIERPIG92ZXJsYXAuXCI7XG4gICAgLy8gcyArPSBcIlxcbk92ZXJsYXA6IFwiICsgb3ZlcmxhcDtcbiAgICAvLyBJZiBub2RlcyBvdmVybGFwLCByZXB1bHNpb24gZm9yY2UgaXMgcHJvcG9ydGlvbmFsXG4gICAgLy8gdG8gdGhlIG92ZXJsYXBcbiAgICB2YXIgZm9yY2UgPSBvcHRpb25zLm5vZGVPdmVybGFwICogb3ZlcmxhcDsgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcblxuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXJlY3Rpb25YICogZGlyZWN0aW9uWCArIGRpcmVjdGlvblkgKiBkaXJlY3Rpb25ZKTsgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuXG4gICAgdmFyIGZvcmNlWCA9IGZvcmNlICogZGlyZWN0aW9uWCAvIGRpc3RhbmNlO1xuICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGRpcmVjdGlvblkgLyBkaXN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzICs9IFwiXFxuTm9kZXMgZG8gTk9UIG92ZXJsYXAuXCI7XG4gICAgLy8gSWYgdGhlcmUncyBubyBvdmVybGFwLCBmb3JjZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsXG4gICAgLy8gdG8gc3F1YXJlZCBkaXN0YW5jZVxuICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTEsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludChub2RlMiwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkpOyAvLyBVc2UgY2xpcHBpbmcgcG9pbnRzIHRvIGNvbXB1dGUgZGlzdGFuY2VcblxuICAgIHZhciBkaXN0YW5jZVggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgIHZhciBkaXN0YW5jZVkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgIHZhciBkaXN0YW5jZVNxciA9IGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWTtcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzdGFuY2VTcXIpOyAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG4gICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcblxuICAgIHZhciBmb3JjZSA9IChub2RlMS5ub2RlUmVwdWxzaW9uICsgbm9kZTIubm9kZVJlcHVsc2lvbikgLyBkaXN0YW5jZVNxcjtcbiAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBkaXN0YW5jZVggLyBkaXN0YW5jZTtcbiAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBkaXN0YW5jZVkgLyBkaXN0YW5jZTtcbiAgfSAvLyBBcHBseSBmb3JjZVxuXG5cbiAgaWYgKCFub2RlMS5pc0xvY2tlZCkge1xuICAgIG5vZGUxLm9mZnNldFggLT0gZm9yY2VYO1xuICAgIG5vZGUxLm9mZnNldFkgLT0gZm9yY2VZO1xuICB9XG5cbiAgaWYgKCFub2RlMi5pc0xvY2tlZCkge1xuICAgIG5vZGUyLm9mZnNldFggKz0gZm9yY2VYO1xuICAgIG5vZGUyLm9mZnNldFkgKz0gZm9yY2VZO1xuICB9IC8vIHMgKz0gXCJcXG5Gb3JjZVg6IFwiICsgZm9yY2VYICsgXCIgRm9yY2VZOiBcIiArIGZvcmNlWTtcbiAgLy8gbG9nRGVidWcocyk7XG5cblxuICByZXR1cm47XG59O1xuLyoqXG4gKiBAYnJpZWYgIDogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBub2RlcyBvdmVybGFwIG9yIG5vdFxuICogQHJldHVybiA6IEFtb3VudCBvZiBvdmVybGFwcGluZyAoMCA9PiBubyBvdmVybGFwKVxuICovXG5cblxudmFyIG5vZGVzT3ZlcmxhcCA9IGZ1bmN0aW9uIG5vZGVzT3ZlcmxhcChub2RlMSwgbm9kZTIsIGRYLCBkWSkge1xuICBpZiAoZFggPiAwKSB7XG4gICAgdmFyIG92ZXJsYXBYID0gbm9kZTEubWF4WCAtIG5vZGUyLm1pblg7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG92ZXJsYXBYID0gbm9kZTIubWF4WCAtIG5vZGUxLm1pblg7XG4gIH1cblxuICBpZiAoZFkgPiAwKSB7XG4gICAgdmFyIG92ZXJsYXBZID0gbm9kZTEubWF4WSAtIG5vZGUyLm1pblk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG92ZXJsYXBZID0gbm9kZTIubWF4WSAtIG5vZGUxLm1pblk7XG4gIH1cblxuICBpZiAob3ZlcmxhcFggPj0gMCAmJiBvdmVybGFwWSA+PSAwKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChvdmVybGFwWCAqIG92ZXJsYXBYICsgb3ZlcmxhcFkgKiBvdmVybGFwWSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG4vKipcbiAqIEBicmllZiA6IEZpbmRzIHRoZSBwb2ludCBpbiB3aGljaCBhbiBlZGdlIChkaXJlY3Rpb24gZFgsIGRZKSBpbnRlcnNlY3RzXG4gKiAgICAgICAgICB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYm94IG9mIGl0J3Mgc291cmNlL3RhcmdldCBub2RlXG4gKi9cblxuXG52YXIgZmluZENsaXBwaW5nUG9pbnQgPSBmdW5jdGlvbiBmaW5kQ2xpcHBpbmdQb2ludChub2RlLCBkWCwgZFkpIHtcbiAgLy8gU2hvcmN1dHNcbiAgdmFyIFggPSBub2RlLnBvc2l0aW9uWDtcbiAgdmFyIFkgPSBub2RlLnBvc2l0aW9uWTtcbiAgdmFyIEggPSBub2RlLmhlaWdodCB8fCAxO1xuICB2YXIgVyA9IG5vZGUud2lkdGggfHwgMTtcbiAgdmFyIGRpclNsb3BlID0gZFkgLyBkWDtcbiAgdmFyIG5vZGVTbG9wZSA9IEggLyBXOyAvLyB2YXIgcyA9ICdDb21wdXRpbmcgY2xpcHBpbmcgcG9pbnQgb2Ygbm9kZSAnICsgbm9kZS5pZCArXG4gIC8vICAgXCIgLiBIZWlnaHQ6ICBcIiArIEggKyBcIiwgV2lkdGg6IFwiICsgVyArXG4gIC8vICAgXCJcXG5EaXJlY3Rpb24gXCIgKyBkWCArIFwiLCBcIiArIGRZO1xuICAvL1xuICAvLyBDb21wdXRlIGludGVyc2VjdGlvblxuXG4gIHZhciByZXMgPSB7fTsgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uICh1cClcblxuICBpZiAoMCA9PT0gZFggJiYgMCA8IGRZKSB7XG4gICAgcmVzLnggPSBYOyAvLyBzICs9IFwiXFxuVXAgZGlyZWN0aW9uXCI7XG5cbiAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAoZG93bilcblxuXG4gIGlmICgwID09PSBkWCAmJiAwID4gZFkpIHtcbiAgICByZXMueCA9IFg7XG4gICAgcmVzLnkgPSBZICsgSCAvIDI7IC8vIHMgKz0gXCJcXG5Eb3duIGRpcmVjdGlvblwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSByaWdodCBib3JkZXJcblxuXG4gIGlmICgwIDwgZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgcmVzLnggPSBYICsgVyAvIDI7XG4gICAgcmVzLnkgPSBZICsgVyAqIGRZIC8gMiAvIGRYOyAvLyBzICs9IFwiXFxuUmlnaHRib3JkZXJcIjtcblxuICAgIHJldHVybiByZXM7XG4gIH0gLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgbGVmdCBib3JkZXJcblxuXG4gIGlmICgwID4gZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgcmVzLnggPSBYIC0gVyAvIDI7XG4gICAgcmVzLnkgPSBZIC0gVyAqIGRZIC8gMiAvIGRYOyAvLyBzICs9IFwiXFxuTGVmdGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSB0b3AgYm9yZGVyXG5cblxuICBpZiAoMCA8IGRZICYmIChkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fCBkaXJTbG9wZSA+PSBub2RlU2xvcGUpKSB7XG4gICAgcmVzLnggPSBYICsgSCAqIGRYIC8gMiAvIGRZO1xuICAgIHJlcy55ID0gWSArIEggLyAyOyAvLyBzICs9IFwiXFxuVG9wIGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBib3R0b20gYm9yZGVyXG5cblxuICBpZiAoMCA+IGRZICYmIChkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fCBkaXJTbG9wZSA+PSBub2RlU2xvcGUpKSB7XG4gICAgcmVzLnggPSBYIC0gSCAqIGRYIC8gMiAvIGRZO1xuICAgIHJlcy55ID0gWSAtIEggLyAyOyAvLyBzICs9IFwiXFxuQm90dG9tIGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBzICs9IFwiXFxuQ2xpcHBpbmcgcG9pbnQgZm91bmQgYXQgXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55O1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuXG4gIHJldHVybiByZXM7XG59O1xuLyoqXG4gKiBAYnJpZWYgOiBDYWxjdWxhdGVzIGFsbCBlZGdlIGZvcmNlc1xuICovXG5cblxudmFyIGNhbGN1bGF0ZUVkZ2VGb3JjZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVFZGdlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgIC8vIEdldCBlZGdlLCBzb3VyY2UgJiB0YXJnZXQgbm9kZXNcbiAgICB2YXIgZWRnZSA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbaV07XG4gICAgdmFyIHNvdXJjZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS5zb3VyY2VJZF07XG4gICAgdmFyIHNvdXJjZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuICAgIHZhciB0YXJnZXRJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W2VkZ2UudGFyZ2V0SWRdO1xuICAgIHZhciB0YXJnZXQgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTsgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcblxuICAgIHZhciBkaXJlY3Rpb25YID0gdGFyZ2V0LnBvc2l0aW9uWCAtIHNvdXJjZS5wb3NpdGlvblg7XG4gICAgdmFyIGRpcmVjdGlvblkgPSB0YXJnZXQucG9zaXRpb25ZIC0gc291cmNlLnBvc2l0aW9uWTsgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgZG8gbm90aGluZy5cbiAgICAvLyBBIHJhbmRvbSBmb3JjZSBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgYXMgbm9kZSByZXB1bHNpb25cblxuICAgIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuXG5cbiAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQoc291cmNlLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQodGFyZ2V0LCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG4gICAgdmFyIGx4ID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICB2YXIgbHkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KGx4ICogbHggKyBseSAqIGx5KTtcbiAgICB2YXIgZm9yY2UgPSBNYXRoLnBvdyhlZGdlLmlkZWFsTGVuZ3RoIC0gbCwgMikgLyBlZGdlLmVsYXN0aWNpdHk7XG5cbiAgICBpZiAoMCAhPT0gbCkge1xuICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogbHggLyBsO1xuICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogbHkgLyBsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZm9yY2VYID0gMDtcbiAgICAgIHZhciBmb3JjZVkgPSAwO1xuICAgIH0gLy8gQWRkIHRoaXMgZm9yY2UgdG8gdGFyZ2V0IGFuZCBzb3VyY2Ugbm9kZXNcblxuXG4gICAgaWYgKCFzb3VyY2UuaXNMb2NrZWQpIHtcbiAgICAgIHNvdXJjZS5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgIHNvdXJjZS5vZmZzZXRZICs9IGZvcmNlWTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldC5pc0xvY2tlZCkge1xuICAgICAgdGFyZ2V0Lm9mZnNldFggLT0gZm9yY2VYO1xuICAgICAgdGFyZ2V0Lm9mZnNldFkgLT0gZm9yY2VZO1xuICAgIH0gLy8gdmFyIHMgPSAnRWRnZSBmb3JjZSBiZXR3ZWVuIG5vZGVzICcgKyBzb3VyY2UuaWQgKyAnIGFuZCAnICsgdGFyZ2V0LmlkO1xuICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBsICsgXCIgRm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKVwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIH1cbn07XG4vKipcbiAqIEBicmllZiA6IENvbXB1dGVzIGdyYXZpdHkgZm9yY2VzIGZvciBhbGwgbm9kZXNcbiAqL1xuXG5cbnZhciBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIHZhciBkaXN0VGhyZXNob2xkID0gMTsgLy8gdmFyIHMgPSAnY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyc7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoOyAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAvLyBDb21wdXRlIGdyYXBoIGNlbnRlclxuXG4gICAgaWYgKDAgPT09IGkpIHtcbiAgICAgIHZhciBjZW50ZXJYID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgdmFyIGNlbnRlclkgPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR2V0IFBhcmVudCBub2RlIGZvciB0aGlzIGdyYXBoLCBhbmQgdXNlIGl0cyBwb3NpdGlvbiBhcyBjZW50ZXJcbiAgICAgIHZhciB0ZW1wID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFswXV1dO1xuICAgICAgdmFyIHBhcmVudCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcC5wYXJlbnRJZF1dO1xuICAgICAgdmFyIGNlbnRlclggPSBwYXJlbnQucG9zaXRpb25YO1xuICAgICAgdmFyIGNlbnRlclkgPSBwYXJlbnQucG9zaXRpb25ZO1xuICAgIH0gLy8gcyA9IFwiQ2VudGVyIGZvdW5kIGF0OiBcIiArIGNlbnRlclggKyBcIiwgXCIgKyBjZW50ZXJZO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIC8vIEFwcGx5IGZvcmNlIHRvIGFsbCBub2RlcyBpbiBncmFwaFxuXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV1dOyAvLyBzID0gXCJOb2RlOiBcIiArIG5vZGUuaWQ7XG5cbiAgICAgIGlmIChub2RlLmlzTG9ja2VkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHggPSBjZW50ZXJYIC0gbm9kZS5wb3NpdGlvblg7XG4gICAgICB2YXIgZHkgPSBjZW50ZXJZIC0gbm9kZS5wb3NpdGlvblk7XG4gICAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgIGlmIChkID4gZGlzdFRocmVzaG9sZCkge1xuICAgICAgICB2YXIgZnggPSBvcHRpb25zLmdyYXZpdHkgKiBkeCAvIGQ7XG4gICAgICAgIHZhciBmeSA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR5IC8gZDtcbiAgICAgICAgbm9kZS5vZmZzZXRYICs9IGZ4O1xuICAgICAgICBub2RlLm9mZnNldFkgKz0gZnk7IC8vIHMgKz0gXCI6IEFwcGxpZWQgZm9yY2U6IFwiICsgZnggKyBcIiwgXCIgKyBmeTtcbiAgICAgIH0gLy8gcyArPSBcIjogc2t5cHBlZCBzaW5jZSBpdCdzIHRvbyBjbG9zZSB0byBjZW50ZXJcIjtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEBicmllZiAgICAgICAgICA6IFRoaXMgZnVuY3Rpb24gcHJvcGFnYXRlcyB0aGUgZXhpc3Rpbmcgb2Zmc2V0cyBmcm9tXG4gKiAgICAgICAgICAgICAgICAgICBwYXJlbnQgbm9kZXMgdG8gaXRzIGRlc2NlbmRlbnRzLlxuICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBPYmplY3RcbiAqIEBhcmcgY3kgICAgICAgICA6IGN5dG9zY2FwZSBPYmplY3RcbiAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gKi9cblxuXG52YXIgcHJvcGFnYXRlRm9yY2VzID0gZnVuY3Rpb24gcHJvcGFnYXRlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gMDsgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcblxuICB2YXIgZW5kID0gLTE7IC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAvLyBsb2dEZWJ1ZygncHJvcGFnYXRlRm9yY2VzJyk7XG4gIC8vIFN0YXJ0IGJ5IHZpc2l0aW5nIHRoZSBub2RlcyBpbiB0aGUgcm9vdCBncmFwaFxuXG4gIHF1ZXVlLnB1c2guYXBwbHkocXVldWUsIGxheW91dEluZm8uZ3JhcGhTZXRbMF0pO1xuICBlbmQgKz0gbGF5b3V0SW5mby5ncmFwaFNldFswXS5sZW5ndGg7IC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsXG5cbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICB2YXIgbm9kZUlkID0gcXVldWVbc3RhcnQrK107XG4gICAgdmFyIG5vZGVJbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVJbmRleF07XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjsgLy8gV2Ugb25seSBuZWVkIHRvIHByb2Nlc3MgdGhlIG5vZGUgaWYgaXQncyBjb21wb3VuZFxuXG4gICAgaWYgKDAgPCBjaGlsZHJlbi5sZW5ndGggJiYgIW5vZGUuaXNMb2NrZWQpIHtcbiAgICAgIHZhciBvZmZYID0gbm9kZS5vZmZzZXRYO1xuICAgICAgdmFyIG9mZlkgPSBub2RlLm9mZnNldFk7IC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBvZmZzZXQgZnJvbSBwYXJlbnQgbm9kZSA6IFwiICsgbm9kZS5pZCArXG4gICAgICAvLyAgIFwiLiBPZmZzZXRYOiBcIiArIG9mZlggKyBcIi4gT2Zmc2V0WTogXCIgKyBvZmZZO1xuICAgICAgLy8gcyArPSBcIlxcbiBDaGlsZHJlbjogXCIgKyBjaGlsZHJlbi50b1N0cmluZygpO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5baV1dXTsgLy8gUHJvcGFnYXRlIG9mZnNldFxuXG4gICAgICAgIGNoaWxkTm9kZS5vZmZzZXRYICs9IG9mZlg7XG4gICAgICAgIGNoaWxkTm9kZS5vZmZzZXRZICs9IG9mZlk7IC8vIEFkZCBjaGlsZHJlbiB0byBxdWV1ZSB0byBiZSB2aXNpdGVkXG5cbiAgICAgICAgcXVldWVbKytlbmRdID0gY2hpbGRyZW5baV07XG4gICAgICB9IC8vIFJlc2V0IHBhcmVudCBvZmZzZXRzXG5cblxuICAgICAgbm9kZS5vZmZzZXRYID0gMDtcbiAgICAgIG5vZGUub2Zmc2V0WSA9IDA7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBAYnJpZWYgOiBVcGRhdGVzIHRoZSBsYXlvdXQgbW9kZWwgcG9zaXRpb25zLCBiYXNlZCBvblxuICogICAgICAgICAgdGhlIGFjY3VtdWxhdGVkIGZvcmNlc1xuICovXG5cblxudmFyIHVwZGF0ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gJ1VwZGF0aW5nIHBvc2l0aW9ucyc7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuICAvLyBSZXNldCBib3VuZGFyaWVzIGZvciBjb21wb3VuZCBub2Rlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcblxuICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIGxvZ0RlYnVnKFwiUmVzZXR0aW5nIGJvdW5kYXJpZXMgb2YgY29tcG91bmQgbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgIG4ubWF4WCA9IHVuZGVmaW5lZDtcbiAgICAgIG4ubWluWCA9IHVuZGVmaW5lZDtcbiAgICAgIG4ubWF4WSA9IHVuZGVmaW5lZDtcbiAgICAgIG4ubWluWSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcblxuICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGggfHwgbi5pc0xvY2tlZCkge1xuICAgICAgLy8gTm8gbmVlZCB0byBzZXQgY29tcG91bmQgb3IgbG9ja2VkIG5vZGUgcG9zaXRpb25cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU2tpcHBpbmcgcG9zaXRpb24gdXBkYXRlIG9mIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIHMgPSBcIk5vZGU6IFwiICsgbi5pZCArIFwiIFByZXZpb3VzIHBvc2l0aW9uOiAoXCIgK1xuICAgIC8vIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7XG4gICAgLy8gTGltaXQgZGlzcGxhY2VtZW50IGluIG9yZGVyIHRvIGltcHJvdmUgc3RhYmlsaXR5XG5cblxuICAgIHZhciB0ZW1wRm9yY2UgPSBsaW1pdEZvcmNlKG4ub2Zmc2V0WCwgbi5vZmZzZXRZLCBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcbiAgICBuLnBvc2l0aW9uWCArPSB0ZW1wRm9yY2UueDtcbiAgICBuLnBvc2l0aW9uWSArPSB0ZW1wRm9yY2UueTtcbiAgICBuLm9mZnNldFggPSAwO1xuICAgIG4ub2Zmc2V0WSA9IDA7XG4gICAgbi5taW5YID0gbi5wb3NpdGlvblggLSBuLndpZHRoO1xuICAgIG4ubWF4WCA9IG4ucG9zaXRpb25YICsgbi53aWR0aDtcbiAgICBuLm1pblkgPSBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0O1xuICAgIG4ubWF4WSA9IG4ucG9zaXRpb25ZICsgbi5oZWlnaHQ7IC8vIHMgKz0gXCIgTmV3IFBvc2l0aW9uOiAoXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIC8vIFVwZGF0ZSBhbmNlc3RyeSBib3VkYXJpZXNcblxuICAgIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhuLCBsYXlvdXRJbmZvKTtcbiAgfSAvLyBVcGRhdGUgc2l6ZSwgcG9zaXRpb24gb2YgY29tcHVuZCBub2Rlc1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG5cbiAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoICYmICFuLmlzTG9ja2VkKSB7XG4gICAgICBuLnBvc2l0aW9uWCA9IChuLm1heFggKyBuLm1pblgpIC8gMjtcbiAgICAgIG4ucG9zaXRpb25ZID0gKG4ubWF4WSArIG4ubWluWSkgLyAyO1xuICAgICAgbi53aWR0aCA9IG4ubWF4WCAtIG4ubWluWDtcbiAgICAgIG4uaGVpZ2h0ID0gbi5tYXhZIC0gbi5taW5ZOyAvLyBzID0gXCJVcGRhdGluZyBwb3NpdGlvbiwgc2l6ZSBvZiBjb21wb3VuZCBub2RlIFwiICsgbi5pZDtcbiAgICAgIC8vIHMgKz0gXCJcXG5Qb3NpdGlvblg6IFwiICsgbi5wb3NpdGlvblggKyBcIiwgUG9zaXRpb25ZOiBcIiArIG4ucG9zaXRpb25ZO1xuICAgICAgLy8gcyArPSBcIlxcbldpZHRoOiBcIiArIG4ud2lkdGggKyBcIiwgSGVpZ2h0OiBcIiArIG4uaGVpZ2h0O1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBAYnJpZWYgOiBMaW1pdHMgYSBmb3JjZSAoZm9yY2VYLCBmb3JjZVkpIHRvIGJlIG5vdFxuICogICAgICAgICAgZ3JlYXRlciAoaW4gbW9kdWxvKSB0aGFuIG1heC5cbiA4ICAgICAgICAgIFByZXNlcnZlcyBmb3JjZSBkaXJlY3Rpb24uXG4gICovXG5cblxudmFyIGxpbWl0Rm9yY2UgPSBmdW5jdGlvbiBsaW1pdEZvcmNlKGZvcmNlWCwgZm9yY2VZLCBtYXgpIHtcbiAgLy8gdmFyIHMgPSBcIkxpbWl0aW5nIGZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIikuIE1heDogXCIgKyBtYXg7XG4gIHZhciBmb3JjZSA9IE1hdGguc3FydChmb3JjZVggKiBmb3JjZVggKyBmb3JjZVkgKiBmb3JjZVkpO1xuXG4gIGlmIChmb3JjZSA+IG1heCkge1xuICAgIHZhciByZXMgPSB7XG4gICAgICB4OiBtYXggKiBmb3JjZVggLyBmb3JjZSxcbiAgICAgIHk6IG1heCAqIGZvcmNlWSAvIGZvcmNlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgeDogZm9yY2VYLFxuICAgICAgeTogZm9yY2VZXG4gICAgfTtcbiAgfSAvLyBzICs9IFwiLlxcblJlc3VsdDogKFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueSArIFwiKVwiO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuXG4gIHJldHVybiByZXM7XG59O1xuLyoqXG4gKiBAYnJpZWYgOiBGdW5jdGlvbiB1c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGNvbXBvdW5kIG5vZGVcbiAqICAgICAgICAgIHNpemVzLCBzaW5jZSB0aGV5IHNob3VsZCBib3VuZCBhbGwgdGhlaXIgc3Vibm9kZXMuXG4gKi9cblxuXG52YXIgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzID0gZnVuY3Rpb24gdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKG5vZGUsIGxheW91dEluZm8pIHtcbiAgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG5ldyBwb3NpdGlvbi9zaXplIG9mIG5vZGUgXCIgKyBub2RlLmlkO1xuICB2YXIgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuXG4gIGlmIChudWxsID09IHBhcmVudElkKSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlIGFyZSBkb25lXG4gICAgLy8gcyArPSBcIi4gTm8gcGFyZW50IG5vZGUuXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgcmV0dXJuO1xuICB9IC8vIEdldCBQYXJlbnQgTm9kZVxuXG5cbiAgdmFyIHAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BhcmVudElkXV07XG4gIHZhciBmbGFnID0gZmFsc2U7IC8vIE1heFhcblxuICBpZiAobnVsbCA9PSBwLm1heFggfHwgbm9kZS5tYXhYICsgcC5wYWRSaWdodCA+IHAubWF4WCkge1xuICAgIHAubWF4WCA9IG5vZGUubWF4WCArIHAucGFkUmlnaHQ7XG4gICAgZmxhZyA9IHRydWU7IC8vIHMgKz0gXCJcXG5OZXcgbWF4WCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhYO1xuICB9IC8vIE1pblhcblxuXG4gIGlmIChudWxsID09IHAubWluWCB8fCBub2RlLm1pblggLSBwLnBhZExlZnQgPCBwLm1pblgpIHtcbiAgICBwLm1pblggPSBub2RlLm1pblggLSBwLnBhZExlZnQ7XG4gICAgZmxhZyA9IHRydWU7IC8vIHMgKz0gXCJcXG5OZXcgbWluWCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5YO1xuICB9IC8vIE1heFlcblxuXG4gIGlmIChudWxsID09IHAubWF4WSB8fCBub2RlLm1heFkgKyBwLnBhZEJvdHRvbSA+IHAubWF4WSkge1xuICAgIHAubWF4WSA9IG5vZGUubWF4WSArIHAucGFkQm90dG9tO1xuICAgIGZsYWcgPSB0cnVlOyAvLyBzICs9IFwiXFxuTmV3IG1heFkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WTtcbiAgfSAvLyBNaW5ZXG5cblxuICBpZiAobnVsbCA9PSBwLm1pblkgfHwgbm9kZS5taW5ZIC0gcC5wYWRUb3AgPCBwLm1pblkpIHtcbiAgICBwLm1pblkgPSBub2RlLm1pblkgLSBwLnBhZFRvcDtcbiAgICBmbGFnID0gdHJ1ZTsgLy8gcyArPSBcIlxcbk5ldyBtaW5ZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblk7XG4gIH0gLy8gSWYgdXBkYXRlZCBib3VuZGFyaWVzLCBwcm9wYWdhdGUgY2hhbmdlcyB1cHdhcmRcblxuXG4gIGlmIChmbGFnKSB7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgcmV0dXJuIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhwLCBsYXlvdXRJbmZvKTtcbiAgfSAvLyBzICs9IFwiLiBObyBjaGFuZ2VzIGluIGJvdW5kYXJpZXMvcG9zaXRpb24gb2YgcGFyZW50IG5vZGUgXCIgKyBwLmlkO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuXG4gIHJldHVybjtcbn07XG5cbnZhciBzZXBhcmF0ZUNvbXBvbmVudHMgPSBmdW5jdGlvbiBzZXBhcmF0ZUNvbXBvbmVudHMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICB2YXIgbm9kZXMgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzO1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIHZhciBjaWQgPSBub2RlLmNtcHRJZDtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdID0gY29tcG9uZW50c1tjaWRdIHx8IFtdO1xuICAgIGNvbXBvbmVudC5wdXNoKG5vZGUpO1xuICB9XG5cbiAgdmFyIHRvdGFsQSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuXG4gICAgaWYgKCFjKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjLngxID0gSW5maW5pdHk7XG4gICAgYy54MiA9IC1JbmZpbml0eTtcbiAgICBjLnkxID0gSW5maW5pdHk7XG4gICAgYy55MiA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIG4gPSBjW2pdO1xuICAgICAgYy54MSA9IE1hdGgubWluKGMueDEsIG4ucG9zaXRpb25YIC0gbi53aWR0aCAvIDIpO1xuICAgICAgYy54MiA9IE1hdGgubWF4KGMueDIsIG4ucG9zaXRpb25YICsgbi53aWR0aCAvIDIpO1xuICAgICAgYy55MSA9IE1hdGgubWluKGMueTEsIG4ucG9zaXRpb25ZIC0gbi5oZWlnaHQgLyAyKTtcbiAgICAgIGMueTIgPSBNYXRoLm1heChjLnkyLCBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0IC8gMik7XG4gICAgfVxuXG4gICAgYy53ID0gYy54MiAtIGMueDE7XG4gICAgYy5oID0gYy55MiAtIGMueTE7XG4gICAgdG90YWxBICs9IGMudyAqIGMuaDtcbiAgfVxuXG4gIGNvbXBvbmVudHMuc29ydChmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMyLncgKiBjMi5oIC0gYzEudyAqIGMxLmg7XG4gIH0pO1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcbiAgdmFyIHVzZWRXID0gMDtcbiAgdmFyIHJvd0ggPSAwO1xuICB2YXIgbWF4Um93VyA9IE1hdGguc3FydCh0b3RhbEEpICogbGF5b3V0SW5mby5jbGllbnRXaWR0aCAvIGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcblxuICAgIGlmICghYykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbiA9IGNbal07XG5cbiAgICAgIGlmICghbi5pc0xvY2tlZCkge1xuICAgICAgICBuLnBvc2l0aW9uWCArPSB4IC0gYy54MTtcbiAgICAgICAgbi5wb3NpdGlvblkgKz0geSAtIGMueTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeCArPSBjLncgKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgdXNlZFcgKz0gYy53ICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgIHJvd0ggPSBNYXRoLm1heChyb3dILCBjLmgpO1xuXG4gICAgaWYgKHVzZWRXID4gbWF4Um93Vykge1xuICAgICAgeSArPSByb3dIICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgeCA9IDA7XG4gICAgICB1c2VkVyA9IDA7XG4gICAgICByb3dIID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0cyRkID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsXG4gIC8vIHBhZGRpbmcgdXNlZCBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBhdm9pZE92ZXJsYXBQYWRkaW5nOiAxMCxcbiAgLy8gZXh0cmEgc3BhY2luZyBhcm91bmQgbm9kZXMgd2hlbiBhdm9pZE92ZXJsYXA6IHRydWVcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBjb25kZW5zZTogZmFsc2UsXG4gIC8vIHVzZXMgYWxsIGF2YWlsYWJsZSBzcGFjZSBvbiBmYWxzZSwgdXNlcyBtaW5pbWFsIHNwYWNlIG9uIHRydWVcbiAgcm93czogdW5kZWZpbmVkLFxuICAvLyBmb3JjZSBudW0gb2Ygcm93cyBpbiB0aGUgZ3JpZFxuICBjb2xzOiB1bmRlZmluZWQsXG4gIC8vIGZvcmNlIG51bSBvZiBjb2x1bW5zIGluIHRoZSBncmlkXG4gIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbihub2RlKSB7fSxcbiAgLy8gcmV0dXJucyB7IHJvdywgY29sIH0gZm9yIGVsZW1lbnRcbiAgc29ydDogdW5kZWZpbmVkLFxuICAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG5cbn07XG5cbmZ1bmN0aW9uIEdyaWRMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJGQsIG9wdGlvbnMpO1xufVxuXG5HcmlkTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG5cbiAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgIG5vZGVzID0gbm9kZXMuc29ydChvcHRpb25zLnNvcnQpO1xuICB9XG5cbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG5cbiAgaWYgKGJiLmggPT09IDAgfHwgYmIudyA9PT0gMCkge1xuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSxcbiAgICAgICAgeTogYmIueTFcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gd2lkdGgvaGVpZ2h0ICogc3BsaXRzXjIgPSBjZWxscyB3aGVyZSBzcGxpdHMgaXMgbnVtYmVyIG9mIHRpbWVzIHRvIHNwbGl0IHdpZHRoXG4gICAgdmFyIGNlbGxzID0gbm9kZXMuc2l6ZSgpO1xuICAgIHZhciBzcGxpdHMgPSBNYXRoLnNxcnQoY2VsbHMgKiBiYi5oIC8gYmIudyk7XG4gICAgdmFyIHJvd3MgPSBNYXRoLnJvdW5kKHNwbGl0cyk7XG4gICAgdmFyIGNvbHMgPSBNYXRoLnJvdW5kKGJiLncgLyBiYi5oICogc3BsaXRzKTtcblxuICAgIHZhciBzbWFsbCA9IGZ1bmN0aW9uIHNtYWxsKHZhbCkge1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihyb3dzLCBjb2xzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyb3dzLCBjb2xzKTtcblxuICAgICAgICBpZiAobWluID09IHJvd3MpIHtcbiAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxhcmdlID0gZnVuY3Rpb24gbGFyZ2UodmFsKSB7XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuXG4gICAgICAgIGlmIChtYXggPT0gcm93cykge1xuICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb1Jvd3MgPSBvcHRpb25zLnJvd3M7XG4gICAgdmFyIG9Db2xzID0gb3B0aW9ucy5jb2xzICE9IG51bGwgPyBvcHRpb25zLmNvbHMgOiBvcHRpb25zLmNvbHVtbnM7IC8vIGlmIHJvd3Mgb3IgY29sdW1ucyB3ZXJlIHNldCBpbiBvcHRpb25zLCB1c2UgdGhvc2UgdmFsdWVzXG5cbiAgICBpZiAob1Jvd3MgIT0gbnVsbCAmJiBvQ29scyAhPSBudWxsKSB7XG4gICAgICByb3dzID0gb1Jvd3M7XG4gICAgICBjb2xzID0gb0NvbHM7XG4gICAgfSBlbHNlIGlmIChvUm93cyAhPSBudWxsICYmIG9Db2xzID09IG51bGwpIHtcbiAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgIGNvbHMgPSBNYXRoLmNlaWwoY2VsbHMgLyByb3dzKTtcbiAgICB9IGVsc2UgaWYgKG9Sb3dzID09IG51bGwgJiYgb0NvbHMgIT0gbnVsbCkge1xuICAgICAgY29scyA9IG9Db2xzO1xuICAgICAgcm93cyA9IE1hdGguY2VpbChjZWxscyAvIGNvbHMpO1xuICAgIH0gLy8gb3RoZXJ3aXNlIHVzZSB0aGUgYXV0b21hdGljIHZhbHVlcyBhbmQgYWRqdXN0IGFjY29yZGluZ2x5XG4gICAgLy8gaWYgcm91bmRpbmcgd2FzIHVwLCBzZWUgaWYgd2UgY2FuIHJlZHVjZSByb3dzIG9yIGNvbHVtbnNcbiAgICBlbHNlIGlmIChjb2xzICogcm93cyA+IGNlbGxzKSB7XG4gICAgICAgIHZhciBzbSA9IHNtYWxsKCk7XG4gICAgICAgIHZhciBsZyA9IGxhcmdlKCk7IC8vIHJlZHVjaW5nIHRoZSBzbWFsbCBzaWRlIHRha2VzIGF3YXkgdGhlIG1vc3QgY2VsbHMsIHNvIHRyeSBpdCBmaXJzdFxuXG4gICAgICAgIGlmICgoc20gLSAxKSAqIGxnID49IGNlbGxzKSB7XG4gICAgICAgICAgc21hbGwoc20gLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmICgobGcgLSAxKSAqIHNtID49IGNlbGxzKSB7XG4gICAgICAgICAgbGFyZ2UobGcgLSAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgcm91bmRpbmcgd2FzIHRvbyBsb3csIGFkZCByb3dzIG9yIGNvbHVtbnNcbiAgICAgICAgd2hpbGUgKGNvbHMgKiByb3dzIDwgY2VsbHMpIHtcbiAgICAgICAgICB2YXIgX3NtID0gc21hbGwoKTtcblxuICAgICAgICAgIHZhciBfbGcgPSBsYXJnZSgpOyAvLyB0cnkgdG8gYWRkIHRvIGxhcmdlciBzaWRlIGZpcnN0IChhZGRzIGxlc3MgaW4gbXVsdGlwbGljYXRpb24pXG5cblxuICAgICAgICAgIGlmICgoX2xnICsgMSkgKiBfc20gPj0gY2VsbHMpIHtcbiAgICAgICAgICAgIGxhcmdlKF9sZyArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbWFsbChfc20gKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIHZhciBjZWxsV2lkdGggPSBiYi53IC8gY29scztcbiAgICB2YXIgY2VsbEhlaWdodCA9IGJiLmggLyByb3dzO1xuXG4gICAgaWYgKG9wdGlvbnMuY29uZGVuc2UpIHtcbiAgICAgIGNlbGxXaWR0aCA9IDA7XG4gICAgICBjZWxsSGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgaWYgKHBvcy54ID09IG51bGwgfHwgcG9zLnkgPT0gbnVsbCkge1xuICAgICAgICAgIC8vIGZvciBiYlxuICAgICAgICAgIHBvcy54ID0gMDtcbiAgICAgICAgICBwb3MueSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmJiID0gbm9kZS5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgcCA9IG9wdGlvbnMuYXZvaWRPdmVybGFwUGFkZGluZztcbiAgICAgICAgdmFyIHcgPSBuYmIudyArIHA7XG4gICAgICAgIHZhciBoID0gbmJiLmggKyBwO1xuICAgICAgICBjZWxsV2lkdGggPSBNYXRoLm1heChjZWxsV2lkdGgsIHcpO1xuICAgICAgICBjZWxsSGVpZ2h0ID0gTWF0aC5tYXgoY2VsbEhlaWdodCwgaCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNlbGxVc2VkID0ge307IC8vIGUuZy4gJ2MtMC0yJyA9PiB0cnVlXG5cbiAgICB2YXIgdXNlZCA9IGZ1bmN0aW9uIHVzZWQocm93LCBjb2wpIHtcbiAgICAgIHJldHVybiBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA/IHRydWUgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHVzZSA9IGZ1bmN0aW9uIHVzZShyb3csIGNvbCkge1xuICAgICAgY2VsbFVzZWRbJ2MtJyArIHJvdyArICctJyArIGNvbF0gPSB0cnVlO1xuICAgIH07IC8vIHRvIGtlZXAgdHJhY2sgb2YgY3VycmVudCBjZWxsIHBvc2l0aW9uXG5cblxuICAgIHZhciByb3cgPSAwO1xuICAgIHZhciBjb2wgPSAwO1xuXG4gICAgdmFyIG1vdmVUb05leHRDZWxsID0gZnVuY3Rpb24gbW92ZVRvTmV4dENlbGwoKSB7XG4gICAgICBjb2wrKztcblxuICAgICAgaWYgKGNvbCA+PSBjb2xzKSB7XG4gICAgICAgIGNvbCA9IDA7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuICAgIH07IC8vIGdldCBhIGNhY2hlIG9mIGFsbCB0aGUgbWFudWFsIHBvc2l0aW9uc1xuXG5cbiAgICB2YXIgaWQybWFuUG9zID0ge307XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG4gICAgICB2YXIgcmNQb3MgPSBvcHRpb25zLnBvc2l0aW9uKF9ub2RlKTtcblxuICAgICAgaWYgKHJjUG9zICYmIChyY1Bvcy5yb3cgIT09IHVuZGVmaW5lZCB8fCByY1Bvcy5jb2wgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHJvdyBvciBjb2wgZGVmJ2RcbiAgICAgICAgdmFyIF9wb3MgPSB7XG4gICAgICAgICAgcm93OiByY1Bvcy5yb3csXG4gICAgICAgICAgY29sOiByY1Bvcy5jb2xcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoX3Bvcy5jb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGZpbmQgdW51c2VkIGNvbFxuICAgICAgICAgIF9wb3MuY29sID0gMDtcblxuICAgICAgICAgIHdoaWxlICh1c2VkKF9wb3Mucm93LCBfcG9zLmNvbCkpIHtcbiAgICAgICAgICAgIF9wb3MuY29sKys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF9wb3Mucm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaW5kIHVudXNlZCByb3dcbiAgICAgICAgICBfcG9zLnJvdyA9IDA7XG5cbiAgICAgICAgICB3aGlsZSAodXNlZChfcG9zLnJvdywgX3Bvcy5jb2wpKSB7XG4gICAgICAgICAgICBfcG9zLnJvdysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlkMm1hblBvc1tfbm9kZS5pZCgpXSA9IF9wb3M7XG4gICAgICAgIHVzZShfcG9zLnJvdywgX3Bvcy5jb2wpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3MoZWxlbWVudCwgaSkge1xuICAgICAgdmFyIHgsIHk7XG5cbiAgICAgIGlmIChlbGVtZW50LmxvY2tlZCgpIHx8IGVsZW1lbnQuaXNQYXJlbnQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIHNlZSBpZiB3ZSBoYXZlIGEgbWFudWFsIHBvc2l0aW9uIHNldFxuXG5cbiAgICAgIHZhciByY1BvcyA9IGlkMm1hblBvc1tlbGVtZW50LmlkKCldO1xuXG4gICAgICBpZiAocmNQb3MpIHtcbiAgICAgICAgeCA9IHJjUG9zLmNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aCAvIDIgKyBiYi54MTtcbiAgICAgICAgeSA9IHJjUG9zLnJvdyAqIGNlbGxIZWlnaHQgKyBjZWxsSGVpZ2h0IC8gMiArIGJiLnkxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIHdoaWxlICh1c2VkKHJvdywgY29sKSkge1xuICAgICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoIC8gMiArIGJiLngxO1xuICAgICAgICB5ID0gcm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQgLyAyICsgYmIueTE7XG4gICAgICAgIHVzZShyb3csIGNvbCk7XG4gICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3MpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgZGVmYXVsdHMkZSA9IHtcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gIC8vIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSAvLyBvbiBsYXlvdXRzdG9wXG5cbn07IC8vIGNvbnN0cnVjdG9yXG4vLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcblxuZnVuY3Rpb24gTnVsbExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkZSwgb3B0aW9ucyk7XG59IC8vIHJ1bnMgdGhlIGxheW91dFxuXG5cbk51bGxMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBlbGVtZW50cyB0byBjb25zaWRlciBpbiB0aGUgbGF5b3V0XG5cbiAgdmFyIGxheW91dCA9IHRoaXM7IC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgLy8gKGRpc2FibGUgZXNsaW50IGZvciBuZXh0IGxpbmUgYXMgdGhpcyBzZXJ2ZXMgYXMgZXhhbXBsZSBsYXlvdXQgY29kZSB0byBleHRlcm5hbCBkZXZlbG9wZXJzKVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICBsYXlvdXQuZW1pdCgnbGF5b3V0c3RhcnQnKTsgLy8gcHV0cyBhbGwgbm9kZXMgYXQgKDAsIDApXG4gIC8vIG4uYi4gbW9zdCBsYXlvdXRzIHdvdWxkIHVzZSBsYXlvdXRQb3NpdGlvbnMoKSwgaW5zdGVhZCBvZiBwb3NpdGlvbnMoKSBhbmQgbWFudWFsIGV2ZW50c1xuXG4gIGVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH0pOyAvLyB0cmlnZ2VyIGxheW91dHJlYWR5IHdoZW4gZWFjaCBub2RlIGhhcyBoYWQgaXRzIHBvc2l0aW9uIHNldCBhdCBsZWFzdCBvbmNlXG5cbiAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgbGF5b3V0LmVtaXQoJ2xheW91dHJlYWR5Jyk7IC8vIHRyaWdnZXIgbGF5b3V0c3RvcCB3aGVuIHRoZSBsYXlvdXQgc3RvcHMgKGUuZy4gZmluaXNoZXMpXG5cbiAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gIGxheW91dC5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTsgLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG5cblxuTnVsbExheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgZGVmYXVsdHMkZiA9IHtcbiAgcG9zaXRpb25zOiB1bmRlZmluZWQsXG4gIC8vIG1hcCBvZiAobm9kZSBpZCkgPT4gKHBvc2l0aW9uIG9iaik7IG9yIGZ1bmN0aW9uKG5vZGUpeyByZXR1cm4gc29tUG9zOyB9XG4gIHpvb206IHVuZGVmaW5lZCxcbiAgLy8gdGhlIHpvb20gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICBwYW46IHVuZGVmaW5lZCxcbiAgLy8gdGhlIHBhbiBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgcGFkZGluZzogMzAsXG4gIC8vIHBhZGRpbmcgb24gZml0XG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0c1xuXG59O1xuXG5mdW5jdGlvbiBQcmVzZXRMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJGYsIG9wdGlvbnMpO1xufVxuXG5QcmVzZXRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBwb3NJc0ZuID0gZm4ob3B0aW9ucy5wb3NpdGlvbnMpO1xuXG4gIGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpIHtcbiAgICBpZiAob3B0aW9ucy5wb3NpdGlvbnMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvcHlQb3NpdGlvbihub2RlLnBvc2l0aW9uKCkpO1xuICAgIH1cblxuICAgIGlmIChwb3NJc0ZuKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5wb3NpdGlvbnMobm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIHBvcyA9IG9wdGlvbnMucG9zaXRpb25zW25vZGUuX3ByaXZhdGUuZGF0YS5pZF07XG5cbiAgICBpZiAocG9zID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwb3M7XG4gIH1cblxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihub2RlKTtcblxuICAgIGlmIChub2RlLmxvY2tlZCgpIHx8IHBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0pO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyRnID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gIHBhZGRpbmc6IDMwLFxuICAvLyBmaXQgcGFkZGluZ1xuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxuXG59O1xuXG5mdW5jdGlvbiBSYW5kb21MYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJGcsIG9wdGlvbnMpO1xufVxuXG5SYW5kb21MYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuXG4gIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3Mobm9kZSwgaSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBiYi54MSArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGJiLncpLFxuICAgICAgeTogYmIueTEgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBiYi5oKVxuICAgIH07XG4gIH07XG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGxheW91dCA9IFt7XG4gIG5hbWU6ICdicmVhZHRoZmlyc3QnLFxuICBpbXBsOiBCcmVhZHRoRmlyc3RMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2NpcmNsZScsXG4gIGltcGw6IENpcmNsZUxheW91dFxufSwge1xuICBuYW1lOiAnY29uY2VudHJpYycsXG4gIGltcGw6IENvbmNlbnRyaWNMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2Nvc2UnLFxuICBpbXBsOiBDb3NlTGF5b3V0XG59LCB7XG4gIG5hbWU6ICdncmlkJyxcbiAgaW1wbDogR3JpZExheW91dFxufSwge1xuICBuYW1lOiAnbnVsbCcsXG4gIGltcGw6IE51bGxMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ3ByZXNldCcsXG4gIGltcGw6IFByZXNldExheW91dFxufSwge1xuICBuYW1lOiAncmFuZG9tJyxcbiAgaW1wbDogUmFuZG9tTGF5b3V0XG59XTtcblxuZnVuY3Rpb24gTnVsbFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5ub3RpZmljYXRpb25zID0gMDsgLy8gZm9yIHRlc3Rpbmdcbn1cblxudmFyIG5vb3AkMSA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIHRocm93SW1nRXJyID0gZnVuY3Rpb24gdGhyb3dJbWdFcnIoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQSBoZWFkbGVzcyBpbnN0YW5jZSBjYW4gbm90IHJlbmRlciBpbWFnZXMnKTtcbn07XG5cbk51bGxSZW5kZXJlci5wcm90b3R5cGUgPSB7XG4gIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZTogbm9vcCQxLFxuICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMrKztcbiAgfSxcbiAgaW5pdDogbm9vcCQxLFxuICBpc0hlYWRsZXNzOiBmdW5jdGlvbiBpc0hlYWRsZXNzKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwbmc6IHRocm93SW1nRXJyLFxuICBqcGc6IHRocm93SW1nRXJyXG59O1xuXG52YXIgQlJwID0ge307XG5CUnAuYXJyb3dTaGFwZVdpZHRoID0gMC4zO1xuXG5CUnAucmVnaXN0ZXJBcnJvd1NoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycm93U2hhcGVzID0gdGhpcy5hcnJvd1NoYXBlcyA9IHt9O1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzOyAvLyBDb250cmFjdCBmb3IgYXJyb3cgc2hhcGVzOlxuICAvLyAwLCAwIGlzIGFycm93IHRpcFxuICAvLyAoMCwgMSkgaXMgZGlyZWN0aW9uIHRvd2FyZHMgbm9kZVxuICAvLyAoMSwgMCkgaXMgcmlnaHRcbiAgLy9cbiAgLy8gZnVuY3Rpb25hbCBhcGk6XG4gIC8vIGNvbGxpZGU6IGNoZWNrIHgsIHkgaW4gc2hhcGVcbiAgLy8gcm91Z2hDb2xsaWRlOiBjYWxsZWQgYmVmb3JlIGNvbGxpZGUsIG5vIGZhbHNlIG5lZ2F0aXZlc1xuICAvLyBkcmF3OiBkcmF3XG4gIC8vIHNwYWNpbmc6IGRpc3QoYXJyb3dUaXAsIG5vZGVCb3VuZGFyeSlcbiAgLy8gZ2FwOiBkaXN0KGVkZ2VUaXAsIG5vZGVCb3VuZGFyeSksIGVkZ2VUaXAgbWF5ICE9IGFycm93VGlwXG5cbiAgdmFyIGJiQ29sbGlkZSA9IGZ1bmN0aW9uIGJiQ29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgIHZhciB4MSA9IHRyYW5zbGF0aW9uLnggLSBzaXplIC8gMiAtIHBhZGRpbmc7XG4gICAgdmFyIHgyID0gdHJhbnNsYXRpb24ueCArIHNpemUgLyAyICsgcGFkZGluZztcbiAgICB2YXIgeTEgPSB0cmFuc2xhdGlvbi55IC0gc2l6ZSAvIDIgLSBwYWRkaW5nO1xuICAgIHZhciB5MiA9IHRyYW5zbGF0aW9uLnkgKyBzaXplIC8gMiArIHBhZGRpbmc7XG4gICAgdmFyIGluc2lkZSA9IHgxIDw9IHggJiYgeCA8PSB4MiAmJiB5MSA8PSB5ICYmIHkgPD0geTI7XG4gICAgcmV0dXJuIGluc2lkZTtcbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgIHZhciB4Um90YXRlZCA9IHggKiBNYXRoLmNvcyhhbmdsZSkgLSB5ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciB5Um90YXRlZCA9IHggKiBNYXRoLnNpbihhbmdsZSkgKyB5ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciB4U2NhbGVkID0geFJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB5U2NhbGVkID0geVJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB4VHJhbnNsYXRlZCA9IHhTY2FsZWQgKyB0cmFuc2xhdGlvbi54O1xuICAgIHZhciB5VHJhbnNsYXRlZCA9IHlTY2FsZWQgKyB0cmFuc2xhdGlvbi55O1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4VHJhbnNsYXRlZCxcbiAgICAgIHk6IHlUcmFuc2xhdGVkXG4gICAgfTtcbiAgfTtcblxuICB2YXIgdHJhbnNmb3JtUG9pbnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnRzKHB0cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgdmFyIHJldFB0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciB4ID0gcHRzW2ldO1xuICAgICAgdmFyIHkgPSBwdHNbaSArIDFdO1xuICAgICAgcmV0UHRzLnB1c2godHJhbnNmb3JtKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgIH1cblxuICAgIHJldHVybiByZXRQdHM7XG4gIH07XG5cbiAgdmFyIHBvaW50c1RvQXJyID0gZnVuY3Rpb24gcG9pbnRzVG9BcnIocHRzKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcHRzW2ldO1xuICAgICAgcmV0LnB1c2gocC54LCBwLnkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgdmFyIHN0YW5kYXJkR2FwID0gZnVuY3Rpb24gc3RhbmRhcmRHYXAoZWRnZSkge1xuICAgIHJldHVybiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykucGZWYWx1ZSAqIDI7XG4gIH07XG5cbiAgdmFyIGRlZmluZUFycm93U2hhcGUgPSBmdW5jdGlvbiBkZWZpbmVBcnJvd1NoYXBlKG5hbWUsIGRlZm4pIHtcbiAgICBpZiAoc3RyaW5nKGRlZm4pKSB7XG4gICAgICBkZWZuID0gYXJyb3dTaGFwZXNbZGVmbl07XG4gICAgfVxuXG4gICAgYXJyb3dTaGFwZXNbbmFtZV0gPSBleHRlbmQoe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLjE1LCAtMC4zLCAwLjE1LCAwLjMsIC0wLjE1LCAwLjNdLFxuICAgICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpO1xuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgfSxcbiAgICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwoJ3BvbHlnb24nKShjb250ZXh0LCBwb2ludHMpO1xuICAgICAgfSxcbiAgICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBnYXA6IHN0YW5kYXJkR2FwXG4gICAgfSwgZGVmbik7XG4gIH07XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSgnbm9uZScsIHtcbiAgICBjb2xsaWRlOiBmYWxzaWZ5LFxuICAgIHJvdWdoQ29sbGlkZTogZmFsc2lmeSxcbiAgICBkcmF3OiBub29wLFxuICAgIHNwYWNpbmc6IHplcm9pZnksXG4gICAgZ2FwOiB6ZXJvaWZ5XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd0cmlhbmdsZScsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgLTAuMywgMCwgMCwgMC4xNSwgLTAuM11cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2Fycm93JywgJ3RyaWFuZ2xlJyk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLWJhY2tjdXJ2ZScsIHtcbiAgICBwb2ludHM6IGFycm93U2hhcGVzWyd0cmlhbmdsZSddLnBvaW50cyxcbiAgICBjb250cm9sUG9pbnQ6IFswLCAtMC4xNV0sXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgdmFyIHB0c1RyYW5zID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgdmFyIGN0cmxQdCA9IHRoaXMuY29udHJvbFBvaW50O1xuICAgICAgdmFyIGN0cmxQdFRyYW5zID0gdHJhbnNmb3JtKGN0cmxQdFswXSwgY3RybFB0WzFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCBwdHNUcmFucywgY3RybFB0VHJhbnMpO1xuICAgIH0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC44O1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLXRlZScsIHtcbiAgICBwb2ludHM6IFswLCAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuMywgMCwgMF0sXG4gICAgcG9pbnRzVGVlOiBbLTAuMTUsIC0wLjQsIC0wLjE1LCAtMC41LCAwLjE1LCAtMC41LCAwLjE1LCAtMC40XSxcbiAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RlZSwgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHZhciBpbnNpZGUgPSBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdHJpUHRzKSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdGVlUHRzKTtcbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgdmFyIHRlZVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RlZSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJpUHRzLCB0ZWVQdHMpO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLWNyb3NzJywge1xuICAgIHBvaW50czogWzAsIDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zLCAwLCAwXSxcbiAgICBiYXNlQ3Jvc3NMaW5lUHRzOiBbLTAuMTUsIC0wLjQsIC8vIGZpcnN0IGhhbGYgb2YgdGhlIHJlY3RhbmdsZVxuICAgIC0wLjE1LCAtMC40LCAwLjE1LCAtMC40LCAvLyBzZWNvbmQgaGFsZiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgMC4xNSwgLTAuNF0sXG4gICAgY3Jvc3NMaW5lUHRzOiBmdW5jdGlvbiBjcm9zc0xpbmVQdHMoc2l6ZSwgZWRnZVdpZHRoKSB7XG4gICAgICAvLyBzaGlmdCBwb2ludHMgc28gdGhhdCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3Jvc3MgcG9pbnRzIG1hdGNoZXMgZWRnZSB3aWR0aFxuICAgICAgdmFyIHAgPSB0aGlzLmJhc2VDcm9zc0xpbmVQdHMuc2xpY2UoKTtcbiAgICAgIHZhciBzaGlmdEZhY3RvciA9IGVkZ2VXaWR0aCAvIHNpemU7XG4gICAgICB2YXIgeTAgPSAzO1xuICAgICAgdmFyIHkxID0gNTtcbiAgICAgIHBbeTBdID0gcFt5MF0gLSBzaGlmdEZhY3RvcjtcbiAgICAgIHBbeTFdID0gcFt5MV0gLSBzaGlmdEZhY3RvcjtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgdmFyIHRyaVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHZhciB0ZWVQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5jcm9zc0xpbmVQdHMoc2l6ZSwgZWRnZVdpZHRoKSwgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHZhciBpbnNpZGUgPSBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdHJpUHRzKSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdGVlUHRzKTtcbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgdmFyIGNyb3NzTGluZVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLmNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmlQdHMsIGNyb3NzTGluZVB0cyk7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndmVlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLCAwLCAwLjE1LCAtMC4zLCAwLCAtMC4xNV0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC41MjU7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnY2lyY2xlJywge1xuICAgIHJhZGl1czogMC4xNSxcbiAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdCA9IHRyYW5zbGF0aW9uO1xuICAgICAgdmFyIGluc2lkZSA9IE1hdGgucG93KHQueCAtIHgsIDIpICsgTWF0aC5wb3codC55IC0geSwgMikgPD0gTWF0aC5wb3coKHNpemUgKyAyICogcGFkZGluZykgKiB0aGlzLnJhZGl1cywgMik7XG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55LCB0aGlzLnJhZGl1cyAqIHNpemUpO1xuICAgIH0sXG4gICAgc3BhY2luZzogZnVuY3Rpb24gc3BhY2luZyhlZGdlKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLnJhZGl1cztcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd0ZWUnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIDAsIC0wLjE1LCAtMC4xLCAwLjE1LCAtMC4xLCAwLjE1LCAwXSxcbiAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnc3F1YXJlJywge1xuICAgIHBvaW50czogWy0wLjE1LCAwLjAwLCAwLjE1LCAwLjAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuM11cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2RpYW1vbmQnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIC0wLjE1LCAwLCAtMC4zLCAwLjE1LCAtMC4xNSwgMCwgMF0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUgKiBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdjaGV2cm9uJywge1xuICAgIHBvaW50czogWzAsIDAsIC0wLjE1LCAtMC4xNSwgLTAuMSwgLTAuMiwgMCwgLTAuMSwgMC4xLCAtMC4yLCAwLjE1LCAtMC4xNV0sXG4gICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgcmV0dXJuIDAuOTUgKiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBCUnAkMSA9IHt9OyAvLyBQcm9qZWN0IG1vdXNlXG5cbkJScCQxLnByb2plY3RJbnRvVmlld3BvcnQgPSBmdW5jdGlvbiAoY2xpZW50WCwgY2xpZW50WSkge1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgb2Zmc2V0cyA9IHRoaXMuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gIHZhciBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICB2YXIgc2NhbGUgPSBvZmZzZXRzWzRdO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgeCA9ICgoY2xpZW50WCAtIG9mZnNldExlZnQpIC8gc2NhbGUgLSBwYW4ueCkgLyB6b29tO1xuICB2YXIgeSA9ICgoY2xpZW50WSAtIG9mZnNldFRvcCkgLyBzY2FsZSAtIHBhbi55KSAvIHpvb207XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG5CUnAkMS5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb250YWluZXJCQikge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckJCO1xuICB9XG5cbiAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHN0eWxlID0gd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuXG4gIHZhciBzdHlsZVZhbHVlID0gZnVuY3Rpb24gc3R5bGVWYWx1ZShuYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSk7XG4gIH07XG5cbiAgdmFyIHBhZGRpbmcgPSB7XG4gICAgbGVmdDogc3R5bGVWYWx1ZSgncGFkZGluZy1sZWZ0JyksXG4gICAgcmlnaHQ6IHN0eWxlVmFsdWUoJ3BhZGRpbmctcmlnaHQnKSxcbiAgICB0b3A6IHN0eWxlVmFsdWUoJ3BhZGRpbmctdG9wJyksXG4gICAgYm90dG9tOiBzdHlsZVZhbHVlKCdwYWRkaW5nLWJvdHRvbScpXG4gIH07XG4gIHZhciBib3JkZXIgPSB7XG4gICAgbGVmdDogc3R5bGVWYWx1ZSgnYm9yZGVyLWxlZnQtd2lkdGgnKSxcbiAgICByaWdodDogc3R5bGVWYWx1ZSgnYm9yZGVyLXJpZ2h0LXdpZHRoJyksXG4gICAgdG9wOiBzdHlsZVZhbHVlKCdib3JkZXItdG9wLXdpZHRoJyksXG4gICAgYm90dG9tOiBzdHlsZVZhbHVlKCdib3JkZXItYm90dG9tLXdpZHRoJylcbiAgfTtcbiAgdmFyIGNsaWVudFdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICB2YXIgY2xpZW50SGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgdmFyIHBhZGRpbmdIb3IgPSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuICB2YXIgcGFkZGluZ1ZlciA9IHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG4gIHZhciBib3JkZXJIb3IgPSBib3JkZXIubGVmdCArIGJvcmRlci5yaWdodDtcbiAgdmFyIHNjYWxlID0gcmVjdC53aWR0aCAvIChjbGllbnRXaWR0aCArIGJvcmRlckhvcik7XG4gIHZhciB1bnNjYWxlZFcgPSBjbGllbnRXaWR0aCAtIHBhZGRpbmdIb3I7XG4gIHZhciB1bnNjYWxlZEggPSBjbGllbnRIZWlnaHQgLSBwYWRkaW5nVmVyO1xuICB2YXIgbGVmdCA9IHJlY3QubGVmdCArIHBhZGRpbmcubGVmdCArIGJvcmRlci5sZWZ0O1xuICB2YXIgdG9wID0gcmVjdC50b3AgKyBwYWRkaW5nLnRvcCArIGJvcmRlci50b3A7XG4gIHJldHVybiB0aGlzLmNvbnRhaW5lckJCID0gW2xlZnQsIHRvcCwgdW5zY2FsZWRXLCB1bnNjYWxlZEgsIHNjYWxlXTtcbn07XG5cbkJScCQxLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb250YWluZXJCQiA9IG51bGw7XG59O1xuXG5CUnAkMS5maW5kTmVhcmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpIHtcbiAgcmV0dXJuIHRoaXMuZmluZE5lYXJlc3RFbGVtZW50cyh4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaClbMF07XG59O1xuXG5CUnAkMS5maW5kTmVhcmVzdEVsZW1lbnRzID0gZnVuY3Rpb24gKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgZWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgdmFyIG5lYXIgPSBbXTsgLy8gMSBub2RlIG1heCwgMSBlZGdlIG1heFxuXG4gIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gIHZhciBoYXNDb21wb3VuZHMgPSByLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGVkZ2VUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDI0IDogOCkgLyB6b29tO1xuICB2YXIgbm9kZVRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcbiAgdmFyIGxhYmVsVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuICB2YXIgbWluU3FEaXN0ID0gSW5maW5pdHk7XG4gIHZhciBuZWFyRWRnZTtcbiAgdmFyIG5lYXJOb2RlO1xuXG4gIGlmIChpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSkge1xuICAgIGVsZXMgPSBlbGVzLmludGVyYWN0aXZlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRWxlKGVsZSwgc3FEaXN0KSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgaWYgKG5lYXJOb2RlKSB7XG4gICAgICAgIHJldHVybjsgLy8gY2FuJ3QgcmVwbGFjZSBub2RlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWFyTm9kZSA9IGVsZTtcbiAgICAgICAgbmVhci5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsZS5pc0VkZ2UoKSAmJiAoc3FEaXN0ID09IG51bGwgfHwgc3FEaXN0IDwgbWluU3FEaXN0KSkge1xuICAgICAgaWYgKG5lYXJFZGdlKSB7XG4gICAgICAgIC8vIHRoZW4gcmVwbGFjZSBleGlzdGluZyBlZGdlXG4gICAgICAgIC8vIGNhbiByZXBsYWNlIG9ubHkgaWYgc2FtZSB6LWluZGV4XG4gICAgICAgIGlmIChuZWFyRWRnZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSA9PT0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlICYmIG5lYXJFZGdlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlID09PSBlbGUucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZWFyW2ldLmlzRWRnZSgpKSB7XG4gICAgICAgICAgICAgIG5lYXJbaV0gPSBlbGU7XG4gICAgICAgICAgICAgIG5lYXJFZGdlID0gZWxlO1xuICAgICAgICAgICAgICBtaW5TcURpc3QgPSBzcURpc3QgIT0gbnVsbCA/IHNxRGlzdCA6IG1pblNxRGlzdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWFyLnB1c2goZWxlKTtcbiAgICAgICAgbmVhckVkZ2UgPSBlbGU7XG4gICAgICAgIG1pblNxRGlzdCA9IHNxRGlzdCAhPSBudWxsID8gc3FEaXN0IDogbWluU3FEaXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrTm9kZShub2RlKSB7XG4gICAgdmFyIHdpZHRoID0gbm9kZS5vdXRlcldpZHRoKCkgKyAyICogbm9kZVRocmVzaG9sZDtcbiAgICB2YXIgaGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpICsgMiAqIG5vZGVUaHJlc2hvbGQ7XG4gICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgIGlmIChwb3MueCAtIGh3IDw9IHggJiYgeCA8PSBwb3MueCArIGh3IC8vIGJiIGNoZWNrIHhcbiAgICAmJiBwb3MueSAtIGhoIDw9IHkgJiYgeSA8PSBwb3MueSArIGhoIC8vIGJiIGNoZWNrIHlcbiAgICApIHtcbiAgICAgICAgdmFyIHNoYXBlID0gci5ub2RlU2hhcGVzW3NlbGYuZ2V0Tm9kZVNoYXBlKG5vZGUpXTtcblxuICAgICAgICBpZiAoc2hhcGUuY2hlY2tQb2ludCh4LCB5LCAwLCB3aWR0aCwgaGVpZ2h0LCBwb3MueCwgcG9zLnkpKSB7XG4gICAgICAgICAgYWRkRWxlKG5vZGUsIDApO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0VkZ2UoZWRnZSkge1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHN0eWxlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBzY2FsZSA9IGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgIHZhciB3aWR0aCA9IHN0eWxlV2lkdGggLyAyICsgZWRnZVRocmVzaG9sZDsgLy8gbW9yZSBsaWtlIGEgZGlzdGFuY2UgcmFkaXVzIGZyb20gY2VudHJlXG5cbiAgICB2YXIgd2lkdGhTcSA9IHdpZHRoICogd2lkdGg7XG4gICAgdmFyIHdpZHRoMiA9IHdpZHRoICogMjtcbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIHNxRGlzdDtcblxuICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyAzIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGlmIChpbkxpbmVWaWNpbml0eSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHdpZHRoMikgJiYgd2lkdGhTcSA+IChzcURpc3QgPSBzcWRpc3RUb0Zpbml0ZUxpbmUoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdKSkpIHtcbiAgICAgICAgICBhZGRFbGUoZWRnZSwgc3FEaXN0KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBpZiAoaW5CZXppZXJWaWNpbml0eSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHB0c1tpICsgNF0sIHB0c1tpICsgNV0sIHdpZHRoMikgJiYgd2lkdGhTcSA+IChzcURpc3QgPSBzcWRpc3RUb1F1YWRyYXRpY0Jlemllcih4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHB0c1tpICsgNF0sIHB0c1tpICsgNV0pKSkge1xuICAgICAgICAgIGFkZEVsZShlZGdlLCBzcURpc3QpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBpZiB3ZSdyZSBjbG9zZSB0byB0aGUgZWRnZSBidXQgZGlkbid0IGhpdCBpdCwgbWF5YmUgd2UgaGl0IGl0cyBhcnJvd3NcblxuXG4gICAgdmFyIHNyYyA9IHNyYyB8fCBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IHRndCB8fCBfcC50YXJnZXQ7XG4gICAgdmFyIGFyU2l6ZSA9IHNlbGYuZ2V0QXJyb3dXaWR0aChzdHlsZVdpZHRoLCBzY2FsZSk7XG4gICAgdmFyIGFycm93cyA9IFt7XG4gICAgICBuYW1lOiAnc291cmNlJyxcbiAgICAgIHg6IHJzLmFycm93U3RhcnRYLFxuICAgICAgeTogcnMuYXJyb3dTdGFydFksXG4gICAgICBhbmdsZTogcnMuc3JjQXJyb3dBbmdsZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0YXJnZXQnLFxuICAgICAgeDogcnMuYXJyb3dFbmRYLFxuICAgICAgeTogcnMuYXJyb3dFbmRZLFxuICAgICAgYW5nbGU6IHJzLnRndEFycm93QW5nbGVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWlkLXNvdXJjZScsXG4gICAgICB4OiBycy5taWRYLFxuICAgICAgeTogcnMubWlkWSxcbiAgICAgIGFuZ2xlOiBycy5taWRzcmNBcnJvd0FuZ2xlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ21pZC10YXJnZXQnLFxuICAgICAgeDogcnMubWlkWCxcbiAgICAgIHk6IHJzLm1pZFksXG4gICAgICBhbmdsZTogcnMubWlkdGd0QXJyb3dBbmdsZVxuICAgIH1dO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhciA9IGFycm93c1tpXTtcbiAgICAgIHZhciBzaGFwZSA9IHIuYXJyb3dTaGFwZXNbZWRnZS5wc3R5bGUoYXIubmFtZSArICctYXJyb3ctc2hhcGUnKS52YWx1ZV07XG4gICAgICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcblxuICAgICAgaWYgKHNoYXBlLnJvdWdoQ29sbGlkZSh4LCB5LCBhclNpemUsIGFyLmFuZ2xlLCB7XG4gICAgICAgIHg6IGFyLngsXG4gICAgICAgIHk6IGFyLnlcbiAgICAgIH0sIGVkZ2VXaWR0aCwgZWRnZVRocmVzaG9sZCkgJiYgc2hhcGUuY29sbGlkZSh4LCB5LCBhclNpemUsIGFyLmFuZ2xlLCB7XG4gICAgICAgIHg6IGFyLngsXG4gICAgICAgIHk6IGFyLnlcbiAgICAgIH0sIGVkZ2VXaWR0aCwgZWRnZVRocmVzaG9sZCkpIHtcbiAgICAgICAgYWRkRWxlKGVkZ2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIGZvciBjb21wb3VuZCBncmFwaHMsIGhpdHRpbmcgZWRnZSBtYXkgYWN0dWFsbHkgd2FudCBhIGNvbm5lY3RlZCBub2RlIGluc3RlYWQgKGIvYyBlZGdlIG1heSBoYXZlIGdyZWF0ZXIgei1pbmRleCBwcmVjZWRlbmNlKVxuXG5cbiAgICBpZiAoaGFzQ29tcG91bmRzICYmIG5lYXIubGVuZ3RoID4gMCkge1xuICAgICAgY2hlY2tOb2RlKHNyYyk7XG4gICAgICBjaGVja05vZGUodGd0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwcm9wKG9iaiwgbmFtZSwgcHJlKSB7XG4gICAgcmV0dXJuIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBuYW1lLCBwcmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tMYWJlbChlbGUsIHByZWZpeCkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgdGggPSBsYWJlbFRocmVzaG9sZDtcbiAgICB2YXIgcHJlZml4RGFzaDtcblxuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIHByZWZpeERhc2ggPSBwcmVmaXggKyAnLSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeERhc2ggPSAnJztcbiAgICB9XG5cbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgYmIgPSBfcC5sYWJlbEJvdW5kc1twcmVmaXggfHwgJ21haW4nXTtcbiAgICB2YXIgdGV4dCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICdsYWJlbCcpLnZhbHVlO1xuICAgIHZhciBldmVudHNFbmFibGVkID0gZWxlLnBzdHlsZSgndGV4dC1ldmVudHMnKS5zdHJWYWx1ZSA9PT0gJ3llcyc7XG5cbiAgICBpZiAoIWV2ZW50c0VuYWJsZWQgfHwgIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgIHZhciBseCA9IHByZXByb3AocnN0eWxlLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgICB2YXIgbHkgPSBwcmVwcm9wKHJzdHlsZSwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgdmFyIHRoZXRhID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpO1xuICAgIHZhciBseDEgPSBiYi54MSAtIHRoO1xuICAgIHZhciBseDIgPSBiYi54MiArIHRoO1xuICAgIHZhciBseTEgPSBiYi55MSAtIHRoO1xuICAgIHZhciBseTIgPSBiYi55MiArIHRoO1xuXG4gICAgaWYgKHRoZXRhKSB7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHRoZXRhKTtcblxuICAgICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSh4LCB5KSB7XG4gICAgICAgIHggPSB4IC0gbHg7XG4gICAgICAgIHkgPSB5IC0gbHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyBseCxcbiAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIGx5XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICB2YXIgcHgxeTEgPSByb3RhdGUobHgxLCBseTEpO1xuICAgICAgdmFyIHB4MXkyID0gcm90YXRlKGx4MSwgbHkyKTtcbiAgICAgIHZhciBweDJ5MSA9IHJvdGF0ZShseDIsIGx5MSk7XG4gICAgICB2YXIgcHgyeTIgPSByb3RhdGUobHgyLCBseTIpO1xuICAgICAgdmFyIHBvaW50cyA9IFtweDF5MS54LCBweDF5MS55LCBweDJ5MS54LCBweDJ5MS55LCBweDJ5Mi54LCBweDJ5Mi55LCBweDF5Mi54LCBweDF5Mi55XTtcblxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpKSB7XG4gICAgICAgIGFkZEVsZShlbGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG8gYSBjaGVhcGVyIGJiIGNoZWNrXG4gICAgICBpZiAoaW5Cb3VuZGluZ0JveChiYiwgeCwgeSkpIHtcbiAgICAgICAgYWRkRWxlKGVsZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSBlbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgLy8gcmV2ZXJzZSBvcmRlciBmb3IgcHJlY2VkZW5jZVxuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgY2hlY2tOb2RlKGVsZSkgfHwgY2hlY2tMYWJlbChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGVkZ2VcbiAgICAgIGNoZWNrRWRnZShlbGUpIHx8IGNoZWNrTGFiZWwoZWxlKSB8fCBjaGVja0xhYmVsKGVsZSwgJ3NvdXJjZScpIHx8IGNoZWNrTGFiZWwoZWxlLCAndGFyZ2V0Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lYXI7XG59OyAvLyAnR2l2ZSBtZSBldmVyeXRoaW5nIGZyb20gdGhpcyBib3gnXG5cblxuQlJwJDEuZ2V0QWxsSW5Cb3ggPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIGVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCkuaW50ZXJhY3RpdmU7XG4gIHZhciBib3ggPSBbXTtcbiAgdmFyIHgxYyA9IE1hdGgubWluKHgxLCB4Mik7XG4gIHZhciB4MmMgPSBNYXRoLm1heCh4MSwgeDIpO1xuICB2YXIgeTFjID0gTWF0aC5taW4oeTEsIHkyKTtcbiAgdmFyIHkyYyA9IE1hdGgubWF4KHkxLCB5Mik7XG4gIHgxID0geDFjO1xuICB4MiA9IHgyYztcbiAgeTEgPSB5MWM7XG4gIHkyID0geTJjO1xuICB2YXIgYm94QmIgPSBtYWtlQm91bmRpbmdCb3goe1xuICAgIHgxOiB4MSxcbiAgICB5MTogeTEsXG4gICAgeDI6IHgyLFxuICAgIHkyOiB5MlxuICB9KTtcblxuICBmb3IgKHZhciBlID0gMDsgZSA8IGVsZXMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tlXTtcblxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHZhciBub2RlID0gZWxlO1xuICAgICAgdmFyIG5vZGVCYiA9IG5vZGUuYm91bmRpbmdCb3goe1xuICAgICAgICBpbmNsdWRlTm9kZXM6IHRydWUsXG4gICAgICAgIGluY2x1ZGVFZGdlczogZmFsc2UsXG4gICAgICAgIGluY2x1ZGVMYWJlbHM6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgaWYgKGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYm94QmIsIG5vZGVCYikgJiYgIWJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChub2RlQmIsIGJveEJiKSkge1xuICAgICAgICBib3gucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkZ2UgPSBlbGU7XG4gICAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICAgIGlmIChycy5zdGFydFggIT0gbnVsbCAmJiBycy5zdGFydFkgIT0gbnVsbCAmJiAhaW5Cb3VuZGluZ0JveChib3hCYiwgcnMuc3RhcnRYLCBycy5zdGFydFkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocnMuZW5kWCAhPSBudWxsICYmIHJzLmVuZFkgIT0gbnVsbCAmJiAhaW5Cb3VuZGluZ0JveChib3hCYiwgcnMuZW5kWCwgcnMuZW5kWSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICB2YXIgcHRzID0gX3AucnN0eWxlLmJlemllclB0cyB8fCBfcC5yc3R5bGUubGluZVB0cyB8fCBfcC5yc3R5bGUuaGF5c3RhY2tQdHM7XG4gICAgICAgIHZhciBhbGxJbnNpZGUgPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFwb2ludEluQm91bmRpbmdCb3goYm94QmIsIHB0c1tpXSkpIHtcbiAgICAgICAgICAgIGFsbEluc2lkZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsbEluc2lkZSkge1xuICAgICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snIHx8IHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3g7XG59O1xuXG52YXIgQlJwJDIgPSB7fTtcblxuQlJwJDIuY2FsY3VsYXRlQXJyb3dBbmdsZXMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuICB2YXIgaXNCZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ2Jlemllcic7XG4gIHZhciBpc011bHRpYmV6aWVyID0gcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcic7XG4gIHZhciBpc1NlZ21lbnRzID0gcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cyc7XG4gIHZhciBpc0NvbXBvdW5kID0gcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCc7XG4gIHZhciBpc1NlbGYgPSBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnOyAvLyBEaXNwbGFjZW1lbnQgZ2l2ZXMgZGlyZWN0aW9uIGZvciBhcnJvd2hlYWQgb3JpZW50YXRpb25cblxuICB2YXIgZGlzcFgsIGRpc3BZO1xuICB2YXIgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIG1pZFgsIG1pZFk7XG5cbiAgaWYgKGlzSGF5c3RhY2spIHtcbiAgICBzdGFydFggPSBycy5oYXlzdGFja1B0c1swXTtcbiAgICBzdGFydFkgPSBycy5oYXlzdGFja1B0c1sxXTtcbiAgICBlbmRYID0gcnMuaGF5c3RhY2tQdHNbMl07XG4gICAgZW5kWSA9IHJzLmhheXN0YWNrUHRzWzNdO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0WCA9IHJzLmFycm93U3RhcnRYO1xuICAgIHN0YXJ0WSA9IHJzLmFycm93U3RhcnRZO1xuICAgIGVuZFggPSBycy5hcnJvd0VuZFg7XG4gICAgZW5kWSA9IHJzLmFycm93RW5kWTtcbiAgfVxuXG4gIG1pZFggPSBycy5taWRYO1xuICBtaWRZID0gcnMubWlkWTsgLy8gc291cmNlXG4gIC8vXG5cbiAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICBkaXNwWCA9IHN0YXJ0WCAtIHJzLnNlZ3B0c1swXTtcbiAgICBkaXNwWSA9IHN0YXJ0WSAtIHJzLnNlZ3B0c1sxXTtcbiAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmIHx8IGlzQmV6aWVyKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgYlggPSBxYmV6aWVyQXQocHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC4xKTtcbiAgICB2YXIgYlkgPSBxYmV6aWVyQXQocHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC4xKTtcbiAgICBkaXNwWCA9IHN0YXJ0WCAtIGJYO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gYlk7XG4gIH0gZWxzZSB7XG4gICAgZGlzcFggPSBzdGFydFggLSBtaWRYO1xuICAgIGRpc3BZID0gc3RhcnRZIC0gbWlkWTtcbiAgfVxuXG4gIHJzLnNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7IC8vIG1pZCB0YXJnZXRcbiAgLy9cblxuICB2YXIgbWlkWCA9IHJzLm1pZFg7XG4gIHZhciBtaWRZID0gcnMubWlkWTtcblxuICBpZiAoaXNIYXlzdGFjaykge1xuICAgIG1pZFggPSAoc3RhcnRYICsgZW5kWCkgLyAyO1xuICAgIG1pZFkgPSAoc3RhcnRZICsgZW5kWSkgLyAyO1xuICB9XG5cbiAgZGlzcFggPSBlbmRYIC0gc3RhcnRYO1xuICBkaXNwWSA9IGVuZFkgLSBzdGFydFk7XG5cbiAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgaWYgKHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDI7XG4gICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICBkaXNwWCA9IHB0c1tpMl0gLSBwdHNbaTFdO1xuICAgICAgZGlzcFkgPSBwdHNbaTIgKyAxXSAtIHB0c1tpMSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICB2YXIgaTMgPSBpMiArIDI7XG4gICAgICBkaXNwWCA9IHB0c1tpMl0gLSBwdHNbaTFdO1xuICAgICAgZGlzcFkgPSBwdHNbaTIgKyAxXSAtIHB0c1tpMSArIDFdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgY3B0cyA9IHJzLmN0cmxwdHM7XG4gICAgdmFyIGJwMHgsIGJwMHk7XG4gICAgdmFyIGJwMXgsIGJwMXk7XG5cbiAgICBpZiAoY3B0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgdmFyIHAwID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBzdGFydHB0XG5cbiAgICAgIHZhciBpYyA9IHAwICsgMjtcbiAgICAgIHZhciBwMSA9IGljICsgMjtcbiAgICAgIGJwMHggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC4wKTtcbiAgICAgIGJwMHkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC4wKTtcbiAgICAgIGJwMXggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC4wMDAxKTtcbiAgICAgIGJwMXkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC4wMDAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGljID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBjdHJwdFxuXG4gICAgICB2YXIgcDAgPSBpYyAtIDI7IC8vIHN0YXJ0cHRcblxuICAgICAgdmFyIHAxID0gaWMgKyAyOyAvLyBlbmRwdFxuXG4gICAgICBicDB4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuNDk5OSk7XG4gICAgICBicDB5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuNDk5OSk7XG4gICAgICBicDF4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuNSk7XG4gICAgICBicDF5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuNSk7XG4gICAgfVxuXG4gICAgZGlzcFggPSBicDF4IC0gYnAweDtcbiAgICBkaXNwWSA9IGJwMXkgLSBicDB5O1xuICB9XG5cbiAgcnMubWlkdGd0QXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTtcbiAgcnMubWlkRGlzcFggPSBkaXNwWDtcbiAgcnMubWlkRGlzcFkgPSBkaXNwWTsgLy8gbWlkIHNvdXJjZVxuICAvL1xuXG4gIGRpc3BYICo9IC0xO1xuICBkaXNwWSAqPSAtMTtcblxuICBpZiAoaXNTZWdtZW50cykge1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICBpZiAocHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSA7IGVsc2Uge1xuICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgdmFyIGkzID0gaTIgKyAyO1xuICAgICAgZGlzcFggPSAtKHB0c1tpM10gLSBwdHNbaTJdKTtcbiAgICAgIGRpc3BZID0gLShwdHNbaTMgKyAxXSAtIHB0c1tpMiArIDFdKTtcbiAgICB9XG4gIH1cblxuICBycy5taWRzcmNBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpOyAvLyB0YXJnZXRcbiAgLy9cblxuICBpZiAoaXNTZWdtZW50cykge1xuICAgIGRpc3BYID0gZW5kWCAtIHJzLnNlZ3B0c1tycy5zZWdwdHMubGVuZ3RoIC0gMl07XG4gICAgZGlzcFkgPSBlbmRZIC0gcnMuc2VncHRzW3JzLnNlZ3B0cy5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmIHx8IGlzQmV6aWVyKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgbCA9IHB0cy5sZW5ndGg7XG4gICAgdmFyIGJYID0gcWJlemllckF0KHB0c1tsIC0gNl0sIHB0c1tsIC0gNF0sIHB0c1tsIC0gMl0sIDAuOSk7XG4gICAgdmFyIGJZID0gcWJlemllckF0KHB0c1tsIC0gNV0sIHB0c1tsIC0gM10sIHB0c1tsIC0gMV0sIDAuOSk7XG4gICAgZGlzcFggPSBlbmRYIC0gYlg7XG4gICAgZGlzcFkgPSBlbmRZIC0gYlk7XG4gIH0gZWxzZSB7XG4gICAgZGlzcFggPSBlbmRYIC0gbWlkWDtcbiAgICBkaXNwWSA9IGVuZFkgLSBtaWRZO1xuICB9XG5cbiAgcnMudGd0QXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTtcbn07XG5cbkJScCQyLmdldEFycm93V2lkdGggPSBCUnAkMi5nZXRBcnJvd0hlaWdodCA9IGZ1bmN0aW9uIChlZGdlV2lkdGgsIHNjYWxlKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgfHwge307XG4gIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtlZGdlV2lkdGggKyAnLCAnICsgc2NhbGVdO1xuXG4gIGlmIChjYWNoZWRWYWwpIHtcbiAgICByZXR1cm4gY2FjaGVkVmFsO1xuICB9XG5cbiAgY2FjaGVkVmFsID0gTWF0aC5tYXgoTWF0aC5wb3coZWRnZVdpZHRoICogMTMuMzcsIDAuOSksIDI5KSAqIHNjYWxlO1xuICBjYWNoZVtlZGdlV2lkdGggKyAnLCAnICsgc2NhbGVdID0gY2FjaGVkVmFsO1xuICByZXR1cm4gY2FjaGVkVmFsO1xufTtcblxudmFyIEJScCQzID0ge307XG5cbkJScCQzLmZpbmRIYXlzdGFja1BvaW50cyA9IGZ1bmN0aW9uIChlZGdlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuXG4gICAgaWYgKCFycy5oYXlzdGFjaykge1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgcnMuc291cmNlID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcbiAgICAgIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgcnMudGFyZ2V0ID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIHNyY1BvcyA9IHNyYy5wb3NpdGlvbigpO1xuICAgIHZhciB0Z3RQb3MgPSB0Z3QucG9zaXRpb24oKTtcbiAgICB2YXIgc3JjVyA9IHNyYy53aWR0aCgpO1xuICAgIHZhciB0Z3RXID0gdGd0LndpZHRoKCk7XG4gICAgdmFyIHNyY0ggPSBzcmMuaGVpZ2h0KCk7XG4gICAgdmFyIHRndEggPSB0Z3QuaGVpZ2h0KCk7XG4gICAgdmFyIHJhZGl1cyA9IGVkZ2UucHN0eWxlKCdoYXlzdGFjay1yYWRpdXMnKS52YWx1ZTtcbiAgICB2YXIgaGFsZlJhZGl1cyA9IHJhZGl1cyAvIDI7IC8vIGIvYyBoYXZlIHRvIGhhbGYgd2lkdGgvaGVpZ2h0XG5cbiAgICBycy5oYXlzdGFja1B0cyA9IHJzLmFsbHB0cyA9IFtycy5zb3VyY2UueCAqIHNyY1cgKiBoYWxmUmFkaXVzICsgc3JjUG9zLngsIHJzLnNvdXJjZS55ICogc3JjSCAqIGhhbGZSYWRpdXMgKyBzcmNQb3MueSwgcnMudGFyZ2V0LnggKiB0Z3RXICogaGFsZlJhZGl1cyArIHRndFBvcy54LCBycy50YXJnZXQueSAqIHRndEggKiBoYWxmUmFkaXVzICsgdGd0UG9zLnldO1xuICAgIHJzLm1pZFggPSAocnMuYWxscHRzWzBdICsgcnMuYWxscHRzWzJdKSAvIDI7XG4gICAgcnMubWlkWSA9IChycy5hbGxwdHNbMV0gKyBycy5hbGxwdHNbM10pIC8gMjsgLy8gYWx3YXlzIG92ZXJyaWRlIGFzIGhheXN0YWNrIGluIGNhc2Ugc2V0IHRvIGRpZmZlcmVudCB0eXBlIHByZXZpb3VzbHlcblxuICAgIHJzLmVkZ2VUeXBlID0gJ2hheXN0YWNrJztcbiAgICBycy5oYXlzdGFjayA9IHRydWU7XG4gICAgdGhpcy5zdG9yZUVkZ2VQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKGVkZ2UpO1xuICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKGVkZ2UpO1xuICB9XG59O1xuXG5CUnAkMy5maW5kU2VnbWVudHNQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgLy8gU2VnbWVudHMgKG11bHRpcGxlIHN0cmFpZ2h0IGxpbmVzKVxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgcG9zUHRzID0gcGFpckluZm8ucG9zUHRzLFxuICAgICAgaW50ZXJzZWN0aW9uUHRzID0gcGFpckluZm8uaW50ZXJzZWN0aW9uUHRzLFxuICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSBwYWlySW5mby52ZWN0b3JOb3JtSW52ZXJzZTtcbiAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgdmFyIHNlZ21lbnRXcyA9IGVkZ2UucHN0eWxlKCdzZWdtZW50LXdlaWdodHMnKTtcbiAgdmFyIHNlZ21lbnREcyA9IGVkZ2UucHN0eWxlKCdzZWdtZW50LWRpc3RhbmNlcycpO1xuICB2YXIgc2VnbWVudHNOID0gTWF0aC5taW4oc2VnbWVudFdzLnBmVmFsdWUubGVuZ3RoLCBzZWdtZW50RHMucGZWYWx1ZS5sZW5ndGgpO1xuICBycy5lZGdlVHlwZSA9ICdzZWdtZW50cyc7XG4gIHJzLnNlZ3B0cyA9IFtdO1xuXG4gIGZvciAodmFyIHMgPSAwOyBzIDwgc2VnbWVudHNOOyBzKyspIHtcbiAgICB2YXIgdyA9IHNlZ21lbnRXcy5wZlZhbHVlW3NdO1xuICAgIHZhciBkID0gc2VnbWVudERzLnBmVmFsdWVbc107XG4gICAgdmFyIHcxID0gMSAtIHc7XG4gICAgdmFyIHcyID0gdztcbiAgICB2YXIgbWlkcHRQdHMgPSBlZGdlRGlzdGFuY2VzID09PSAnbm9kZS1wb3NpdGlvbicgPyBwb3NQdHMgOiBpbnRlcnNlY3Rpb25QdHM7XG4gICAgdmFyIGFkanVzdGVkTWlkcHQgPSB7XG4gICAgICB4OiBtaWRwdFB0cy54MSAqIHcxICsgbWlkcHRQdHMueDIgKiB3MixcbiAgICAgIHk6IG1pZHB0UHRzLnkxICogdzEgKyBtaWRwdFB0cy55MiAqIHcyXG4gICAgfTtcbiAgICBycy5zZWdwdHMucHVzaChhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZCwgYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGQpO1xuICB9XG59O1xuXG5CUnAkMy5maW5kTG9vcFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbywgaSwgZWRnZUlzVW5idW5kbGVkKSB7XG4gIC8vIFNlbGYtZWRnZVxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgZGlyQ291bnRzID0gcGFpckluZm8uZGlyQ291bnRzLFxuICAgICAgc3JjUG9zID0gcGFpckluZm8uc3JjUG9zO1xuICB2YXIgY3RybHB0RGlzdHMgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnKTtcbiAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gIHZhciBsb29wRGlyID0gZWRnZS5wc3R5bGUoJ2xvb3AtZGlyZWN0aW9uJykucGZWYWx1ZTtcbiAgdmFyIGxvb3BTd3AgPSBlZGdlLnBzdHlsZSgnbG9vcC1zd2VlcCcpLnBmVmFsdWU7XG4gIHZhciBzdGVwU2l6ZSA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScpLnBmVmFsdWU7XG4gIHJzLmVkZ2VUeXBlID0gJ3NlbGYnO1xuICB2YXIgaiA9IGk7XG4gIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuXG4gIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICBqID0gMDtcbiAgICBsb29wRGlzdCA9IGN0cmxwdERpc3Q7XG4gIH1cblxuICB2YXIgbG9vcEFuZ2xlID0gbG9vcERpciAtIE1hdGguUEkgLyAyO1xuICB2YXIgb3V0QW5nbGUgPSBsb29wQW5nbGUgLSBsb29wU3dwIC8gMjtcbiAgdmFyIGluQW5nbGUgPSBsb29wQW5nbGUgKyBsb29wU3dwIC8gMjsgLy8gaW5jcmVhc2UgYnkgc3RlcCBzaXplIGZvciBvdmVybGFwcGluZyBsb29wcywga2V5ZWQgb24gZGlyZWN0aW9uIGFuZCBzd2VlcCB2YWx1ZXNcblxuICB2YXIgZGMgPSBTdHJpbmcobG9vcERpciArICdfJyArIGxvb3BTd3ApO1xuICBqID0gZGlyQ291bnRzW2RjXSA9PT0gdW5kZWZpbmVkID8gZGlyQ291bnRzW2RjXSA9IDAgOiArK2RpckNvdW50c1tkY107XG4gIHJzLmN0cmxwdHMgPSBbc3JjUG9zLnggKyBNYXRoLmNvcyhvdXRBbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueSArIE1hdGguc2luKG91dEFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy54ICsgTWF0aC5jb3MoaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueSArIE1hdGguc2luKGluQW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKV07XG59O1xuXG5CUnAkMy5maW5kQ29tcG91bmRMb29wUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvLCBpLCBlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgLy8gQ29tcG91bmQgZWRnZVxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICBycy5lZGdlVHlwZSA9ICdjb21wb3VuZCc7XG4gIHZhciBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3MsXG4gICAgICB0Z3RQb3MgPSBwYWlySW5mby50Z3RQb3MsXG4gICAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICAgIHNyY0ggPSBwYWlySW5mby5zcmNILFxuICAgICAgdGd0VyA9IHBhaXJJbmZvLnRndFcsXG4gICAgICB0Z3RIID0gcGFpckluZm8udGd0SDtcbiAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyk7XG4gIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICB2YXIgaiA9IGk7XG4gIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuXG4gIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICBqID0gMDtcbiAgICBsb29wRGlzdCA9IGN0cmxwdERpc3Q7XG4gIH1cblxuICB2YXIgbG9vcFcgPSA1MDtcbiAgdmFyIGxvb3BhUG9zID0ge1xuICAgIHg6IHNyY1Bvcy54IC0gc3JjVyAvIDIsXG4gICAgeTogc3JjUG9zLnkgLSBzcmNIIC8gMlxuICB9O1xuICB2YXIgbG9vcGJQb3MgPSB7XG4gICAgeDogdGd0UG9zLnggLSB0Z3RXIC8gMixcbiAgICB5OiB0Z3RQb3MueSAtIHRndEggLyAyXG4gIH07XG4gIHZhciBsb29wUG9zID0ge1xuICAgIHg6IE1hdGgubWluKGxvb3BhUG9zLngsIGxvb3BiUG9zLngpLFxuICAgIHk6IE1hdGgubWluKGxvb3BhUG9zLnksIGxvb3BiUG9zLnkpXG4gIH07IC8vIGF2b2lkcyBjYXNlcyB3aXRoIGltcG9zc2libGUgYmV6aWVyc1xuXG4gIHZhciBtaW5Db21wb3VuZFN0cmV0Y2ggPSAwLjU7XG4gIHZhciBjb21wb3VuZFN0cmV0Y2hBID0gTWF0aC5tYXgobWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyhzcmNXICogMC4wMSkpO1xuICB2YXIgY29tcG91bmRTdHJldGNoQiA9IE1hdGgubWF4KG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2codGd0VyAqIDAuMDEpKTtcbiAgcnMuY3RybHB0cyA9IFtsb29wUG9zLngsIGxvb3BQb3MueSAtICgxICsgTWF0aC5wb3cobG9vcFcsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hBLCBsb29wUG9zLnggLSAoMSArIE1hdGgucG93KGxvb3BXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogY29tcG91bmRTdHJldGNoQiwgbG9vcFBvcy55XTtcbn07XG5cbkJScCQzLmZpbmRTdHJhaWdodEVkZ2VQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAvLyBTdHJhaWdodCBlZGdlIHdpdGhpbiBidW5kbGVcbiAgZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaC5lZGdlVHlwZSA9ICdzdHJhaWdodCc7XG59O1xuXG5CUnAkMy5maW5kQmV6aWVyUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvLCBpLCBlZGdlSXNVbmJ1bmRsZWQsIGVkZ2VJc1N3YXBwZWQpIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHZlY3Rvck5vcm1JbnZlcnNlID0gcGFpckluZm8udmVjdG9yTm9ybUludmVyc2UsXG4gICAgICBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMsXG4gICAgICBpbnRlcnNlY3Rpb25QdHMgPSBwYWlySW5mby5pbnRlcnNlY3Rpb25QdHM7XG4gIHZhciBlZGdlRGlzdGFuY2VzID0gZWRnZS5wc3R5bGUoJ2VkZ2UtZGlzdGFuY2VzJykudmFsdWU7XG4gIHZhciBzdGVwU2l6ZSA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScpLnBmVmFsdWU7XG4gIHZhciBjdHJscHREaXN0cyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LWRpc3RhbmNlcycpO1xuICB2YXIgY3RybHB0V3MgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC13ZWlnaHRzJyk7XG4gIHZhciBiZXppZXJOID0gY3RybHB0RGlzdHMgJiYgY3RybHB0V3MgPyBNYXRoLm1pbihjdHJscHREaXN0cy52YWx1ZS5sZW5ndGgsIGN0cmxwdFdzLnZhbHVlLmxlbmd0aCkgOiAxO1xuICB2YXIgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVswXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGN0cmxwdFdlaWdodCA9IGN0cmxwdFdzLnZhbHVlWzBdOyAvLyAoTXVsdGkpYmV6aWVyXG5cbiAgdmFyIG11bHRpID0gZWRnZUlzVW5idW5kbGVkO1xuICBycy5lZGdlVHlwZSA9IG11bHRpID8gJ211bHRpYmV6aWVyJyA6ICdiZXppZXInO1xuICBycy5jdHJscHRzID0gW107XG5cbiAgZm9yICh2YXIgYiA9IDA7IGIgPCBiZXppZXJOOyBiKyspIHtcbiAgICB2YXIgbm9ybWN0cmxwdERpc3QgPSAoMC41IC0gcGFpckluZm8uZWxlcy5sZW5ndGggLyAyICsgaSkgKiBzdGVwU2l6ZSAqIChlZGdlSXNTd2FwcGVkID8gLTEgOiAxKTtcbiAgICB2YXIgbWFuY3RybHB0RGlzdCA9IHZvaWQgMDtcbiAgICB2YXIgc2lnbiA9IHNpZ251bShub3JtY3RybHB0RGlzdCk7XG5cbiAgICBpZiAobXVsdGkpIHtcbiAgICAgIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbYl0gOiBzdGVwU2l6ZTsgLy8gZmFsbCBiYWNrIG9uIHN0ZXAgc2l6ZVxuXG4gICAgICBjdHJscHRXZWlnaHQgPSBjdHJscHRXcy52YWx1ZVtiXTtcbiAgICB9XG5cbiAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICAvLyBtdWx0aSBvciBzaW5nbGUgdW5idW5kbGVkXG4gICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFuY3RybHB0RGlzdCA9IGN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IHNpZ24gKiBjdHJscHREaXN0IDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBkaXN0YW5jZUZyb21NaWRwb2ludCA9IG1hbmN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IG1hbmN0cmxwdERpc3QgOiBub3JtY3RybHB0RGlzdDtcbiAgICB2YXIgdzEgPSAxIC0gY3RybHB0V2VpZ2h0O1xuICAgIHZhciB3MiA9IGN0cmxwdFdlaWdodDtcbiAgICB2YXIgbWlkcHRQdHMgPSBlZGdlRGlzdGFuY2VzID09PSAnbm9kZS1wb3NpdGlvbicgPyBwb3NQdHMgOiBpbnRlcnNlY3Rpb25QdHM7XG4gICAgdmFyIGFkanVzdGVkTWlkcHQgPSB7XG4gICAgICB4OiBtaWRwdFB0cy54MSAqIHcxICsgbWlkcHRQdHMueDIgKiB3MixcbiAgICAgIHk6IG1pZHB0UHRzLnkxICogdzEgKyBtaWRwdFB0cy55MiAqIHcyXG4gICAgfTtcbiAgICBycy5jdHJscHRzLnB1c2goYWRqdXN0ZWRNaWRwdC54ICsgdmVjdG9yTm9ybUludmVyc2UueCAqIGRpc3RhbmNlRnJvbU1pZHBvaW50LCBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQpO1xuICB9XG59O1xuXG5CUnAkMy5maW5kVGF4aVBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbykge1xuICAvLyBUYXhpY2FiIGdlb21ldHJ5IHdpdGggdHdvIHR1cm5zIG1heGltdW1cbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgcnMuZWRnZVR5cGUgPSAnc2VnbWVudHMnO1xuICB2YXIgVkVSVElDQUwgPSAndmVydGljYWwnO1xuICB2YXIgSE9SSVpPTlRBTCA9ICdob3Jpem9udGFsJztcbiAgdmFyIExFRlRXQVJEID0gJ2xlZnR3YXJkJztcbiAgdmFyIFJJR0hUV0FSRCA9ICdyaWdodHdhcmQnO1xuICB2YXIgRE9XTldBUkQgPSAnZG93bndhcmQnO1xuICB2YXIgVVBXQVJEID0gJ3Vwd2FyZCc7XG4gIHZhciBBVVRPID0gJ2F1dG8nO1xuICB2YXIgcG9zUHRzID0gcGFpckluZm8ucG9zUHRzLFxuICAgICAgc3JjVyA9IHBhaXJJbmZvLnNyY1csXG4gICAgICBzcmNIID0gcGFpckluZm8uc3JjSCxcbiAgICAgIHRndFcgPSBwYWlySW5mby50Z3RXLFxuICAgICAgdGd0SCA9IHBhaXJJbmZvLnRndEg7XG4gIHZhciBlZGdlRGlzdGFuY2VzID0gZWRnZS5wc3R5bGUoJ2VkZ2UtZGlzdGFuY2VzJykudmFsdWU7XG4gIHZhciBkSW5jbHVkZXNOb2RlQm9keSA9IGVkZ2VEaXN0YW5jZXMgIT09ICdub2RlLXBvc2l0aW9uJztcbiAgdmFyIHRheGlEaXIgPSBlZGdlLnBzdHlsZSgndGF4aS1kaXJlY3Rpb24nKS52YWx1ZTtcbiAgdmFyIHJhd1RheGlEaXIgPSB0YXhpRGlyOyAvLyB1bnByb2Nlc3NlZCB2YWx1ZVxuXG4gIHZhciB0YXhpVHVybiA9IGVkZ2UucHN0eWxlKCd0YXhpLXR1cm4nKTtcbiAgdmFyIHRheGlUdXJuUGZWYWwgPSB0YXhpVHVybi5wZlZhbHVlO1xuICB2YXIgbWluRCA9IGVkZ2UucHN0eWxlKCd0YXhpLXR1cm4tbWluLWRpc3RhbmNlJykucGZWYWx1ZTtcbiAgdmFyIHR1cm5Jc1BlcmNlbnQgPSB0YXhpVHVybi51bml0cyA9PT0gJyUnO1xuICB2YXIgZHcgPSBkSW5jbHVkZXNOb2RlQm9keSA/IChzcmNXICsgdGd0VykgLyAyIDogMDtcbiAgdmFyIGRoID0gZEluY2x1ZGVzTm9kZUJvZHkgPyAoc3JjSCArIHRndEgpIC8gMiA6IDA7XG4gIHZhciBwZHggPSBwb3NQdHMueDIgLSBwb3NQdHMueDE7XG4gIHZhciBwZHkgPSBwb3NQdHMueTIgLSBwb3NQdHMueTE7IC8vIHRha2UgYXdheSB0aGUgZWZmZWN0aXZlIHcvaCBmcm9tIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGRlbHRhIHZhbHVlXG5cbiAgdmFyIHN1YkRXSCA9IGZ1bmN0aW9uIHN1YkRXSChkeHksIGR3aCkge1xuICAgIGlmIChkeHkgPiAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoZHh5IC0gZHdoLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGR4eSArIGR3aCwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkeCA9IHN1YkRXSChwZHgsIGR3KTtcbiAgdmFyIGR5ID0gc3ViRFdIKHBkeSwgZGgpO1xuICB2YXIgaXNFeHBsaWNpdERpciA9IGZhbHNlO1xuXG4gIGlmICh0YXhpRGlyID09PSBBVVRPKSB7XG4gICAgdGF4aURpciA9IE1hdGguYWJzKGR4KSA+IE1hdGguYWJzKGR5KSA/IEhPUklaT05UQUwgOiBWRVJUSUNBTDtcbiAgfSBlbHNlIGlmICh0YXhpRGlyID09PSBVUFdBUkQgfHwgdGF4aURpciA9PT0gRE9XTldBUkQpIHtcbiAgICB0YXhpRGlyID0gVkVSVElDQUw7XG4gICAgaXNFeHBsaWNpdERpciA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGF4aURpciA9PT0gTEVGVFdBUkQgfHwgdGF4aURpciA9PT0gUklHSFRXQVJEKSB7XG4gICAgdGF4aURpciA9IEhPUklaT05UQUw7XG4gICAgaXNFeHBsaWNpdERpciA9IHRydWU7XG4gIH1cblxuICB2YXIgaXNWZXJ0ID0gdGF4aURpciA9PT0gVkVSVElDQUw7XG4gIHZhciBsID0gaXNWZXJ0ID8gZHkgOiBkeDtcbiAgdmFyIHBsID0gaXNWZXJ0ID8gcGR5IDogcGR4O1xuICB2YXIgc2duTCA9IHNpZ251bShwbCk7XG4gIHZhciBmb3JjZWREaXIgPSBmYWxzZTtcblxuICBpZiAoIShpc0V4cGxpY2l0RGlyICYmIHR1cm5Jc1BlcmNlbnQpIC8vIGZvcmNpbmcgaW4gdGhpcyBjYXNlIHdvdWxkIGNhdXNlIHdlaXJkIGdyb3dpbmcgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAmJiAocmF3VGF4aURpciA9PT0gRE9XTldBUkQgJiYgcGwgPCAwIHx8IHJhd1RheGlEaXIgPT09IFVQV0FSRCAmJiBwbCA+IDAgfHwgcmF3VGF4aURpciA9PT0gTEVGVFdBUkQgJiYgcGwgPiAwIHx8IHJhd1RheGlEaXIgPT09IFJJR0hUV0FSRCAmJiBwbCA8IDApKSB7XG4gICAgc2duTCAqPSAtMTtcbiAgICBsID0gc2duTCAqIE1hdGguYWJzKGwpO1xuICAgIGZvcmNlZERpciA9IHRydWU7XG4gIH1cblxuICB2YXIgZCA9IHR1cm5Jc1BlcmNlbnQgPyB0YXhpVHVyblBmVmFsICogbCA6IHRheGlUdXJuUGZWYWwgKiBzZ25MO1xuXG4gIHZhciBnZXRJc1Rvb0Nsb3NlID0gZnVuY3Rpb24gZ2V0SXNUb29DbG9zZShkKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGQpIDwgbWluRCB8fCBNYXRoLmFicyhkKSA+PSBNYXRoLmFicyhsKTtcbiAgfTtcblxuICB2YXIgaXNUb29DbG9zZVNyYyA9IGdldElzVG9vQ2xvc2UoZCk7XG4gIHZhciBpc1Rvb0Nsb3NlVGd0ID0gZ2V0SXNUb29DbG9zZShsIC0gZCk7XG4gIHZhciBpc1Rvb0Nsb3NlID0gaXNUb29DbG9zZVNyYyB8fCBpc1Rvb0Nsb3NlVGd0O1xuXG4gIGlmIChpc1Rvb0Nsb3NlICYmICFmb3JjZWREaXIpIHtcbiAgICAvLyBub24taWRlYWwgcm91dGluZ1xuICAgIGlmIChpc1ZlcnQpIHtcbiAgICAgIC8vIHZlcnRpY2FsIGZhbGxiYWNrc1xuICAgICAgdmFyIGxTaGFwZUluc2lkZVNyYyA9IE1hdGguYWJzKHBsKSA8PSBzcmNIIC8gMjtcbiAgICAgIHZhciBsU2hhcGVJbnNpZGVUZ3QgPSBNYXRoLmFicyhwZHgpIDw9IHRndFcgLyAyO1xuXG4gICAgICBpZiAobFNoYXBlSW5zaWRlU3JjKSB7XG4gICAgICAgIC8vIGhvcml6b250YWwgWi1zaGFwZSAoZGlyZWN0aW9uIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciB4ID0gKHBvc1B0cy54MSArIHBvc1B0cy54MikgLyAyO1xuICAgICAgICB2YXIgeTEgPSBwb3NQdHMueTEsXG4gICAgICAgICAgICB5MiA9IHBvc1B0cy55MjtcbiAgICAgICAgcnMuc2VncHRzID0gW3gsIHkxLCB4LCB5Ml07XG4gICAgICB9IGVsc2UgaWYgKGxTaGFwZUluc2lkZVRndCkge1xuICAgICAgICAvLyB2ZXJ0aWNhbCBaLXNoYXBlIChkaXN0YW5jZSBub3QgcmVzcGVjdGVkKVxuICAgICAgICB2YXIgeSA9IChwb3NQdHMueTEgKyBwb3NQdHMueTIpIC8gMjtcbiAgICAgICAgdmFyIHgxID0gcG9zUHRzLngxLFxuICAgICAgICAgICAgeDIgPSBwb3NQdHMueDI7XG4gICAgICAgIHJzLnNlZ3B0cyA9IFt4MSwgeSwgeDIsIHldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTC1zaGFwZSBmYWxsYmFjayAodHVybiBkaXN0YW5jZSBub3QgcmVzcGVjdGVkLCBidXQgd29ya3Mgd2VsbCB3aXRoIHRyZWUgc2libGluZ3MpXG4gICAgICAgIHJzLnNlZ3B0cyA9IFtwb3NQdHMueDEsIHBvc1B0cy55Ml07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvcml6b250YWwgZmFsbGJhY2tzXG4gICAgICB2YXIgX2xTaGFwZUluc2lkZVNyYyA9IE1hdGguYWJzKHBsKSA8PSBzcmNXIC8gMjtcblxuICAgICAgdmFyIF9sU2hhcGVJbnNpZGVUZ3QgPSBNYXRoLmFicyhwZHkpIDw9IHRndEggLyAyO1xuXG4gICAgICBpZiAoX2xTaGFwZUluc2lkZVNyYykge1xuICAgICAgICAvLyB2ZXJ0aWNhbCBaLXNoYXBlIChkaXJlY3Rpb24gbm90IHJlc3BlY3RlZClcbiAgICAgICAgdmFyIF95ID0gKHBvc1B0cy55MSArIHBvc1B0cy55MikgLyAyO1xuXG4gICAgICAgIHZhciBfeCA9IHBvc1B0cy54MSxcbiAgICAgICAgICAgIF94MiA9IHBvc1B0cy54MjtcbiAgICAgICAgcnMuc2VncHRzID0gW194LCBfeSwgX3gyLCBfeV07XG4gICAgICB9IGVsc2UgaWYgKF9sU2hhcGVJbnNpZGVUZ3QpIHtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBaLXNoYXBlICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciBfeDMgPSAocG9zUHRzLngxICsgcG9zUHRzLngyKSAvIDI7XG5cbiAgICAgICAgdmFyIF95MiA9IHBvc1B0cy55MSxcbiAgICAgICAgICAgIF95MyA9IHBvc1B0cy55MjtcbiAgICAgICAgcnMuc2VncHRzID0gW194MywgX3kyLCBfeDMsIF95M107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMLXNoYXBlICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQsIGJ1dCB3b3JrcyB3ZWxsIGZvciB0cmVlIHNpYmxpbmdzKVxuICAgICAgICBycy5zZWdwdHMgPSBbcG9zUHRzLngyLCBwb3NQdHMueTFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZGVhbCByb3V0aW5nXG4gICAgaWYgKGlzVmVydCkge1xuICAgICAgdmFyIF95NCA9IHBvc1B0cy55MSArIGQgKyAoZEluY2x1ZGVzTm9kZUJvZHkgPyBzcmNIIC8gMiAqIHNnbkwgOiAwKTtcblxuICAgICAgdmFyIF94NCA9IHBvc1B0cy54MSxcbiAgICAgICAgICBfeDUgPSBwb3NQdHMueDI7XG4gICAgICBycy5zZWdwdHMgPSBbX3g0LCBfeTQsIF94NSwgX3k0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9yaXpvbnRhbFxuICAgICAgdmFyIF94NiA9IHBvc1B0cy54MSArIGQgKyAoZEluY2x1ZGVzTm9kZUJvZHkgPyBzcmNXIC8gMiAqIHNnbkwgOiAwKTtcblxuICAgICAgdmFyIF95NSA9IHBvc1B0cy55MSxcbiAgICAgICAgICBfeTYgPSBwb3NQdHMueTI7XG4gICAgICBycy5zZWdwdHMgPSBbX3g2LCBfeTUsIF94NiwgX3k2XTtcbiAgICB9XG4gIH1cbn07XG5cbkJScCQzLnRyeVRvQ29ycmVjdEludmFsaWRQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDsgLy8gY2FuIG9ubHkgY29ycmVjdCBiZXppZXJzIGZvciBub3cuLi5cblxuICBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInKSB7XG4gICAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyxcbiAgICAgICAgdGd0UG9zID0gcGFpckluZm8udGd0UG9zLFxuICAgICAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICAgICAgc3JjSCA9IHBhaXJJbmZvLnNyY0gsXG4gICAgICAgIHRndFcgPSBwYWlySW5mby50Z3RXLFxuICAgICAgICB0Z3RIID0gcGFpckluZm8udGd0SCxcbiAgICAgICAgc3JjU2hhcGUgPSBwYWlySW5mby5zcmNTaGFwZSxcbiAgICAgICAgdGd0U2hhcGUgPSBwYWlySW5mby50Z3RTaGFwZTtcbiAgICB2YXIgYmFkU3RhcnQgPSAhbnVtYmVyKHJzLnN0YXJ0WCkgfHwgIW51bWJlcihycy5zdGFydFkpO1xuICAgIHZhciBiYWRBU3RhcnQgPSAhbnVtYmVyKHJzLmFycm93U3RhcnRYKSB8fCAhbnVtYmVyKHJzLmFycm93U3RhcnRZKTtcbiAgICB2YXIgYmFkRW5kID0gIW51bWJlcihycy5lbmRYKSB8fCAhbnVtYmVyKHJzLmVuZFkpO1xuICAgIHZhciBiYWRBRW5kID0gIW51bWJlcihycy5hcnJvd0VuZFgpIHx8ICFudW1iZXIocnMuYXJyb3dFbmRZKTtcbiAgICB2YXIgbWluQ3BBRGlzdEZhY3RvciA9IDM7XG4gICAgdmFyIGFycm93VyA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLmFycm93U2hhcGVXaWR0aDtcbiAgICB2YXIgbWluQ3BBRGlzdCA9IG1pbkNwQURpc3RGYWN0b3IgKiBhcnJvd1c7XG4gICAgdmFyIHN0YXJ0QUNwRGlzdCA9IGRpc3Qoe1xuICAgICAgeDogcnMuY3RybHB0c1swXSxcbiAgICAgIHk6IHJzLmN0cmxwdHNbMV1cbiAgICB9LCB7XG4gICAgICB4OiBycy5zdGFydFgsXG4gICAgICB5OiBycy5zdGFydFlcbiAgICB9KTtcbiAgICB2YXIgY2xvc2VTdGFydEFDcCA9IHN0YXJ0QUNwRGlzdCA8IG1pbkNwQURpc3Q7XG4gICAgdmFyIGVuZEFDcERpc3QgPSBkaXN0KHtcbiAgICAgIHg6IHJzLmN0cmxwdHNbMF0sXG4gICAgICB5OiBycy5jdHJscHRzWzFdXG4gICAgfSwge1xuICAgICAgeDogcnMuZW5kWCxcbiAgICAgIHk6IHJzLmVuZFlcbiAgICB9KTtcbiAgICB2YXIgY2xvc2VFbmRBQ3AgPSBlbmRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcbiAgICB2YXIgb3ZlcmxhcHBpbmcgPSBmYWxzZTtcblxuICAgIGlmIChiYWRTdGFydCB8fCBiYWRBU3RhcnQgfHwgY2xvc2VTdGFydEFDcCkge1xuICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlOyAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHNyYyBjZW50cmUgdG8gb3V0c2lkZSB0aGUgc3JjIHNoYXBlXG4gICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG5cbiAgICAgIHZhciBjcEQgPSB7XG4gICAgICAgIC8vIGRlbHRhXG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gLSBzcmNQb3MueCxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXSAtIHNyY1Bvcy55XG4gICAgICB9O1xuICAgICAgdmFyIGNwTCA9IE1hdGguc3FydChjcEQueCAqIGNwRC54ICsgY3BELnkgKiBjcEQueSk7IC8vIGxlbmd0aCBvZiBsaW5lXG5cbiAgICAgIHZhciBjcE0gPSB7XG4gICAgICAgIC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgeDogY3BELnggLyBjcEwsXG4gICAgICAgIHk6IGNwRC55IC8gY3BMXG4gICAgICB9O1xuICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuICAgICAgdmFyIGNwUHJvaiA9IHtcbiAgICAgICAgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICB4OiBycy5jdHJscHRzWzBdICsgY3BNLnggKiAyICogcmFkaXVzLFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgY3BNLnkgKiAyICogcmFkaXVzXG4gICAgICB9O1xuICAgICAgdmFyIHNyY0N0cmxQdEludG4gPSBzcmNTaGFwZS5pbnRlcnNlY3RMaW5lKHNyY1Bvcy54LCBzcmNQb3MueSwgc3JjVywgc3JjSCwgY3BQcm9qLngsIGNwUHJvai55LCAwKTtcblxuICAgICAgaWYgKGNsb3NlU3RhcnRBQ3ApIHtcbiAgICAgICAgcnMuY3RybHB0c1swXSA9IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgICAgcnMuY3RybHB0c1sxXSA9IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmN0cmxwdHNbMF0gPSBzcmNDdHJsUHRJbnRuWzBdICsgY3BNLnggKiBtaW5DcEFEaXN0O1xuICAgICAgICBycy5jdHJscHRzWzFdID0gc3JjQ3RybFB0SW50blsxXSArIGNwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFkRW5kIHx8IGJhZEFFbmQgfHwgY2xvc2VFbmRBQ3ApIHtcbiAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTsgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSB0Z3QgY2VudHJlIHRvIG91dHNpZGUgdGhlIHRndCBzaGFwZVxuICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuXG4gICAgICB2YXIgX2NwRCA9IHtcbiAgICAgICAgLy8gZGVsdGFcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSAtIHRndFBvcy54LFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdIC0gdGd0UG9zLnlcbiAgICAgIH07XG5cbiAgICAgIHZhciBfY3BMID0gTWF0aC5zcXJ0KF9jcEQueCAqIF9jcEQueCArIF9jcEQueSAqIF9jcEQueSk7IC8vIGxlbmd0aCBvZiBsaW5lXG5cblxuICAgICAgdmFyIF9jcE0gPSB7XG4gICAgICAgIC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgeDogX2NwRC54IC8gX2NwTCxcbiAgICAgICAgeTogX2NwRC55IC8gX2NwTFxuICAgICAgfTtcblxuICAgICAgdmFyIF9yYWRpdXMgPSBNYXRoLm1heChzcmNXLCBzcmNIKTtcblxuICAgICAgdmFyIF9jcFByb2ogPSB7XG4gICAgICAgIC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSArIF9jcE0ueCAqIDIgKiBfcmFkaXVzLFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgX2NwTS55ICogMiAqIF9yYWRpdXNcbiAgICAgIH07XG4gICAgICB2YXIgdGd0Q3RybFB0SW50biA9IHRndFNoYXBlLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0Z3RXLCB0Z3RILCBfY3BQcm9qLngsIF9jcFByb2oueSwgMCk7XG5cbiAgICAgIGlmIChjbG9zZUVuZEFDcCkge1xuICAgICAgICBycy5jdHJscHRzWzBdID0gcnMuY3RybHB0c1swXSArIF9jcE0ueCAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICAgIHJzLmN0cmxwdHNbMV0gPSBycy5jdHJscHRzWzFdICsgX2NwTS55ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmN0cmxwdHNbMF0gPSB0Z3RDdHJsUHRJbnRuWzBdICsgX2NwTS54ICogbWluQ3BBRGlzdDtcbiAgICAgICAgcnMuY3RybHB0c1sxXSA9IHRndEN0cmxQdEludG5bMV0gKyBfY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvdmVybGFwcGluZykge1xuICAgICAgLy8gcmVjYWxjIGVuZHB0c1xuICAgICAgdGhpcy5maW5kRW5kcG9pbnRzKGVkZ2UpO1xuICAgIH1cbiAgfVxufTtcblxuQlJwJDMuc3RvcmVBbGxwdHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gIGlmIChycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIHJzLmFsbHB0cyA9IFtdO1xuICAgIHJzLmFsbHB0cy5wdXNoKHJzLnN0YXJ0WCwgcnMuc3RhcnRZKTtcblxuICAgIGZvciAodmFyIGIgPSAwOyBiICsgMSA8IHJzLmN0cmxwdHMubGVuZ3RoOyBiICs9IDIpIHtcbiAgICAgIC8vIGN0cmwgcHQgaXRzZWxmXG4gICAgICBycy5hbGxwdHMucHVzaChycy5jdHJscHRzW2JdLCBycy5jdHJscHRzW2IgKyAxXSk7IC8vIHRoZSBtaWRwdCBiZXR3ZWVuIGN0cmxwdHMgYXMgaW50ZXJtZWRpYXRlIGRlc3RpbmF0aW9uIHB0c1xuXG4gICAgICBpZiAoYiArIDMgPCBycy5jdHJscHRzLmxlbmd0aCkge1xuICAgICAgICBycy5hbGxwdHMucHVzaCgocnMuY3RybHB0c1tiXSArIHJzLmN0cmxwdHNbYiArIDJdKSAvIDIsIChycy5jdHJscHRzW2IgKyAxXSArIHJzLmN0cmxwdHNbYiArIDNdKSAvIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJzLmFsbHB0cy5wdXNoKHJzLmVuZFgsIHJzLmVuZFkpO1xuICAgIHZhciBtLCBtdDtcblxuICAgIGlmIChycy5jdHJscHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICBtID0gcnMuYWxscHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgcnMubWlkWCA9IHJzLmFsbHB0c1ttXTtcbiAgICAgIHJzLm1pZFkgPSBycy5hbGxwdHNbbSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcnMuYWxscHRzLmxlbmd0aCAvIDIgLSAzO1xuICAgICAgbXQgPSAwLjU7XG4gICAgICBycy5taWRYID0gcWJlemllckF0KHJzLmFsbHB0c1ttXSwgcnMuYWxscHRzW20gKyAyXSwgcnMuYWxscHRzW20gKyA0XSwgbXQpO1xuICAgICAgcnMubWlkWSA9IHFiZXppZXJBdChycy5hbGxwdHNbbSArIDFdLCBycy5hbGxwdHNbbSArIDNdLCBycy5hbGxwdHNbbSArIDVdLCBtdCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgLy8gbmVlZCB0byBjYWxjIHRoZXNlIGFmdGVyIGVuZHB0c1xuICAgIHJzLmFsbHB0cyA9IFtycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuZW5kWCwgcnMuZW5kWV07IC8vIGRlZmF1bHQgbWlkcHQgZm9yIGxhYmVscyBldGNcblxuICAgIHJzLm1pZFggPSAocnMuc3RhcnRYICsgcnMuZW5kWCArIHJzLmFycm93U3RhcnRYICsgcnMuYXJyb3dFbmRYKSAvIDQ7XG4gICAgcnMubWlkWSA9IChycy5zdGFydFkgKyBycy5lbmRZICsgcnMuYXJyb3dTdGFydFkgKyBycy5hcnJvd0VuZFkpIC8gNDtcbiAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJykge1xuICAgIHJzLmFsbHB0cyA9IFtdO1xuICAgIHJzLmFsbHB0cy5wdXNoKHJzLnN0YXJ0WCwgcnMuc3RhcnRZKTtcbiAgICBycy5hbGxwdHMucHVzaC5hcHBseShycy5hbGxwdHMsIHJzLnNlZ3B0cyk7XG4gICAgcnMuYWxscHRzLnB1c2gocnMuZW5kWCwgcnMuZW5kWSk7XG5cbiAgICBpZiAocnMuc2VncHRzLmxlbmd0aCAlIDQgPT09IDApIHtcbiAgICAgIHZhciBpMiA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyO1xuICAgICAgdmFyIGkxID0gaTIgLSAyO1xuICAgICAgcnMubWlkWCA9IChycy5zZWdwdHNbaTFdICsgcnMuc2VncHRzW2kyXSkgLyAyO1xuICAgICAgcnMubWlkWSA9IChycy5zZWdwdHNbaTEgKyAxXSArIHJzLnNlZ3B0c1tpMiArIDFdKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfaSA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyIC0gMTtcblxuICAgICAgcnMubWlkWCA9IHJzLnNlZ3B0c1tfaV07XG4gICAgICBycy5taWRZID0gcnMuc2VncHRzW19pICsgMV07XG4gICAgfVxuICB9XG59O1xuXG5CUnAkMy5jaGVja0ZvckludmFsaWRFZGdlV2FybmluZyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgaWYgKHJzLm5vZGVzT3ZlcmxhcCB8fCBudW1iZXIocnMuc3RhcnRYKSAmJiBudW1iZXIocnMuc3RhcnRZKSAmJiBudW1iZXIocnMuZW5kWCkgJiYgbnVtYmVyKHJzLmVuZFkpKSB7XG4gICAgcnMubG9nZ2VkRXJyID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFycy5sb2dnZWRFcnIpIHtcbiAgICAgIHJzLmxvZ2dlZEVyciA9IHRydWU7XG4gICAgICB3YXJuKCdFZGdlIGAnICsgZWRnZS5pZCgpICsgJ2AgaGFzIGludmFsaWQgZW5kcG9pbnRzIGFuZCBzbyBpdCBpcyBpbXBvc3NpYmxlIHRvIGRyYXcuICBBZGp1c3QgeW91ciBlZGdlIHN0eWxlIChlLmcuIGNvbnRyb2wgcG9pbnRzKSBhY2NvcmRpbmdseSBvciB1c2UgYW4gYWx0ZXJuYXRpdmUgZWRnZSB0eXBlLiAgVGhpcyBpcyBleHBlY3RlZCBiZWhhdmlvdXIgd2hlbiB0aGUgc291cmNlIG5vZGUgYW5kIHRoZSB0YXJnZXQgbm9kZSBvdmVybGFwLicpO1xuICAgIH1cbiAgfVxufTtcblxuQlJwJDMuZmluZEVkZ2VDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKCFlZGdlcyB8fCBlZGdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBoYXNoVGFibGUgPSB7XG4gICAgbWFwOiBuZXcgTWFwJDEoKSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChwYWlySWQpIHtcbiAgICAgIHZhciBtYXAyID0gdGhpcy5tYXAuZ2V0KHBhaXJJZFswXSk7XG5cbiAgICAgIGlmIChtYXAyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1hcDIuZ2V0KHBhaXJJZFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHBhaXJJZCwgdmFsKSB7XG4gICAgICB2YXIgbWFwMiA9IHRoaXMubWFwLmdldChwYWlySWRbMF0pO1xuXG4gICAgICBpZiAobWFwMiA9PSBudWxsKSB7XG4gICAgICAgIG1hcDIgPSBuZXcgTWFwJDEoKTtcbiAgICAgICAgdGhpcy5tYXAuc2V0KHBhaXJJZFswXSwgbWFwMik7XG4gICAgICB9XG5cbiAgICAgIG1hcDIuc2V0KHBhaXJJZFsxXSwgdmFsKTtcbiAgICB9XG4gIH07XG4gIHZhciBwYWlySWRzID0gW107XG4gIHZhciBoYXlzdGFja0VkZ2VzID0gW107IC8vIGNyZWF0ZSBhIHRhYmxlIG9mIGVkZ2UgKHNyYywgdGd0KSA9PiBsaXN0IG9mIGVkZ2VzIGJldHdlZW4gdGhlbVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIGN1cnZlU3R5bGUgPSBlZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTsgLy8gaWdub3JlIGVkZ2VzIHdobyBhcmUgbm90IHRvIGJlIGRpc3BsYXllZFxuICAgIC8vIHRoZXkgc2hvdWxkbid0IHRha2UgdXAgc3BhY2VcblxuICAgIGlmIChlZGdlLnJlbW92ZWQoKSB8fCAhZWRnZS50YWtlc1VwU3BhY2UoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGN1cnZlU3R5bGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgIGhheXN0YWNrRWRnZXMucHVzaChlZGdlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJyB8fCBjdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQnIHx8IGN1cnZlU3R5bGUgPT09ICd0YXhpJztcbiAgICB2YXIgZWRnZUlzQmV6aWVyID0gY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICdiZXppZXInO1xuICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICB2YXIgc3JjSW5kZXggPSBzcmMucG9vbEluZGV4KCk7XG4gICAgdmFyIHRndEluZGV4ID0gdGd0LnBvb2xJbmRleCgpO1xuICAgIHZhciBwYWlySWQgPSBbc3JjSW5kZXgsIHRndEluZGV4XS5zb3J0KCk7XG4gICAgdmFyIHRhYmxlRW50cnkgPSBoYXNoVGFibGUuZ2V0KHBhaXJJZCk7XG5cbiAgICBpZiAodGFibGVFbnRyeSA9PSBudWxsKSB7XG4gICAgICB0YWJsZUVudHJ5ID0ge1xuICAgICAgICBlbGVzOiBbXVxuICAgICAgfTtcbiAgICAgIGhhc2hUYWJsZS5zZXQocGFpcklkLCB0YWJsZUVudHJ5KTtcbiAgICAgIHBhaXJJZHMucHVzaChwYWlySWQpO1xuICAgIH1cblxuICAgIHRhYmxlRW50cnkuZWxlcy5wdXNoKGVkZ2UpO1xuXG4gICAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgICAgdGFibGVFbnRyeS5oYXNVbmJ1bmRsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChlZGdlSXNCZXppZXIpIHtcbiAgICAgIHRhYmxlRW50cnkuaGFzQmV6aWVyID0gdHJ1ZTtcbiAgICB9XG4gIH0gLy8gZm9yIGVhY2ggcGFpciAoc3JjLCB0Z3QpLCBjcmVhdGUgdGhlIGN0cmwgcHRzXG4gIC8vIE5lc3RlZCBmb3IgbG9vcCBpcyBPSzsgdG90YWwgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZm9yIGJvdGggbG9vcHMgPSBlZGdlQ291bnRcblxuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHApIHtcbiAgICB2YXIgcGFpcklkID0gcGFpcklkc1twXTtcbiAgICB2YXIgcGFpckluZm8gPSBoYXNoVGFibGUuZ2V0KHBhaXJJZCk7XG4gICAgdmFyIHN3YXBwZWRwYWlySW5mbyA9IHZvaWQgMDtcblxuICAgIGlmICghcGFpckluZm8uaGFzVW5idW5kbGVkKSB7XG4gICAgICB2YXIgcGxsRWRnZXMgPSBwYWlySW5mby5lbGVzWzBdLnBhcmFsbGVsRWRnZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuaXNCdW5kbGVkQmV6aWVyKCk7XG4gICAgICB9KTtcbiAgICAgIGNsZWFyQXJyYXkocGFpckluZm8uZWxlcyk7XG4gICAgICBwbGxFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBwYWlySW5mby5lbGVzLnB1c2goZWRnZSk7XG4gICAgICB9KTsgLy8gZm9yIGVhY2ggcGFpciBpZCwgdGhlIGVkZ2VzIHNob3VsZCBiZSBzb3J0ZWQgYnkgaW5kZXhcblxuICAgICAgcGFpckluZm8uZWxlcy5zb3J0KGZ1bmN0aW9uIChlZGdlMSwgZWRnZTIpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UxLnBvb2xJbmRleCgpIC0gZWRnZTIucG9vbEluZGV4KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RFZGdlID0gcGFpckluZm8uZWxlc1swXTtcbiAgICB2YXIgc3JjID0gZmlyc3RFZGdlLnNvdXJjZSgpO1xuICAgIHZhciB0Z3QgPSBmaXJzdEVkZ2UudGFyZ2V0KCk7IC8vIG1ha2Ugc3VyZSBzcmMvdGd0IGRpc3RpbmN0aW9uIGlzIGNvbnNpc3RlbnQgdy5yLnQuIHBhaXJJZFxuXG4gICAgaWYgKHNyYy5wb29sSW5kZXgoKSA+IHRndC5wb29sSW5kZXgoKSkge1xuICAgICAgdmFyIHRlbXAgPSBzcmM7XG4gICAgICBzcmMgPSB0Z3Q7XG4gICAgICB0Z3QgPSB0ZW1wO1xuICAgIH1cblxuICAgIHZhciBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3MgPSBzcmMucG9zaXRpb24oKTtcbiAgICB2YXIgdGd0UG9zID0gcGFpckluZm8udGd0UG9zID0gdGd0LnBvc2l0aW9uKCk7XG4gICAgdmFyIHNyY1cgPSBwYWlySW5mby5zcmNXID0gc3JjLm91dGVyV2lkdGgoKTtcbiAgICB2YXIgc3JjSCA9IHBhaXJJbmZvLnNyY0ggPSBzcmMub3V0ZXJIZWlnaHQoKTtcbiAgICB2YXIgdGd0VyA9IHBhaXJJbmZvLnRndFcgPSB0Z3Qub3V0ZXJXaWR0aCgpO1xuICAgIHZhciB0Z3RIID0gcGFpckluZm8udGd0SCA9IHRndC5vdXRlckhlaWdodCgpO1xuXG4gICAgdmFyIHNyY1NoYXBlID0gcGFpckluZm8uc3JjU2hhcGUgPSByLm5vZGVTaGFwZXNbX3RoaXMuZ2V0Tm9kZVNoYXBlKHNyYyldO1xuXG4gICAgdmFyIHRndFNoYXBlID0gcGFpckluZm8udGd0U2hhcGUgPSByLm5vZGVTaGFwZXNbX3RoaXMuZ2V0Tm9kZVNoYXBlKHRndCldO1xuXG4gICAgcGFpckluZm8uZGlyQ291bnRzID0ge1xuICAgICAgJ25vcnRoJzogMCxcbiAgICAgICd3ZXN0JzogMCxcbiAgICAgICdzb3V0aCc6IDAsXG4gICAgICAnZWFzdCc6IDAsXG4gICAgICAnbm9ydGh3ZXN0JzogMCxcbiAgICAgICdzb3V0aHdlc3QnOiAwLFxuICAgICAgJ25vcnRoZWFzdCc6IDAsXG4gICAgICAnc291dGhlYXN0JzogMFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwYWlySW5mby5lbGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBfZWRnZSA9IHBhaXJJbmZvLmVsZXNbX2kyXTtcbiAgICAgIHZhciBycyA9IF9lZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgICB2YXIgX2N1cnZlU3R5bGUgPSBfZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG5cbiAgICAgIHZhciBfZWRnZUlzVW5idW5kbGVkID0gX2N1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBfY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJyB8fCBfY3VydmVTdHlsZSA9PT0gJ3RheGknOyAvLyB3aGV0aGVyIHRoZSBub3JtYWxpc2VkIHBhaXIgb3JkZXIgaXMgdGhlIHJldmVyc2Ugb2YgdGhlIGVkZ2UncyBzcmMtdGd0IG9yZGVyXG5cblxuICAgICAgdmFyIGVkZ2VJc1N3YXBwZWQgPSAhc3JjLnNhbWUoX2VkZ2Uuc291cmNlKCkpO1xuXG4gICAgICBpZiAoIXBhaXJJbmZvLmNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24gJiYgc3JjICE9PSB0Z3QgJiYgKHBhaXJJbmZvLmhhc0JlemllciB8fCBwYWlySW5mby5oYXNVbmJ1bmRsZWQpKSB7XG4gICAgICAgIHBhaXJJbmZvLmNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24gPSB0cnVlOyAvLyBwdCBvdXRzaWRlIHNyYyBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcblxuICAgICAgICB2YXIgc3JjT3V0c2lkZSA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzcmNXLCBzcmNILCB0Z3RQb3MueCwgdGd0UG9zLnksIDApO1xuICAgICAgICB2YXIgc3JjSW50biA9IHBhaXJJbmZvLnNyY0ludG4gPSBzcmNPdXRzaWRlOyAvLyBwdCBvdXRzaWRlIHRndCBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcblxuICAgICAgICB2YXIgdGd0T3V0c2lkZSA9IHRndFNoYXBlLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0Z3RXLCB0Z3RILCBzcmNQb3MueCwgc3JjUG9zLnksIDApO1xuICAgICAgICB2YXIgdGd0SW50biA9IHBhaXJJbmZvLnRndEludG4gPSB0Z3RPdXRzaWRlO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUHRzID0gcGFpckluZm8uaW50ZXJzZWN0aW9uUHRzID0ge1xuICAgICAgICAgIHgxOiBzcmNPdXRzaWRlWzBdLFxuICAgICAgICAgIHgyOiB0Z3RPdXRzaWRlWzBdLFxuICAgICAgICAgIHkxOiBzcmNPdXRzaWRlWzFdLFxuICAgICAgICAgIHkyOiB0Z3RPdXRzaWRlWzFdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMgPSB7XG4gICAgICAgICAgeDE6IHNyY1Bvcy54LFxuICAgICAgICAgIHgyOiB0Z3RQb3MueCxcbiAgICAgICAgICB5MTogc3JjUG9zLnksXG4gICAgICAgICAgeTI6IHRndFBvcy55XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkeSA9IHRndE91dHNpZGVbMV0gLSBzcmNPdXRzaWRlWzFdO1xuICAgICAgICB2YXIgZHggPSB0Z3RPdXRzaWRlWzBdIC0gc3JjT3V0c2lkZVswXTtcbiAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB2YXIgdmVjdG9yID0gcGFpckluZm8udmVjdG9yID0ge1xuICAgICAgICAgIHg6IGR4LFxuICAgICAgICAgIHk6IGR5XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2ZWN0b3JOb3JtID0gcGFpckluZm8udmVjdG9yTm9ybSA9IHtcbiAgICAgICAgICB4OiB2ZWN0b3IueCAvIGwsXG4gICAgICAgICAgeTogdmVjdG9yLnkgLyBsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB2ZWN0b3JOb3JtSW52ZXJzZSA9IHtcbiAgICAgICAgICB4OiAtdmVjdG9yTm9ybS55LFxuICAgICAgICAgIHk6IHZlY3Rvck5vcm0ueFxuICAgICAgICB9OyAvLyBpZiBub2RlIHNoYXBlcyBvdmVybGFwLCB0aGVuIG5vIGN0cmwgcHRzIHRvIGRyYXdcblxuICAgICAgICBwYWlySW5mby5ub2Rlc092ZXJsYXAgPSAhbnVtYmVyKGwpIHx8IHRndFNoYXBlLmNoZWNrUG9pbnQoc3JjT3V0c2lkZVswXSwgc3JjT3V0c2lkZVsxXSwgMCwgdGd0VywgdGd0SCwgdGd0UG9zLngsIHRndFBvcy55KSB8fCBzcmNTaGFwZS5jaGVja1BvaW50KHRndE91dHNpZGVbMF0sIHRndE91dHNpZGVbMV0sIDAsIHNyY1csIHNyY0gsIHNyY1Bvcy54LCBzcmNQb3MueSk7XG4gICAgICAgIHBhaXJJbmZvLnZlY3Rvck5vcm1JbnZlcnNlID0gdmVjdG9yTm9ybUludmVyc2U7XG4gICAgICAgIHN3YXBwZWRwYWlySW5mbyA9IHtcbiAgICAgICAgICBub2Rlc092ZXJsYXA6IHBhaXJJbmZvLm5vZGVzT3ZlcmxhcCxcbiAgICAgICAgICBkaXJDb3VudHM6IHBhaXJJbmZvLmRpckNvdW50cyxcbiAgICAgICAgICBjYWxjdWxhdGVkSW50ZXJzZWN0aW9uOiB0cnVlLFxuICAgICAgICAgIGhhc0JlemllcjogcGFpckluZm8uaGFzQmV6aWVyLFxuICAgICAgICAgIGhhc1VuYnVuZGxlZDogcGFpckluZm8uaGFzVW5idW5kbGVkLFxuICAgICAgICAgIGVsZXM6IHBhaXJJbmZvLmVsZXMsXG4gICAgICAgICAgc3JjUG9zOiB0Z3RQb3MsXG4gICAgICAgICAgdGd0UG9zOiBzcmNQb3MsXG4gICAgICAgICAgc3JjVzogdGd0VyxcbiAgICAgICAgICBzcmNIOiB0Z3RILFxuICAgICAgICAgIHRndFc6IHNyY1csXG4gICAgICAgICAgdGd0SDogc3JjSCxcbiAgICAgICAgICBzcmNJbnRuOiB0Z3RJbnRuLFxuICAgICAgICAgIHRndEludG46IHNyY0ludG4sXG4gICAgICAgICAgc3JjU2hhcGU6IHRndFNoYXBlLFxuICAgICAgICAgIHRndFNoYXBlOiBzcmNTaGFwZSxcbiAgICAgICAgICBwb3NQdHM6IHtcbiAgICAgICAgICAgIHgxOiBwb3NQdHMueDIsXG4gICAgICAgICAgICB5MTogcG9zUHRzLnkyLFxuICAgICAgICAgICAgeDI6IHBvc1B0cy54MSxcbiAgICAgICAgICAgIHkyOiBwb3NQdHMueTFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGludGVyc2VjdGlvblB0czoge1xuICAgICAgICAgICAgeDE6IGludGVyc2VjdGlvblB0cy54MixcbiAgICAgICAgICAgIHkxOiBpbnRlcnNlY3Rpb25QdHMueTIsXG4gICAgICAgICAgICB4MjogaW50ZXJzZWN0aW9uUHRzLngxLFxuICAgICAgICAgICAgeTI6IGludGVyc2VjdGlvblB0cy55MVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVjdG9yOiB7XG4gICAgICAgICAgICB4OiAtdmVjdG9yLngsXG4gICAgICAgICAgICB5OiAtdmVjdG9yLnlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlY3Rvck5vcm06IHtcbiAgICAgICAgICAgIHg6IC12ZWN0b3JOb3JtLngsXG4gICAgICAgICAgICB5OiAtdmVjdG9yTm9ybS55XG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZWN0b3JOb3JtSW52ZXJzZToge1xuICAgICAgICAgICAgeDogLXZlY3Rvck5vcm1JbnZlcnNlLngsXG4gICAgICAgICAgICB5OiAtdmVjdG9yTm9ybUludmVyc2UueVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhc3NlZFBhaXJJbmZvID0gZWRnZUlzU3dhcHBlZCA/IHN3YXBwZWRwYWlySW5mbyA6IHBhaXJJbmZvO1xuICAgICAgcnMubm9kZXNPdmVybGFwID0gcGFzc2VkUGFpckluZm8ubm9kZXNPdmVybGFwO1xuICAgICAgcnMuc3JjSW50biA9IHBhc3NlZFBhaXJJbmZvLnNyY0ludG47XG4gICAgICBycy50Z3RJbnRuID0gcGFzc2VkUGFpckluZm8udGd0SW50bjtcblxuICAgICAgaWYgKGhhc0NvbXBvdW5kcyAmJiAoc3JjLmlzUGFyZW50KCkgfHwgc3JjLmlzQ2hpbGQoKSB8fCB0Z3QuaXNQYXJlbnQoKSB8fCB0Z3QuaXNDaGlsZCgpKSAmJiAoc3JjLnBhcmVudHMoKS5hbnlTYW1lKHRndCkgfHwgdGd0LnBhcmVudHMoKS5hbnlTYW1lKHNyYykgfHwgc3JjLnNhbWUodGd0KSAmJiBzcmMuaXNQYXJlbnQoKSkpIHtcbiAgICAgICAgX3RoaXMuZmluZENvbXBvdW5kTG9vcFBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8sIF9pMiwgX2VkZ2VJc1VuYnVuZGxlZCk7XG4gICAgICB9IGVsc2UgaWYgKHNyYyA9PT0gdGd0KSB7XG4gICAgICAgIF90aGlzLmZpbmRMb29wUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbywgX2kyLCBfZWRnZUlzVW5idW5kbGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoX2N1cnZlU3R5bGUgPT09ICdzZWdtZW50cycpIHtcbiAgICAgICAgX3RoaXMuZmluZFNlZ21lbnRzUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbyk7XG4gICAgICB9IGVsc2UgaWYgKF9jdXJ2ZVN0eWxlID09PSAndGF4aScpIHtcbiAgICAgICAgX3RoaXMuZmluZFRheGlQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvKTtcbiAgICAgIH0gZWxzZSBpZiAoX2N1cnZlU3R5bGUgPT09ICdzdHJhaWdodCcgfHwgIV9lZGdlSXNVbmJ1bmRsZWQgJiYgcGFpckluZm8uZWxlcy5sZW5ndGggJSAyID09PSAxICYmIF9pMiA9PT0gTWF0aC5mbG9vcihwYWlySW5mby5lbGVzLmxlbmd0aCAvIDIpKSB7XG4gICAgICAgIF90aGlzLmZpbmRTdHJhaWdodEVkZ2VQb2ludHMoX2VkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuZmluZEJlemllclBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8sIF9pMiwgX2VkZ2VJc1VuYnVuZGxlZCwgZWRnZUlzU3dhcHBlZCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmZpbmRFbmRwb2ludHMoX2VkZ2UpO1xuXG4gICAgICBfdGhpcy50cnlUb0NvcnJlY3RJbnZhbGlkUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbyk7XG5cbiAgICAgIF90aGlzLmNoZWNrRm9ySW52YWxpZEVkZ2VXYXJuaW5nKF9lZGdlKTtcblxuICAgICAgX3RoaXMuc3RvcmVBbGxwdHMoX2VkZ2UpO1xuXG4gICAgICBfdGhpcy5zdG9yZUVkZ2VQcm9qZWN0aW9ucyhfZWRnZSk7XG5cbiAgICAgIF90aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKF9lZGdlKTtcblxuICAgICAgX3RoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyhfZWRnZSk7XG5cbiAgICAgIF90aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKF9lZGdlKTtcbiAgICB9IC8vIGZvciBwYWlyIGVkZ2VzXG5cbiAgfTtcblxuICBmb3IgKHZhciBwID0gMDsgcCA8IHBhaXJJZHMubGVuZ3RoOyBwKyspIHtcbiAgICBfbG9vcChwKTtcbiAgfSAvLyBmb3IgcGFpciBpZHNcbiAgLy8gaGF5c3RhY2tzIGF2b2lkIHRoZSBleHBlbnNlIG9mIHBhaXJJbmZvIHN0dWZmIChpbnRlcnNlY3Rpb25zIGV0Yy4pXG5cblxuICB0aGlzLmZpbmRIYXlzdGFja1BvaW50cyhoYXlzdGFja0VkZ2VzKTtcbn07XG5cbmZ1bmN0aW9uIGdldFB0cyhwdHMpIHtcbiAgdmFyIHJldFB0cyA9IFtdO1xuXG4gIGlmIChwdHMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHggPSBwdHNbaV07XG4gICAgdmFyIHkgPSBwdHNbaSArIDFdO1xuICAgIHJldFB0cy5wdXNoKHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcmV0UHRzO1xufVxuXG5CUnAkMy5nZXRTZWdtZW50UG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHR5cGUgPSBycy5lZGdlVHlwZTtcblxuICBpZiAodHlwZSA9PT0gJ3NlZ21lbnRzJykge1xuICAgIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICAgIHJldHVybiBnZXRQdHMocnMuc2VncHRzKTtcbiAgfVxufTtcblxuQlJwJDMuZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciB0eXBlID0gcnMuZWRnZVR5cGU7XG5cbiAgaWYgKHR5cGUgPT09ICdiZXppZXInIHx8IHR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgdHlwZSA9PT0gJ3NlbGYnIHx8IHR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgICByZXR1cm4gZ2V0UHRzKHJzLmN0cmxwdHMpO1xuICB9XG59O1xuXG5CUnAkMy5nZXRFZGdlTWlkcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBycy5taWRYLFxuICAgIHk6IHJzLm1pZFlcbiAgfTtcbn07XG5cbnZhciBCUnAkNCA9IHt9O1xuXG5CUnAkNC5tYW51YWxFbmRwdFRvUHggPSBmdW5jdGlvbiAobm9kZSwgcHJvcCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBucG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICB2YXIgdyA9IG5vZGUub3V0ZXJXaWR0aCgpO1xuICB2YXIgaCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcblxuICBpZiAocHJvcC52YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcCA9IFtwcm9wLnBmVmFsdWVbMF0sIHByb3AucGZWYWx1ZVsxXV07XG5cbiAgICBpZiAocHJvcC51bml0c1swXSA9PT0gJyUnKSB7XG4gICAgICBwWzBdID0gcFswXSAqIHc7XG4gICAgfVxuXG4gICAgaWYgKHByb3AudW5pdHNbMV0gPT09ICclJykge1xuICAgICAgcFsxXSA9IHBbMV0gKiBoO1xuICAgIH1cblxuICAgIHBbMF0gKz0gbnBvcy54O1xuICAgIHBbMV0gKz0gbnBvcy55O1xuICAgIHJldHVybiBwO1xuICB9IGVsc2Uge1xuICAgIHZhciBhbmdsZSA9IHByb3AucGZWYWx1ZVswXTtcbiAgICBhbmdsZSA9IC1NYXRoLlBJIC8gMiArIGFuZ2xlOyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrXG5cbiAgICB2YXIgbCA9IDIgKiBNYXRoLm1heCh3LCBoKTtcbiAgICB2YXIgX3AgPSBbbnBvcy54ICsgTWF0aC5jb3MoYW5nbGUpICogbCwgbnBvcy55ICsgTWF0aC5zaW4oYW5nbGUpICogbF07XG4gICAgcmV0dXJuIHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShub2RlKV0uaW50ZXJzZWN0TGluZShucG9zLngsIG5wb3MueSwgdywgaCwgX3BbMF0sIF9wWzFdLCAwKTtcbiAgfVxufTtcblxuQlJwJDQuZmluZEVuZHBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGludGVyc2VjdDtcbiAgdmFyIHNvdXJjZSA9IGVkZ2Uuc291cmNlKClbMF07XG4gIHZhciB0YXJnZXQgPSBlZGdlLnRhcmdldCgpWzBdO1xuICB2YXIgc3JjUG9zID0gc291cmNlLnBvc2l0aW9uKCk7XG4gIHZhciB0Z3RQb3MgPSB0YXJnZXQucG9zaXRpb24oKTtcbiAgdmFyIHRndEFyU2hhcGUgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWFycm93LXNoYXBlJykudmFsdWU7XG4gIHZhciBzcmNBclNoYXBlID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICB2YXIgdGd0RGlzdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJykucGZWYWx1ZTtcbiAgdmFyIHNyY0Rpc3QgPSBlZGdlLnBzdHlsZSgnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZScpLnBmVmFsdWU7XG4gIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBldCA9IHJzLmVkZ2VUeXBlO1xuICB2YXIgdGF4aSA9IGN1cnZlU3R5bGUgPT09ICd0YXhpJztcbiAgdmFyIHNlbGYgPSBldCA9PT0gJ3NlbGYnIHx8IGV0ID09PSAnY29tcG91bmQnO1xuICB2YXIgYmV6aWVyID0gZXQgPT09ICdiZXppZXInIHx8IGV0ID09PSAnbXVsdGliZXppZXInIHx8IHNlbGY7XG4gIHZhciBtdWx0aSA9IGV0ICE9PSAnYmV6aWVyJztcbiAgdmFyIGxpbmVzID0gZXQgPT09ICdzdHJhaWdodCcgfHwgZXQgPT09ICdzZWdtZW50cyc7XG4gIHZhciBzZWdtZW50cyA9IGV0ID09PSAnc2VnbWVudHMnO1xuICB2YXIgaGFzRW5kcHRzID0gYmV6aWVyIHx8IG11bHRpIHx8IGxpbmVzO1xuICB2YXIgb3ZlcnJpZGVFbmRwdHMgPSBzZWxmIHx8IHRheGk7XG4gIHZhciBzcmNNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtZW5kcG9pbnQnKTtcbiAgdmFyIHNyY01hbkVuZHB0VmFsID0gb3ZlcnJpZGVFbmRwdHMgPyAnb3V0c2lkZS10by1ub2RlJyA6IHNyY01hbkVuZHB0LnZhbHVlO1xuICB2YXIgdGd0TWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWVuZHBvaW50Jyk7XG4gIHZhciB0Z3RNYW5FbmRwdFZhbCA9IG92ZXJyaWRlRW5kcHRzID8gJ291dHNpZGUtdG8tbm9kZScgOiB0Z3RNYW5FbmRwdC52YWx1ZTtcbiAgcnMuc3JjTWFuRW5kcHQgPSBzcmNNYW5FbmRwdDtcbiAgcnMudGd0TWFuRW5kcHQgPSB0Z3RNYW5FbmRwdDtcbiAgdmFyIHAxOyAvLyBsYXN0IGtub3duIHBvaW50IG9mIGVkZ2Ugb24gdGFyZ2V0IHNpZGVcblxuICB2YXIgcDI7IC8vIGxhc3Qga25vd24gcG9pbnQgb2YgZWRnZSBvbiBzb3VyY2Ugc2lkZVxuXG4gIHZhciBwMV9pOyAvLyBwb2ludCB0byBpbnRlcnNlY3Qgd2l0aCB0YXJnZXQgc2hhcGVcblxuICB2YXIgcDJfaTsgLy8gcG9pbnQgdG8gaW50ZXJzZWN0IHdpdGggc291cmNlIHNoYXBlXG5cbiAgaWYgKGJlemllcikge1xuICAgIHZhciBjcFN0YXJ0ID0gW3JzLmN0cmxwdHNbMF0sIHJzLmN0cmxwdHNbMV1dO1xuICAgIHZhciBjcEVuZCA9IG11bHRpID8gW3JzLmN0cmxwdHNbcnMuY3RybHB0cy5sZW5ndGggLSAyXSwgcnMuY3RybHB0c1tycy5jdHJscHRzLmxlbmd0aCAtIDFdXSA6IGNwU3RhcnQ7XG4gICAgcDEgPSBjcEVuZDtcbiAgICBwMiA9IGNwU3RhcnQ7XG4gIH0gZWxzZSBpZiAobGluZXMpIHtcbiAgICB2YXIgc3JjQXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbdGd0UG9zLngsIHRndFBvcy55XSA6IHJzLnNlZ3B0cy5zbGljZSgwLCAyKTtcbiAgICB2YXIgdGd0QXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbc3JjUG9zLngsIHNyY1Bvcy55XSA6IHJzLnNlZ3B0cy5zbGljZShycy5zZWdwdHMubGVuZ3RoIC0gMik7XG4gICAgcDEgPSB0Z3RBcnJvd0Zyb21QdDtcbiAgICBwMiA9IHNyY0Fycm93RnJvbVB0O1xuICB9XG5cbiAgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnaW5zaWRlLXRvLW5vZGUnKSB7XG4gICAgaW50ZXJzZWN0ID0gW3RndFBvcy54LCB0Z3RQb3MueV07XG4gIH0gZWxzZSBpZiAodGd0TWFuRW5kcHQudW5pdHMpIHtcbiAgICBpbnRlcnNlY3QgPSB0aGlzLm1hbnVhbEVuZHB0VG9QeCh0YXJnZXQsIHRndE1hbkVuZHB0KTtcbiAgfSBlbHNlIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScpIHtcbiAgICBpbnRlcnNlY3QgPSBycy50Z3RJbnRuOyAvLyB1c2UgY2FjaGVkIHZhbHVlIGZyb20gY3RybHB0IGNhbGNcbiAgfSBlbHNlIHtcbiAgICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJykge1xuICAgICAgcDFfaSA9IHAxO1xuICAgIH0gZWxzZSBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgcDFfaSA9IFtzcmNQb3MueCwgc3JjUG9zLnldO1xuICAgIH1cblxuICAgIGludGVyc2VjdCA9IHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZSh0YXJnZXQpXS5pbnRlcnNlY3RMaW5lKHRndFBvcy54LCB0Z3RQb3MueSwgdGFyZ2V0Lm91dGVyV2lkdGgoKSwgdGFyZ2V0Lm91dGVySGVpZ2h0KCksIHAxX2lbMF0sIHAxX2lbMV0sIDApO1xuXG4gICAgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJyB8fCB0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCcpIHtcbiAgICAgIHZhciB0cnMgPSB0YXJnZXQuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgbHcgPSB0cnMubGFiZWxXaWR0aDtcbiAgICAgIHZhciBsaCA9IHRycy5sYWJlbEhlaWdodDtcbiAgICAgIHZhciBseCA9IHRycy5sYWJlbFg7XG4gICAgICB2YXIgbHkgPSB0cnMubGFiZWxZO1xuICAgICAgdmFyIHZhID0gdGFyZ2V0LnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcblxuICAgICAgaWYgKHZhID09PSAndG9wJykge1xuICAgICAgICBseSAtPSBsaCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKHZhID09PSAnYm90dG9tJykge1xuICAgICAgICBseSArPSBsaCAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYSA9IHRhcmdldC5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWU7XG5cbiAgICAgIGlmIChoYSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGx4IC09IGx3IC8gMjtcbiAgICAgIH0gZWxzZSBpZiAoaGEgPT09ICdyaWdodCcpIHtcbiAgICAgICAgbHggKz0gbHcgLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFiZWxJbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbJ3JlY3RhbmdsZSddLmludGVyc2VjdExpbmUobHgsIGx5LCBsdywgbGgsIHAxX2lbMF0sIHAxX2lbMV0sIDApO1xuICAgICAgdmFyIHJlZlB0ID0gc3JjUG9zO1xuICAgICAgdmFyIGludFNxZGlzdCA9IHNxZGlzdChyZWZQdCwgYXJyYXkycG9pbnQoaW50ZXJzZWN0KSk7XG4gICAgICB2YXIgbGFiSW50U3FkaXN0ID0gc3FkaXN0KHJlZlB0LCBhcnJheTJwb2ludChsYWJlbEludGVyc2VjdCkpO1xuXG4gICAgICBpZiAobGFiSW50U3FkaXN0IDwgaW50U3FkaXN0KSB7XG4gICAgICAgIGludGVyc2VjdCA9IGxhYmVsSW50ZXJzZWN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBhcnJvd0VuZCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMSwgci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5zcGFjaW5nKGVkZ2UpICsgdGd0RGlzdCk7XG4gIHZhciBlZGdlRW5kID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAxLCByLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLmdhcChlZGdlKSArIHRndERpc3QpO1xuICBycy5lbmRYID0gZWRnZUVuZFswXTtcbiAgcnMuZW5kWSA9IGVkZ2VFbmRbMV07XG4gIHJzLmFycm93RW5kWCA9IGFycm93RW5kWzBdO1xuICBycy5hcnJvd0VuZFkgPSBhcnJvd0VuZFsxXTtcblxuICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdpbnNpZGUtdG8tbm9kZScpIHtcbiAgICBpbnRlcnNlY3QgPSBbc3JjUG9zLngsIHNyY1Bvcy55XTtcbiAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdC51bml0cykge1xuICAgIGludGVyc2VjdCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KHNvdXJjZSwgc3JjTWFuRW5kcHQpO1xuICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJykge1xuICAgIGludGVyc2VjdCA9IHJzLnNyY0ludG47IC8vIHVzZSBjYWNoZWQgdmFsdWUgZnJvbSBjdHJscHQgY2FsY1xuICB9IGVsc2Uge1xuICAgIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZScgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnKSB7XG4gICAgICBwMl9pID0gcDI7XG4gICAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICBwMl9pID0gW3RndFBvcy54LCB0Z3RQb3MueV07XG4gICAgfVxuXG4gICAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHNvdXJjZSldLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzb3VyY2Uub3V0ZXJXaWR0aCgpLCBzb3VyY2Uub3V0ZXJIZWlnaHQoKSwgcDJfaVswXSwgcDJfaVsxXSwgMCk7XG5cbiAgICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnIHx8IHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgdmFyIHNycyA9IHNvdXJjZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBfbHcgPSBzcnMubGFiZWxXaWR0aDtcbiAgICAgIHZhciBfbGggPSBzcnMubGFiZWxIZWlnaHQ7XG4gICAgICB2YXIgX2x4ID0gc3JzLmxhYmVsWDtcbiAgICAgIHZhciBfbHkgPSBzcnMubGFiZWxZO1xuICAgICAgdmFyIF92YSA9IHNvdXJjZS5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWU7XG5cbiAgICAgIGlmIChfdmEgPT09ICd0b3AnKSB7XG4gICAgICAgIF9seSAtPSBfbGggLyAyO1xuICAgICAgfSBlbHNlIGlmIChfdmEgPT09ICdib3R0b20nKSB7XG4gICAgICAgIF9seSArPSBfbGggLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2hhID0gc291cmNlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcblxuICAgICAgaWYgKF9oYSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIF9seCAtPSBfbHcgLyAyO1xuICAgICAgfSBlbHNlIGlmIChfaGEgPT09ICdyaWdodCcpIHtcbiAgICAgICAgX2x4ICs9IF9sdyAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbGFiZWxJbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbJ3JlY3RhbmdsZSddLmludGVyc2VjdExpbmUoX2x4LCBfbHksIF9sdywgX2xoLCBwMl9pWzBdLCBwMl9pWzFdLCAwKTtcblxuICAgICAgdmFyIF9yZWZQdCA9IHRndFBvcztcblxuICAgICAgdmFyIF9pbnRTcWRpc3QgPSBzcWRpc3QoX3JlZlB0LCBhcnJheTJwb2ludChpbnRlcnNlY3QpKTtcblxuICAgICAgdmFyIF9sYWJJbnRTcWRpc3QgPSBzcWRpc3QoX3JlZlB0LCBhcnJheTJwb2ludChfbGFiZWxJbnRlcnNlY3QpKTtcblxuICAgICAgaWYgKF9sYWJJbnRTcWRpc3QgPCBfaW50U3FkaXN0KSB7XG4gICAgICAgIGludGVyc2VjdCA9IF9sYWJlbEludGVyc2VjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYXJyb3dTdGFydCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMiwgci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5zcGFjaW5nKGVkZ2UpICsgc3JjRGlzdCk7XG4gIHZhciBlZGdlU3RhcnQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDIsIHIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uZ2FwKGVkZ2UpICsgc3JjRGlzdCk7XG4gIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgcnMuc3RhcnRZID0gZWRnZVN0YXJ0WzFdO1xuICBycy5hcnJvd1N0YXJ0WCA9IGFycm93U3RhcnRbMF07XG4gIHJzLmFycm93U3RhcnRZID0gYXJyb3dTdGFydFsxXTtcblxuICBpZiAoaGFzRW5kcHRzKSB7XG4gICAgaWYgKCFudW1iZXIocnMuc3RhcnRYKSB8fCAhbnVtYmVyKHJzLnN0YXJ0WSkgfHwgIW51bWJlcihycy5lbmRYKSB8fCAhbnVtYmVyKHJzLmVuZFkpKSB7XG4gICAgICBycy5iYWRMaW5lID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnMuYmFkTGluZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuQlJwJDQuZ2V0U291cmNlRW5kcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcblxuICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuaGF5c3RhY2tQdHNbMF0sXG4gICAgICAgIHk6IHJzLmhheXN0YWNrUHRzWzFdXG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJzLmFycm93U3RhcnRYLFxuICAgICAgICB5OiBycy5hcnJvd1N0YXJ0WVxuICAgICAgfTtcbiAgfVxufTtcblxuQlJwJDQuZ2V0VGFyZ2V0RW5kcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcblxuICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnMuaGF5c3RhY2tQdHNbMl0sXG4gICAgICAgIHk6IHJzLmhheXN0YWNrUHRzWzNdXG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJzLmFycm93RW5kWCxcbiAgICAgICAgeTogcnMuYXJyb3dFbmRZXG4gICAgICB9O1xuICB9XG59O1xuXG52YXIgQlJwJDUgPSB7fTtcblxuZnVuY3Rpb24gcHVzaEJlemllclB0cyhyLCBlZGdlLCBwdHMpIHtcbiAgdmFyIHFiZXppZXJBdCQxID0gZnVuY3Rpb24gcWJlemllckF0JDEocDEsIHAyLCBwMywgdCkge1xuICAgIHJldHVybiBxYmV6aWVyQXQocDEsIHAyLCBwMywgdCk7XG4gIH07XG5cbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5iZXppZXJQcm9qUGN0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gci5iZXppZXJQcm9qUGN0c1tpXTtcbiAgICBicHRzLnB1c2goe1xuICAgICAgeDogcWJlemllckF0JDEocHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgcCksXG4gICAgICB5OiBxYmV6aWVyQXQkMShwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCBwKVxuICAgIH0pO1xuICB9XG59XG5cbkJScCQ1LnN0b3JlRWRnZVByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciBldCA9IHJzLmVkZ2VUeXBlOyAvLyBjbGVhciB0aGUgY2FjaGVkIHBvaW50cyBzdGF0ZVxuXG4gIF9wLnJzdHlsZS5iZXppZXJQdHMgPSBudWxsO1xuICBfcC5yc3R5bGUubGluZVB0cyA9IG51bGw7XG4gIF9wLnJzdHlsZS5oYXlzdGFja1B0cyA9IG51bGw7XG5cbiAgaWYgKGV0ID09PSAnbXVsdGliZXppZXInIHx8IGV0ID09PSAnYmV6aWVyJyB8fCBldCA9PT0gJ3NlbGYnIHx8IGV0ID09PSAnY29tcG91bmQnKSB7XG4gICAgX3AucnN0eWxlLmJlemllclB0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBwdXNoQmV6aWVyUHRzKHRoaXMsIGVkZ2UsIHJzLmFsbHB0cy5zbGljZShpLCBpICsgNikpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldCA9PT0gJ3NlZ21lbnRzJykge1xuICAgIHZhciBscHRzID0gX3AucnN0eWxlLmxpbmVQdHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpICsgMSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgbHB0cy5wdXNoKHtcbiAgICAgICAgeDogcnMuYWxscHRzW2ldLFxuICAgICAgICB5OiBycy5hbGxwdHNbaSArIDFdXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXQgPT09ICdoYXlzdGFjaycpIHtcbiAgICB2YXIgaHB0cyA9IHJzLmhheXN0YWNrUHRzO1xuICAgIF9wLnJzdHlsZS5oYXlzdGFja1B0cyA9IFt7XG4gICAgICB4OiBocHRzWzBdLFxuICAgICAgeTogaHB0c1sxXVxuICAgIH0sIHtcbiAgICAgIHg6IGhwdHNbMl0sXG4gICAgICB5OiBocHRzWzNdXG4gICAgfV07XG4gIH1cblxuICBfcC5yc3R5bGUuYXJyb3dXaWR0aCA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLmFycm93U2hhcGVXaWR0aDtcbn07XG5cbkJScCQ1LnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIHRoaXMuZmluZEVkZ2VDb250cm9sUG9pbnRzKGVkZ2VzKTtcbn07XG5cbnZhciBCUnAkNiA9IHt9O1xuXG5CUnAkNi5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgY29udGVudCA9IG5vZGUucHN0eWxlKCdsYWJlbCcpLnN0clZhbHVlO1xuXG4gIGlmIChlbXB0eVN0cmluZyhjb250ZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0ZXh0WCwgdGV4dFk7XG4gIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gIHZhciBub2RlV2lkdGggPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHBhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcbiAgdmFyIG5vZGVQb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciB0ZXh0SGFsaWduID0gbm9kZS5wc3R5bGUoJ3RleHQtaGFsaWduJykuc3RyVmFsdWU7XG4gIHZhciB0ZXh0VmFsaWduID0gbm9kZS5wc3R5bGUoJ3RleHQtdmFsaWduJykuc3RyVmFsdWU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuXG4gIHN3aXRjaCAodGV4dEhhbGlnbikge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggLSBub2RlV2lkdGggLyAyIC0gcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgdGV4dFggPSBub2RlUG9zLnggKyBub2RlV2lkdGggLyAyICsgcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGUuZy4gY2VudGVyXG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueDtcbiAgfVxuXG4gIHN3aXRjaCAodGV4dFZhbGlnbikge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueSAtIG5vZGVIZWlnaHQgLyAyIC0gcGFkZGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHRleHRZID0gbm9kZVBvcy55ICsgbm9kZUhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZS5nLiBtaWRkbGVcbiAgICAgIHRleHRZID0gbm9kZVBvcy55O1xuICB9XG5cbiAgcnMubGFiZWxYID0gdGV4dFg7XG4gIHJzLmxhYmVsWSA9IHRleHRZO1xuICByc3R5bGUubGFiZWxYID0gdGV4dFg7XG4gIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcbiAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyhub2RlKTtcbn07XG5cbnZhciBsaW5lQW5nbGVGcm9tRGVsdGEgPSBmdW5jdGlvbiBsaW5lQW5nbGVGcm9tRGVsdGEoZHgsIGR5KSB7XG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbihkeSAvIGR4KTtcblxuICBpZiAoZHggPT09IDAgJiYgYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgPSBhbmdsZSAqIC0xO1xuICB9XG5cbiAgcmV0dXJuIGFuZ2xlO1xufTtcblxudmFyIGxpbmVBbmdsZSA9IGZ1bmN0aW9uIGxpbmVBbmdsZShwMCwgcDEpIHtcbiAgdmFyIGR4ID0gcDEueCAtIHAwLng7XG4gIHZhciBkeSA9IHAxLnkgLSBwMC55O1xuICByZXR1cm4gbGluZUFuZ2xlRnJvbURlbHRhKGR4LCBkeSk7XG59O1xuXG52YXIgYmV6aWVyQW5nbGUgPSBmdW5jdGlvbiBiZXppZXJBbmdsZShwMCwgcDEsIHAyLCB0KSB7XG4gIHZhciB0MCA9IGJvdW5kKDAsIHQgLSAwLjAwMSwgMSk7XG4gIHZhciB0MSA9IGJvdW5kKDAsIHQgKyAwLjAwMSwgMSk7XG4gIHZhciBscDAgPSBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0MCk7XG4gIHZhciBscDEgPSBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0MSk7XG4gIHJldHVybiBsaW5lQW5nbGUobHAwLCBscDEpO1xufTtcblxuQlJwJDYucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBwO1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY29udGVudCA9IHtcbiAgICBtaWQ6IGVkZ2UucHN0eWxlKCdsYWJlbCcpLnN0clZhbHVlLFxuICAgIHNvdXJjZTogZWRnZS5wc3R5bGUoJ3NvdXJjZS1sYWJlbCcpLnN0clZhbHVlLFxuICAgIHRhcmdldDogZWRnZS5wc3R5bGUoJ3RhcmdldC1sYWJlbCcpLnN0clZhbHVlXG4gIH07XG5cbiAgaWYgKGNvbnRlbnQubWlkIHx8IGNvbnRlbnQuc291cmNlIHx8IGNvbnRlbnQudGFyZ2V0KSA7IGVsc2Uge1xuICAgICAgcmV0dXJuOyAvLyBubyBsYWJlbHMgPT4gbm8gY2FsY3NcbiAgICB9IC8vIGFkZCBjZW50ZXIgcG9pbnQgdG8gc3R5bGUgc28gYm91bmRpbmcgYm94IGNhbGN1bGF0aW9ucyBjYW4gdXNlIGl0XG4gIC8vXG5cblxuICBwID0ge1xuICAgIHg6IHJzLm1pZFgsXG4gICAgeTogcnMubWlkWVxuICB9O1xuXG4gIHZhciBzZXRScyA9IGZ1bmN0aW9uIHNldFJzKHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKSB7XG4gICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpO1xuICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gIH07XG5cbiAgc2V0UnMoJ2xhYmVsWCcsIG51bGwsIHAueCk7XG4gIHNldFJzKCdsYWJlbFknLCBudWxsLCBwLnkpO1xuICB2YXIgbWlkQW5nbGUgPSBsaW5lQW5nbGVGcm9tRGVsdGEocnMubWlkRGlzcFgsIHJzLm1pZERpc3BZKTtcbiAgc2V0UnMoJ2xhYmVsQXV0b0FuZ2xlJywgbnVsbCwgbWlkQW5nbGUpO1xuXG4gIHZhciBjcmVhdGVDb250cm9sUG9pbnRJbmZvID0gZnVuY3Rpb24gY3JlYXRlQ29udHJvbFBvaW50SW5mbygpIHtcbiAgICBpZiAoY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGU7XG4gICAgfSAvLyB1c2UgY2FjaGUgc28gb25seSAxeCBwZXIgZWRnZVxuXG5cbiAgICB2YXIgY3RybHB0cyA9IFtdOyAvLyBzdG9yZSBlYWNoIGN0cmxwdCBpbmZvIGluaXRcblxuICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgdmFyIHAwID0ge1xuICAgICAgICB4OiBycy5hbGxwdHNbaV0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV1cbiAgICAgIH07XG4gICAgICB2YXIgcDEgPSB7XG4gICAgICAgIHg6IHJzLmFsbHB0c1tpICsgMl0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgM11cbiAgICAgIH07IC8vIGN0cmxwdFxuXG4gICAgICB2YXIgcDIgPSB7XG4gICAgICAgIHg6IHJzLmFsbHB0c1tpICsgNF0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgNV1cbiAgICAgIH07XG4gICAgICBjdHJscHRzLnB1c2goe1xuICAgICAgICBwMDogcDAsXG4gICAgICAgIHAxOiBwMSxcbiAgICAgICAgcDI6IHAyLFxuICAgICAgICBzdGFydERpc3Q6IDAsXG4gICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgc2VnbWVudHM6IFtdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG4gICAgdmFyIG5Qcm9qcyA9IHIuYmV6aWVyUHJvalBjdHMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gYWRkU2VnbWVudChjcCwgcDAsIHAxLCB0MCwgdDEpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkaXN0KHAwLCBwMSk7XG4gICAgICB2YXIgcHJldlNlZ21lbnQgPSBjcC5zZWdtZW50c1tjcC5zZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBzZWdtZW50ID0ge1xuICAgICAgICBwMDogcDAsXG4gICAgICAgIHAxOiBwMSxcbiAgICAgICAgdDA6IHQwLFxuICAgICAgICB0MTogdDEsXG4gICAgICAgIHN0YXJ0RGlzdDogcHJldlNlZ21lbnQgPyBwcmV2U2VnbWVudC5zdGFydERpc3QgKyBwcmV2U2VnbWVudC5sZW5ndGggOiAwLFxuICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgICAgfTtcbiAgICAgIGNwLnNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICBjcC5sZW5ndGggKz0gbGVuZ3RoO1xuICAgIH0gLy8gdXBkYXRlIGVhY2ggY3RybHB0IHdpdGggc2VnbWVudCBpbmZvXG5cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjdHJscHRzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGNwID0gY3RybHB0c1tfaV07XG4gICAgICB2YXIgcHJldkNwID0gY3RybHB0c1tfaSAtIDFdO1xuXG4gICAgICBpZiAocHJldkNwKSB7XG4gICAgICAgIGNwLnN0YXJ0RGlzdCA9IHByZXZDcC5zdGFydERpc3QgKyBwcmV2Q3AubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBhZGRTZWdtZW50KGNwLCBjcC5wMCwgYnB0c1tfaSAqIG5Qcm9qc10sIDAsIHIuYmV6aWVyUHJvalBjdHNbMF0pOyAvLyBmaXJzdFxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5Qcm9qcyAtIDE7IGorKykge1xuICAgICAgICBhZGRTZWdtZW50KGNwLCBicHRzW19pICogblByb2pzICsgal0sIGJwdHNbX2kgKiBuUHJvanMgKyBqICsgMV0sIHIuYmV6aWVyUHJvalBjdHNbal0sIHIuYmV6aWVyUHJvalBjdHNbaiArIDFdKTtcbiAgICAgIH1cblxuICAgICAgYWRkU2VnbWVudChjcCwgYnB0c1tfaSAqIG5Qcm9qcyArIG5Qcm9qcyAtIDFdLCBjcC5wMiwgci5iZXppZXJQcm9qUGN0c1tuUHJvanMgLSAxXSwgMSk7IC8vIGxhc3RcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSA9IGN0cmxwdHM7XG4gIH07XG5cbiAgdmFyIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24gPSBmdW5jdGlvbiBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKHByZWZpeCkge1xuICAgIHZhciBhbmdsZTtcbiAgICB2YXIgaXNTcmMgPSBwcmVmaXggPT09ICdzb3VyY2UnO1xuXG4gICAgaWYgKCFjb250ZW50W3ByZWZpeF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy10ZXh0LW9mZnNldCcpLnBmVmFsdWU7XG5cbiAgICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgICBjYXNlICdzZWxmJzpcbiAgICAgIGNhc2UgJ2NvbXBvdW5kJzpcbiAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY3BzID0gY3JlYXRlQ29udHJvbFBvaW50SW5mbygpO1xuICAgICAgICAgIHZhciBzZWxlY3RlZDtcbiAgICAgICAgICB2YXIgc3RhcnREaXN0ID0gMDtcbiAgICAgICAgICB2YXIgdG90YWxEaXN0ID0gMDsgLy8gZmluZCB0aGUgc2VnbWVudCB3ZSdyZSBvblxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfY3AgPSBjcHNbaXNTcmMgPyBpIDogY3BzLmxlbmd0aCAtIDEgLSBpXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfY3Auc2VnbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9zZWcgPSBfY3Auc2VnbWVudHNbaXNTcmMgPyBqIDogX2NwLnNlZ21lbnRzLmxlbmd0aCAtIDEgLSBqXTtcbiAgICAgICAgICAgICAgdmFyIGxhc3RTZWcgPSBpID09PSBjcHMubGVuZ3RoIC0gMSAmJiBqID09PSBfY3Auc2VnbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgc3RhcnREaXN0ID0gdG90YWxEaXN0O1xuICAgICAgICAgICAgICB0b3RhbERpc3QgKz0gX3NlZy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgaWYgKHRvdGFsRGlzdCA+PSBvZmZzZXQgfHwgbGFzdFNlZykge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0ge1xuICAgICAgICAgICAgICAgICAgY3A6IF9jcCxcbiAgICAgICAgICAgICAgICAgIHNlZ21lbnQ6IF9zZWdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY3AgPSBzZWxlY3RlZC5jcDtcbiAgICAgICAgICB2YXIgc2VnID0gc2VsZWN0ZWQuc2VnbWVudDtcbiAgICAgICAgICB2YXIgdFNlZ21lbnQgPSAob2Zmc2V0IC0gc3RhcnREaXN0KSAvIHNlZy5sZW5ndGg7XG4gICAgICAgICAgdmFyIHNlZ0R0ID0gc2VnLnQxIC0gc2VnLnQwO1xuICAgICAgICAgIHZhciB0ID0gaXNTcmMgPyBzZWcudDAgKyBzZWdEdCAqIHRTZWdtZW50IDogc2VnLnQxIC0gc2VnRHQgKiB0U2VnbWVudDtcbiAgICAgICAgICB0ID0gYm91bmQoMCwgdCwgMSk7XG4gICAgICAgICAgcCA9IHFiZXppZXJQdEF0KGNwLnAwLCBjcC5wMSwgY3AucDIsIHQpO1xuICAgICAgICAgIGFuZ2xlID0gYmV6aWVyQW5nbGUoY3AucDAsIGNwLnAxLCBjcC5wMiwgdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3RyYWlnaHQnOlxuICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGQgPSAwLFxuICAgICAgICAgICAgICBkaSxcbiAgICAgICAgICAgICAgZDA7XG4gICAgICAgICAgdmFyIHAwLCBwMTtcbiAgICAgICAgICB2YXIgbCA9IHJzLmFsbHB0cy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgKyAzIDwgbDsgX2kyICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChpc1NyYykge1xuICAgICAgICAgICAgICBwMCA9IHtcbiAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbX2kyXSxcbiAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbX2kyICsgMV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcDEgPSB7XG4gICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW19pMiArIDJdLFxuICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tfaTIgKyAzXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcDAgPSB7XG4gICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW2wgLSAyIC0gX2kyXSxcbiAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbbCAtIDEgLSBfaTJdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHAxID0ge1xuICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tsIC0gNCAtIF9pMl0sXG4gICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW2wgLSAzIC0gX2kyXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaSA9IGRpc3QocDAsIHAxKTtcbiAgICAgICAgICAgIGQwID0gZDtcbiAgICAgICAgICAgIGQgKz0gZGk7XG5cbiAgICAgICAgICAgIGlmIChkID49IG9mZnNldCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcEQgPSBvZmZzZXQgLSBkMDtcblxuICAgICAgICAgIHZhciBfdCA9IHBEIC8gZGk7XG5cbiAgICAgICAgICBfdCA9IGJvdW5kKDAsIF90LCAxKTtcbiAgICAgICAgICBwID0gbGluZUF0KHAwLCBwMSwgX3QpO1xuICAgICAgICAgIGFuZ2xlID0gbGluZUFuZ2xlKHAwLCBwMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRScygnbGFiZWxYJywgcHJlZml4LCBwLngpO1xuICAgIHNldFJzKCdsYWJlbFknLCBwcmVmaXgsIHAueSk7XG4gICAgc2V0UnMoJ2xhYmVsQXV0b0FuZ2xlJywgcHJlZml4LCBhbmdsZSk7XG4gIH07XG5cbiAgY2FsY3VsYXRlRW5kUHJvamVjdGlvbignc291cmNlJyk7XG4gIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24oJ3RhcmdldCcpO1xuICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKGVkZ2UpO1xufTtcblxuQlJwJDYuYXBwbHlMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyhlbGUpO1xuXG4gIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlLCAnc291cmNlJyk7XG4gICAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKGVsZSwgJ3RhcmdldCcpO1xuICB9XG59O1xuXG5CUnAkNi5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dChlbGUsIHByZWZpeCk7XG4gIHZhciBsYWJlbERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIHRleHQpO1xuICB2YXIgbGluZUhlaWdodCA9IGVsZS5wc3R5bGUoJ2xpbmUtaGVpZ2h0JykucGZWYWx1ZTtcbiAgdmFyIHRleHRXcmFwID0gZWxlLnBzdHlsZSgndGV4dC13cmFwJykuc3RyVmFsdWU7XG4gIHZhciBsaW5lcyA9IGdldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHByZWZpeCkgfHwgW107XG4gIHZhciBudW1MaW5lcyA9IHRleHRXcmFwICE9PSAnd3JhcCcgPyAxIDogTWF0aC5tYXgobGluZXMubGVuZ3RoLCAxKTtcbiAgdmFyIG5vcm1QZXJMaW5lSGVpZ2h0ID0gbGFiZWxEaW1zLmhlaWdodCAvIG51bUxpbmVzO1xuICB2YXIgbGFiZWxMaW5lSGVpZ2h0ID0gbm9ybVBlckxpbmVIZWlnaHQgKiBsaW5lSGVpZ2h0O1xuICB2YXIgd2lkdGggPSBsYWJlbERpbXMud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0ICsgKG51bUxpbmVzIC0gMSkgKiAobGluZUhlaWdodCAtIDEpICogbm9ybVBlckxpbmVIZWlnaHQ7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxXaWR0aCcsIHByZWZpeCwgd2lkdGgpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxXaWR0aCcsIHByZWZpeCwgd2lkdGgpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4LCBoZWlnaHQpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgsIGhlaWdodCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbExpbmVIZWlnaHQnLCBwcmVmaXgsIGxhYmVsTGluZUhlaWdodCk7XG59O1xuXG5CUnAkNi5nZXRMYWJlbFRleHQgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcGZkID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gIHZhciB0ZXh0ID0gZWxlLnBzdHlsZShwZmQgKyAnbGFiZWwnKS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRUcmFuc2Zvcm0gPSBlbGUucHN0eWxlKCd0ZXh0LXRyYW5zZm9ybScpLnZhbHVlO1xuXG4gIHZhciByc2NyYXRjaCA9IGZ1bmN0aW9uIHJzY3JhdGNoKHByb3BOYW1lLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCk7XG4gICAgfVxuICB9OyAvLyBmb3IgZW1wdHkgdGV4dCwgc2tpcCBhbGwgcHJvY2Vzc2luZ1xuXG5cbiAgaWYgKCF0ZXh0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ25vbmUnKSA7IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ3VwcGVyY2FzZScpIHtcbiAgICB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ2xvd2VyY2FzZScpIHtcbiAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdmFyIHdyYXBTdHlsZSA9IGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnZhbHVlO1xuXG4gIGlmICh3cmFwU3R5bGUgPT09ICd3cmFwJykge1xuICAgIHZhciBsYWJlbEtleSA9IHJzY3JhdGNoKCdsYWJlbEtleScpOyAvLyBzYXZlIHJlY2FsYyBpZiB0aGUgbGFiZWwgaXMgdGhlIHNhbWUgYXMgYmVmb3JlXG5cbiAgICBpZiAobGFiZWxLZXkgIT0gbnVsbCAmJiByc2NyYXRjaCgnbGFiZWxXcmFwS2V5JykgPT09IGxhYmVsS2V5KSB7XG4gICAgICByZXR1cm4gcnNjcmF0Y2goJ2xhYmVsV3JhcENhY2hlZFRleHQnKTtcbiAgICB9XG5cbiAgICB2YXIgendzcCA9IFwiXFx1MjAwQlwiO1xuICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgIHZhciBtYXhXID0gZWxlLnBzdHlsZSgndGV4dC1tYXgtd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBvdmVyZmxvdyA9IGVsZS5wc3R5bGUoJ3RleHQtb3ZlcmZsb3ctd3JhcCcpLnZhbHVlO1xuICAgIHZhciBvdmVyZmxvd0FueSA9IG92ZXJmbG93ID09PSAnYW55d2hlcmUnO1xuICAgIHZhciB3cmFwcGVkTGluZXMgPSBbXTtcbiAgICB2YXIgd29yZHNSZWdleCA9IC9bXFxzXFx1MjAwYl0rLztcbiAgICB2YXIgd29yZFNlcGFyYXRvciA9IG92ZXJmbG93QW55ID8gJycgOiAnICc7XG5cbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2xdO1xuICAgICAgdmFyIGxpbmVEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCBsaW5lKTtcbiAgICAgIHZhciBsaW5lVyA9IGxpbmVEaW1zLndpZHRoO1xuXG4gICAgICBpZiAob3ZlcmZsb3dBbnkpIHtcbiAgICAgICAgdmFyIHByb2Nlc3NlZExpbmUgPSBsaW5lLnNwbGl0KCcnKS5qb2luKHp3c3ApO1xuICAgICAgICBsaW5lID0gcHJvY2Vzc2VkTGluZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmVXID4gbWF4Vykge1xuICAgICAgICAvLyBsaW5lIGlzIHRvbyBsb25nXG4gICAgICAgIHZhciB3b3JkcyA9IGxpbmUuc3BsaXQod29yZHNSZWdleCk7XG4gICAgICAgIHZhciBzdWJsaW5lID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCB3b3Jkcy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgIHZhciB3b3JkID0gd29yZHNbd107XG4gICAgICAgICAgdmFyIHRlc3RMaW5lID0gc3VibGluZS5sZW5ndGggPT09IDAgPyB3b3JkIDogc3VibGluZSArIHdvcmRTZXBhcmF0b3IgKyB3b3JkO1xuICAgICAgICAgIHZhciB0ZXN0RGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKGVsZSwgdGVzdExpbmUpO1xuICAgICAgICAgIHZhciB0ZXN0VyA9IHRlc3REaW1zLndpZHRoO1xuXG4gICAgICAgICAgaWYgKHRlc3RXIDw9IG1heFcpIHtcbiAgICAgICAgICAgIC8vIHdvcmQgZml0cyBvbiBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgIHN1YmxpbmUgKz0gd29yZCArIHdvcmRTZXBhcmF0b3I7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdvcmQgc3RhcnRzIG5ldyBsaW5lXG4gICAgICAgICAgICBpZiAoc3VibGluZSkge1xuICAgICAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaChzdWJsaW5lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3VibGluZSA9IHdvcmQgKyB3b3JkU2VwYXJhdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiB0aGVyZSdzIHJlbWFpbmluZyB0ZXh0LCBwdXQgaXQgaW4gYSB3cmFwcGVkIGxpbmVcblxuXG4gICAgICAgIGlmICghc3VibGluZS5tYXRjaCgvXltcXHNcXHUyMDBiXSskLykpIHtcbiAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaChzdWJsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbGluZSBpcyBhbHJlYWR5IHNob3J0IGVub3VnaFxuICAgICAgICB3cmFwcGVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvclxuXG5cbiAgICByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCB3cmFwcGVkTGluZXMpO1xuICAgIHRleHQgPSByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkVGV4dCcsIHdyYXBwZWRMaW5lcy5qb2luKCdcXG4nKSk7XG4gICAgcnNjcmF0Y2goJ2xhYmVsV3JhcEtleScsIGxhYmVsS2V5KTtcbiAgfSBlbHNlIGlmICh3cmFwU3R5bGUgPT09ICdlbGxpcHNpcycpIHtcbiAgICB2YXIgX21heFcgPSBlbGUucHN0eWxlKCd0ZXh0LW1heC13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGVsbGlwc2l6ZWQgPSAnJztcbiAgICB2YXIgZWxsaXBzaXMgPSBcIlxcdTIwMjZcIjtcbiAgICB2YXIgaW5jTGFzdENoID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3aWR0aFdpdGhOZXh0Q2ggPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIGVsbGlwc2l6ZWQgKyB0ZXh0W2ldICsgZWxsaXBzaXMpLndpZHRoO1xuXG4gICAgICBpZiAod2lkdGhXaXRoTmV4dENoID4gX21heFcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGVsbGlwc2l6ZWQgKz0gdGV4dFtpXTtcblxuICAgICAgaWYgKGkgPT09IHRleHQubGVuZ3RoIC0gMSkge1xuICAgICAgICBpbmNMYXN0Q2ggPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW5jTGFzdENoKSB7XG4gICAgICBlbGxpcHNpemVkICs9IGVsbGlwc2lzO1xuICAgIH1cblxuICAgIHJldHVybiBlbGxpcHNpemVkO1xuICB9IC8vIGlmIGVsbGlwc2l6ZVxuXG5cbiAgcmV0dXJuIHRleHQ7XG59O1xuXG5CUnAkNi5nZXRMYWJlbEp1c3RpZmljYXRpb24gPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBqdXN0aWZpY2F0aW9uID0gZWxlLnBzdHlsZSgndGV4dC1qdXN0aWZpY2F0aW9uJykuc3RyVmFsdWU7XG4gIHZhciB0ZXh0SGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS5zdHJWYWx1ZTtcblxuICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgc3dpdGNoICh0ZXh0SGFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIHJldHVybiAncmlnaHQnO1xuXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICByZXR1cm4gJ2xlZnQnO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBqdXN0aWZpY2F0aW9uO1xuICB9XG59O1xuXG5CUnAkNi5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlLCB0ZXh0KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGNhY2hlS2V5ID0gaGFzaFN0cmluZyh0ZXh0LCBlbGUuX3ByaXZhdGUubGFiZWxEaW1zS2V5KTtcbiAgdmFyIGNhY2hlID0gci5sYWJlbERpbUNhY2hlIHx8IChyLmxhYmVsRGltQ2FjaGUgPSBbXSk7XG4gIHZhciBleGlzdGluZ1ZhbCA9IGNhY2hlW2NhY2hlS2V5XTtcblxuICBpZiAoZXhpc3RpbmdWYWwgIT0gbnVsbCkge1xuICAgIHJldHVybiBleGlzdGluZ1ZhbDtcbiAgfVxuXG4gIHZhciBzaXplTXVsdCA9IDE7IC8vIGluY3JlYXNlIHRoZSBzY2FsZSB0byBpbmNyZWFzZSBhY2N1cmFjeSB3LnIudC4gem9vbWVkIHRleHRcblxuICB2YXIgZlN0eWxlID0gZWxlLnBzdHlsZSgnZm9udC1zdHlsZScpLnN0clZhbHVlO1xuICB2YXIgc2l6ZSA9IHNpemVNdWx0ICogZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZSArICdweCc7XG4gIHZhciBmYW1pbHkgPSBlbGUucHN0eWxlKCdmb250LWZhbWlseScpLnN0clZhbHVlO1xuICB2YXIgd2VpZ2h0ID0gZWxlLnBzdHlsZSgnZm9udC13ZWlnaHQnKS5zdHJWYWx1ZTtcbiAgdmFyIGRpdiA9IHRoaXMubGFiZWxDYWxjRGl2O1xuXG4gIGlmICghZGl2KSB7XG4gICAgZGl2ID0gdGhpcy5sYWJlbENhbGNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIH1cblxuICB2YXIgZHMgPSBkaXYuc3R5bGU7IC8vIGZyb20gZWxlIHN0eWxlXG5cbiAgZHMuZm9udEZhbWlseSA9IGZhbWlseTtcbiAgZHMuZm9udFN0eWxlID0gZlN0eWxlO1xuICBkcy5mb250U2l6ZSA9IHNpemU7XG4gIGRzLmZvbnRXZWlnaHQgPSB3ZWlnaHQ7IC8vIGZvcmNlZCBzdHlsZVxuXG4gIGRzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZHMubGVmdCA9ICctOTk5OXB4JztcbiAgZHMudG9wID0gJy05OTk5cHgnO1xuICBkcy56SW5kZXggPSAnLTEnO1xuICBkcy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIGRzLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gIGRzLnBhZGRpbmcgPSAnMCc7XG4gIGRzLmxpbmVIZWlnaHQgPSAnMSc7XG5cbiAgaWYgKGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnZhbHVlID09PSAnd3JhcCcpIHtcbiAgICBkcy53aGl0ZVNwYWNlID0gJ3ByZSc7IC8vIHNvIG5ld2xpbmVzIGFyZSB0YWtlbiBpbnRvIGFjY291bnRcbiAgfSBlbHNlIHtcbiAgICBkcy53aGl0ZVNwYWNlID0gJ25vcm1hbCc7XG4gIH0gLy8gcHV0IGxhYmVsIGNvbnRlbnQgaW4gZGl2XG5cblxuICBkaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuICByZXR1cm4gY2FjaGVbY2FjaGVLZXldID0ge1xuICAgIHdpZHRoOiBNYXRoLmNlaWwoZGl2LmNsaWVudFdpZHRoIC8gc2l6ZU11bHQpLFxuICAgIGhlaWdodDogTWF0aC5jZWlsKGRpdi5jbGllbnRIZWlnaHQgLyBzaXplTXVsdClcbiAgfTtcbn07XG5cbkJScCQ2LmNhbGN1bGF0ZUxhYmVsQW5nbGUgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgdmFyIHByZWZpeERhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgdmFyIHJvdCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gIHZhciByb3RTdHIgPSByb3Quc3RyVmFsdWU7XG5cbiAgaWYgKHJvdFN0ciA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoaXNFZGdlICYmIHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgcmV0dXJuIHJzLmxhYmVsQXV0b0FuZ2xlO1xuICB9IGVsc2UgaWYgKHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJvdC5wZlZhbHVlO1xuICB9XG59O1xuXG5CUnAkNi5jYWxjdWxhdGVMYWJlbEFuZ2xlcyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICBycy5sYWJlbEFuZ2xlID0gci5jYWxjdWxhdGVMYWJlbEFuZ2xlKGVsZSk7XG5cbiAgaWYgKGlzRWRnZSkge1xuICAgIHJzLnNvdXJjZUxhYmVsQW5nbGUgPSByLmNhbGN1bGF0ZUxhYmVsQW5nbGUoZWxlLCAnc291cmNlJyk7XG4gICAgcnMudGFyZ2V0TGFiZWxBbmdsZSA9IHIuY2FsY3VsYXRlTGFiZWxBbmdsZShlbGUsICd0YXJnZXQnKTtcbiAgfVxufTtcblxudmFyIEJScCQ3ID0ge307XG52YXIgVE9PX1NNQUxMX0NVVF9SRUNUID0gMjg7XG52YXIgd2FybmVkQ3V0UmVjdCA9IGZhbHNlO1xuXG5CUnAkNy5nZXROb2RlU2hhcGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBzaGFwZSA9IG5vZGUucHN0eWxlKCdzaGFwZScpLnZhbHVlO1xuXG4gIGlmIChzaGFwZSA9PT0gJ2N1dHJlY3RhbmdsZScgJiYgKG5vZGUud2lkdGgoKSA8IFRPT19TTUFMTF9DVVRfUkVDVCB8fCBub2RlLmhlaWdodCgpIDwgVE9PX1NNQUxMX0NVVF9SRUNUKSkge1xuICAgIGlmICghd2FybmVkQ3V0UmVjdCkge1xuICAgICAgd2FybignVGhlIGBjdXRyZWN0YW5nbGVgIG5vZGUgc2hhcGUgY2FuIG5vdCBiZSB1c2VkIGF0IHNtYWxsIHNpemVzIHNvIGByZWN0YW5nbGVgIGlzIHVzZWQgaW5zdGVhZCcpO1xuICAgICAgd2FybmVkQ3V0UmVjdCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuICB9XG5cbiAgaWYgKG5vZGUuaXNQYXJlbnQoKSkge1xuICAgIGlmIChzaGFwZSA9PT0gJ3JlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdyb3VuZHJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdjdXRyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAnYmFycmVsJykge1xuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNoYXBlID09PSAncG9seWdvbicpIHtcbiAgICB2YXIgcG9pbnRzID0gbm9kZS5wc3R5bGUoJ3NoYXBlLXBvbHlnb24tcG9pbnRzJykudmFsdWU7XG4gICAgcmV0dXJuIHIubm9kZVNoYXBlcy5tYWtlUG9seWdvbihwb2ludHMpLm5hbWU7XG4gIH1cblxuICByZXR1cm4gc2hhcGU7XG59O1xuXG52YXIgQlJwJDggPSB7fTtcblxuQlJwJDgucmVnaXN0ZXJDYWxjdWxhdGlvbkxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgdmFyIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHZhciBlbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShlbGVzKSB7XG4gICAgdmFyIGRpcnR5U3R5bGVDYWNoZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgZWxlc1RvVXBkYXRlLm1lcmdlKGVsZXMpO1xuXG4gICAgaWYgKGRpcnR5U3R5bGVDYWNoZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgICAgICByc3R5bGUuY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgcnN0eWxlLmNsZWFuQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHIuYmluZGVyKGN5KS5vbignYm91bmRzLiogZGlydHkuKicsIGZ1bmN0aW9uIG9uRGlydHlCb3VuZHMoZSkge1xuICAgIHZhciBlbGUgPSBlLnRhcmdldDtcbiAgICBlbnF1ZXVlKGVsZSk7XG4gIH0pLm9uKCdzdHlsZS4qIGJhY2tncm91bmQuKicsIGZ1bmN0aW9uIG9uRGlydHlTdHlsZShlKSB7XG4gICAgdmFyIGVsZSA9IGUudGFyZ2V0O1xuICAgIGVucXVldWUoZWxlLCBmYWxzZSk7XG4gIH0pO1xuXG4gIHZhciB1cGRhdGVFbGVDYWxjcyA9IGZ1bmN0aW9uIHVwZGF0ZUVsZUNhbGNzKHdpbGxEcmF3KSB7XG4gICAgaWYgKHdpbGxEcmF3KSB7XG4gICAgICB2YXIgZm5zID0gci5vblVwZGF0ZUVsZUNhbGNzRm5zO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1RvVXBkYXRlW2ldO1xuICAgICAgICB2YXIgcnN0eWxlID0gZWxlLl9wcml2YXRlLnJzdHlsZTtcblxuICAgICAgICBpZiAoZWxlLmlzTm9kZSgpICYmICFyc3R5bGUuY2xlYW5Db25uZWN0ZWQpIHtcbiAgICAgICAgICBlbnF1ZXVlKGVsZS5jb25uZWN0ZWRFZGdlcygpKTtcbiAgICAgICAgICByc3R5bGUuY2xlYW5Db25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZm4gPSBmbnNbaV07XG4gICAgICAgICAgZm4od2lsbERyYXcsIGVsZXNUb1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWxlc1RvVXBkYXRlKTtcbiAgICAgIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgci5mbHVzaFJlbmRlcmVkU3R5bGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB1cGRhdGVFbGVDYWxjcyh0cnVlKTtcbiAgfTtcblxuICByLmJlZm9yZVJlbmRlcih1cGRhdGVFbGVDYWxjcywgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmVsZUNhbGNzKTtcbn07XG5cbkJScCQ4Lm9uVXBkYXRlRWxlQ2FsY3MgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGZucyA9IHRoaXMub25VcGRhdGVFbGVDYWxjc0ZucyA9IHRoaXMub25VcGRhdGVFbGVDYWxjc0ZucyB8fCBbXTtcbiAgZm5zLnB1c2goZm4pO1xufTtcblxuQlJwJDgucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24gKGVsZXMsIHVzZUNhY2hlKSB7XG4gIHZhciBlZGdlcyA9IFtdO1xuICB2YXIgbm9kZXMgPSBbXTsgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIHVzZWQgZm9yIGNhbGNzIHdoZW4gZGVzdHJveWVkLCBlLmcuIGVsZS5ib3VuZGluZ0JveCgpXG5cbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIHVzZSBjYWNoZSBieSBkZWZhdWx0IGZvciBwZXJmXG5cblxuICBpZiAodXNlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHVzZUNhY2hlID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlOyAvLyBvbmx5IHVwZGF0ZSBpZiBkaXJ0eSBhbmQgaW4gZ3JhcGhcblxuICAgIGlmICh1c2VDYWNoZSAmJiByc3R5bGUuY2xlYW4gfHwgZWxlLnJlbW92ZWQoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBvbmx5IHVwZGF0ZSBpZiBub3QgZGlzcGxheTogbm9uZVxuXG5cbiAgICBpZiAoZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChfcC5ncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgbm9kZXMucHVzaChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlZGdlc1xuICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgIH1cblxuICAgIHJzdHlsZS5jbGVhbiA9IHRydWU7XG4gIH0gLy8gdXBkYXRlIG5vZGUgZGF0YSBmcm9tIHByb2plY3Rpb25zXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IG5vZGVzW2ldO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbihlbGUpO1xuICAgIHJzdHlsZS5ub2RlWCA9IHBvcy54O1xuICAgIHJzdHlsZS5ub2RlWSA9IHBvcy55O1xuICAgIHJzdHlsZS5ub2RlVyA9IGVsZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICByc3R5bGUubm9kZUggPSBlbGUucHN0eWxlKCdoZWlnaHQnKS5wZlZhbHVlO1xuICB9XG5cbiAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyhlZGdlcyk7IC8vIHVwZGF0ZSBlZGdlIGRhdGEgZnJvbSBwcm9qZWN0aW9uc1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWRnZXNbaV07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7IC8vIHVwZGF0ZSByc3R5bGUgcG9zaXRpb25zXG5cbiAgICByc3R5bGUuc3JjWCA9IHJzLmFycm93U3RhcnRYO1xuICAgIHJzdHlsZS5zcmNZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgcnN0eWxlLnRndFggPSBycy5hcnJvd0VuZFg7XG4gICAgcnN0eWxlLnRndFkgPSBycy5hcnJvd0VuZFk7XG4gICAgcnN0eWxlLm1pZFggPSBycy5taWRYO1xuICAgIHJzdHlsZS5taWRZID0gcnMubWlkWTtcbiAgICByc3R5bGUubGFiZWxBbmdsZSA9IHJzLmxhYmVsQW5nbGU7XG4gICAgcnN0eWxlLnNvdXJjZUxhYmVsQW5nbGUgPSBycy5zb3VyY2VMYWJlbEFuZ2xlO1xuICAgIHJzdHlsZS50YXJnZXRMYWJlbEFuZ2xlID0gcnMudGFyZ2V0TGFiZWxBbmdsZTtcbiAgfVxufTtcblxudmFyIEJScCQ5ID0ge307XG5cbkJScCQ5LnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlcyA9IHRoaXMuY2FjaGVkWlNvcnRlZEVsZXM7XG5cbiAgaWYgKCFlbGVzKSB7XG4gICAgLy8ganVzdCBsZXQgdGhpcyBiZSByZWNhbGN1bGF0ZWQgb24gdGhlIG5leHQgeiBzb3J0IHRpY2tcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVzLmRyYWcgPSBbXTtcbiAgZWxlcy5ub25kcmFnID0gW107XG4gIHZhciBncmFiVGFyZ2V0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgIGlmIChlbGUuZ3JhYmJlZCgpICYmICFlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgZ3JhYlRhcmdldHMucHVzaChlbGUpO1xuICAgIH0gZWxzZSBpZiAocnMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIGVsZXMuZHJhZy5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMubm9uZHJhZy5wdXNoKGVsZSk7XG4gICAgfVxuICB9IC8vIHB1dCB0aGUgZ3JhYiB0YXJnZXQgbm9kZXMgbGFzdCBzbyBpdCdzIG9uIHRvcCBvZiBpdHMgbmVpZ2hib3VyaG9vZFxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFiVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBncmFiVGFyZ2V0c1tpXTtcbiAgICBlbGVzLmRyYWcucHVzaChlbGUpO1xuICB9XG59O1xuXG5CUnAkOS5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBudWxsO1xufTtcblxuQlJwJDkuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiAoZm9yY2VSZWNhbGMpIHtcbiAgaWYgKGZvcmNlUmVjYWxjIHx8ICF0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzLmN5Lm11dGFibGVFbGVtZW50cygpLnRvQXJyYXkoKTtcbiAgICBlbGVzLnNvcnQoekluZGV4U29ydCk7XG4gICAgZWxlcy5pbnRlcmFjdGl2ZSA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaW50ZXJhY3RpdmUoKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gZWxlcztcbiAgICB0aGlzLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gIH0gZWxzZSB7XG4gICAgZWxlcyA9IHRoaXMuY2FjaGVkWlNvcnRlZEVsZXM7XG4gIH1cblxuICByZXR1cm4gZWxlcztcbn07XG5cbnZhciBCUnAkYSA9IHt9O1xuW0JScCQxLCBCUnAkMiwgQlJwJDMsIEJScCQ0LCBCUnAkNSwgQlJwJDYsIEJScCQ3LCBCUnAkOCwgQlJwJDldLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChCUnAkYSwgcHJvcHMpO1xufSk7XG5cbnZhciBCUnAkYiA9IHt9O1xuXG5CUnAkYi5nZXRDYWNoZWRJbWFnZSA9IGZ1bmN0aW9uICh1cmwsIGNyb3NzT3JpZ2luLCBvbkxvYWQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSB8fCB7fTtcbiAgdmFyIGNhY2hlID0gaW1hZ2VDYWNoZVt1cmxdO1xuXG4gIGlmIChjYWNoZSkge1xuICAgIGlmICghY2FjaGUuaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgIGNhY2hlLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZS5pbWFnZTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZSA9IGltYWdlQ2FjaGVbdXJsXSA9IGltYWdlQ2FjaGVbdXJsXSB8fCB7fTtcbiAgICB2YXIgaW1hZ2UgPSBjYWNoZS5pbWFnZSA9IG5ldyBJbWFnZSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGltYWdlLmVycm9yID0gdHJ1ZTtcbiAgICB9KTsgLy8gIzE1ODIgc2FmYXJpIGRvZXNuJ3QgbG9hZCBkYXRhIHVyaXMgd2l0aCBjcm9zc09yaWdpbiBwcm9wZXJseVxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjM5NzhcblxuICAgIHZhciBkYXRhVXJpUHJlZml4ID0gJ2RhdGE6JztcbiAgICB2YXIgaXNEYXRhVXJpID0gdXJsLnN1YnN0cmluZygwLCBkYXRhVXJpUHJlZml4Lmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gZGF0YVVyaVByZWZpeDtcblxuICAgIGlmICghaXNEYXRhVXJpKSB7XG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luOyAvLyBwcmV2ZW50IHRhaW50ZWQgY2FudmFzXG4gICAgfVxuXG4gICAgaW1hZ2Uuc3JjID0gdXJsO1xuICAgIHJldHVybiBpbWFnZTtcbiAgfVxufTtcblxudmFyIEJScCRjID0ge307XG4vKiBnbG9iYWwgZG9jdW1lbnQsIHdpbmRvdywgUmVzaXplT2JzZXJ2ZXIsIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuQlJwJGMucmVnaXN0ZXJCaW5kaW5nID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMsIFsxXSk7IC8vIGNvcHlcblxuICB2YXIgYiA9IHRoaXMuYmluZGVyKHRhcmdldCk7XG4gIHJldHVybiBiLm9uLmFwcGx5KGIsIGFyZ3MpO1xufTtcblxuQlJwJGMuYmluZGVyID0gZnVuY3Rpb24gKHRndCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciB0Z3RJc0RvbSA9IHRndCA9PT0gd2luZG93IHx8IHRndCA9PT0gZG9jdW1lbnQgfHwgdGd0ID09PSBkb2N1bWVudC5ib2R5IHx8IGRvbUVsZW1lbnQodGd0KTtcblxuICBpZiAoci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMgPT0gbnVsbCkge1xuICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWQjZmVhdHVyZS1kZXRlY3Rpb25cbiAgICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7Ly8gbm90IHN1cHBvcnRlZFxuICAgIH1cblxuICAgIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzID0gc3VwcG9ydHNQYXNzaXZlO1xuICB9XG5cbiAgdmFyIG9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGd0SXNEb20gJiYgci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMpIHtcbiAgICAgIC8vIHJlcGxhY2UgdXNlQ2FwdHVyZSB3LyBvcHRzIG9ialxuICAgICAgYXJnc1syXSA9IHtcbiAgICAgICAgY2FwdHVyZTogdXNlQ2FwdHVyZSAhPSBudWxsID8gdXNlQ2FwdHVyZSA6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgb25jZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgci5iaW5kaW5ncy5wdXNoKHtcbiAgICAgIHRhcmdldDogdGd0LFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuICAgICh0Z3QuYWRkRXZlbnRMaXN0ZW5lciB8fCB0Z3Qub24pLmFwcGx5KHRndCwgYXJncyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvbjogb24sXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogb24sXG4gICAgYWRkTGlzdGVuZXI6IG9uLFxuICAgIGJpbmQ6IG9uXG4gIH07XG59O1xuXG5CUnAkYy5ub2RlSXNEcmFnZ2FibGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLmlzTm9kZSgpICYmICFub2RlLmxvY2tlZCgpICYmIG5vZGUuZ3JhYmJhYmxlKCk7XG59O1xuXG5CUnAkYy5ub2RlSXNHcmFiYmFibGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gdGhpcy5ub2RlSXNEcmFnZ2FibGUobm9kZSkgJiYgbm9kZS5pbnRlcmFjdGl2ZSgpO1xufTtcblxuQlJwJGMubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHZhciBpc1NlbGVjdGVkID0gZnVuY3Rpb24gaXNTZWxlY3RlZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCk7XG4gIH07XG5cbiAgdmFyIHRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbiB0cmlnZ2VyRXZlbnRzKHRhcmdldCwgbmFtZXMsIGUsIHBvc2l0aW9uKSB7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICB0YXJnZXQgPSByLmN5O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICB0YXJnZXQuZW1pdCh7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6IG5hbWUsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc011bHRTZWxLZXlEb3duID0gZnVuY3Rpb24gaXNNdWx0U2VsS2V5RG93bihlKSB7XG4gICAgcmV0dXJuIGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5IHx8IGUuY3RybEtleTsgLy8gbWF5YmUgZS5hbHRLZXlcbiAgfTtcblxuICB2YXIgYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2ggPSBmdW5jdGlvbiBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChkb3duLCBkb3ducykge1xuICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gdHJ1ZTtcblxuICAgIGlmIChyLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSAmJiBkb3duICYmIGRvd24ucGFubmFibGUoKSkge1xuICAgICAgLy8gYSBncmFiYmFibGUgY29tcG91bmQgbm9kZSBiZWxvdyB0aGUgZWxlID0+IG5vIHBhc3N0aHJvdWdoIHBhbm5pbmdcbiAgICAgIGZvciAodmFyIGkgPSAwOyBkb3ducyAmJiBpIDwgZG93bnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRvd24gPSBkb3duc1tpXTtcblxuICAgICAgICBpZiAoZG93bi5pc05vZGUoKSAmJiBkb3duLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICBhbGxvd1Bhc3N0aHJvdWdoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWxsb3dQYXNzdGhyb3VnaCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsbG93UGFzc3Rocm91Z2g7XG4gIH07XG5cbiAgdmFyIHNldEdyYWJiZWQgPSBmdW5jdGlvbiBzZXRHcmFiYmVkKGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5ncmFiYmVkID0gdHJ1ZTtcbiAgfTtcblxuICB2YXIgc2V0RnJlZWQgPSBmdW5jdGlvbiBzZXRGcmVlZChlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBzZXRJbkRyYWdMYXllciA9IGZ1bmN0aW9uIHNldEluRHJhZ0xheWVyKGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHNldE91dERyYWdMYXllciA9IGZ1bmN0aW9uIHNldE91dERyYWdMYXllcihlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgc2V0R3JhYlRhcmdldCA9IGZ1bmN0aW9uIHNldEdyYWJUYXJnZXQoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmlzR3JhYlRhcmdldCA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHJlbW92ZUdyYWJUYXJnZXQgPSBmdW5jdGlvbiByZW1vdmVHcmFiVGFyZ2V0KGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pc0dyYWJUYXJnZXQgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgYWRkVG9EcmFnTGlzdCA9IGZ1bmN0aW9uIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKSB7XG4gICAgdmFyIGxpc3QgPSBvcHRzLmFkZFRvTGlzdDtcbiAgICB2YXIgbGlzdEhhc0VsZSA9IGxpc3QuaGFzKGVsZSk7XG5cbiAgICBpZiAoIWxpc3RIYXNFbGUpIHtcbiAgICAgIGxpc3QubWVyZ2UoZWxlKTtcbiAgICAgIHNldEdyYWJiZWQoZWxlKTtcbiAgICB9XG4gIH07IC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggY2hpbGQgbm9kZXMgYW5kIGlubmVyIGVkZ2VzXG4gIC8vIG9mIGEgY29tcG91bmQgbm9kZSB0byBiZSBkcmFnZ2VkIGFzIHdlbGwgYXMgdGhlIGdyYWJiZWQgYW5kIHNlbGVjdGVkIG5vZGVzXG5cblxuICB2YXIgYWRkRGVzY2VuZGFudHNUb0RyYWcgPSBmdW5jdGlvbiBhZGREZXNjZW5kYW50c1RvRHJhZyhub2RlLCBvcHRzKSB7XG4gICAgaWYgKCFub2RlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBub3RoaW5nIHRvIGRvXG5cblxuICAgIHZhciBpbm5lck5vZGVzID0gbm9kZS5kZXNjZW5kYW50cygpO1xuXG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgIGlubmVyTm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICBpbm5lck5vZGVzLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuYWRkVG9MaXN0KSB7XG4gICAgICBvcHRzLmFkZFRvTGlzdC51bm1lcmdlKGlubmVyTm9kZXMpO1xuICAgIH1cbiAgfTsgLy8gYWRkcyB0aGUgZ2l2ZW4gbm9kZXMgYW5kIGl0cyBuZWlnaGJvdXJob29kIHRvIHRoZSBkcmFnIGxheWVyXG5cblxuICB2YXIgYWRkTm9kZXNUb0RyYWcgPSBmdW5jdGlvbiBhZGROb2Rlc1RvRHJhZyhub2Rlcywgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gbm9kZXMuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiAob3B0cy5pbkRyYWdMYXllcikge1xuICAgICAgbm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICBub2Rlcy5uZWlnaGJvcmhvb2QoKS5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gIWhhc0NvbXBvdW5kTm9kZXMgfHwgZWxlLmlzRWRnZSgpO1xuICAgICAgfSkuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuYWRkVG9MaXN0KSB7XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgYWRkVG9EcmFnTGlzdChlbGUsIG9wdHMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWRkRGVzY2VuZGFudHNUb0RyYWcobm9kZXMsIG9wdHMpOyAvLyBhbHdheXMgYWRkIHRvIGRyYWdcbiAgICAvLyBhbHNvIGFkZCBub2RlcyBhbmQgZWRnZXMgcmVsYXRlZCB0byB0aGUgdG9wbW9zdCBhbmNlc3RvclxuXG4gICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIobm9kZXMsIHtcbiAgICAgIGluRHJhZ0xheWVyOiBvcHRzLmluRHJhZ0xheWVyXG4gICAgfSk7XG4gICAgci51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICB9O1xuXG4gIHZhciBhZGROb2RlVG9EcmFnID0gYWRkTm9kZXNUb0RyYWc7XG5cbiAgdmFyIGZyZWVEcmFnZ2VkRWxlbWVudHMgPSBmdW5jdGlvbiBmcmVlRHJhZ2dlZEVsZW1lbnRzKGdyYWJiZWRFbGVzKSB7XG4gICAgaWYgKCFncmFiYmVkRWxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8ganVzdCBnbyBvdmVyIGFsbCBlbGVtZW50cyByYXRoZXIgdGhhbiBkb2luZyBhIGJ1bmNoIG9mIChwb3NzaWJseSBleHBlbnNpdmUpIHRyYXZlcnNhbHNcblxuXG4gICAgci5nZXRDYWNoZWRaU29ydGVkRWxlcygpLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgc2V0RnJlZWQoZWxlKTtcbiAgICAgIHNldE91dERyYWdMYXllcihlbGUpO1xuICAgICAgcmVtb3ZlR3JhYlRhcmdldChlbGUpO1xuICAgIH0pO1xuICAgIHIudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfTsgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBhbmNlc3RvciBub2RlcyBhbmQgZWRnZXMgc2hvdWxkIGdvXG4gIC8vIHRvIHRoZSBkcmFnIGxheWVyIChvciBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGRyYWcgbGF5ZXIpLlxuXG5cbiAgdmFyIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyID0gZnVuY3Rpb24gdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIobm9kZSwgb3B0cykge1xuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyID09IG51bGwgJiYgb3B0cy5hZGRUb0xpc3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbm90aGluZyB0byBkb1xuXG5cbiAgICBpZiAoIW5vZGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGZpbmQgdG9wLWxldmVsIHBhcmVudFxuXG5cbiAgICB2YXIgcGFyZW50ID0gbm9kZS5hbmNlc3RvcnMoKS5vcnBoYW5zKCk7IC8vIG5vIHBhcmVudCBub2RlOiBubyBub2RlcyB0byBhZGQgdG8gdGhlIGRyYWcgbGF5ZXJcblxuICAgIGlmIChwYXJlbnQuc2FtZShub2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IHBhcmVudC5kZXNjZW5kYW50cygpLnNwYXduU2VsZigpLm1lcmdlKHBhcmVudCkudW5tZXJnZShub2RlKS51bm1lcmdlKG5vZGUuZGVzY2VuZGFudHMoKSk7XG4gICAgdmFyIGVkZ2VzID0gbm9kZXMuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyKSB7XG4gICAgICBlZGdlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgIG5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmFkZFRvTGlzdCkge1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYmx1ckFjdGl2ZURvbUVsZW1lbnQgPSBmdW5jdGlvbiBibHVyQWN0aXZlRG9tRWxlbWVudCgpIHtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPSBudWxsICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1ciAhPSBudWxsKSB7XG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhdmVNdXRhdGlvbnNBcGkgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBoYXZlUmVzaXplT2JzZXJ2ZXJBcGkgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnOyAvLyB3YXRjaCBmb3Igd2hlbiB0aGUgY3kgY29udGFpbmVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgZG9tXG5cbiAgaWYgKGhhdmVNdXRhdGlvbnNBcGkpIHtcbiAgICByLnJlbW92ZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dG5zKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dG5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtdXRuID0gbXV0bnNbaV07XG4gICAgICAgIHZhciByTm9kZXMgPSBtdXRuLnJlbW92ZWROb2RlcztcblxuICAgICAgICBpZiAock5vZGVzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciByTm9kZSA9IHJOb2Rlc1tqXTtcblxuICAgICAgICAgICAgaWYgKHJOb2RlID09PSByLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICByLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoci5jb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgci5yZW1vdmVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyLnBhcmVudE5vZGUsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdET01Ob2RlUmVtb3ZlZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBvblJlc2l6ZSA9IHV0aWwoZnVuY3Rpb24gKCkge1xuICAgIHIuY3kucmVzaXplKCk7XG4gIH0sIDEwMCk7XG5cbiAgaWYgKGhhdmVNdXRhdGlvbnNBcGkpIHtcbiAgICByLnN0eWxlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihvblJlc2l6ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIHIuc3R5bGVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyLCB7XG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSk7XG4gIH0gLy8gYXV0byByZXNpemVcblxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3Jlc2l6ZScsIG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGlmIChoYXZlUmVzaXplT2JzZXJ2ZXJBcGkpIHtcbiAgICByLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgci5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyKTtcbiAgfVxuXG4gIHZhciBmb3JFYWNoVXAgPSBmdW5jdGlvbiBmb3JFYWNoVXAoZG9tRWxlLCBmbikge1xuICAgIHdoaWxlIChkb21FbGUgIT0gbnVsbCkge1xuICAgICAgZm4oZG9tRWxlKTtcbiAgICAgIGRvbUVsZSA9IGRvbUVsZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW52YWxpZGF0ZUNvb3JkcyA9IGZ1bmN0aW9uIGludmFsaWRhdGVDb29yZHMoKSB7XG4gICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgfTtcblxuICBmb3JFYWNoVXAoci5jb250YWluZXIsIGZ1bmN0aW9uIChkb21FbGUpIHtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICd0cmFuc2l0aW9uZW5kJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnYW5pbWF0aW9uZW5kJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnc2Nyb2xsJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gIH0pOyAvLyBzdG9wIHJpZ2h0IGNsaWNrIG1lbnUgZnJvbSBhcHBlYXJpbmcgb24gY3lcblxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuXG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IGZ1bmN0aW9uIGluQm94U2VsZWN0aW9uKCkge1xuICAgIHJldHVybiByLnNlbGVjdGlvbls0XSAhPT0gMDtcbiAgfTtcblxuICB2YXIgZXZlbnRJbkNvbnRhaW5lciA9IGZ1bmN0aW9uIGV2ZW50SW5Db250YWluZXIoZSkge1xuICAgIC8vIHNhdmUgY3ljbGVzIGlmIG1vdXNlIGV2ZW50cyBhcmVuJ3QgdG8gYmUgY2FwdHVyZWRcbiAgICB2YXIgY29udGFpbmVyUGFnZUNvb3JkcyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgIHZhciB4ID0gY29udGFpbmVyUGFnZUNvb3Jkc1swXTtcbiAgICB2YXIgeSA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMV07XG4gICAgdmFyIHdpZHRoID0gY29udGFpbmVyUGFnZUNvb3Jkc1syXTtcbiAgICB2YXIgaGVpZ2h0ID0gY29udGFpbmVyUGFnZUNvb3Jkc1szXTtcbiAgICB2YXIgcG9zaXRpb25zID0gZS50b3VjaGVzID8gZS50b3VjaGVzIDogW2VdO1xuICAgIHZhciBhdExlYXN0T25lUG9zSW5zaWRlID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwb3NpdGlvbnNbaV07XG5cbiAgICAgIGlmICh4IDw9IHAuY2xpZW50WCAmJiBwLmNsaWVudFggPD0geCArIHdpZHRoICYmIHkgPD0gcC5jbGllbnRZICYmIHAuY2xpZW50WSA8PSB5ICsgaGVpZ2h0KSB7XG4gICAgICAgIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWF0TGVhc3RPbmVQb3NJbnNpZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gci5jb250YWluZXI7XG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgIHZhciB0UGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgdmFyIGNvbnRhaW5lcklzVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICB3aGlsZSAodFBhcmVudCkge1xuICAgICAgaWYgKHRQYXJlbnQgPT09IGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXJJc1RhcmdldCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0UGFyZW50ID0gdFBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmICghY29udGFpbmVySXNUYXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGlmIHRhcmdldCBpcyBvdXRpc2RlIGN5IGNvbnRhaW5lciwgdGhlbiB0aGlzIGV2ZW50IGlzIG5vdCBmb3IgdXNcblxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07IC8vIFByaW1hcnkga2V5XG5cblxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIG1vdXNlZG93bkhhbmRsZXIoZSkge1xuICAgIGlmICghZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBibHVyQWN0aXZlRG9tRWxlbWVudCgpO1xuICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgIHIuaG92ZXJEYXRhLndoaWNoID0gZS53aGljaDtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBncG9zID0gW2UuY2xpZW50WCwgZS5jbGllbnRZXTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGdwb3NbMF0sIGdwb3NbMV0pO1xuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhcnMgPSByLmZpbmROZWFyZXN0RWxlbWVudHMocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICB2YXIgbmVhciA9IG5lYXJzWzBdO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gcG9zO1xuICAgIHIuaG92ZXJEYXRhLm1kb3duR1BvcyA9IGdwb3M7XG5cbiAgICB2YXIgY2hlY2tGb3JUYXBob2xkID0gZnVuY3Rpb24gY2hlY2tGb3JUYXBob2xkKCkge1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgY2xlYXJUaW1lb3V0KHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0KTtcbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGUgPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgICAgICAgaWYgKGVsZSkge1xuICAgICAgICAgICAgZWxlLmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgci50YXBob2xkRHVyYXRpb24pO1xuICAgIH07IC8vIFJpZ2h0IGNsaWNrIGJ1dHRvblxuXG5cbiAgICBpZiAoZS53aGljaCA9PSAzKSB7XG4gICAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gdHJ1ZTtcbiAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobmVhcikge1xuICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgIG5lYXIuZW1pdChjeHRFdnQpO1xuICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgIH1cblxuICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTsgLy8gUHJpbWFyeSBidXR0b25cbiAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gMSkge1xuICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgfSAvLyBFbGVtZW50IGRyYWdnaW5nXG5cblxuICAgICAge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgdW5kZXIgdGhlIGN1cnNvciBhbmQgaXQgaXMgZHJhZ2dhYmxlLCBwcmVwYXJlIHRvIGdyYWIgaXRcbiAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyLm5vZGVJc0dyYWJiYWJsZShuZWFyKSkge1xuICAgICAgICAgICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdHJpZ2dlckdyYWIgPSBmdW5jdGlvbiB0cmlnZ2VyR3JhYihlbGUpIHtcbiAgICAgICAgICAgICAgZWxlLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2V0R3JhYlRhcmdldChuZWFyKTtcblxuICAgICAgICAgICAgaWYgKCFuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyhuZWFyLCB7XG4gICAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKS5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuc2VsZWN0ZWQoKSAmJiByLm5vZGVJc0dyYWJiYWJsZShlbGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoc2VsZWN0ZWROb2Rlcywge1xuICAgICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFib24nKSk7XG4gICAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaCh0cmlnZ2VyR3JhYik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuZG93biA9IG5lYXI7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd25zID0gbmVhcnM7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2Vkb3duJywgJ3RhcHN0YXJ0JywgJ3Ztb3VzZWRvd24nXSwgZSwge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0gZWxzZSBpZiAobmVhci5wYW5uYWJsZSgpKSB7XG4gICAgICAgIHNlbGVjdFs0XSA9IDE7IC8vIGZvciBmdXR1cmUgcGFuXG4gICAgICB9XG5cbiAgICAgIGNoZWNrRm9yVGFwaG9sZCgpO1xuICAgIH0gLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb24gYm94IGNvb3JkaW5hdGVzXG5cblxuICAgIHNlbGVjdFswXSA9IHNlbGVjdFsyXSA9IHBvc1swXTtcbiAgICBzZWxlY3RbMV0gPSBzZWxlY3RbM10gPSBwb3NbMV07XG4gIH0sIGZhbHNlKTtcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gbW91c2Vtb3ZlSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcblxuICAgIGlmICghY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIGdwb3MgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZ3Bvc1swXSwgZ3Bvc1sxXSk7XG4gICAgdmFyIG1kb3duUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG4gICAgdmFyIG1kb3duR1BvcyA9IHIuaG92ZXJEYXRhLm1kb3duR1BvcztcbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIG5lYXIgPSBudWxsO1xuXG4gICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gci5ob3ZlckRhdGEubGFzdDtcbiAgICB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG4gICAgdmFyIGRpc3AgPSBbcG9zWzBdIC0gc2VsZWN0WzJdLCBwb3NbMV0gLSBzZWxlY3RbM11dO1xuICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuXG4gICAgaWYgKG1kb3duR1Bvcykge1xuICAgICAgdmFyIGR4ID0gZ3Bvc1swXSAtIG1kb3duR1Bvc1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gZ3Bvc1sxXSAtIG1kb3duR1Bvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyA9IGlzT3ZlclRocmVzaG9sZERyYWcgPSBkaXN0MiA+PSByLmRlc2t0b3BUYXBUaHJlc2hvbGQyO1xuICAgIH1cblxuICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oZSk7XG5cbiAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZURyYWdEZWx0YSA9IGZ1bmN0aW9uIHVwZGF0ZURyYWdEZWx0YSgpIHtcbiAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgIGlmIChkcmFnRGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMF0pO1xuICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZW1vdmUnLCAndm1vdXNlbW92ZScsICd0YXBkcmFnJ10sIGUsIHtcbiAgICAgIHg6IHBvc1swXSxcbiAgICAgIHk6IHBvc1sxXVxuICAgIH0pO1xuXG4gICAgdmFyIGdvSW50b0JveE1vZGUgPSBmdW5jdGlvbiBnb0ludG9Cb3hNb2RlKCkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdib3hzdGFydCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfTsgLy8gdHJpZ2dlciBjb250ZXh0IGRyYWcgaWYgcm1vdXNlIGRvd25cblxuXG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAzKSB7XG4gICAgICAvLyBidXQgb25seSBpZiBvdmVyIHRocmVzaG9sZFxuICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgZG93bi5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIuaG92ZXJEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgICBpZiAoci5ob3ZlckRhdGEuY3h0T3Zlcikge1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3Zlci5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgbmVhci5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDaGVjayBpZiB3ZSBhcmUgZHJhZyBwYW5uaW5nIHRoZSBlbnRpcmUgZ3JhcGhcblxuICAgIH0gZWxzZSBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgICAgaWYgKGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgdmFyIGRlbHRhUDtcblxuICAgICAgICBpZiAoci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4pIHtcbiAgICAgICAgICB2YXIgbWRQb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcbiAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICB4OiAocG9zWzBdIC0gbWRQb3NbMF0pICogem9vbSxcbiAgICAgICAgICAgIHk6IChwb3NbMV0gLSBtZFBvc1sxXSkgKiB6b29tXG4gICAgICAgICAgfTtcbiAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY3kucGFuQnkoZGVsdGFQKTtcbiAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IHRydWU7XG4gICAgICB9IC8vIE5lZWRzIHJlcHJvamVjdCBkdWUgdG8gcGFuIGNoYW5naW5nIHZpZXdwb3J0XG5cblxuICAgICAgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTsgLy8gQ2hlY2tzIHByaW1hcnkgYnV0dG9uIGRvd24gJiBvdXQgb2YgdGltZSAmIG1vdXNlIG5vdCBtb3ZlZCBtdWNoXG4gICAgfSBlbHNlIGlmIChzZWxlY3RbNF0gPT0gMSAmJiAoZG93biA9PSBudWxsIHx8IGRvd24ucGFubmFibGUoKSkpIHtcbiAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmcgJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIChtdWx0U2VsS2V5RG93biB8fCAhY3kucGFubmluZ0VuYWJsZWQoKSB8fCAhY3kudXNlclBhbm5pbmdFbmFibGVkKCkpKSB7XG4gICAgICAgICAgZ29JbnRvQm94TW9kZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goZG93biwgci5ob3ZlckRhdGEuZG93bnMpO1xuXG4gICAgICAgICAgaWYgKGFsbG93UGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGVjdFs0XSA9IDA7XG4gICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBhcnJheTJwb2ludChtZG93blBvcyk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG93biAmJiBkb3duLnBhbm5hYmxlKCkgJiYgZG93bi5hY3RpdmUoKSkge1xuICAgICAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb3duICYmIGRvd24ucGFubmFibGUoKSAmJiBkb3duLmFjdGl2ZSgpKSB7XG4gICAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKCFkb3duIHx8ICFkb3duLmdyYWJiZWQoKSkgJiYgbmVhciAhPSBsYXN0KSB7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhsYXN0LCBbJ21vdXNlb3V0JywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZW92ZXInLCAndGFwZHJhZ292ZXInXSwgZSwge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAvLyB0aGVuIHdlIGNhbiB0YWtlIGFjdGlvblxuICAgICAgICAgIGlmIChjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgIC8vIHRoZW4gc2VsZWN0aW9uIG92ZXJyaWRlc1xuICAgICAgICAgICAgaWYgKGRvd24gJiYgZG93bi5ncmFiYmVkKCkpIHtcbiAgICAgICAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlbWVudHMpO1xuICAgICAgICAgICAgICBkb3duLmVtaXQoJ2ZyZWVvbicpO1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdCgnZnJlZScpO1xuXG4gICAgICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgICAgICBkb3duLmVtaXQoJ2RyYWdmcmVlb24nKTtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdCgnZHJhZ2ZyZWUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnb0ludG9Cb3hNb2RlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkb3duICYmIGRvd24uZ3JhYmJlZCgpICYmIHIubm9kZUlzRHJhZ2dhYmxlKGRvd24pKSB7XG4gICAgICAgICAgICAvLyBkcmFnIG5vZGVcbiAgICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuXG4gICAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlOyAvLyBpbmRpY2F0ZSB0aGF0IHdlIGFjdHVhbGx5IGRpZCBkcmFnIHRoZSBub2RlXG5cbiAgICAgICAgICAgIHZhciB0b1RyaWdnZXIgPSBjeS5jb2xsZWN0aW9uKCk7IC8vIG5vdywgYWRkIHRoZSBlbGVtZW50cyB0byB0aGUgZHJhZyBsYXllciBpZiBub3QgZG9uZSBhbHJlYWR5XG5cbiAgICAgICAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzKSB7XG4gICAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKGRyYWdnZWRFbGVtZW50cywge1xuICAgICAgICAgICAgICAgIGluRHJhZ0xheWVyOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG90YWxTaGlmdCA9IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG51bWJlcihkaXNwWzBdKSAmJiBudW1iZXIoZGlzcFsxXSkpIHtcbiAgICAgICAgICAgICAgdG90YWxTaGlmdC54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkaXNwWzFdO1xuXG4gICAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdEZWx0YSAmJiBudW1iZXIoZHJhZ0RlbHRhWzBdKSAmJiBudW1iZXIoZHJhZ0RlbHRhWzFdKSkge1xuICAgICAgICAgICAgICAgICAgdG90YWxTaGlmdC54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBkRWxlID0gZHJhZ2dlZEVsZW1lbnRzW2ldO1xuXG4gICAgICAgICAgICAgIGlmIChyLm5vZGVJc0RyYWdnYWJsZShkRWxlKSAmJiBkRWxlLmdyYWJiZWQoKSkge1xuICAgICAgICAgICAgICAgIHRvVHJpZ2dlci5tZXJnZShkRWxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuICAgICAgICAgICAgdG9UcmlnZ2VyLnNpbGVudFNoaWZ0KHRvdGFsU2hpZnQpLmVtaXQoJ3Bvc2l0aW9uIGRyYWcnKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHNhdmUgZHJhZyBkZWx0YSBmb3Igd2hlbiB3ZSBhY3R1YWxseSBzdGFydCBkcmFnZ2luZyBzbyB0aGUgcmVsYXRpdmUgZ3JhYiBwb3MgaXMgY29uc3RhbnRcbiAgICAgICAgICB1cGRhdGVEcmFnRGVsdGEoKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBwcmV2ZW50IHRoZSBkcmFnZ2luZyBmcm9tIHRyaWdnZXJpbmcgdGV4dCBzZWxlY3Rpb24gb24gdGhlIHBhZ2VcblxuXG4gICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgfVxuXG4gICAgc2VsZWN0WzJdID0gcG9zWzBdO1xuICAgIHNlbGVjdFszXSA9IHBvc1sxXTtcblxuICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uIG1vdXNldXBIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuXG4gICAgaWYgKCFjYXB0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcbiAgICB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG4gICAgdmFyIG11bHRTZWxLZXlEb3duID0gaXNNdWx0U2VsS2V5RG93bihlKTtcblxuICAgIGlmIChyLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24pIHtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSB0cnVlO1xuICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDsgLy8gbm90IGFjdGl2ZSBiZyBub3dcblxuICAgIGlmIChkb3duKSB7XG4gICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDMpIHtcbiAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgZG93bi5lbWl0KGN4dEV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCkge1xuICAgICAgICB2YXIgY3h0VGFwID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgIGRvd24uZW1pdChjeHRUYXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3h0VGFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS53aGljaCA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChyLmhvdmVyRGF0YS53aGljaCA9PT0gMSkge1xuICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNldXAnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJ10sIGUsIHtcbiAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICB5OiBwb3NbMV1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSBhIG5vZGUgYXJvdW5kXG4gICAgICAmJiAhci5ob3ZlckRhdGEuZHJhZ2dlZCAvLyBkaWRuJ3QgcGFuXG4gICAgICAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nIC8vIG5vdCBib3ggc2VsZWN0aW9uXG4gICAgICAmJiAhci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0b28gbXVjaFxuICAgICAgKSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhkb3duLCBbJ2NsaWNrJywgJ3RhcCcsICd2Y2xpY2snXSwgZSwge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gRGVzZWxlY3QgYWxsIGVsZW1lbnRzIGlmIG5vdGhpbmcgaXMgY3VycmVudGx5IHVuZGVyIHRoZSBtb3VzZSBjdXJzb3IgYW5kIHdlIGFyZW4ndCBkcmFnZ2luZyBzb21ldGhpbmdcblxuXG4gICAgICBpZiAoZG93biA9PSBudWxsICYmIC8vIG5vdCBtb3VzZWRvd24gb24gbm9kZVxuICAgICAgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0aGUgbm9kZSBhcm91bmRcbiAgICAgICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICYmICFpc011bHRTZWxLZXlEb3duKGUpKSB7XG4gICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcblxuICAgICAgICBpZiAoZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBkcmFnZ2VkRWxlbWVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICB9IC8vIFNpbmdsZSBzZWxlY3Rpb25cblxuXG4gICAgICBpZiAobmVhciA9PSBkb3duICYmICFyLmRyYWdEYXRhLmRpZERyYWcgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBpZiAobmVhciAhPSBudWxsICYmIG5lYXIuX3ByaXZhdGUuc2VsZWN0YWJsZSkge1xuICAgICAgICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykgOyBlbHNlIGlmIChjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScgfHwgbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgIGlmIChuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgbmVhci51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmVhci5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bm1lcmdlKG5lYXIpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgICAgIG5lYXIuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgdmFyIGJveCA9IGN5LmNvbGxlY3Rpb24oci5nZXRBbGxJbkJveChzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10pKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgICBpZiAoYm94Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgIHR5cGU6ICdib3hlbmQnLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uIGVsZVdvdWxkQmVTZWxlY3RlZChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKSAmJiAhZWxlLnNlbGVjdGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJykge1xuICAgICAgICAgIGJveC5lbWl0KCdib3gnKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KCdib3hzZWxlY3QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVubWVyZ2UoYm94KS51bnNlbGVjdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJveC5lbWl0KCdib3gnKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KCdib3hzZWxlY3QnKTtcbiAgICAgICAgfSAvLyBhbHdheXMgbmVlZCByZWRyYXcgaW4gY2FzZSBlbGVzIHVuc2VsZWN0YWJsZVxuXG5cbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0gLy8gQ2FuY2VsIGRyYWcgcGFuXG5cblxuICAgICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSB7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlbGVjdFs0XSkge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHZhciBkb3duV2FzR3JhYmJlZCA9IGRvd24gJiYgZG93bi5ncmFiYmVkKCk7XG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZW1lbnRzKTtcblxuICAgICAgICBpZiAoZG93bldhc0dyYWJiZWQpIHtcbiAgICAgICAgICBkb3duLmVtaXQoJ2ZyZWVvbicpO1xuICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdmcmVlJyk7XG5cbiAgICAgICAgICBpZiAoci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgICBkb3duLmVtaXQoJ2RyYWdmcmVlb24nKTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdkcmFnZnJlZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gZWxzZSBub3QgcmlnaHQgbW91c2VcblxuXG4gICAgc2VsZWN0WzRdID0gMDtcbiAgICByLmhvdmVyRGF0YS5kb3duID0gbnVsbDtcbiAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyA9IGZhbHNlO1xuICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICByLmhvdmVyRGF0YS5tZG93blBvcyA9IG51bGw7XG4gICAgci5ob3ZlckRhdGEubWRvd25HUG9zID0gbnVsbDtcbiAgfSwgZmFsc2UpO1xuXG4gIHZhciB3aGVlbEhhbmRsZXIgPSBmdW5jdGlvbiB3aGVlbEhhbmRsZXIoZSkge1xuICAgIGlmIChyLnNjcm9sbGluZ1BhZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHdoaWxlIHNjcm9sbGluZywgaWdub3JlIHdoZWVsLXRvLXpvb21cblxuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICB2YXIgcnBvcyA9IFtwb3NbMF0gKiBjeS56b29tKCkgKyBjeS5wYW4oKS54LCBwb3NbMV0gKiBjeS56b29tKCkgKyBjeS5wYW4oKS55XTtcblxuICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCB8fCBpbkJveFNlbGVjdGlvbigpKSB7XG4gICAgICAvLyBpZiBwYW4gZHJhZ2dpbmcgb3IgY3h0IGRyYWdnaW5nLCB3aGVlbCBtb3ZlbWVudHMgbWFrZSBubyB6b29tXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IHRydWU7XG4gICAgICBjbGVhclRpbWVvdXQoci5kYXRhLndoZWVsVGltZW91dCk7XG4gICAgICByLmRhdGEud2hlZWxUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCAxNTApO1xuICAgICAgdmFyIGRpZmY7XG5cbiAgICAgIGlmIChlLmRlbHRhWSAhPSBudWxsKSB7XG4gICAgICAgIGRpZmYgPSBlLmRlbHRhWSAvIC0yNTA7XG4gICAgICB9IGVsc2UgaWYgKGUud2hlZWxEZWx0YVkgIT0gbnVsbCkge1xuICAgICAgICBkaWZmID0gZS53aGVlbERlbHRhWSAvIDEwMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmID0gZS53aGVlbERlbHRhIC8gMTAwMDtcbiAgICAgIH1cblxuICAgICAgZGlmZiA9IGRpZmYgKiByLndoZWVsU2Vuc2l0aXZpdHk7XG4gICAgICB2YXIgbmVlZHNXaGVlbEZpeCA9IGUuZGVsdGFNb2RlID09PSAxO1xuXG4gICAgICBpZiAobmVlZHNXaGVlbEZpeCkge1xuICAgICAgICAvLyBmaXhlcyBzbG93IHdoZWVsIGV2ZW50cyBvbiBmZi9saW51eCBhbmQgZmYvd2luZG93c1xuICAgICAgICBkaWZmICo9IDMzO1xuICAgICAgfVxuXG4gICAgICBjeS56b29tKHtcbiAgICAgICAgbGV2ZWw6IGN5Lnpvb20oKSAqIE1hdGgucG93KDEwLCBkaWZmKSxcbiAgICAgICAgcmVuZGVyZWRQb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHJwb3NbMF0sXG4gICAgICAgICAgeTogcnBvc1sxXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07IC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggd2hldGhlciBtb3VzZSB3aGVlbCBzaG91bGQgdHJpZ2dlciB6b29taW5nXG4gIC8vIC0tXG5cblxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3doZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTsgLy8gZGlzYWJsZSBub25zdGFuZGFyZCB3aGVlbCBldmVudHNcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZXdoZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdET01Nb3VzZVNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7IC8vIG9sZGVyIGZpcmVmb3hcblxuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdzY3JvbGwnLCBmdW5jdGlvbiBzY3JvbGxIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgci5zY3JvbGxpbmdQYWdlID0gdHJ1ZTtcbiAgICBjbGVhclRpbWVvdXQoci5zY3JvbGxpbmdQYWdlVGltZW91dCk7XG4gICAgci5zY3JvbGxpbmdQYWdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgci5zY3JvbGxpbmdQYWdlID0gZmFsc2U7XG4gICAgfSwgMjUwKTtcbiAgfSwgdHJ1ZSk7IC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggaGFuZGxpbmcgbW91c2VvdXQvbW91c2VvdmVyIG9uIHRoZSBDeXRvc2NhcGUgY29udGFpbmVyXG4gIC8vIEhhbmRsZSBtb3VzZW91dCBvbiBDeXRvc2NhcGUgY29udGFpbmVyXG5cbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZW91dCcsIGZ1bmN0aW9uIG1vdXNlT3V0SGFuZGxlcihlKSB7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgci5jeS5lbWl0KHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICB0eXBlOiAnbW91c2VvdXQnLFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICB5OiBwb3NbMV1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgZmFsc2UpO1xuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIG1vdXNlT3ZlckhhbmRsZXIoZSkge1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHIuY3kuZW1pdCh7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgdHlwZTogJ21vdXNlb3ZlcicsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfVxuICAgIH0pO1xuICB9LCBmYWxzZSk7XG4gIHZhciBmMXgxLCBmMXkxLCBmMngxLCBmMnkxOyAvLyBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cblxuICB2YXIgZGlzdGFuY2UxLCBkaXN0YW5jZTFTcTsgLy8gaW5pdGlhbCBkaXN0YW5jZSBiZXR3ZWVuIGZpbmdlciAxIGFuZCBmaW5nZXIgMiBmb3IgcGluY2gtdG8tem9vbVxuXG4gIHZhciBjZW50ZXIxLCBtb2RlbENlbnRlcjE7IC8vIGNlbnRlciBwb2ludCBvbiBzdGFydCBwaW5jaCB0byB6b29tXG5cbiAgdmFyIG9mZnNldExlZnQsIG9mZnNldFRvcDtcbiAgdmFyIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQ7XG4gIHZhciB0d29GaW5nZXJzU3RhcnRJbnNpZGU7XG5cbiAgdmFyIGRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gIH07XG5cbiAgdmFyIGRpc3RhbmNlU3EgPSBmdW5jdGlvbiBkaXN0YW5jZVNxKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuICh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKTtcbiAgfTtcblxuICB2YXIgdG91Y2hzdGFydEhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnRIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hzdGFydEhhbmRsZXIoZSkge1xuICAgIGlmICghZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJsdXJBY3RpdmVEb21FbGVtZW50KCk7XG4gICAgci50b3VjaERhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG5cbiAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICB9IC8vIHJlY29yZCBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cblxuXG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyk7XG4gICAgICB2YXIgb2Zmc2V0cyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gICAgICBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICAgICAgY29udGFpbmVyV2lkdGggPSBvZmZzZXRzWzJdO1xuICAgICAgY29udGFpbmVySGVpZ2h0ID0gb2Zmc2V0c1szXTtcbiAgICAgIGYxeDEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gICAgICBmMXkxID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICBmMngxID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgZjJ5MSA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlID0gMCA8PSBmMXgxICYmIGYxeDEgPD0gY29udGFpbmVyV2lkdGggJiYgMCA8PSBmMngxICYmIGYyeDEgPD0gY29udGFpbmVyV2lkdGggJiYgMCA8PSBmMXkxICYmIGYxeTEgPD0gY29udGFpbmVySGVpZ2h0ICYmIDAgPD0gZjJ5MSAmJiBmMnkxIDw9IGNvbnRhaW5lckhlaWdodDtcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UoZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSk7XG4gICAgICBkaXN0YW5jZTFTcSA9IGRpc3RhbmNlU3EoZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSk7XG4gICAgICBjZW50ZXIxID0gWyhmMXgxICsgZjJ4MSkgLyAyLCAoZjF5MSArIGYyeTEpIC8gMl07XG4gICAgICBtb2RlbENlbnRlcjEgPSBbKGNlbnRlcjFbMF0gLSBwYW4ueCkgLyB6b29tLCAoY2VudGVyMVsxXSAtIHBhbi55KSAvIHpvb21dOyAvLyBjb25zaWRlciBjb250ZXh0IHRhcFxuXG4gICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZCA9IDIwMDtcbiAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkU3EgPSBjeHREaXN0VGhyZXNob2xkICogY3h0RGlzdFRocmVzaG9sZDtcblxuICAgICAgaWYgKGRpc3RhbmNlMVNxIDwgY3h0RGlzdFRocmVzaG9sZFNxICYmICFlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgdmFyIG5lYXIxID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICB2YXIgbmVhcjIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMl0sIG5vd1szXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKG5lYXIxICYmIG5lYXIxLmlzTm9kZSgpKSB7XG4gICAgICAgICAgbmVhcjEuYWN0aXZhdGUoKS5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIxO1xuICAgICAgICB9IGVsc2UgaWYgKG5lYXIyICYmIG5lYXIyLmlzTm9kZSgpKSB7XG4gICAgICAgICAgbmVhcjIuYWN0aXZhdGUoKS5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEuY3h0ID0gdHJ1ZTtcbiAgICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAvLyBpZ25vcmVcbiAgICAgIC8vIHNhZmFyaSBvbiBpb3MgcGFucyB0aGUgcGFnZSBvdGhlcndpc2UgKG5vcm1hbGx5IHlvdSBzaG91bGQgYmUgYWJsZSB0byBwcmV2ZW50ZGVmYXVsdCBvbiB0b3VjaG1vdmUuLi4pXG4gICAgICBpZiAoY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1sxXSkgOyBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgIHZhciBuZWFycyA9IHIuZmluZE5lYXJlc3RFbGVtZW50cyhub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB2YXIgbmVhciA9IG5lYXJzWzBdO1xuXG4gICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydHMgPSBuZWFycztcblxuICAgICAgICBpZiAoci5ub2RlSXNHcmFiYmFibGUobmVhcikpIHtcbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBudWxsO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKG5lYXIuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgZHJhZyBlbGVtZW50cywgc2luY2UgbmVhciB3aWxsIGJlIGFkZGVkIGFnYWluXG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKSAmJiByLm5vZGVJc0dyYWJiYWJsZShlbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhzZWxlY3RlZE5vZGVzLCB7XG4gICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGROb2RlVG9EcmFnKG5lYXIsIHtcbiAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0R3JhYlRhcmdldChuZWFyKTtcblxuICAgICAgICAgIHZhciBtYWtlRXZlbnQgPSBmdW5jdGlvbiBtYWtlRXZlbnQodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGVzKSB7XG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgbi5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsndG91Y2hzdGFydCcsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJ10sIGUsIHtcbiAgICAgICAgeDogbm93WzBdLFxuICAgICAgICB5OiBub3dbMV1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH07XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9IC8vIFRhcCwgdGFwaG9sZFxuICAgICAgLy8gLS0tLS1cblxuXG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaFN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgICAgY2xlYXJUaW1lb3V0KHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0KTtcbiAgICAgIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID09PSBmYWxzZSAmJiAhci5waW5jaGluZyAvLyBpZiBwaW5jaGluZywgdGhlbiB0YXBob2xkIHVuc2VsZWN0IHNob3VsZG4ndCB0YWtlIGVmZmVjdFxuICAgICAgICAmJiAhci50b3VjaERhdGEuc2VsZWN0aW5nIC8vIGJveCBzZWxlY3Rpb24gc2hvdWxkbid0IGFsbG93IHRhcGhvbGQgdGhyb3VnaFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMoci50b3VjaERhdGEuc3RhcnQsIFsndGFwaG9sZCddLCBlLCB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPj0gMSkge1xuICAgICAgdmFyIHNQb3MgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNQb3NbaV0gPSBlYXJsaWVyW2ldID0gbm93W2ldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG91Y2gwID0gZS50b3VjaGVzWzBdO1xuICAgICAgci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb24gPSBbdG91Y2gwLmNsaWVudFgsIHRvdWNoMC5jbGllbnRZXTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbiAgdmFyIHRvdWNobW92ZUhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaG1vdmVIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlO1xuXG4gICAgaWYgKCFjYXB0dXJlICYmICFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRHUG9zID0gci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb247XG4gICAgdmFyIGlzT3ZlclRocmVzaG9sZERyYWc7XG5cbiAgICBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMF0gJiYgc3RhcnRHUG9zKSB7XG4gICAgICB2YXIgZGlzcCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKykge1xuICAgICAgICBkaXNwW2pdID0gbm93W2pdIC0gZWFybGllcltqXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGR4ID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBzdGFydEdQb3NbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gc3RhcnRHUG9zWzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICBpc092ZXJUaHJlc2hvbGREcmFnID0gZGlzdDIgPj0gci50b3VjaFRhcFRocmVzaG9sZDI7XG4gICAgfSAvLyBjb250ZXh0IHN3aXBlIGNhbmNlbGxpbmdcblxuXG4gICAgaWYgKGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7IC8vIHZhciBkaXN0YW5jZTIgPSBkaXN0YW5jZSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuXG4gICAgICB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIpO1xuICAgICAgdmFyIGZhY3RvclNxID0gZGlzdGFuY2UyU3EgLyBkaXN0YW5jZTFTcTtcbiAgICAgIHZhciBkaXN0VGhyZXNob2xkID0gMTUwO1xuICAgICAgdmFyIGRpc3RUaHJlc2hvbGRTcSA9IGRpc3RUaHJlc2hvbGQgKiBkaXN0VGhyZXNob2xkO1xuICAgICAgdmFyIGZhY3RvclRocmVzaG9sZCA9IDEuNTtcbiAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGRTcSA9IGZhY3RvclRocmVzaG9sZCAqIGZhY3RvclRocmVzaG9sZDsgLy8gY2FuY2VsIGN0eCBnZXN0dXJlcyBpZiB0aGUgZGlzdGFuY2UgYi90IHRoZSBmaW5nZXJzIGluY3JlYXNlc1xuXG4gICAgICBpZiAoZmFjdG9yU3EgPj0gZmFjdG9yVGhyZXNob2xkU3EgfHwgZGlzdGFuY2UyU3EgPj0gZGlzdFRocmVzaG9sZFNxKSB7XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnVuYWN0aXZhdGUoKS5lbWl0KGN4dEV2dCk7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gY29udGV4dCBzd2lwZVxuXG5cbiAgICBpZiAoY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQpIHtcbiAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuZW1pdChjeHRFdnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcbiAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuXG4gICAgICBpZiAoIXIudG91Y2hEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci50b3VjaERhdGEuY3h0T3Zlcikge1xuICAgICAgICBpZiAoci50b3VjaERhdGEuY3h0T3Zlcikge1xuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgbmVhci5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ292ZXInLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBib3ggc2VsZWN0aW9uXG5cbiAgICB9IGVsc2UgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sYXN0VGhyZWVUb3VjaCA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICBpZiAoIXIudG91Y2hEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdib3hzdGFydCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IHRydWU7XG4gICAgICByLnRvdWNoRGF0YS5kaWRTZWxlY3QgPSB0cnVlO1xuICAgICAgc2VsZWN0WzRdID0gMTtcblxuICAgICAgaWYgKCFzZWxlY3QgfHwgc2VsZWN0Lmxlbmd0aCA9PT0gMCB8fCBzZWxlY3RbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxlY3RbMF0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDM7XG4gICAgICAgIHNlbGVjdFsxXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMztcbiAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzICsgMTtcbiAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMztcbiAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzO1xuICAgICAgfVxuXG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTsgLy8gcGluY2ggdG8gem9vbVxuICAgIH0gZWxzZSBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMV0gJiYgIXIudG91Y2hEYXRhLmRpZFNlbGVjdCAvLyBkb24ndCBhbGxvdyBib3ggc2VsZWN0aW9uIHRvIGRlZ3JhZGUgdG8gcGluY2gtdG8tem9vbVxuICAgICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgLy8gdHdvIGZpbmdlcnMgPT4gcGluY2ggdG8gem9vbVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgaWYgKGRyYWdnZWRFbGVzKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGVfcCA9IGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlO1xuICAgICAgICAgIGRlX3AuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgIGRlX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX3N0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7IC8vICh4MiwgeTIpIGZvciBmaW5nZXJzIDEgYW5kIDJcblxuICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIpOyAvLyB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAvLyB2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KCBkaXN0YW5jZTJTcSApIC8gTWF0aC5zcXJ0KCBkaXN0YW5jZTFTcSApO1xuXG4gICAgICB2YXIgZmFjdG9yID0gZGlzdGFuY2UyIC8gZGlzdGFuY2UxO1xuXG4gICAgICBpZiAodHdvRmluZ2Vyc1N0YXJ0SW5zaWRlKSB7XG4gICAgICAgIC8vIGRlbHRhIGZpbmdlcjFcbiAgICAgICAgdmFyIGRmMXggPSBmMXgyIC0gZjF4MTtcbiAgICAgICAgdmFyIGRmMXkgPSBmMXkyIC0gZjF5MTsgLy8gZGVsdGEgZmluZ2VyIDJcblxuICAgICAgICB2YXIgZGYyeCA9IGYyeDIgLSBmMngxO1xuICAgICAgICB2YXIgZGYyeSA9IGYyeTIgLSBmMnkxOyAvLyB0cmFuc2xhdGlvbiBpcyB0aGUgbm9ybWFsaXNlZCB2ZWN0b3Igb2YgdGhlIHR3byBmaW5nZXJzIG1vdmVtZW50XG4gICAgICAgIC8vIGkuZS4gc28gcGluY2hpbmcgY2FuY2VscyBvdXQgYW5kIG1vdmluZyB0b2dldGhlciBwYW5zXG5cbiAgICAgICAgdmFyIHR4ID0gKGRmMXggKyBkZjJ4KSAvIDI7XG4gICAgICAgIHZhciB0eSA9IChkZjF5ICsgZGYyeSkgLyAyOyAvLyBub3cgY2FsY3VsYXRlIHRoZSB6b29tXG5cbiAgICAgICAgdmFyIHpvb20xID0gY3kuem9vbSgpO1xuICAgICAgICB2YXIgem9vbTIgPSB6b29tMSAqIGZhY3RvcjtcbiAgICAgICAgdmFyIHBhbjEgPSBjeS5wYW4oKTsgLy8gdGhlIG1vZGVsIGNlbnRlciBwb2ludCBjb252ZXJ0ZWQgdG8gdGhlIGN1cnJlbnQgcmVuZGVyZWQgcG9zXG5cbiAgICAgICAgdmFyIGN0cnggPSBtb2RlbENlbnRlcjFbMF0gKiB6b29tMSArIHBhbjEueDtcbiAgICAgICAgdmFyIGN0cnkgPSBtb2RlbENlbnRlcjFbMV0gKiB6b29tMSArIHBhbjEueTtcbiAgICAgICAgdmFyIHBhbjIgPSB7XG4gICAgICAgICAgeDogLXpvb20yIC8gem9vbTEgKiAoY3RyeCAtIHBhbjEueCAtIHR4KSArIGN0cngsXG4gICAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAoY3RyeSAtIHBhbjEueSAtIHR5KSArIGN0cnlcbiAgICAgICAgfTsgLy8gcmVtb3ZlIGRyYWdnZWQgZWxlc1xuXG4gICAgICAgIGlmIChfc3RhcnQgJiYgX3N0YXJ0LmFjdGl2ZSgpKSB7XG4gICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZXMpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuXG4gICAgICAgICAgX3N0YXJ0LnVuYWN0aXZhdGUoKS5lbWl0KCdmcmVlb24nKTtcblxuICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2ZyZWUnKTtcblxuICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgIF9zdGFydC5lbWl0KCdkcmFnZnJlZW9uJyk7XG5cbiAgICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2RyYWdmcmVlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3kudmlld3BvcnQoe1xuICAgICAgICAgIHpvb206IHpvb20yLFxuICAgICAgICAgIHBhbjogcGFuMixcbiAgICAgICAgICBjYW5jZWxPbkZhaWxlZFpvb206IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlMjtcbiAgICAgICAgZjF4MSA9IGYxeDI7XG4gICAgICAgIGYxeTEgPSBmMXkyO1xuICAgICAgICBmMngxID0gZjJ4MjtcbiAgICAgICAgZjJ5MSA9IGYyeTI7XG4gICAgICAgIHIucGluY2hpbmcgPSB0cnVlO1xuICAgICAgfSAvLyBSZS1wcm9qZWN0XG5cblxuICAgICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSAmJiAhci50b3VjaERhdGEuZGlkU2VsZWN0IC8vIGRvbid0IGFsbG93IGJveCBzZWxlY3Rpb24gdG8gZGVncmFkZSB0byBzaW5nbGUgZmluZ2VyIGV2ZW50cyBsaWtlIHBhbm5pbmdcbiAgICApIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgICAgIHZhciBsYXN0ID0gci50b3VjaERhdGEubGFzdDtcbiAgICAgICAgdmFyIG5lYXI7XG5cbiAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuc3dpcGVQYW5uaW5nKSB7XG4gICAgICAgICAgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gLy8gZHJhZ2dpbmcgbm9kZXNcblxuXG4gICAgICAgIGlmIChjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwgJiYgci5ub2RlSXNEcmFnZ2FibGUoc3RhcnQpKSB7XG4gICAgICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gZHJhZ2dpbmcgY2FuIGhhcHBlblxuICAgICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG5cbiAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoZHJhZ2dlZEVsZXMsIHtcbiAgICAgICAgICAgICAgICBpbkRyYWdMYXllcjogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB0b3RhbFNoaWZ0ID0ge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAobnVtYmVyKGRpc3BbMF0pICYmIG51bWJlcihkaXNwWzFdKSkge1xuICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRpc3BbMV07XG5cbiAgICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGE7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0RlbHRhICYmIG51bWJlcihkcmFnRGVsdGFbMF0pICYmIG51bWJlcihkcmFnRGVsdGFbMV0pKSB7XG4gICAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVzLnNpbGVudFNoaWZ0KHRvdGFsU2hpZnQpLmVtaXQoJ3Bvc2l0aW9uIGRyYWcnKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSA9PSBlYXJsaWVyWzBdICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gPT0gZWFybGllclsxXSkge1xuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJpc2Uga2VlcCB0cmFjayBvZiBkcmFnIGRlbHRhIGZvciBsYXRlclxuICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKGRyYWdEZWx0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFswXSk7XG4gICAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB0b3VjaG1vdmVcblxuXG4gICAgICAgIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0IHx8IG5lYXIsIFsndG91Y2htb3ZlJywgJ3RhcGRyYWcnLCAndm1vdXNlbW92ZSddLCBlLCB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICgoIXN0YXJ0IHx8ICFzdGFydC5ncmFiYmVkKCkpICYmIG5lYXIgIT0gbGFzdCkge1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgbGFzdC5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnb3V0JyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICAgICAgbmVhci5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnb3ZlcicsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci50b3VjaERhdGEubGFzdCA9IG5lYXI7XG4gICAgICAgIH0gLy8gY2hlY2sgdG8gY2FuY2VsIHRhcGhvbGRcblxuICAgICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobm93W2ldICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25baV0gJiYgaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gcGFubmluZ1xuXG5cbiAgICAgICAgaWYgKGNhcHR1cmUgJiYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQucGFubmFibGUoKSkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goc3RhcnQsIHIudG91Y2hEYXRhLnN0YXJ0cyk7XG5cbiAgICAgICAgICBpZiAoYWxsb3dQYXNzdGhyb3VnaCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoIXIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbikge1xuICAgICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBhcnJheTJwb2ludChyLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHIuc3dpcGVQYW5uaW5nKSB7XG4gICAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgICAgICByLnN3aXBlUGFubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgICB4OiBkeCAqIHpvb20sXG4gICAgICAgICAgICAgICAgeTogZHkgKiB6b29tXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gUmUtcHJvamVjdFxuXG5cbiAgICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIGVhcmxpZXJbal0gPSBub3dbal07XG4gICAgfSAvLyB0aGUgYWN0aXZlIGJnIGluZGljYXRvciBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIG1ha2luZyBhIHN3aXBlIHRoYXQgaXMgbmVpdGhlciBmb3IgZHJhZ2dpbmcgbm9kZXMgb3IgcGFubmluZ1xuXG5cbiAgICBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMCAmJiAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLnN3aXBlUGFubmluZyAmJiByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gIT0gbnVsbCkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG4gIHZhciB0b3VjaGNhbmNlbEhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNoY2FuY2VsJywgdG91Y2hjYW5jZWxIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hjYW5jZWxIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHRvdWNoZW5kSGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2hlbmQnLCB0b3VjaGVuZEhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaGVuZEhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG5cbiAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgci5zd2lwZVBhbm5pbmcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuXG4gICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIGN0eFRhcGVuZDtcblxuICAgIGlmIChyLnRvdWNoRGF0YS5jeHQpIHtcbiAgICAgIGN0eFRhcGVuZCA9IHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgc3RhcnQuZW1pdChjdHhUYXBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjdHhUYXBlbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXIudG91Y2hEYXRhLmN4dERyYWdnZWQpIHtcbiAgICAgICAgdmFyIGN0eFRhcCA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdjeHR0YXAnLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgc3RhcnQuZW1pdChjdHhUYXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3R4VGFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByLnRvdWNoRGF0YS5jeHQgPSBmYWxzZTtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBubyBtb3JlIGJveCBzZWxlY3Rpb24gaWYgd2UgZG9uJ3QgaGF2ZSB0aHJlZSBmaW5nZXJzXG5cblxuICAgIGlmICghZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiByLnRvdWNoRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgdmFyIGJveCA9IGN5LmNvbGxlY3Rpb24oci5nZXRBbGxJbkJveChzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10pKTtcbiAgICAgIHNlbGVjdFswXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFsxXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFsyXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFszXSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGVjdFs0XSA9IDA7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgY3kuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdib3hlbmQnLFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBlbGVXb3VsZEJlU2VsZWN0ZWQgPSBmdW5jdGlvbiBlbGVXb3VsZEJlU2VsZWN0ZWQoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuc2VsZWN0YWJsZSgpICYmICFlbGUuc2VsZWN0ZWQoKTtcbiAgICAgIH07XG5cbiAgICAgIGJveC5lbWl0KCdib3gnKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KCdib3hzZWxlY3QnKTtcblxuICAgICAgaWYgKGJveC5ub25lbXB0eSgpKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1sxXSkgOyBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIDsgZWxzZSBpZiAoIWUudG91Y2hlc1swXSkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHN0YXJ0V2FzR3JhYmJlZCA9IHN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQ7XG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZXMpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0V2FzR3JhYmJlZCkge1xuICAgICAgICAgIHN0YXJ0LmVtaXQoJ2ZyZWVvbicpO1xuICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2ZyZWUnKTtcblxuICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgIHN0YXJ0LmVtaXQoJ2RyYWdmcmVlb24nKTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2RyYWdmcmVlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWyd0b3VjaGVuZCcsICd0YXBlbmQnLCAndm1vdXNldXAnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ3RvdWNoZW5kJywgJ3RhcGVuZCcsICd2bW91c2V1cCcsICd0YXBkcmFnb3V0J10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHggPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdIC0gbm93WzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdIC0gbm93WzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTsgLy8gVGFwIGV2ZW50LCByb3VnaGx5IHNhbWUgYXMgbW91c2UgY2xpY2sgZXZlbnQgZm9yIHRvdWNoXG5cbiAgICAgIGlmICghci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCkge1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQsIFsndGFwJywgJ3ZjbGljayddLCBlLCB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gUHJlcGFyZSB0byBzZWxlY3QgdGhlIGN1cnJlbnRseSB0b3VjaGVkIG5vZGUsIG9ubHkgaWYgaXQgaGFzbid0IGJlZW4gZHJhZ2dlZCBwYXN0IGEgY2VydGFpbiBkaXN0YW5jZVxuXG5cbiAgICAgIGlmIChzdGFydCAhPSBudWxsICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IGRyYWcgbm9kZXMgYXJvdW5kXG4gICAgICAmJiBzdGFydC5fcHJpdmF0ZS5zZWxlY3RhYmxlICYmIHJkaXN0MiA8IHIudG91Y2hUYXBUaHJlc2hvbGQyICYmICFyLnBpbmNoaW5nIC8vIHBpbmNoIHRvIHpvb20gc2hvdWxkIG5vdCBhZmZlY3Qgc2VsZWN0aW9uXG4gICAgICApIHtcbiAgICAgICAgICBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bm1lcmdlKHN0YXJ0KS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgc3RhcnQuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICBzdGFydC51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnQuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICBlYXJsaWVyW2pdID0gbm93W2pdO1xuICAgIH1cblxuICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlOyAvLyByZXNldCBmb3IgbmV4dCB0b3VjaHN0YXJ0XG5cbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgci50b3VjaERhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgICByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gbnVsbDtcbiAgICAgIHIudG91Y2hEYXRhLmRpZFNlbGVjdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gdGhlIG9sZCBzdGFydCBnbG9iYWwgcG9zJ24gbWF5IG5vdCBiZSB0aGUgc2FtZSBmaW5nZXIgdGhhdCByZW1haW5zXG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gW2UudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WV07XG4gICAgICB9XG5cbiAgICAgIHIucGluY2hpbmcgPSBmYWxzZTtcbiAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9IC8vci5yZWRyYXcoKTtcblxuICB9LCBmYWxzZSk7IC8vIGZhbGxiYWNrIGNvbXBhdGliaWxpdHkgbGF5ZXIgZm9yIG1zIHBvaW50ZXIgZXZlbnRzXG5cbiAgaWYgKHR5cGVvZiBUb3VjaEV2ZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBwb2ludGVycyA9IFtdO1xuXG4gICAgdmFyIG1ha2VUb3VjaCA9IGZ1bmN0aW9uIG1ha2VUb3VjaChlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgZm9yY2U6IDEsXG4gICAgICAgIGlkZW50aWZpZXI6IGUucG9pbnRlcklkLFxuICAgICAgICBwYWdlWDogZS5wYWdlWCxcbiAgICAgICAgcGFnZVk6IGUucGFnZVksXG4gICAgICAgIHJhZGl1c1g6IGUud2lkdGggLyAyLFxuICAgICAgICByYWRpdXNZOiBlLmhlaWdodCAvIDIsXG4gICAgICAgIHNjcmVlblg6IGUuc2NyZWVuWCxcbiAgICAgICAgc2NyZWVuWTogZS5zY3JlZW5ZLFxuICAgICAgICB0YXJnZXQ6IGUudGFyZ2V0XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgbWFrZVBvaW50ZXIgPSBmdW5jdGlvbiBtYWtlUG9pbnRlcihlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBldmVudDogZSxcbiAgICAgICAgdG91Y2g6IG1ha2VUb3VjaChlKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFBvaW50ZXIgPSBmdW5jdGlvbiBhZGRQb2ludGVyKGUpIHtcbiAgICAgIHBvaW50ZXJzLnB1c2gobWFrZVBvaW50ZXIoZSkpO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXIoZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IHBvaW50ZXJzW2ldO1xuXG4gICAgICAgIGlmIChwLmV2ZW50LnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgICBwb2ludGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVQb2ludGVyID0gZnVuY3Rpb24gdXBkYXRlUG9pbnRlcihlKSB7XG4gICAgICB2YXIgcCA9IHBvaW50ZXJzLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC5ldmVudC5wb2ludGVySWQgPT09IGUucG9pbnRlcklkO1xuICAgICAgfSlbMF07XG4gICAgICBwLmV2ZW50ID0gZTtcbiAgICAgIHAudG91Y2ggPSBtYWtlVG91Y2goZSk7XG4gICAgfTtcblxuICAgIHZhciBhZGRUb3VjaGVzVG9FdmVudCA9IGZ1bmN0aW9uIGFkZFRvdWNoZXNUb0V2ZW50KGUpIHtcbiAgICAgIGUudG91Y2hlcyA9IHBvaW50ZXJzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC50b3VjaDtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgcG9pbnRlcklzTW91c2UgPSBmdW5jdGlvbiBwb2ludGVySXNNb3VzZShlKSB7XG4gICAgICByZXR1cm4gZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBlLnBvaW50ZXJUeXBlID09PSA0O1xuICAgIH07XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGFkZFBvaW50ZXIoZSk7XG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNoc3RhcnRIYW5kbGVyKGUpO1xuICAgIH0pO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcnVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG5cbiAgICAgIHJlbW92ZVBvaW50ZXIoZSk7XG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNoZW5kSGFuZGxlcihlKTtcbiAgICB9KTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJjYW5jZWwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cblxuICAgICAgcmVtb3ZlUG9pbnRlcihlKTtcbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2hjYW5jZWxIYW5kbGVyKGUpO1xuICAgIH0pO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcm1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdXBkYXRlUG9pbnRlcihlKTtcbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2htb3ZlSGFuZGxlcihlKTtcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIEJScCRkID0ge307XG5cbkJScCRkLmdlbmVyYXRlUG9seWdvbiA9IGZ1bmN0aW9uIChuYW1lLCBwb2ludHMpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1tuYW1lXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBvaW50czogcG9pbnRzLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKCdwb2x5Z29uJywgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgdGhpcy5wb2ludHMpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCB0aGlzLnBvaW50cywgbm9kZVgsIG5vZGVZLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAkZC5nZW5lcmF0ZUVsbGlwc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2VsbGlwc2UnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnZWxsaXBzZScsXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0TGluZUVsbGlwc2UoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCAvIDIgKyBwYWRkaW5nLCBoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIHJldHVybiBjaGVja0luRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAkZC5nZW5lcmF0ZVJvdW5kUG9seWdvbiA9IGZ1bmN0aW9uIChuYW1lLCBwb2ludHMpIHtcbiAgLy8gUHJlLWNvbXB1dGUgY29udHJvbCBwb2ludHNcbiAgLy8gU2luY2UgdGhlc2UgcG9pbnRzIGRlcGVuZCBvbiB0aGUgcmFkaXVzIGxlbmd0aCAod2hpY2ggaW4gdHVybnMgZGVwZW5kIG9uIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIG5vZGUpIHdlIHdpbGwgb25seSBwcmUtY29tcHV0ZVxuICAvLyB0aGUgdW5pdCB2ZWN0b3JzLlxuICAvLyBGb3Igc2ltcGxpY2l0eSB0aGUgbGF5b3V0IHdpbGwgYmU6XG4gIC8vIFsgcDAsIFVuaXRWZWN0b3JQMFAxLCBwMSwgVW5pVmVjdG9yUDFQMiwgLi4uLCBwbiwgVW5pdFZlY3RvclBuUDAgXVxuICB2YXIgYWxsUG9pbnRzID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICB2YXIgc291cmNlSW5kZXggPSBpICogMjtcbiAgICB2YXIgZGVzdEluZGV4ID0gdm9pZCAwO1xuXG4gICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgIGRlc3RJbmRleCA9IChpICsgMSkgKiAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0SW5kZXggPSAwO1xuICAgIH1cblxuICAgIGFsbFBvaW50c1tpICogNF0gPSBwb2ludHNbc291cmNlSW5kZXhdO1xuICAgIGFsbFBvaW50c1tpICogNCArIDFdID0gcG9pbnRzW3NvdXJjZUluZGV4ICsgMV07XG4gICAgdmFyIHhEZXN0ID0gcG9pbnRzW2Rlc3RJbmRleF0gLSBwb2ludHNbc291cmNlSW5kZXhdO1xuICAgIHZhciB5RGVzdCA9IHBvaW50c1tkZXN0SW5kZXggKyAxXSAtIHBvaW50c1tzb3VyY2VJbmRleCArIDFdO1xuICAgIHZhciBub3JtID0gTWF0aC5zcXJ0KHhEZXN0ICogeERlc3QgKyB5RGVzdCAqIHlEZXN0KTtcbiAgICBhbGxQb2ludHNbaSAqIDQgKyAyXSA9IHhEZXN0IC8gbm9ybTtcbiAgICBhbGxQb2ludHNbaSAqIDQgKyAzXSA9IHlEZXN0IC8gbm9ybTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbbmFtZV0gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogbmFtZSxcbiAgICBwb2ludHM6IGFsbFBvaW50cyxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCgncm91bmQtcG9seWdvbicsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzKTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gcm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCB0aGlzLnBvaW50cywgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUm91bmRQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAkZC5nZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydyb3VuZC1yZWN0YW5nbGUnXSA9IHRoaXMubm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAncm91bmQtcmVjdGFuZ2xlJyxcbiAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGRpYW0gPSBjb3JuZXJSYWRpdXMgKiAyOyAvLyBDaGVjayBoQm94XG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSBkaWFtLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgdkJveFxuXG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gZGlhbSwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgdG9wIGxlZnQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cywgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayB0b3AgcmlnaHQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cywgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayBib3R0b20gcmlnaHQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayBib3R0b20gbGVmdCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAkZC5nZW5lcmF0ZUN1dFJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snY3V0LXJlY3RhbmdsZSddID0gdGhpcy5ub2RlU2hhcGVzWydjdXRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnY3V0LXJlY3RhbmdsZScsXG4gICAgY29ybmVyTGVuZ3RoOiBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKSxcbiAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgZ2VuZXJhdGVDdXRUcmlhbmdsZVB0czogZnVuY3Rpb24gZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICB2YXIgY2wgPSB0aGlzLmNvcm5lckxlbmd0aDtcbiAgICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgeEJlZ2luID0gY2VudGVyWCAtIGh3O1xuICAgICAgdmFyIHhFbmQgPSBjZW50ZXJYICsgaHc7XG4gICAgICB2YXIgeUJlZ2luID0gY2VudGVyWSAtIGhoO1xuICAgICAgdmFyIHlFbmQgPSBjZW50ZXJZICsgaGg7IC8vIHBvaW50cyBhcmUgaW4gY2xvY2t3aXNlIG9yZGVyLCBpbm5lciAoaW1hZ2luYXJ5KSB0cmlhbmdsZSBwdCBvbiBbNCwgNV1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wTGVmdDogW3hCZWdpbiwgeUJlZ2luICsgY2wsIHhCZWdpbiArIGNsLCB5QmVnaW4sIHhCZWdpbiArIGNsLCB5QmVnaW4gKyBjbF0sXG4gICAgICAgIHRvcFJpZ2h0OiBbeEVuZCAtIGNsLCB5QmVnaW4sIHhFbmQsIHlCZWdpbiArIGNsLCB4RW5kIC0gY2wsIHlCZWdpbiArIGNsXSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IFt4RW5kLCB5RW5kIC0gY2wsIHhFbmQgLSBjbCwgeUVuZCwgeEVuZCAtIGNsLCB5RW5kIC0gY2xdLFxuICAgICAgICBib3R0b21MZWZ0OiBbeEJlZ2luICsgY2wsIHlFbmQsIHhCZWdpbiwgeUVuZCAtIGNsLCB4QmVnaW4gKyBjbCwgeUVuZCAtIGNsXVxuICAgICAgfTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICB2YXIgY1B0cyA9IHRoaXMuZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyh3aWR0aCArIDIgKiBwYWRkaW5nLCBoZWlnaHQgKyAyICogcGFkZGluZywgbm9kZVgsIG5vZGVZKTtcbiAgICAgIHZhciBwdHMgPSBbXS5jb25jYXQuYXBwbHkoW10sIFtjUHRzLnRvcExlZnQuc3BsaWNlKDAsIDQpLCBjUHRzLnRvcFJpZ2h0LnNwbGljZSgwLCA0KSwgY1B0cy5ib3R0b21SaWdodC5zcGxpY2UoMCwgNCksIGNQdHMuYm90dG9tTGVmdC5zcGxpY2UoMCwgNCldKTtcbiAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBwdHMsIG5vZGVYLCBub2RlWSk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogdGhpcy5jb3JuZXJMZW5ndGgsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBDaGVjayB2Qm94XG5cblxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogdGhpcy5jb3JuZXJMZW5ndGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXRUcmlhbmdsZVB0cyA9IHRoaXMuZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMudG9wTGVmdCkgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLnRvcFJpZ2h0KSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMuYm90dG9tUmlnaHQpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy5ib3R0b21MZWZ0KTtcbiAgICB9XG4gIH07XG59O1xuXG5CUnAkZC5nZW5lcmF0ZUJhcnJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snYmFycmVsJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogJ2JhcnJlbCcsXG4gICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICAvLyB1c2UgdHdvIGZpeGVkIHQgdmFsdWVzIGZvciB0aGUgYmV6aWVyIGN1cnZlIGFwcHJveGltYXRpb25cbiAgICAgIHZhciB0MCA9IDAuMTU7XG4gICAgICB2YXIgdDEgPSAwLjU7XG4gICAgICB2YXIgdDIgPSAwLjg1O1xuICAgICAgdmFyIGJQdHMgPSB0aGlzLmdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoICsgMiAqIHBhZGRpbmcsIGhlaWdodCArIDIgKiBwYWRkaW5nLCBub2RlWCwgbm9kZVkpO1xuXG4gICAgICB2YXIgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyA9IGZ1bmN0aW9uIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMocHRzKSB7XG4gICAgICAgIC8vIGFwcHJveGltYXRlIGN1cnZlIHB0cyBiYXNlZCBvbiB0aGUgdHdvIHQgdmFsdWVzXG4gICAgICAgIHZhciBtMCA9IHFiZXppZXJQdEF0KHtcbiAgICAgICAgICB4OiBwdHNbMF0sXG4gICAgICAgICAgeTogcHRzWzFdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbMl0sXG4gICAgICAgICAgeTogcHRzWzNdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbNF0sXG4gICAgICAgICAgeTogcHRzWzVdXG4gICAgICAgIH0sIHQwKTtcbiAgICAgICAgdmFyIG0xID0gcWJlemllclB0QXQoe1xuICAgICAgICAgIHg6IHB0c1swXSxcbiAgICAgICAgICB5OiBwdHNbMV1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1syXSxcbiAgICAgICAgICB5OiBwdHNbM11cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1s0XSxcbiAgICAgICAgICB5OiBwdHNbNV1cbiAgICAgICAgfSwgdDEpO1xuICAgICAgICB2YXIgbTIgPSBxYmV6aWVyUHRBdCh7XG4gICAgICAgICAgeDogcHRzWzBdLFxuICAgICAgICAgIHk6IHB0c1sxXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzJdLFxuICAgICAgICAgIHk6IHB0c1szXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzRdLFxuICAgICAgICAgIHk6IHB0c1s1XVxuICAgICAgICB9LCB0Mik7XG4gICAgICAgIHJldHVybiBbcHRzWzBdLCBwdHNbMV0sIG0wLngsIG0wLnksIG0xLngsIG0xLnksIG0yLngsIG0yLnksIHB0c1s0XSwgcHRzWzVdXTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBwdHMgPSBbXS5jb25jYXQoYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLnRvcExlZnQpLCBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMudG9wUmlnaHQpLCBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMuYm90dG9tUmlnaHQpLCBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMuYm90dG9tTGVmdCkpO1xuICAgICAgcmV0dXJuIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHB0cywgbm9kZVgsIG5vZGVZKTtcbiAgICB9LFxuICAgIGdlbmVyYXRlQmFycmVsQmV6aWVyUHRzOiBmdW5jdGlvbiBnZW5lcmF0ZUJhcnJlbEJlemllclB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgICAgdmFyIHhCZWdpbiA9IGNlbnRlclggLSBodztcbiAgICAgIHZhciB4RW5kID0gY2VudGVyWCArIGh3O1xuICAgICAgdmFyIHlCZWdpbiA9IGNlbnRlclkgLSBoaDtcbiAgICAgIHZhciB5RW5kID0gY2VudGVyWSArIGhoO1xuICAgICAgdmFyIGN1cnZlQ29uc3RhbnRzID0gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgaE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgICAgIHZhciB3T2Zmc2V0ID0gY3VydmVDb25zdGFudHMud2lkdGhPZmZzZXQ7XG4gICAgICB2YXIgY3RybFB0WE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmN0cmxQdE9mZnNldFBjdCAqIHdpZHRoOyAvLyBwb2ludHMgYXJlIGluIGNsb2Nrd2lzZSBvcmRlciwgaW5uZXIgKGltYWdpbmFyeSkgY29udHJvbCBwdCBvbiBbNCwgNV1cblxuICAgICAgdmFyIHB0cyA9IHtcbiAgICAgICAgdG9wTGVmdDogW3hCZWdpbiwgeUJlZ2luICsgaE9mZnNldCwgeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4QmVnaW4gKyB3T2Zmc2V0LCB5QmVnaW5dLFxuICAgICAgICB0b3BSaWdodDogW3hFbmQgLSB3T2Zmc2V0LCB5QmVnaW4sIHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhFbmQsIHlCZWdpbiArIGhPZmZzZXRdLFxuICAgICAgICBib3R0b21SaWdodDogW3hFbmQsIHlFbmQgLSBoT2Zmc2V0LCB4RW5kIC0gY3RybFB0WE9mZnNldCwgeUVuZCwgeEVuZCAtIHdPZmZzZXQsIHlFbmRdLFxuICAgICAgICBib3R0b21MZWZ0OiBbeEJlZ2luICsgd09mZnNldCwgeUVuZCwgeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUVuZCwgeEJlZ2luLCB5RW5kIC0gaE9mZnNldF1cbiAgICAgIH07XG4gICAgICBwdHMudG9wTGVmdC5pc1RvcCA9IHRydWU7XG4gICAgICBwdHMudG9wUmlnaHQuaXNUb3AgPSB0cnVlO1xuICAgICAgcHRzLmJvdHRvbUxlZnQuaXNCb3R0b20gPSB0cnVlO1xuICAgICAgcHRzLmJvdHRvbVJpZ2h0LmlzQm90dG9tID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwdHM7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIHZhciBjdXJ2ZUNvbnN0YW50cyA9IGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGhPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gICAgICB2YXIgd09mZnNldCA9IGN1cnZlQ29uc3RhbnRzLndpZHRoT2Zmc2V0OyAvLyBDaGVjayBoQm94XG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogaE9mZnNldCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIHZCb3hcblxuXG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIDIgKiB3T2Zmc2V0LCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFycmVsQ3VydmVQdHMgPSB0aGlzLmdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpO1xuXG4gICAgICB2YXIgZ2V0Q3VydmVUID0gZnVuY3Rpb24gZ2V0Q3VydmVUKHgsIHksIGN1cnZlUHRzKSB7XG4gICAgICAgIHZhciB4MCA9IGN1cnZlUHRzWzRdO1xuICAgICAgICB2YXIgeDEgPSBjdXJ2ZVB0c1syXTtcbiAgICAgICAgdmFyIHgyID0gY3VydmVQdHNbMF07XG4gICAgICAgIHZhciB5MCA9IGN1cnZlUHRzWzVdOyAvLyB2YXIgeTEgPSBjdXJ2ZVB0c1sgMyBdO1xuXG4gICAgICAgIHZhciB5MiA9IGN1cnZlUHRzWzFdO1xuICAgICAgICB2YXIgeE1pbiA9IE1hdGgubWluKHgwLCB4Mik7XG4gICAgICAgIHZhciB4TWF4ID0gTWF0aC5tYXgoeDAsIHgyKTtcbiAgICAgICAgdmFyIHlNaW4gPSBNYXRoLm1pbih5MCwgeTIpO1xuICAgICAgICB2YXIgeU1heCA9IE1hdGgubWF4KHkwLCB5Mik7XG5cbiAgICAgICAgaWYgKHhNaW4gPD0geCAmJiB4IDw9IHhNYXggJiYgeU1pbiA8PSB5ICYmIHkgPD0geU1heCkge1xuICAgICAgICAgIHZhciBjb2VmZiA9IGJlemllclB0c1RvUXVhZENvZWZmKHgwLCB4MSwgeDIpO1xuICAgICAgICAgIHZhciByb290cyA9IHNvbHZlUXVhZHJhdGljKGNvZWZmWzBdLCBjb2VmZlsxXSwgY29lZmZbMl0sIHgpO1xuICAgICAgICAgIHZhciB2YWxpZFJvb3RzID0gcm9vdHMuZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gMCA8PSByICYmIHIgPD0gMTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh2YWxpZFJvb3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZFJvb3RzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgdmFyIGN1cnZlUmVnaW9ucyA9IE9iamVjdC5rZXlzKGJhcnJlbEN1cnZlUHRzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJ2ZVJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvcm5lciA9IGN1cnZlUmVnaW9uc1tpXTtcbiAgICAgICAgdmFyIGNvcm5lclB0cyA9IGJhcnJlbEN1cnZlUHRzW2Nvcm5lcl07XG4gICAgICAgIHZhciB0ID0gZ2V0Q3VydmVUKHgsIHksIGNvcm5lclB0cyk7XG5cbiAgICAgICAgaWYgKHQgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHkwID0gY29ybmVyUHRzWzVdO1xuICAgICAgICB2YXIgeTEgPSBjb3JuZXJQdHNbM107XG4gICAgICAgIHZhciB5MiA9IGNvcm5lclB0c1sxXTtcbiAgICAgICAgdmFyIGJlelkgPSBxYmV6aWVyQXQoeTAsIHkxLCB5MiwgdCk7XG5cbiAgICAgICAgaWYgKGNvcm5lclB0cy5pc1RvcCAmJiBiZXpZIDw9IHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb3JuZXJQdHMuaXNCb3R0b20gJiYgeSA8PSBiZXpZKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn07XG5cbkJScCRkLmdlbmVyYXRlQm90dG9tUm91bmRyZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnXSA9IHRoaXMubm9kZVNoYXBlc1snYm90dG9tcm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZScsXG4gICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICB2YXIgdG9wU3RhcnRZID0gbm9kZVkgLSAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgICAgdmFyIHRvcEVuZFkgPSB0b3BTdGFydFk7XG4gICAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgdmFyIHRvcEludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFN0YXJ0WCwgdG9wU3RhcnRZLCB0b3BFbmRYLCB0b3BFbmRZLCBmYWxzZSk7XG5cbiAgICAgIGlmICh0b3BJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRvcEludGVyc2VjdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGRpYW0gPSAyICogY29ybmVyUmFkaXVzOyAvLyBDaGVjayBoQm94XG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSBkaWFtLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQ2hlY2sgdkJveFxuXG5cbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gZGlhbSwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gY2hlY2sgbm9uLXJvdW5kZWQgdG9wIHNpZGVcblxuXG4gICAgICB2YXIgb3V0ZXJXaWR0aCA9IHdpZHRoIC8gMiArIDIgKiBwYWRkaW5nO1xuICAgICAgdmFyIG91dGVySGVpZ2h0ID0gaGVpZ2h0IC8gMiArIDIgKiBwYWRkaW5nO1xuICAgICAgdmFyIHBvaW50cyA9IFtjZW50ZXJYIC0gb3V0ZXJXaWR0aCwgY2VudGVyWSAtIG91dGVySGVpZ2h0LCBjZW50ZXJYIC0gb3V0ZXJXaWR0aCwgY2VudGVyWSwgY2VudGVyWCArIG91dGVyV2lkdGgsIGNlbnRlclksIGNlbnRlclggKyBvdXRlcldpZHRoLCBjZW50ZXJZIC0gb3V0ZXJIZWlnaHRdO1xuXG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIGJvdHRvbSByaWdodCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIENoZWNrIGJvdHRvbSBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn07XG5cbkJScCRkLnJlZ2lzdGVyTm9kZVNoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVTaGFwZXMgPSB0aGlzLm5vZGVTaGFwZXMgPSB7fTtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgdGhpcy5nZW5lcmF0ZUVsbGlwc2UoKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3RyaWFuZ2xlJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDMsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtdHJpYW5nbGUnLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoMywgMCkpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbigncmVjdGFuZ2xlJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApKTtcbiAgbm9kZVNoYXBlc1snc3F1YXJlJ10gPSBub2RlU2hhcGVzWydyZWN0YW5nbGUnXTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlKCk7XG4gIHRoaXMuZ2VuZXJhdGVDdXRSZWN0YW5nbGUoKTtcbiAgdGhpcy5nZW5lcmF0ZUJhcnJlbCgpO1xuICB0aGlzLmdlbmVyYXRlQm90dG9tUm91bmRyZWN0YW5nbGUoKTtcbiAge1xuICAgIHZhciBkaWFtb25kUG9pbnRzID0gWzAsIDEsIDEsIDAsIDAsIC0xLCAtMSwgMF07XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2RpYW1vbmQnLCBkaWFtb25kUG9pbnRzKTtcbiAgICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1kaWFtb25kJywgZGlhbW9uZFBvaW50cyk7XG4gIH1cbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3BlbnRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDUsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtcGVudGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNSwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbignaGV4YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg2LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLWhleGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNiwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbignaGVwdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNywgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1oZXB0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg3LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdvY3RhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDgsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtb2N0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg4LCAwKSk7XG4gIHZhciBzdGFyNVBvaW50cyA9IG5ldyBBcnJheSgyMCk7XG4gIHtcbiAgICB2YXIgb3V0ZXJQb2ludHMgPSBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKDUsIDApO1xuICAgIHZhciBpbm5lclBvaW50cyA9IGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgTWF0aC5QSSAvIDUpOyAvLyBPdXRlciByYWRpdXMgaXMgMTsgaW5uZXIgcmFkaXVzIG9mIHN0YXIgaXMgc21hbGxlclxuXG4gICAgdmFyIGlubmVyUmFkaXVzID0gMC41ICogKDMgLSBNYXRoLnNxcnQoNSkpO1xuICAgIGlubmVyUmFkaXVzICo9IDEuNTc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgaW5uZXJQb2ludHNbaSAqIDJdICo9IGlubmVyUmFkaXVzO1xuICAgICAgaW5uZXJQb2ludHNbaSAqIDIgKyAxXSAqPSBpbm5lclJhZGl1cztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDIwIC8gNDsgaSsrKSB7XG4gICAgICBzdGFyNVBvaW50c1tpICogNF0gPSBvdXRlclBvaW50c1tpICogMl07XG4gICAgICBzdGFyNVBvaW50c1tpICogNCArIDFdID0gb3V0ZXJQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIHN0YXI1UG9pbnRzW2kgKiA0ICsgMl0gPSBpbm5lclBvaW50c1tpICogMl07XG4gICAgICBzdGFyNVBvaW50c1tpICogNCArIDNdID0gaW5uZXJQb2ludHNbaSAqIDIgKyAxXTtcbiAgICB9XG4gIH1cbiAgc3RhcjVQb2ludHMgPSBmaXRQb2x5Z29uVG9TcXVhcmUoc3RhcjVQb2ludHMpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbignc3RhcicsIHN0YXI1UG9pbnRzKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3ZlZScsIFstMSwgLTEsIDAsIC0wLjMzMywgMSwgLTEsIDAsIDFdKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3Job21ib2lkJywgWy0xLCAtMSwgMC4zMzMsIC0xLCAxLCAxLCAtMC4zMzMsIDFdKTtcbiAgdGhpcy5ub2RlU2hhcGVzWydjb25jYXZlaGV4YWdvbiddID0gdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2NvbmNhdmUtaGV4YWdvbicsIFstMSwgLTAuOTUsIC0wLjc1LCAwLCAtMSwgMC45NSwgMSwgMC45NSwgMC43NSwgMCwgMSwgLTAuOTVdKTtcbiAge1xuICAgIHZhciB0YWdQb2ludHMgPSBbLTEsIC0xLCAwLjI1LCAtMSwgMSwgMCwgMC4yNSwgMSwgLTEsIDFdO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd0YWcnLCB0YWdQb2ludHMpO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLXRhZycsIHRhZ1BvaW50cyk7XG4gIH1cblxuICBub2RlU2hhcGVzLm1ha2VQb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cykge1xuICAgIC8vIHVzZSBjYWNoaW5nIG9uIHVzZXItc3BlY2lmaWVkIHBvbHlnb25zIHNvIHRoZXkgYXJlIGFzIGZhc3QgYXMgbmF0aXZlIHNoYXBlc1xuICAgIHZhciBrZXkgPSBwb2ludHMuam9pbignJCcpO1xuICAgIHZhciBuYW1lID0gJ3BvbHlnb24tJyArIGtleTtcbiAgICB2YXIgc2hhcGU7XG5cbiAgICBpZiAoc2hhcGUgPSB0aGlzW25hbWVdKSB7XG4gICAgICAvLyBnb3QgY2FjaGVkIHNoYXBlXG4gICAgICByZXR1cm4gc2hhcGU7XG4gICAgfSAvLyBjcmVhdGUgYW5kIGNhY2hlIG5ldyBzaGFwZVxuXG5cbiAgICByZXR1cm4gcmVuZGVyZXIuZ2VuZXJhdGVQb2x5Z29uKG5hbWUsIHBvaW50cyk7XG4gIH07XG59O1xuXG52YXIgQlJwJGUgPSB7fTtcblxuQlJwJGUudGltZVRvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWRyYXdUb3RhbFRpbWUgLyB0aGlzLnJlZHJhd0NvdW50O1xufTtcblxuQlJwJGUucmVkcmF3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgc3RhdGljRW1wdHlPYmplY3QoKTtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGlmIChyLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gMDtcbiAgfVxuXG4gIGlmIChyLmxhc3RSZWRyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByLmxhc3RSZWRyYXdUaW1lID0gMDtcbiAgfVxuXG4gIGlmIChyLmxhc3REcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgci5sYXN0RHJhd1RpbWUgPSAwO1xuICB9XG5cbiAgci5yZXF1ZXN0ZWRGcmFtZSA9IHRydWU7XG4gIHIucmVuZGVyT3B0aW9ucyA9IG9wdGlvbnM7XG59O1xuXG5CUnAkZS5iZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiAoZm4sIHByaW9yaXR5KSB7XG4gIC8vIHRoZSByZW5kZXJlciBjYW4ndCBhZGQgdGljayBjYWxsYmFja3Mgd2hlbiBkZXN0cm95ZWRcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByaW9yaXR5ID09IG51bGwpIHtcbiAgICBlcnJvcignUHJpb3JpdHkgaXMgbm90IG9wdGlvbmFsIGZvciBiZWZvcmVSZW5kZXInKTtcbiAgfVxuXG4gIHZhciBjYnMgPSB0aGlzLmJlZm9yZVJlbmRlckNhbGxiYWNrcztcbiAgY2JzLnB1c2goe1xuICAgIGZuOiBmbixcbiAgICBwcmlvcml0eTogcHJpb3JpdHlcbiAgfSk7IC8vIGhpZ2hlciBwcmlvcml0eSBjYWxsYmFja3MgZXhlY3V0ZWQgZmlyc3RcblxuICBjYnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eTtcbiAgfSk7XG59O1xuXG52YXIgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gZnVuY3Rpb24gYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIHdpbGxEcmF3LCBzdGFydFRpbWUpIHtcbiAgdmFyIGNicyA9IHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2JzW2ldLmZuKHdpbGxEcmF3LCBzdGFydFRpbWUpO1xuICB9XG59O1xuXG5CUnAkZS5zdGFydFJlbmRlckxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGN5ID0gci5jeTtcblxuICBpZiAoci5yZW5kZXJMb29wU3RhcnRlZCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICByLnJlbmRlckxvb3BTdGFydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciByZW5kZXJGbiA9IGZ1bmN0aW9uIHJlbmRlckZuKHJlcXVlc3RUaW1lKSB7XG4gICAgaWYgKHIuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN5LmJhdGNoaW5nKCkpIDsgZWxzZSBpZiAoci5yZXF1ZXN0ZWRGcmFtZSAmJiAhci5za2lwRnJhbWUpIHtcbiAgICAgIGJlZm9yZVJlbmRlckNhbGxiYWNrcyhyLCB0cnVlLCByZXF1ZXN0VGltZSk7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgIHIucmVuZGVyKHIucmVuZGVyT3B0aW9ucyk7XG4gICAgICB2YXIgZW5kVGltZSA9IHIubGFzdERyYXdUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcblxuICAgICAgaWYgKHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIucmVkcmF3Q291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLnJlZHJhd0NvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgci5yZWRyYXdDb3VudCsrO1xuXG4gICAgICBpZiAoci5yZWRyYXdUb3RhbFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLnJlZHJhd1RvdGFsVGltZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICByLnJlZHJhd1RvdGFsVGltZSArPSBkdXJhdGlvbjtcbiAgICAgIHIubGFzdFJlZHJhd1RpbWUgPSBkdXJhdGlvbjsgLy8gdXNlIGEgd2VpZ2h0ZWQgYXZlcmFnZSB3aXRoIGEgYmlhcyBmcm9tIHRoZSBwcmV2aW91cyBhdmVyYWdlIHNvIHdlIGRvbid0IHNwaWtlIHNvIGVhc2lseVxuXG4gICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gci5hdmVyYWdlUmVkcmF3VGltZSAvIDIgKyBkdXJhdGlvbiAvIDI7XG4gICAgICByLnJlcXVlc3RlZEZyYW1lID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJlZm9yZVJlbmRlckNhbGxiYWNrcyhyLCBmYWxzZSwgcmVxdWVzdFRpbWUpO1xuICAgIH1cblxuICAgIHIuc2tpcEZyYW1lID0gZmFsc2U7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckZuKTtcbiAgfTtcblxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyRm4pO1xufTtcblxudmFyIEJhc2VSZW5kZXJlciA9IGZ1bmN0aW9uIEJhc2VSZW5kZXJlcihvcHRpb25zKSB7XG4gIHRoaXMuaW5pdChvcHRpb25zKTtcbn07XG5cbnZhciBCUiA9IEJhc2VSZW5kZXJlcjtcbnZhciBCUnAkZiA9IEJSLnByb3RvdHlwZTtcbkJScCRmLmNsaWVudEZ1bmN0aW9ucyA9IFsncmVkcmF3SGludCcsICdyZW5kZXInLCAncmVuZGVyVG8nLCAnbWF0Y2hDYW52YXNTaXplJywgJ25vZGVTaGFwZUltcGwnLCAnYXJyb3dTaGFwZUltcGwnXTtcblxuQlJwJGYuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciByID0gdGhpcztcbiAgci5vcHRpb25zID0gb3B0aW9ucztcbiAgci5jeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBjdHIgPSByLmNvbnRhaW5lciA9IG9wdGlvbnMuY3kuY29udGFpbmVyKCk7IC8vIHByZXBlbmQgYSBzdHlsZXNoZWV0IGluIHRoZSBoZWFkIHN1Y2ggdGhhdFxuXG4gIGlmICh3aW5kb3ckMSkge1xuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdyQxLmRvY3VtZW50O1xuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZDtcbiAgICB2YXIgc3R5bGVzaGVldElkID0gJ19fX19fX19fX19jeXRvc2NhcGVfc3R5bGVzaGVldCc7XG4gICAgdmFyIGNsYXNzTmFtZSA9ICdfX19fX19fX19fY3l0b3NjYXBlX2NvbnRhaW5lcic7XG4gICAgdmFyIHN0eWxlc2hlZXRBbHJlYWR5RXhpc3RzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3R5bGVzaGVldElkKSAhPSBudWxsO1xuXG4gICAgaWYgKGN0ci5jbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUpIDwgMCkge1xuICAgICAgY3RyLmNsYXNzTmFtZSA9IChjdHIuY2xhc3NOYW1lIHx8ICcnKSArICcgJyArIGNsYXNzTmFtZTtcbiAgICB9XG5cbiAgICBpZiAoIXN0eWxlc2hlZXRBbHJlYWR5RXhpc3RzKSB7XG4gICAgICB2YXIgc3R5bGVzaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZXNoZWV0LmlkID0gc3R5bGVzaGVldElkO1xuICAgICAgc3R5bGVzaGVldC5pbm5lckhUTUwgPSAnLicgKyBjbGFzc05hbWUgKyAnIHsgcG9zaXRpb246IHJlbGF0aXZlOyB9JztcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlc2hlZXQsIGhlYWQuY2hpbGRyZW5bMF0pOyAvLyBmaXJzdCBzbyBsb3dlc3QgcHJpb3JpdHlcbiAgICB9XG5cbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUoY3RyKTtcbiAgICB2YXIgcG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJyk7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICB3YXJuKCdBIEN5dG9zY2FwZSBjb250YWluZXIgaGFzIHN0eWxlIHBvc2l0aW9uOnN0YXRpYyBhbmQgc28gY2FuIG5vdCB1c2UgVUkgZXh0ZW5zaW9ucyBwcm9wZXJseScpO1xuICAgIH1cbiAgfVxuXG4gIHIuc2VsZWN0aW9uID0gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMF07IC8vIENvb3JkaW5hdGVzIGZvciBzZWxlY3Rpb24gYm94LCBwbHVzIGVuYWJsZWQgZmxhZ1xuXG4gIHIuYmV6aWVyUHJvalBjdHMgPSBbMC4wNSwgMC4yMjUsIDAuNCwgMC41LCAwLjYsIDAuNzc1LCAwLjk1XTsgLy8tLVBvaW50ZXItcmVsYXRlZCBkYXRhXG5cbiAgci5ob3ZlckRhdGEgPSB7XG4gICAgZG93bjogbnVsbCxcbiAgICBsYXN0OiBudWxsLFxuICAgIGRvd25UaW1lOiBudWxsLFxuICAgIHRyaWdnZXJNb2RlOiBudWxsLFxuICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICBpbml0aWFsUGFuOiBbbnVsbCwgbnVsbF0sXG4gICAgY2FwdHVyZTogZmFsc2VcbiAgfTtcbiAgci5kcmFnRGF0YSA9IHtcbiAgICBwb3NzaWJsZURyYWdFbGVtZW50czogW11cbiAgfTtcbiAgci50b3VjaERhdGEgPSB7XG4gICAgc3RhcnQ6IG51bGwsXG4gICAgY2FwdHVyZTogZmFsc2UsXG4gICAgLy8gVGhlc2UgMyBmaWVsZHMgcmVsYXRlZCB0byB0YXAsIHRhcGhvbGQgZXZlbnRzXG4gICAgc3RhcnRQb3NpdGlvbjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdLFxuICAgIHNpbmdsZVRvdWNoU3RhcnRUaW1lOiBudWxsLFxuICAgIHNpbmdsZVRvdWNoTW92ZWQ6IHRydWUsXG4gICAgbm93OiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sXG4gICAgZWFybGllcjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdXG4gIH07XG4gIHIucmVkcmF3cyA9IDA7XG4gIHIuc2hvd0ZwcyA9IG9wdGlvbnMuc2hvd0ZwcztcbiAgci5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gIHIuaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgci50ZXh0dXJlT25WaWV3cG9ydCA9IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQ7XG4gIHIud2hlZWxTZW5zaXRpdml0eSA9IG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgci5tb3Rpb25CbHVyRW5hYmxlZCA9IG9wdGlvbnMubW90aW9uQmx1cjsgLy8gb24gYnkgZGVmYXVsdFxuXG4gIHIuZm9yY2VkUGl4ZWxSYXRpbyA9IG51bWJlcihvcHRpb25zLnBpeGVsUmF0aW8pID8gb3B0aW9ucy5waXhlbFJhdGlvIDogbnVsbDtcbiAgci5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBmb3IgaW5pdGlhbCBraWNrIG9mZlxuXG4gIHIubW90aW9uQmx1ck9wYWNpdHkgPSBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5O1xuICByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kgPSAxIC0gci5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIHIubWJQeFJCbHVycnkgPSAxOyAvLzAuODtcblxuICByLm1pbk1iTG93UXVhbEZyYW1lcyA9IDQ7XG4gIHIuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyID0gW107XG4gIHIuZGVza3RvcFRhcFRocmVzaG9sZCA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgci5kZXNrdG9wVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCAqIG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgci50b3VjaFRhcFRocmVzaG9sZCA9IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gIHIudG91Y2hUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZCAqIG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gIHIudGFwaG9sZER1cmF0aW9uID0gNTAwO1xuICByLmJpbmRpbmdzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcyA9IHtcbiAgICAvLyBoaWdoZXIgcHJpb3JpdHkgZXhlY3MgYmVmb3JlIGxvd2VyIG9uZVxuICAgIGFuaW1hdGlvbnM6IDQwMCxcbiAgICBlbGVDYWxjczogMzAwLFxuICAgIGVsZVR4ckRlcTogMjAwLFxuICAgIGx5clR4ckRlcTogMTUwLFxuICAgIGx5clR4clNraXA6IDEwMFxuICB9O1xuICByLnJlZ2lzdGVyTm9kZVNoYXBlcygpO1xuICByLnJlZ2lzdGVyQXJyb3dTaGFwZXMoKTtcbiAgci5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzKCk7XG59O1xuXG5CUnAkZi5ub3RpZnkgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBlbGVzKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGN5ID0gci5jeTsgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIG5vdGlmaWVkIGFmdGVyIGl0J3MgZGVzdHJveWVkXG5cbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2luaXQnKSB7XG4gICAgci5sb2FkKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2Rlc3Ryb3knKSB7XG4gICAgci5kZXN0cm95KCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2FkZCcgfHwgZXZlbnROYW1lID09PSAncmVtb3ZlJyB8fCBldmVudE5hbWUgPT09ICdtb3ZlJyAmJiBjeS5oYXNDb21wb3VuZE5vZGVzKCkgfHwgZXZlbnROYW1lID09PSAnbG9hZCcgfHwgZXZlbnROYW1lID09PSAnem9yZGVyJyB8fCBldmVudE5hbWUgPT09ICdtb3VudCcpIHtcbiAgICByLmludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcygpO1xuICB9XG5cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gIH1cblxuICBpZiAoZXZlbnROYW1lID09PSAnbG9hZCcgfHwgZXZlbnROYW1lID09PSAncmVzaXplJyB8fCBldmVudE5hbWUgPT09ICdtb3VudCcpIHtcbiAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgIHIubWF0Y2hDYW52YXNTaXplKHIuY29udGFpbmVyKTtcbiAgfVxuXG4gIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgdGhpcy5zdGFydFJlbmRlckxvb3AoKTtcbiAgdGhpcy5yZWRyYXcoKTtcbn07XG5cbkJScCRmLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gdGhpcztcbiAgci5kZXN0cm95ZWQgPSB0cnVlO1xuICByLmN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLmJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJpbmRpbmcgPSByLmJpbmRpbmdzW2ldO1xuICAgIHZhciBiID0gYmluZGluZztcbiAgICB2YXIgdGd0ID0gYi50YXJnZXQ7XG4gICAgKHRndC5vZmYgfHwgdGd0LnJlbW92ZUV2ZW50TGlzdGVuZXIpLmFwcGx5KHRndCwgYi5hcmdzKTtcbiAgfVxuXG4gIHIuYmluZGluZ3MgPSBbXTtcbiAgci5iZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBbXTtcbiAgci5vblVwZGF0ZUVsZUNhbGNzRm5zID0gW107XG5cbiAgaWYgKHIucmVtb3ZlT2JzZXJ2ZXIpIHtcbiAgICByLnJlbW92ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIGlmIChyLnN0eWxlT2JzZXJ2ZXIpIHtcbiAgICByLnN0eWxlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgaWYgKHIucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICByLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIGlmIChyLmxhYmVsQ2FsY0Rpdikge1xuICAgIHRyeSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHIubGFiZWxDYWxjRGl2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH0gY2F0Y2ggKGUpIHsvLyBpZTEwIGlzc3VlICMxMDE0XG4gICAgfVxuICB9XG59O1xuXG5CUnAkZi5pc0hlYWRsZXNzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5bQlJwLCBCUnAkYSwgQlJwJGIsIEJScCRjLCBCUnAkZCwgQlJwJGVdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gIGV4dGVuZChCUnAkZiwgcHJvcHMpO1xufSk7XG5cbnZhciBmdWxsRnBzVGltZSA9IDEwMDAgLyA2MDsgLy8gYXNzdW1lIDYwIGZyYW1lcyBwZXIgc2Vjb25kXG5cbnZhciBkZWZzID0ge1xuICBzZXR1cERlcXVldWVpbmc6IGZ1bmN0aW9uIHNldHVwRGVxdWV1ZWluZyhvcHRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldHVwRGVxdWV1ZWluZ0ltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICAgIGlmIChzZWxmLmRlcXVldWVpbmdTZXR1cCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmRlcXVldWVpbmdTZXR1cCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBxdWV1ZVJlZHJhdyA9IHV0aWwoZnVuY3Rpb24gKCkge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCBvcHRzLmRlcVJlZHJhd1RocmVzaG9sZCk7XG5cbiAgICAgIHZhciBkZXF1ZXVlID0gZnVuY3Rpb24gZGVxdWV1ZSh3aWxsRHJhdywgZnJhbWVTdGFydFRpbWUpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHZhciBhdmdSZW5kZXJUaW1lID0gci5hdmVyYWdlUmVkcmF3VGltZTtcbiAgICAgICAgdmFyIHJlbmRlclRpbWUgPSByLmxhc3RSZWRyYXdUaW1lO1xuICAgICAgICB2YXIgZGVxZCA9IFtdO1xuICAgICAgICB2YXIgZXh0ZW50ID0gci5jeS5leHRlbnQoKTtcbiAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSByLmdldFBpeGVsUmF0aW8oKTsgLy8gaWYgd2UgYXJlbid0IGluIGEgdGljayB0aGF0IGNhdXNlcyBhIGRyYXcsIHRoZW4gdGhlIHJlbmRlcmVkIHN0eWxlXG4gICAgICAgIC8vIHF1ZXVlIHdvbid0IGF1dG9tYXRpY2FsbHkgYmUgZmx1c2hlZCBiZWZvcmUgZGVxdWV1ZWluZyBzdGFydHNcblxuICAgICAgICBpZiAoIXdpbGxEcmF3KSB7XG4gICAgICAgICAgci5mbHVzaFJlbmRlcmVkU3R5bGVRdWV1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICAgIHZhciBub3cgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IG5vdyAtIHN0YXJ0VGltZTtcbiAgICAgICAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IG5vdyAtIGZyYW1lU3RhcnRUaW1lO1xuXG4gICAgICAgICAgaWYgKHJlbmRlclRpbWUgPCBmdWxsRnBzVGltZSkge1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgcmVuZGVyaW5nIGZhc3RlciB0aGFuIHRoZSBpZGVhbCBmcHMsIHRoZW4gZG8gZGVxdWV1ZWluZ1xuICAgICAgICAgICAgLy8gZHVyaW5nIGFsbCBvZiB0aGUgcmVtYWluaW5nIGZyYW1lIHRpbWVcbiAgICAgICAgICAgIHZhciB0aW1lQXZhaWxhYmxlID0gZnVsbEZwc1RpbWUgLSAod2lsbERyYXcgPyBhdmdSZW5kZXJUaW1lIDogMCk7XG5cbiAgICAgICAgICAgIGlmIChmcmFtZUR1cmF0aW9uID49IG9wdHMuZGVxRmFzdENvc3QgKiB0aW1lQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAod2lsbERyYXcpIHtcbiAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID49IG9wdHMuZGVxQ29zdCAqIHJlbmRlclRpbWUgfHwgZHVyYXRpb24gPj0gb3B0cy5kZXFBdmdDb3N0ICogYXZnUmVuZGVyVGltZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFOb0RyYXdDb3N0ICogZnVsbEZwc1RpbWUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRoaXNEZXFkID0gb3B0cy5kZXEoc2VsZiwgcGl4ZWxSYXRpbywgZXh0ZW50KTtcblxuICAgICAgICAgIGlmICh0aGlzRGVxZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXNEZXFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGRlcWQucHVzaCh0aGlzRGVxZFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBjYWxsYmFja3Mgb24gZGVxdWV1ZVxuXG5cbiAgICAgICAgaWYgKGRlcWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9wdHMub25EZXFkKHNlbGYsIGRlcWQpO1xuXG4gICAgICAgICAgaWYgKCF3aWxsRHJhdyAmJiBvcHRzLnNob3VsZFJlZHJhdyhzZWxmLCBkZXFkLCBwaXhlbFJhdGlvLCBleHRlbnQpKSB7XG4gICAgICAgICAgICBxdWV1ZVJlZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHByaW9yaXR5ID0gb3B0cy5wcmlvcml0eSB8fCBub29wO1xuICAgICAgci5iZWZvcmVSZW5kZXIoZGVxdWV1ZSwgcHJpb3JpdHkoc2VsZikpO1xuICAgIH07XG4gIH1cbn07XG5cbi8vIFVzZXMga2V5cyBzbyBlbGVtZW50cyBtYXkgc2hhcmUgdGhlIHNhbWUgY2FjaGUuXG5cbnZhciBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cChnZXRLZXkpIHtcbiAgICB2YXIgZG9lc0VsZUludmFsaWRhdGVLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNpZnk7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cCk7XG5cbiAgICB0aGlzLmlkc0J5S2V5ID0gbmV3IE1hcCQxKCk7XG4gICAgdGhpcy5rZXlGb3JJZCA9IG5ldyBNYXAkMSgpO1xuICAgIHRoaXMuY2FjaGVzQnlMdmwgPSBuZXcgTWFwJDEoKTtcbiAgICB0aGlzLmx2bHMgPSBbXTtcbiAgICB0aGlzLmdldEtleSA9IGdldEtleTtcbiAgICB0aGlzLmRvZXNFbGVJbnZhbGlkYXRlS2V5ID0gZG9lc0VsZUludmFsaWRhdGVLZXk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cCwgW3tcbiAgICBrZXk6IFwiZ2V0SWRzRm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElkc0ZvcihrZXkpIHtcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICBlcnJvcihcIkNhbiBub3QgZ2V0IGlkIGxpc3QgZm9yIG51bGwga2V5XCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWRzQnlLZXkgPSB0aGlzLmlkc0J5S2V5O1xuICAgICAgdmFyIGlkcyA9IHRoaXMuaWRzQnlLZXkuZ2V0KGtleSk7XG5cbiAgICAgIGlmICghaWRzKSB7XG4gICAgICAgIGlkcyA9IG5ldyBTZXQkMSgpO1xuICAgICAgICBpZHNCeUtleS5zZXQoa2V5LCBpZHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaWRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRJZEZvcktleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJZEZvcktleShrZXksIGlkKSB7XG4gICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5nZXRJZHNGb3Ioa2V5KS5hZGQoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVJZEZvcktleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVJZEZvcktleShrZXksIGlkKSB7XG4gICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5nZXRJZHNGb3Ioa2V5KVtcImRlbGV0ZVwiXShpZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE51bWJlck9mSWRzRm9yS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE51bWJlck9mSWRzRm9yS2V5KGtleSkge1xuICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWRzRm9yKGtleSkuc2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlS2V5TWFwcGluZ0ZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVLZXlNYXBwaW5nRm9yKGVsZSkge1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTtcbiAgICAgIHZhciBjdXJyS2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHRoaXMuZGVsZXRlSWRGb3JLZXkocHJldktleSwgaWQpO1xuICAgICAgdGhpcy5hZGRJZEZvcktleShjdXJyS2V5LCBpZCk7XG4gICAgICB0aGlzLmtleUZvcklkLnNldChpZCwgY3VycktleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUtleU1hcHBpbmdGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlS2V5TWFwcGluZ0ZvcihlbGUpIHtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7XG4gICAgICB0aGlzLmRlbGV0ZUlkRm9yS2V5KHByZXZLZXksIGlkKTtcbiAgICAgIHRoaXMua2V5Rm9ySWRbXCJkZWxldGVcIl0oaWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJrZXlIYXNDaGFuZ2VkRm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleUhhc0NoYW5nZWRGb3IoZWxlKSB7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpO1xuICAgICAgdmFyIG5ld0tleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICByZXR1cm4gcHJldktleSAhPT0gbmV3S2V5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0ludmFsaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbnZhbGlkKGVsZSkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5SGFzQ2hhbmdlZEZvcihlbGUpIHx8IHRoaXMuZG9lc0VsZUludmFsaWRhdGVLZXkoZWxlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FjaGVzQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FjaGVzQXQobHZsKSB7XG4gICAgICB2YXIgY2FjaGVzQnlMdmwgPSB0aGlzLmNhY2hlc0J5THZsLFxuICAgICAgICAgIGx2bHMgPSB0aGlzLmx2bHM7XG4gICAgICB2YXIgY2FjaGVzID0gY2FjaGVzQnlMdmwuZ2V0KGx2bCk7XG5cbiAgICAgIGlmICghY2FjaGVzKSB7XG4gICAgICAgIGNhY2hlcyA9IG5ldyBNYXAkMSgpO1xuICAgICAgICBjYWNoZXNCeUx2bC5zZXQobHZsLCBjYWNoZXMpO1xuICAgICAgICBsdmxzLnB1c2gobHZsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FjaGUoa2V5LCBsdmwpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENhY2hlc0F0KGx2bCkuZ2V0KGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoZWxlLCBsdmwpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgdmFyIGNhY2hlID0gdGhpcy5nZXRDYWNoZShrZXksIGx2bCk7IC8vIGdldHRpbmcgZm9yIGFuIGVsZW1lbnQgbWF5IG5lZWQgdG8gYWRkIHRvIHRoZSBpZCBsaXN0IGIvYyBlbGVzIGNhbiBzaGFyZSBrZXlzXG5cbiAgICAgIGlmIChjYWNoZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudXBkYXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZvckNhY2hlZEtleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JDYWNoZWRLZXkoZWxlLCBsdmwpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmtleUZvcklkLmdldChlbGUuaWQoKSk7IC8vIG4uYi4gdXNlIGNhY2hlZCBrZXksIG5vdCBuZXdseSBjb21wdXRlZCBrZXlcblxuICAgICAgdmFyIGNhY2hlID0gdGhpcy5nZXRDYWNoZShrZXksIGx2bCk7XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0NhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0NhY2hlKGtleSwgbHZsKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZXNBdChsdmwpLmhhcyhrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGVsZSwgbHZsKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHJldHVybiB0aGlzLmhhc0NhY2hlKGtleSwgbHZsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2FjaGUoa2V5LCBsdmwsIGNhY2hlKSB7XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICB0aGlzLmdldENhY2hlc0F0KGx2bCkuc2V0KGtleSwgY2FjaGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGVsZSwgbHZsLCBjYWNoZSkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICB0aGlzLnNldENhY2hlKGtleSwgbHZsLCBjYWNoZSk7XG4gICAgICB0aGlzLnVwZGF0ZUtleU1hcHBpbmdGb3IoZWxlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlQ2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQ2FjaGUoa2V5LCBsdmwpIHtcbiAgICAgIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKVtcImRlbGV0ZVwiXShrZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShlbGUsIGx2bCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICB0aGlzLmRlbGV0ZUNhY2hlKGtleSwgbHZsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZGF0ZUtleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlS2V5KGtleSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5sdmxzLmZvckVhY2goZnVuY3Rpb24gKGx2bCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuZGVsZXRlQ2FjaGUoa2V5LCBsdmwpO1xuICAgICAgfSk7XG4gICAgfSAvLyByZXR1cm5zIHRydWUgaWYgbm8gb3RoZXIgZWxlcyByZWZlcmVuY2UgdGhlIGludmFsaWRhdGVkIGNhY2hlIChuLmIuIG90aGVyIGVsZXMgbWF5IG5lZWQgdGhlIGNhY2hlIHdpdGggdGhlIHNhbWUga2V5KVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlKGVsZSkge1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIga2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpOyAvLyBuLmIuIHVzZSBzdG9yZWQga2V5IHJhdGhlciB0aGFuIGN1cnJlbnQgKHBvdGVudGlhbCBrZXkpXG5cbiAgICAgIHRoaXMuZGVsZXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgICAgdmFyIGVudGlyZUtleUludmFsaWRhdGVkID0gdGhpcy5kb2VzRWxlSW52YWxpZGF0ZUtleShlbGUpO1xuXG4gICAgICBpZiAoZW50aXJlS2V5SW52YWxpZGF0ZWQpIHtcbiAgICAgICAgLy8gY2xlYXIgbWFwcGluZyBmb3IgY3VycmVudCBrZXlcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlS2V5KGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbnRpcmVLZXlJbnZhbGlkYXRlZCB8fCB0aGlzLmdldE51bWJlck9mSWRzRm9yS2V5KGtleSkgPT09IDA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXA7XG59KCk7XG5cbnZhciBtaW5UeHJIID0gMjU7IC8vIHRoZSBzaXplIG9mIHRoZSB0ZXh0dXJlIGNhY2hlIGZvciBzbWFsbCBoZWlnaHQgZWxlcyAoc3BlY2lhbCBjYXNlKVxuXG52YXIgdHhyU3RlcEggPSA1MDsgLy8gdGhlIG1pbiBzaXplIG9mIHRoZSByZWd1bGFyIGNhY2hlLCBhbmQgdGhlIHNpemUgaXQgaW5jcmVhc2VzIHdpdGggZWFjaCBzdGVwIHVwXG5cbnZhciBtaW5MdmwgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG5cbnZhciBtYXhMdmwgPSAzOyAvLyB3aGVuIGxhcmdlciB0aGFuIHRoaXMgc2NhbGUganVzdCByZW5kZXIgZGlyZWN0bHkgKGNhY2hpbmcgaXMgbm90IGhlbHBmdWwpXG5cbnZhciBtYXhab29tID0gNy45OTsgLy8gYmV5b25kIHRoaXMgem9vbSBsZXZlbCwgbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHVzZWRcblxudmFyIGVsZVR4clNwYWNpbmcgPSA4OyAvLyBzcGFjaW5nIGJldHdlZW4gZWxlbWVudHMgb24gdGV4dHVyZXMgdG8gYXZvaWQgYmxpdHRpbmcgb3ZlcmxhcHNcblxudmFyIGRlZlR4cldpZHRoID0gMTAyNDsgLy8gZGVmYXVsdC9taW5pbXVtIHRleHR1cmUgd2lkdGhcblxudmFyIG1heFR4clcgPSAxMDI0OyAvLyB0aGUgbWF4aW11bSB3aWR0aCBvZiBhIHRleHR1cmVcblxudmFyIG1heFR4ckggPSAxMDI0OyAvLyB0aGUgbWF4aW11bSBoZWlnaHQgb2YgYSB0ZXh0dXJlXG5cbnZhciBtaW5VdGlsaXR5ID0gMC4yOyAvLyBpZiB1c2FnZSBvZiB0ZXh0dXJlIGlzIGxlc3MgdGhhbiB0aGlzLCBpdCBpcyByZXRpcmVkXG5cbnZhciBtYXhGdWxsbmVzcyA9IDAuODsgLy8gZnVsbG5lc3Mgb2YgdGV4dHVyZSBhZnRlciB3aGljaCBxdWV1ZSByZW1vdmFsIGlzIGNoZWNrZWRcblxudmFyIG1heEZ1bGxuZXNzQ2hlY2tzID0gMTA7IC8vIGRlcXVldWVkIGFmdGVyIHRoaXMgbWFueSBjaGVja3NcblxudmFyIGRlcUNvc3QgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcblxudmFyIGRlcUF2Z0Nvc3QgPSAwLjE7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgY29tcGFyZWQgdG8gYXZlcmFnZSBvdmVyYWxsIHJlZHJhdyB0aW1lXG5cbnZhciBkZXFOb0RyYXdDb3N0ID0gMC45OyAvLyAlIG9mIGF2ZyBmcmFtZSB0aW1lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRlcXVldWVpbmcgd2hlbiBub3QgZHJhd2luZ1xuXG52YXIgZGVxRmFzdENvc3QgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG5cbnZhciBkZXFSZWRyYXdUaHJlc2hvbGQgPSAxMDA7IC8vIHRpbWUgdG8gYmF0Y2ggcmVkcmF3cyB0b2dldGhlciBmcm9tIGRlcXVldWVpbmcgdG8gYWxsb3cgbW9yZSBkZXF1ZXVlaW5nIGNhbGNzIHRvIGhhcHBlbiBpbiB0aGUgbWVhbndoaWxlXG5cbnZhciBtYXhEZXFTaXplID0gMTsgLy8gbnVtYmVyIG9mIGVsZXMgdG8gZGVxdWV1ZSBhbmQgcmVuZGVyIGF0IGhpZ2hlciB0ZXh0dXJlIGluIGVhY2ggYmF0Y2hcblxudmFyIGdldFR4clJlYXNvbnMgPSB7XG4gIGRlcXVldWU6ICdkZXF1ZXVlJyxcbiAgZG93bnNjYWxlOiAnZG93bnNjYWxlJyxcbiAgaGlnaFF1YWxpdHk6ICdoaWdoUXVhbGl0eSdcbn07XG52YXIgaW5pdERlZmF1bHRzID0gZGVmYXVsdHMoe1xuICBnZXRLZXk6IG51bGwsXG4gIGRvZXNFbGVJbnZhbGlkYXRlS2V5OiBmYWxzaWZ5LFxuICBkcmF3RWxlbWVudDogbnVsbCxcbiAgZ2V0Qm91bmRpbmdCb3g6IG51bGwsXG4gIGdldFJvdGF0aW9uUG9pbnQ6IG51bGwsXG4gIGdldFJvdGF0aW9uT2Zmc2V0OiBudWxsLFxuICBpc1Zpc2libGU6IHRydWVpZnksXG4gIGFsbG93RWRnZVR4ckNhY2hpbmc6IHRydWUsXG4gIGFsbG93UGFyZW50VHhyQ2FjaGluZzogdHJ1ZVxufSk7XG5cbnZhciBFbGVtZW50VGV4dHVyZUNhY2hlID0gZnVuY3Rpb24gRWxlbWVudFRleHR1cmVDYWNoZShyZW5kZXJlciwgaW5pdE9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIHNlbGYub25EZXF1ZXVlcyA9IFtdO1xuICB2YXIgb3B0cyA9IGluaXREZWZhdWx0cyhpbml0T3B0aW9ucyk7XG4gIGV4dGVuZChzZWxmLCBvcHRzKTtcbiAgc2VsZi5sb29rdXAgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cChvcHRzLmdldEtleSwgb3B0cy5kb2VzRWxlSW52YWxpZGF0ZUtleSk7XG4gIHNlbGYuc2V0dXBEZXF1ZXVlaW5nKCk7XG59O1xuXG52YXIgRVRDcCA9IEVsZW1lbnRUZXh0dXJlQ2FjaGUucHJvdG90eXBlO1xuRVRDcC5yZWFzb25zID0gZ2V0VHhyUmVhc29uczsgLy8gdGhlIGxpc3Qgb2YgdGV4dHVyZXMgaW4gd2hpY2ggbmV3IHN1YnRleHR1cmVzIGZvciBlbGVtZW50cyBjYW4gYmUgcGxhY2VkXG5cbkVUQ3AuZ2V0VGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24gKHR4ckgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmVsZUltZ0NhY2hlcyA9IHNlbGYuZWxlSW1nQ2FjaGVzIHx8IHt9O1xuICByZXR1cm4gc2VsZi5lbGVJbWdDYWNoZXNbdHhySF0gPSBzZWxmLmVsZUltZ0NhY2hlc1t0eHJIXSB8fCBbXTtcbn07IC8vIHRoZSBsaXN0IG9mIHVzdXNlZCB0ZXh0dXJlcyB3aGljaCBjYW4gYmUgcmVjeWNsZWQgKGluIHVzZSBpbiB0ZXh0dXJlIHF1ZXVlKVxuXG5cbkVUQ3AuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSA9IGZ1bmN0aW9uICh0eHJIKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJ0eHRyUXMgPSBzZWxmLmVsZUltZ0NhY2hlcy5yZXRpcmVkID0gc2VsZi5lbGVJbWdDYWNoZXMucmV0aXJlZCB8fCB7fTtcbiAgdmFyIHJ0eHRyUSA9IHJ0eHRyUXNbdHhySF0gPSBydHh0clFzW3R4ckhdIHx8IFtdO1xuICByZXR1cm4gcnR4dHJRO1xufTsgLy8gcXVldWUgb2YgZWxlbWVudCBkcmF3IHJlcXVlc3RzIGF0IGRpZmZlcmVudCBzY2FsZSBsZXZlbHNcblxuXG5FVENwLmdldEVsZW1lbnRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSB8fCBuZXcgSGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnJlcXMgLSBhLnJlcXM7XG4gIH0pO1xuICByZXR1cm4gcTtcbn07IC8vIHF1ZXVlIG9mIGVsZW1lbnQgZHJhdyByZXF1ZXN0cyBhdCBkaWZmZXJlbnQgc2NhbGUgbGV2ZWxzIChlbGVtZW50IGlkIGxvb2t1cClcblxuXG5FVENwLmdldEVsZW1lbnRLZXlUb1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBrMnEgPSBzZWxmLmVsZUtleVRvQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlS2V5VG9DYWNoZVF1ZXVlIHx8IHt9O1xuICByZXR1cm4gazJxO1xufTtcblxuRVRDcC5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZSwgYmIsIHB4UmF0aW8sIGx2bCwgcmVhc29uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICB2YXIgbG9va3VwID0gdGhpcy5sb29rdXA7XG5cbiAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCB8fCBpc05hTihiYi53KSB8fCBpc05hTihiYi5oKSB8fCAhZWxlLnZpc2libGUoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKCFzZWxmLmFsbG93RWRnZVR4ckNhY2hpbmcgJiYgZWxlLmlzRWRnZSgpIHx8ICFzZWxmLmFsbG93UGFyZW50VHhyQ2FjaGluZyAmJiBlbGUuaXNQYXJlbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGx2bCA9PSBudWxsKSB7XG4gICAgbHZsID0gTWF0aC5jZWlsKGxvZzIoem9vbSAqIHB4UmF0aW8pKTtcbiAgfVxuXG4gIGlmIChsdmwgPCBtaW5MdmwpIHtcbiAgICBsdmwgPSBtaW5Mdmw7XG4gIH0gZWxzZSBpZiAoem9vbSA+PSBtYXhab29tIHx8IGx2bCA+IG1heEx2bCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgdmFyIGVsZVNjYWxlZEggPSBiYi5oICogc2NhbGU7XG4gIHZhciBlbGVTY2FsZWRXID0gYmIudyAqIHNjYWxlO1xuICB2YXIgc2NhbGVkTGFiZWxTaG93biA9IHIuZWxlVGV4dEJpZ2dlclRoYW5NaW4oZWxlLCBzY2FsZSk7XG5cbiAgaWYgKCF0aGlzLmlzVmlzaWJsZShlbGUsIHNjYWxlZExhYmVsU2hvd24pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZWxlQ2FjaGUgPSBsb29rdXAuZ2V0KGVsZSwgbHZsKTsgLy8gaWYgdGhpcyBnZXQgd2FzIG9uIGFuIHVudXNlZC9pbnZhbGlkYXRlZCBjYWNoZSwgdGhlbiByZXN0b3JlIHRoZSB0ZXh0dXJlIHVzYWdlIG1ldHJpY1xuXG4gIGlmIChlbGVDYWNoZSAmJiBlbGVDYWNoZS5pbnZhbGlkYXRlZCkge1xuICAgIGVsZUNhY2hlLmludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgZWxlQ2FjaGUudGV4dHVyZS5pbnZhbGlkYXRlZFdpZHRoIC09IGVsZUNhY2hlLndpZHRoO1xuICB9XG5cbiAgaWYgKGVsZUNhY2hlKSB7XG4gICAgcmV0dXJuIGVsZUNhY2hlO1xuICB9XG5cbiAgdmFyIHR4ckg7IC8vIHdoaWNoIHRleHR1cmUgaGVpZ2h0IHRoaXMgZWxlIGJlbG9uZ3MgdG9cblxuICBpZiAoZWxlU2NhbGVkSCA8PSBtaW5UeHJIKSB7XG4gICAgdHhySCA9IG1pblR4ckg7XG4gIH0gZWxzZSBpZiAoZWxlU2NhbGVkSCA8PSB0eHJTdGVwSCkge1xuICAgIHR4ckggPSB0eHJTdGVwSDtcbiAgfSBlbHNlIHtcbiAgICB0eHJIID0gTWF0aC5jZWlsKGVsZVNjYWxlZEggLyB0eHJTdGVwSCkgKiB0eHJTdGVwSDtcbiAgfVxuXG4gIGlmIChlbGVTY2FsZWRIID4gbWF4VHhySCB8fCBlbGVTY2FsZWRXID4gbWF4VHhyVykge1xuICAgIHJldHVybiBudWxsOyAvLyBjYWNoaW5nIGxhcmdlIGVsZW1lbnRzIGlzIG5vdCBlZmZpY2llbnRcbiAgfVxuXG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7IC8vIGZpcnN0IHRyeSB0aGUgc2Vjb25kIGxhc3Qgb25lIGluIGNhc2UgaXQgaGFzIHNwYWNlIGF0IHRoZSBlbmRcblxuICB2YXIgdHhyID0gdHhyUVt0eHJRLmxlbmd0aCAtIDJdO1xuXG4gIHZhciBhZGROZXdUeHIgPSBmdW5jdGlvbiBhZGROZXdUeHIoKSB7XG4gICAgcmV0dXJuIHNlbGYucmVjeWNsZVRleHR1cmUodHhySCwgZWxlU2NhbGVkVykgfHwgc2VsZi5hZGRUZXh0dXJlKHR4ckgsIGVsZVNjYWxlZFcpO1xuICB9OyAvLyB0cnkgdGhlIGxhc3Qgb25lIGlmIHRoZXJlIGlzIG5vIHNlY29uZCBsYXN0IG9uZVxuXG5cbiAgaWYgKCF0eHIpIHtcbiAgICB0eHIgPSB0eHJRW3R4clEubGVuZ3RoIC0gMV07XG4gIH0gLy8gaWYgdGhlIGxhc3Qgb25lIGRvZXNuJ3QgZXhpc3QsIHdlIG5lZWQgYSBmaXJzdCBvbmVcblxuXG4gIGlmICghdHhyKSB7XG4gICAgdHhyID0gYWRkTmV3VHhyKCk7XG4gIH0gLy8gaWYgdGhlcmUncyBubyByb29tIGluIHRoZSBjdXJyZW50IHRleHR1cmUsIHdlIG5lZWQgYSBuZXcgb25lXG5cblxuICBpZiAodHhyLndpZHRoIC0gdHhyLnVzZWRXaWR0aCA8IGVsZVNjYWxlZFcpIHtcbiAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgfVxuXG4gIHZhciBzY2FsYWJsZUZyb20gPSBmdW5jdGlvbiBzY2FsYWJsZUZyb20ob3RoZXJDYWNoZSkge1xuICAgIHJldHVybiBvdGhlckNhY2hlICYmIG90aGVyQ2FjaGUuc2NhbGVkTGFiZWxTaG93biA9PT0gc2NhbGVkTGFiZWxTaG93bjtcbiAgfTtcblxuICB2YXIgZGVxaW5nID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5kZXF1ZXVlO1xuICB2YXIgaGlnaFF1YWxpdHlSZXEgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmhpZ2hRdWFsaXR5O1xuICB2YXIgZG93bnNjYWxlUmVxID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5kb3duc2NhbGU7XG4gIHZhciBoaWdoZXJDYWNoZTsgLy8gdGhlIG5lYXJlc3QgY2FjaGUgd2l0aCBhIGhpZ2hlciBsZXZlbFxuXG4gIGZvciAodmFyIGwgPSBsdmwgKyAxOyBsIDw9IG1heEx2bDsgbCsrKSB7XG4gICAgdmFyIGMgPSBsb29rdXAuZ2V0KGVsZSwgbCk7XG5cbiAgICBpZiAoYykge1xuICAgICAgaGlnaGVyQ2FjaGUgPSBjO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG9uZVVwQ2FjaGUgPSBoaWdoZXJDYWNoZSAmJiBoaWdoZXJDYWNoZS5sZXZlbCA9PT0gbHZsICsgMSA/IGhpZ2hlckNhY2hlIDogbnVsbDtcblxuICB2YXIgZG93bnNjYWxlID0gZnVuY3Rpb24gZG93bnNjYWxlKCkge1xuICAgIHR4ci5jb250ZXh0LmRyYXdJbWFnZShvbmVVcENhY2hlLnRleHR1cmUuY2FudmFzLCBvbmVVcENhY2hlLngsIDAsIG9uZVVwQ2FjaGUud2lkdGgsIG9uZVVwQ2FjaGUuaGVpZ2h0LCB0eHIudXNlZFdpZHRoLCAwLCBlbGVTY2FsZWRXLCBlbGVTY2FsZWRIKTtcbiAgfTsgLy8gcmVzZXQgZWxlIGFyZWEgaW4gdGV4dHVyZVxuXG5cbiAgdHhyLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICB0eHIuY29udGV4dC5jbGVhclJlY3QodHhyLnVzZWRXaWR0aCwgMCwgZWxlU2NhbGVkVywgdHhySCk7XG5cbiAgaWYgKHNjYWxhYmxlRnJvbShvbmVVcENhY2hlKSkge1xuICAgIC8vIHRoZW4gd2UgY2FuIHJlbGF0aXZlbHkgY2hlYXBseSByZXNjYWxlIHRoZSBleGlzdGluZyBpbWFnZSB3L28gcmVyZW5kZXJpbmdcbiAgICBkb3duc2NhbGUoKTtcbiAgfSBlbHNlIGlmIChzY2FsYWJsZUZyb20oaGlnaGVyQ2FjaGUpKSB7XG4gICAgLy8gdGhlbiB1c2UgdGhlIGhpZ2hlciBjYWNoZSBmb3Igbm93IGFuZCBxdWV1ZSB0aGUgbmV4dCBsZXZlbCBkb3duXG4gICAgLy8gdG8gY2hlYXBseSBzY2FsZSB0b3dhcmRzIHRoZSBzbWFsbGVyIGxldmVsXG4gICAgaWYgKGhpZ2hRdWFsaXR5UmVxKSB7XG4gICAgICBmb3IgKHZhciBfbCA9IGhpZ2hlckNhY2hlLmxldmVsOyBfbCA+IGx2bDsgX2wtLSkge1xuICAgICAgICBvbmVVcENhY2hlID0gc2VsZi5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIF9sLCBnZXRUeHJSZWFzb25zLmRvd25zY2FsZSk7XG4gICAgICB9XG5cbiAgICAgIGRvd25zY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnF1ZXVlRWxlbWVudChlbGUsIGhpZ2hlckNhY2hlLmxldmVsIC0gMSk7XG4gICAgICByZXR1cm4gaGlnaGVyQ2FjaGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsb3dlckNhY2hlOyAvLyB0aGUgbmVhcmVzdCBjYWNoZSB3aXRoIGEgbG93ZXIgbGV2ZWxcblxuICAgIGlmICghZGVxaW5nICYmICFoaWdoUXVhbGl0eVJlcSAmJiAhZG93bnNjYWxlUmVxKSB7XG4gICAgICBmb3IgKHZhciBfbDIgPSBsdmwgLSAxOyBfbDIgPj0gbWluTHZsOyBfbDItLSkge1xuICAgICAgICB2YXIgX2MgPSBsb29rdXAuZ2V0KGVsZSwgX2wyKTtcblxuICAgICAgICBpZiAoX2MpIHtcbiAgICAgICAgICBsb3dlckNhY2hlID0gX2M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2NhbGFibGVGcm9tKGxvd2VyQ2FjaGUpKSB7XG4gICAgICAvLyB0aGVuIHVzZSB0aGUgbG93ZXIgcXVhbGl0eSBjYWNoZSBmb3Igbm93IGFuZCBxdWV1ZSB0aGUgYmV0dGVyIG9uZSBmb3IgbGF0ZXJcbiAgICAgIHNlbGYucXVldWVFbGVtZW50KGVsZSwgbHZsKTtcbiAgICAgIHJldHVybiBsb3dlckNhY2hlO1xuICAgIH1cblxuICAgIHR4ci5jb250ZXh0LnRyYW5zbGF0ZSh0eHIudXNlZFdpZHRoLCAwKTtcbiAgICB0eHIuY29udGV4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgIHRoaXMuZHJhd0VsZW1lbnQodHhyLmNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIGZhbHNlKTtcbiAgICB0eHIuY29udGV4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgdHhyLmNvbnRleHQudHJhbnNsYXRlKC10eHIudXNlZFdpZHRoLCAwKTtcbiAgfVxuXG4gIGVsZUNhY2hlID0ge1xuICAgIHg6IHR4ci51c2VkV2lkdGgsXG4gICAgdGV4dHVyZTogdHhyLFxuICAgIGxldmVsOiBsdmwsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHdpZHRoOiBlbGVTY2FsZWRXLFxuICAgIGhlaWdodDogZWxlU2NhbGVkSCxcbiAgICBzY2FsZWRMYWJlbFNob3duOiBzY2FsZWRMYWJlbFNob3duXG4gIH07XG4gIHR4ci51c2VkV2lkdGggKz0gTWF0aC5jZWlsKGVsZVNjYWxlZFcgKyBlbGVUeHJTcGFjaW5nKTtcbiAgdHhyLmVsZUNhY2hlcy5wdXNoKGVsZUNhY2hlKTtcbiAgbG9va3VwLnNldChlbGUsIGx2bCwgZWxlQ2FjaGUpO1xuICBzZWxmLmNoZWNrVGV4dHVyZUZ1bGxuZXNzKHR4cik7XG4gIHJldHVybiBlbGVDYWNoZTtcbn07XG5cbkVUQ3AuaW52YWxpZGF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlRWxlbWVudChlbGVzW2ldKTtcbiAgfVxufTtcblxuRVRDcC5pbnZhbGlkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbG9va3VwID0gc2VsZi5sb29rdXA7XG4gIHZhciBjYWNoZXMgPSBbXTtcbiAgdmFyIGludmFsaWQgPSBsb29rdXAuaXNJbnZhbGlkKGVsZSk7XG5cbiAgaWYgKCFpbnZhbGlkKSB7XG4gICAgcmV0dXJuOyAvLyBvdmVycmlkZSB0aGUgaW52YWxpZGF0aW9uIHJlcXVlc3QgaWYgdGhlIGVsZW1lbnQga2V5IGhhcyBub3QgY2hhbmdlZFxuICB9XG5cbiAgZm9yICh2YXIgbHZsID0gbWluTHZsOyBsdmwgPD0gbWF4THZsOyBsdmwrKykge1xuICAgIHZhciBjYWNoZSA9IGxvb2t1cC5nZXRGb3JDYWNoZWRLZXkoZWxlLCBsdmwpO1xuXG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICBjYWNoZXMucHVzaChjYWNoZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vT3RoZXJFbGVzVXNlQ2FjaGUgPSBsb29rdXAuaW52YWxpZGF0ZShlbGUpO1xuXG4gIGlmIChub090aGVyRWxlc1VzZUNhY2hlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfY2FjaGUgPSBjYWNoZXNbaV07XG4gICAgICB2YXIgdHhyID0gX2NhY2hlLnRleHR1cmU7IC8vIHJlbW92ZSBzcGFjZSBmcm9tIHRoZSB0ZXh0dXJlIGl0IGJlbG9uZ3MgdG9cblxuICAgICAgdHhyLmludmFsaWRhdGVkV2lkdGggKz0gX2NhY2hlLndpZHRoOyAvLyBtYXJrIHRoZSBjYWNoZSBhcyBpbnZhbGlkYXRlZFxuXG4gICAgICBfY2FjaGUuaW52YWxpZGF0ZWQgPSB0cnVlOyAvLyByZXRpcmUgdGhlIHRleHR1cmUgaWYgaXRzIHV0aWxpdHkgaXMgbG93XG5cbiAgICAgIHNlbGYuY2hlY2tUZXh0dXJlVXRpbGl0eSh0eHIpO1xuICAgIH1cbiAgfSAvLyByZW1vdmUgZnJvbSBxdWV1ZSBzaW5jZSB0aGUgb2xkIHJlcSB3YXMgZm9yIHRoZSBvbGQgc3RhdGVcblxuXG4gIHNlbGYucmVtb3ZlRnJvbVF1ZXVlKGVsZSk7XG59O1xuXG5FVENwLmNoZWNrVGV4dHVyZVV0aWxpdHkgPSBmdW5jdGlvbiAodHhyKSB7XG4gIC8vIGludmFsaWRhdGUgYWxsIGVudHJpZXMgaW4gdGhlIGNhY2hlIGlmIHRoZSBjYWNoZSBzaXplIGlzIHNtYWxsXG4gIGlmICh0eHIuaW52YWxpZGF0ZWRXaWR0aCA+PSBtaW5VdGlsaXR5ICogdHhyLndpZHRoKSB7XG4gICAgdGhpcy5yZXRpcmVUZXh0dXJlKHR4cik7XG4gIH1cbn07XG5cbkVUQ3AuY2hlY2tUZXh0dXJlRnVsbG5lc3MgPSBmdW5jdGlvbiAodHhyKSB7XG4gIC8vIGlmIHRleHR1cmUgaGFzIGJlZW4gbW9zdGx5IGZpbGxlZCBhbmQgcGFzc2VkIG92ZXIgc2V2ZXJhbCB0aW1lcywgcmVtb3ZlXG4gIC8vIGl0IGZyb20gdGhlIHF1ZXVlIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FzdGUgdGltZSBsb29raW5nIGF0IGl0IHRvIHB1dCBuZXcgdGhpbmdzXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHIuaGVpZ2h0KTtcblxuICBpZiAodHhyLnVzZWRXaWR0aCAvIHR4ci53aWR0aCA+IG1heEZ1bGxuZXNzICYmIHR4ci5mdWxsbmVzc0NoZWNrcyA+PSBtYXhGdWxsbmVzc0NoZWNrcykge1xuICAgIHJlbW92ZUZyb21BcnJheSh0eHJRLCB0eHIpO1xuICB9IGVsc2Uge1xuICAgIHR4ci5mdWxsbmVzc0NoZWNrcysrO1xuICB9XG59O1xuXG5FVENwLnJldGlyZVRleHR1cmUgPSBmdW5jdGlvbiAodHhyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4ckggPSB0eHIuaGVpZ2h0O1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICB2YXIgbG9va3VwID0gdGhpcy5sb29rdXA7IC8vIHJldGlyZSB0aGUgdGV4dHVyZSBmcm9tIHRoZSBhY3RpdmUgLyBzZWFyY2hhYmxlIHF1ZXVlOlxuXG4gIHJlbW92ZUZyb21BcnJheSh0eHJRLCB0eHIpO1xuICB0eHIucmV0aXJlZCA9IHRydWU7IC8vIHJlbW92ZSB0aGUgcmVmcyBmcm9tIHRoZSBlbGVzIHRvIHRoZSBjYWNoZXM6XG5cbiAgdmFyIGVsZUNhY2hlcyA9IHR4ci5lbGVDYWNoZXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVDYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlQ2FjaGUgPSBlbGVDYWNoZXNbaV07XG4gICAgbG9va3VwLmRlbGV0ZUNhY2hlKGVsZUNhY2hlLmtleSwgZWxlQ2FjaGUubGV2ZWwpO1xuICB9XG5cbiAgY2xlYXJBcnJheShlbGVDYWNoZXMpOyAvLyBhZGQgdGhlIHRleHR1cmUgdG8gYSByZXRpcmVkIHF1ZXVlIHNvIGl0IGNhbiBiZSByZWN5Y2xlZCBpbiBmdXR1cmU6XG5cbiAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgcnR4dHJRLnB1c2godHhyKTtcbn07XG5cbkVUQ3AuYWRkVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHJILCBtaW5XKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgdmFyIHR4ciA9IHt9O1xuICB0eHJRLnB1c2godHhyKTtcbiAgdHhyLmVsZUNhY2hlcyA9IFtdO1xuICB0eHIuaGVpZ2h0ID0gdHhySDtcbiAgdHhyLndpZHRoID0gTWF0aC5tYXgoZGVmVHhyV2lkdGgsIG1pblcpO1xuICB0eHIudXNlZFdpZHRoID0gMDtcbiAgdHhyLmludmFsaWRhdGVkV2lkdGggPSAwO1xuICB0eHIuZnVsbG5lc3NDaGVja3MgPSAwO1xuICB0eHIuY2FudmFzID0gc2VsZi5yZW5kZXJlci5tYWtlT2Zmc2NyZWVuQ2FudmFzKHR4ci53aWR0aCwgdHhyLmhlaWdodCk7XG4gIHR4ci5jb250ZXh0ID0gdHhyLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICByZXR1cm4gdHhyO1xufTtcblxuRVRDcC5yZWN5Y2xlVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHJILCBtaW5XKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSh0eHJIKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ0eHRyUS5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0eHIgPSBydHh0clFbaV07XG5cbiAgICBpZiAodHhyLndpZHRoID49IG1pblcpIHtcbiAgICAgIHR4ci5yZXRpcmVkID0gZmFsc2U7XG4gICAgICB0eHIudXNlZFdpZHRoID0gMDtcbiAgICAgIHR4ci5pbnZhbGlkYXRlZFdpZHRoID0gMDtcbiAgICAgIHR4ci5mdWxsbmVzc0NoZWNrcyA9IDA7XG4gICAgICBjbGVhckFycmF5KHR4ci5lbGVDYWNoZXMpO1xuICAgICAgdHhyLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgdHhyLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHR4ci53aWR0aCwgdHhyLmhlaWdodCk7XG4gICAgICByZW1vdmVGcm9tQXJyYXkocnR4dHJRLCB0eHIpO1xuICAgICAgdHhyUS5wdXNoKHR4cik7XG4gICAgICByZXR1cm4gdHhyO1xuICAgIH1cbiAgfVxufTtcblxuRVRDcC5xdWV1ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlLCBsdmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gIHZhciBrMnEgPSBzZWxmLmdldEVsZW1lbnRLZXlUb1F1ZXVlKCk7XG4gIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICB2YXIgZXhpc3RpbmdSZXEgPSBrMnFba2V5XTtcblxuICBpZiAoZXhpc3RpbmdSZXEpIHtcbiAgICAvLyB1c2UgdGhlIG1heCBsdmwgYi9jIGluIGJldHdlZW4gbHZscyBhcmUgY2hlYXAgdG8gbWFrZVxuICAgIGV4aXN0aW5nUmVxLmxldmVsID0gTWF0aC5tYXgoZXhpc3RpbmdSZXEubGV2ZWwsIGx2bCk7XG4gICAgZXhpc3RpbmdSZXEuZWxlcy5tZXJnZShlbGUpO1xuICAgIGV4aXN0aW5nUmVxLnJlcXMrKztcbiAgICBxLnVwZGF0ZUl0ZW0oZXhpc3RpbmdSZXEpO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXEgPSB7XG4gICAgICBlbGVzOiBlbGUuc3Bhd24oKS5tZXJnZShlbGUpLFxuICAgICAgbGV2ZWw6IGx2bCxcbiAgICAgIHJlcXM6IDEsXG4gICAgICBrZXk6IGtleVxuICAgIH07XG4gICAgcS5wdXNoKHJlcSk7XG4gICAgazJxW2tleV0gPSByZXE7XG4gIH1cbn07XG5cbkVUQ3AuZGVxdWV1ZSA9IGZ1bmN0aW9uIChweFJhdGlvXG4vKiwgZXh0ZW50Ki9cbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5nZXRFbGVtZW50UXVldWUoKTtcbiAgdmFyIGsycSA9IHNlbGYuZ2V0RWxlbWVudEtleVRvUXVldWUoKTtcbiAgdmFyIGRlcXVldWVkID0gW107XG4gIHZhciBsb29rdXAgPSBzZWxmLmxvb2t1cDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1heERlcVNpemU7IGkrKykge1xuICAgIGlmIChxLnNpemUoKSA+IDApIHtcbiAgICAgIHZhciByZXEgPSBxLnBvcCgpO1xuICAgICAgdmFyIGtleSA9IHJlcS5rZXk7XG4gICAgICB2YXIgZWxlID0gcmVxLmVsZXNbMF07IC8vIGFsbCBlbGVzIGhhdmUgdGhlIHNhbWUga2V5XG5cbiAgICAgIHZhciBjYWNoZUV4aXN0cyA9IGxvb2t1cC5oYXNDYWNoZShlbGUsIHJlcS5sZXZlbCk7IC8vIGNsZWFyIG91dCB0aGUga2V5IHRvIHJlcSBsb29rdXBcblxuICAgICAgazJxW2tleV0gPSBudWxsOyAvLyBkZXF1ZXVlaW5nIGlzbid0IG5lY2Vzc2FyeSB3aXRoIGFuIGV4aXN0aW5nIGNhY2hlXG5cbiAgICAgIGlmIChjYWNoZUV4aXN0cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGVxdWV1ZWQucHVzaChyZXEpO1xuICAgICAgdmFyIGJiID0gc2VsZi5nZXRCb3VuZGluZ0JveChlbGUpO1xuICAgICAgc2VsZi5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIHJlcS5sZXZlbCwgZ2V0VHhyUmVhc29ucy5kZXF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlcXVldWVkO1xufTtcblxuRVRDcC5yZW1vdmVGcm9tUXVldWUgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICB2YXIgazJxID0gc2VsZi5nZXRFbGVtZW50S2V5VG9RdWV1ZSgpO1xuICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgdmFyIHJlcSA9IGsycVtrZXldO1xuXG4gIGlmIChyZXEgIT0gbnVsbCkge1xuICAgIGlmIChyZXEuZWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIHJlbW92ZSBpZiBsYXN0IGVsZSBpbiB0aGUgcmVxXG4gICAgICAvLyBicmluZyB0byBmcm9udCBvZiBxdWV1ZVxuICAgICAgcmVxLnJlcXMgPSBNQVhfSU5UO1xuICAgICAgcS51cGRhdGVJdGVtKHJlcSk7XG4gICAgICBxLnBvcCgpOyAvLyByZW1vdmUgZnJvbSBxdWV1ZVxuXG4gICAgICBrMnFba2V5XSA9IG51bGw7IC8vIHJlbW92ZSBmcm9tIGxvb2t1cCBtYXBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgcmVtb3ZlIGVsZSBmcm9tIHJlcVxuICAgICAgcmVxLmVsZXMudW5tZXJnZShlbGUpO1xuICAgIH1cbiAgfVxufTtcblxuRVRDcC5vbkRlcXVldWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdGhpcy5vbkRlcXVldWVzLnB1c2goZm4pO1xufTtcblxuRVRDcC5vZmZEZXF1ZXVlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJlbW92ZUZyb21BcnJheSh0aGlzLm9uRGVxdWV1ZXMsIGZuKTtcbn07XG5cbkVUQ3Auc2V0dXBEZXF1ZXVlaW5nID0gZGVmcy5zZXR1cERlcXVldWVpbmcoe1xuICBkZXFSZWRyYXdUaHJlc2hvbGQ6IGRlcVJlZHJhd1RocmVzaG9sZCxcbiAgZGVxQ29zdDogZGVxQ29zdCxcbiAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCxcbiAgZGVxTm9EcmF3Q29zdDogZGVxTm9EcmF3Q29zdCxcbiAgZGVxRmFzdENvc3Q6IGRlcUZhc3RDb3N0LFxuICBkZXE6IGZ1bmN0aW9uIGRlcShzZWxmLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICByZXR1cm4gc2VsZi5kZXF1ZXVlKHB4UmF0aW8sIGV4dGVudCk7XG4gIH0sXG4gIG9uRGVxZDogZnVuY3Rpb24gb25EZXFkKHNlbGYsIGRlcWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYub25EZXF1ZXVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZuID0gc2VsZi5vbkRlcXVldWVzW2ldO1xuICAgICAgZm4oZGVxZCk7XG4gICAgfVxuICB9LFxuICBzaG91bGRSZWRyYXc6IGZ1bmN0aW9uIHNob3VsZFJlZHJhdyhzZWxmLCBkZXFkLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGVzID0gZGVxZFtpXS5lbGVzO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGJiID0gZWxlc1tqXS5ib3VuZGluZ0JveCgpO1xuXG4gICAgICAgIGlmIChib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJiLCBleHRlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHByaW9yaXR5OiBmdW5jdGlvbiBwcmlvcml0eShzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGYucmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5lbGVUeHJEZXE7XG4gIH1cbn0pO1xuXG52YXIgZGVmTnVtTGF5ZXJzID0gMTsgLy8gZGVmYXVsdCBudW1iZXIgb2YgbGF5ZXJzIHRvIHVzZVxuXG52YXIgbWluTHZsJDEgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG5cbnZhciBtYXhMdmwkMSA9IDI7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcblxudmFyIG1heFpvb20kMSA9IDMuOTk7IC8vIGJleW9uZCB0aGlzIHpvb20gbGV2ZWwsIGxheWVyZWQgdGV4dHVyZXMgYXJlIG5vdCB1c2VkXG5cbnZhciBkZXFSZWRyYXdUaHJlc2hvbGQkMSA9IDUwOyAvLyB0aW1lIHRvIGJhdGNoIHJlZHJhd3MgdG9nZXRoZXIgZnJvbSBkZXF1ZXVlaW5nIHRvIGFsbG93IG1vcmUgZGVxdWV1ZWluZyBjYWxjcyB0byBoYXBwZW4gaW4gdGhlIG1lYW53aGlsZVxuXG52YXIgcmVmaW5lRWxlRGVib3VuY2VUaW1lID0gNTA7IC8vIHRpbWUgdG8gZGVib3VuY2Ugc2hhcnBlciBlbGUgdGV4dHVyZSB1cGRhdGVzXG5cbnZhciBkZXFDb3N0JDEgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcblxudmFyIGRlcUF2Z0Nvc3QkMSA9IDAuMTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBjb21wYXJlZCB0byBhdmVyYWdlIG92ZXJhbGwgcmVkcmF3IHRpbWVcblxudmFyIGRlcU5vRHJhd0Nvc3QkMSA9IDAuOTsgLy8gJSBvZiBhdmcgZnJhbWUgdGltZSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkZXF1ZXVlaW5nIHdoZW4gbm90IGRyYXdpbmdcblxudmFyIGRlcUZhc3RDb3N0JDEgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG5cbnZhciBtYXhEZXFTaXplJDEgPSAxOyAvLyBudW1iZXIgb2YgZWxlcyB0byBkZXF1ZXVlIGFuZCByZW5kZXIgYXQgaGlnaGVyIHRleHR1cmUgaW4gZWFjaCBiYXRjaFxuXG52YXIgaW52YWxpZFRocmVzaG9sZCA9IDI1MDsgLy8gdGltZSB0aHJlc2hvbGQgZm9yIGRpc2FibGluZyBiL2Mgb2YgaW52YWxpZGF0aW9uc1xuXG52YXIgbWF4TGF5ZXJBcmVhID0gNDAwMCAqIDQwMDA7IC8vIGxheWVycyBjYW4ndCBiZSBiaWdnZXIgdGhhbiB0aGlzXG5cbnZhciB1c2VIaWdoUXVhbGl0eUVsZVR4clJlcXMgPSB0cnVlOyAvLyB3aGV0aGVyIHRvIHVzZSBoaWdoIHF1YWxpdHkgZWxlIHR4ciByZXF1ZXN0cyAoZ2VuZXJhbGx5IGZhc3RlciBhbmQgY2hlYXBlciBpbiB0aGUgbG9uZ3Rlcm0pXG4vLyB2YXIgbG9nID0gZnVuY3Rpb24oKXsgY29uc29sZS5sb2cuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApOyB9O1xuXG52YXIgTGF5ZXJlZFRleHR1cmVDYWNoZSA9IGZ1bmN0aW9uIExheWVyZWRUZXh0dXJlQ2FjaGUocmVuZGVyZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHNlbGYucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgdmFyIGN5ID0gci5jeTtcbiAgc2VsZi5sYXllcnNCeUxldmVsID0ge307IC8vIGUuZy4gMiA9PiBbIGxheWVyMSwgbGF5ZXIyLCAuLi4sIGxheWVyTiBdXG5cbiAgc2VsZi5maXJzdEdldCA9IHRydWU7XG4gIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gMiAqIGludmFsaWRUaHJlc2hvbGQ7XG4gIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcbiAgc2VsZi5lbGVUeHJEZXFzID0gY3kuY29sbGVjdGlvbigpO1xuICBzZWxmLnNjaGVkdWxlRWxlbWVudFJlZmluZW1lbnQgPSB1dGlsKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLnJlZmluZUVsZW1lbnRUZXh0dXJlcyhzZWxmLmVsZVR4ckRlcXMpO1xuICAgIHNlbGYuZWxlVHhyRGVxcy51bm1lcmdlKHNlbGYuZWxlVHhyRGVxcyk7XG4gIH0sIHJlZmluZUVsZURlYm91bmNlVGltZSk7XG4gIHIuYmVmb3JlUmVuZGVyKGZ1bmN0aW9uICh3aWxsRHJhdywgbm93KSB7XG4gICAgaWYgKG5vdyAtIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPD0gaW52YWxpZFRocmVzaG9sZCkge1xuICAgICAgc2VsZi5za2lwcGluZyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH0sIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5seXJUeHJTa2lwKTtcblxuICB2YXIgcVNvcnQgPSBmdW5jdGlvbiBxU29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGIucmVxcyAtIGEucmVxcztcbiAgfTtcblxuICBzZWxmLmxheWVyc1F1ZXVlID0gbmV3IEhlYXAocVNvcnQpO1xuICBzZWxmLnNldHVwRGVxdWV1ZWluZygpO1xufTtcblxudmFyIExUQ3AgPSBMYXllcmVkVGV4dHVyZUNhY2hlLnByb3RvdHlwZTtcbnZhciBsYXllcklkUG9vbCA9IDA7XG52YXIgTUFYX0lOVCQxID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuTFRDcC5tYWtlTGF5ZXIgPSBmdW5jdGlvbiAoYmIsIGx2bCkge1xuICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB2YXIgdyA9IE1hdGguY2VpbChiYi53ICogc2NhbGUpO1xuICB2YXIgaCA9IE1hdGguY2VpbChiYi5oICogc2NhbGUpO1xuICB2YXIgY2FudmFzID0gdGhpcy5yZW5kZXJlci5tYWtlT2Zmc2NyZWVuQ2FudmFzKHcsIGgpO1xuICB2YXIgbGF5ZXIgPSB7XG4gICAgaWQ6IGxheWVySWRQb29sID0gKytsYXllcklkUG9vbCAlIE1BWF9JTlQkMSxcbiAgICBiYjogYmIsXG4gICAgbGV2ZWw6IGx2bCxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgZWxlczogW10sXG4gICAgZWxlc1F1ZXVlOiBbXSxcbiAgICByZXFzOiAwXG4gIH07IC8vIGxvZygnbWFrZSBsYXllciAlcyB3aXRoIHcgJXMgYW5kIGggJXMgYW5kIGx2bCAlcycsIGxheWVyLmlkLCBsYXllci53aWR0aCwgbGF5ZXIuaGVpZ2h0LCBsYXllci5sZXZlbCk7XG5cbiAgdmFyIGN4dCA9IGxheWVyLmNvbnRleHQ7XG4gIHZhciBkeCA9IC1sYXllci5iYi54MTtcbiAgdmFyIGR5ID0gLWxheWVyLmJiLnkxOyAvLyBkbyB0aGUgdHJhbnNmb3JtIG9uIGNyZWF0aW9uIHRvIHNhdmUgY3ljbGVzIChpdCdzIHRoZSBzYW1lIGZvciBhbGwgZWxlcylcblxuICBjeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgY3h0LnRyYW5zbGF0ZShkeCwgZHkpO1xuICByZXR1cm4gbGF5ZXI7XG59O1xuXG5MVENwLmdldExheWVycyA9IGZ1bmN0aW9uIChlbGVzLCBweFJhdGlvLCBsdmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgciA9IHNlbGYucmVuZGVyZXI7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgZmlyc3RHZXQgPSBzZWxmLmZpcnN0R2V0O1xuICBzZWxmLmZpcnN0R2V0ID0gZmFsc2U7IC8vIGxvZygnLS1cXG5nZXQgbGF5ZXJzIHdpdGggJXMgZWxlcycsIGVsZXMubGVuZ3RoKTtcbiAgLy9sb2cgZWxlcy5tYXAoZnVuY3Rpb24oZWxlKXsgcmV0dXJuIGVsZS5pZCgpIH0pICk7XG5cbiAgaWYgKGx2bCA9PSBudWxsKSB7XG4gICAgbHZsID0gTWF0aC5jZWlsKGxvZzIoem9vbSAqIHB4UmF0aW8pKTtcblxuICAgIGlmIChsdmwgPCBtaW5MdmwkMSkge1xuICAgICAgbHZsID0gbWluTHZsJDE7XG4gICAgfSBlbHNlIGlmICh6b29tID49IG1heFpvb20kMSB8fCBsdmwgPiBtYXhMdmwkMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgc2VsZi52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyhsdmwsIGVsZXMpO1xuICB2YXIgbGF5ZXJzQnlMdmwgPSBzZWxmLmxheWVyc0J5TGV2ZWw7XG4gIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gIHZhciBsYXllcnMgPSBsYXllcnNCeUx2bFtsdmxdID0gbGF5ZXJzQnlMdmxbbHZsXSB8fCBbXTtcbiAgdmFyIGJiO1xuICB2YXIgbHZsQ29tcGxldGUgPSBzZWxmLmxldmVsSXNDb21wbGV0ZShsdmwsIGVsZXMpO1xuICB2YXIgdG1wTGF5ZXJzO1xuXG4gIHZhciBjaGVja1RlbXBMZXZlbHMgPSBmdW5jdGlvbiBjaGVja1RlbXBMZXZlbHMoKSB7XG4gICAgdmFyIGNhblVzZUFzVG1wTHZsID0gZnVuY3Rpb24gY2FuVXNlQXNUbXBMdmwobCkge1xuICAgICAgc2VsZi52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyhsLCBlbGVzKTtcblxuICAgICAgaWYgKHNlbGYubGV2ZWxJc0NvbXBsZXRlKGwsIGVsZXMpKSB7XG4gICAgICAgIHRtcExheWVycyA9IGxheWVyc0J5THZsW2xdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNoZWNrTHZscyA9IGZ1bmN0aW9uIGNoZWNrTHZscyhkaXIpIHtcbiAgICAgIGlmICh0bXBMYXllcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBsID0gbHZsICsgZGlyOyBtaW5MdmwkMSA8PSBsICYmIGwgPD0gbWF4THZsJDE7IGwgKz0gZGlyKSB7XG4gICAgICAgIGlmIChjYW5Vc2VBc1RtcEx2bChsKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNoZWNrTHZscygrMSk7XG4gICAgY2hlY2tMdmxzKC0xKTsgLy8gcmVtb3ZlIHRoZSBpbnZhbGlkIGxheWVyczsgdGhleSB3aWxsIGJlIHJlcGxhY2VkIGFzIG5lZWRlZCBsYXRlciBpbiB0aGlzIGZ1bmN0aW9uXG5cbiAgICBmb3IgKHZhciBpID0gbGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheShsYXllcnMsIGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYgKCFsdmxDb21wbGV0ZSkge1xuICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIGluY29tcGxldGUsIHRoZW4gdXNlIHRoZSBjbG9zZXN0LCBiZXN0IHF1YWxpdHkgbGF5ZXJzZXQgdGVtcG9yYXJpbHlcbiAgICAvLyBhbmQgbGF0ZXIgcXVldWUgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgc28gd2UgY2FuIGdldCB0aGUgcHJvcGVyIHF1YWxpdHkgbGV2ZWwgc29vblxuICAgIGNoZWNrVGVtcExldmVscygpO1xuICB9IGVsc2Uge1xuICAgIC8vIGxvZygnbGV2ZWwgY29tcGxldGUsIHVzaW5nIGV4aXN0aW5nIGxheWVyc1xcbi0tJyk7XG4gICAgcmV0dXJuIGxheWVycztcbiAgfVxuXG4gIHZhciBnZXRCYiA9IGZ1bmN0aW9uIGdldEJiKCkge1xuICAgIGlmICghYmIpIHtcbiAgICAgIGJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVCb3VuZGluZ0JveChiYiwgZWxlc1tpXS5ib3VuZGluZ0JveCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmI7XG4gIH07XG5cbiAgdmFyIG1ha2VMYXllciA9IGZ1bmN0aW9uIG1ha2VMYXllcihvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIGFmdGVyID0gb3B0cy5hZnRlcjtcbiAgICBnZXRCYigpO1xuICAgIHZhciBhcmVhID0gYmIudyAqIHNjYWxlICogKGJiLmggKiBzY2FsZSk7XG5cbiAgICBpZiAoYXJlYSA+IG1heExheWVyQXJlYSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxheWVyID0gc2VsZi5tYWtlTGF5ZXIoYmIsIGx2bCk7XG5cbiAgICBpZiAoYWZ0ZXIgIT0gbnVsbCkge1xuICAgICAgdmFyIGluZGV4ID0gbGF5ZXJzLmluZGV4T2YoYWZ0ZXIpICsgMTtcbiAgICAgIGxheWVycy5zcGxpY2UoaW5kZXgsIDAsIGxheWVyKTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuaW5zZXJ0ID09PSB1bmRlZmluZWQgfHwgb3B0cy5pbnNlcnQpIHtcbiAgICAgIC8vIG5vIGFmdGVyIHNwZWNpZmllZCA9PiBmaXJzdCBsYXllciBtYWRlIHNvIHB1dCBhdCBzdGFydFxuICAgICAgbGF5ZXJzLnVuc2hpZnQobGF5ZXIpO1xuICAgIH0gLy8gaWYoIHRtcExheWVycyApe1xuICAgIC8vc2VsZi5xdWV1ZUxheWVyKCBsYXllciApO1xuICAgIC8vIH1cblxuXG4gICAgcmV0dXJuIGxheWVyO1xuICB9O1xuXG4gIGlmIChzZWxmLnNraXBwaW5nICYmICFmaXJzdEdldCkge1xuICAgIC8vIGxvZygnc2tpcCBsYXllcnMnKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBsb2coJ2RvIGxheWVycycpO1xuXG5cbiAgdmFyIGxheWVyID0gbnVsbDtcbiAgdmFyIG1heEVsZXNQZXJMYXllciA9IGVsZXMubGVuZ3RoIC8gZGVmTnVtTGF5ZXJzO1xuICB2YXIgYWxsb3dMYXp5UXVldWVpbmcgPSAgIWZpcnN0R2V0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyB8fCB7fTsgLy8gbG9nKCdsb29rIGF0IGVsZScsIGVsZS5pZCgpKTtcblxuICAgIHZhciBleGlzdGluZ0xheWVyID0gY2FjaGVzW2x2bF07XG5cbiAgICBpZiAoZXhpc3RpbmdMYXllcikge1xuICAgICAgLy8gcmV1c2UgbGF5ZXIgZm9yIGxhdGVyIGVsZXNcbiAgICAgIC8vIGxvZygncmV1c2UgbGF5ZXIgZm9yJywgZWxlLmlkKCkpO1xuICAgICAgbGF5ZXIgPSBleGlzdGluZ0xheWVyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFsYXllciB8fCBsYXllci5lbGVzLmxlbmd0aCA+PSBtYXhFbGVzUGVyTGF5ZXIgfHwgIWJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChsYXllci5iYiwgZWxlLmJvdW5kaW5nQm94KCkpKSB7XG4gICAgICAvLyBsb2coJ21ha2UgbmV3IGxheWVyIGZvciBlbGUgJXMnLCBlbGUuaWQoKSk7XG4gICAgICBsYXllciA9IG1ha2VMYXllcih7XG4gICAgICAgIGluc2VydDogdHJ1ZSxcbiAgICAgICAgYWZ0ZXI6IGxheWVyXG4gICAgICB9KTsgLy8gaWYgbm93IGxheWVyIGNhbiBiZSBidWlsdCB0aGVuIHdlIGNhbid0IHVzZSBsYXllcnMgYXQgdGhpcyBsZXZlbFxuXG4gICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBsb2coJ25ldyBsYXllciB3aXRoIGlkICVzJywgbGF5ZXIuaWQpO1xuXG4gICAgfVxuXG4gICAgaWYgKHRtcExheWVycyB8fCBhbGxvd0xhenlRdWV1ZWluZykge1xuICAgICAgLy8gbG9nKCdxdWV1ZSBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5xdWV1ZUxheWVyKGxheWVyLCBlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2coJ2RyYXcgZWxlICVzIGluIGxheWVyICVzJywgZWxlLmlkKCksIGxheWVyLmlkKTtcbiAgICAgIHNlbGYuZHJhd0VsZUluTGF5ZXIobGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvKTtcbiAgICB9XG5cbiAgICBsYXllci5lbGVzLnB1c2goZWxlKTtcbiAgICBjYWNoZXNbbHZsXSA9IGxheWVyO1xuICB9IC8vIGxvZygnLS0nKTtcblxuXG4gIGlmICh0bXBMYXllcnMpIHtcbiAgICAvLyB0aGVuIHdlIG9ubHkgcXVldWVkIHRoZSBjdXJyZW50IGxheWVyc2V0IGFuZCBjYW4ndCBkcmF3IGl0IHlldFxuICAgIHJldHVybiB0bXBMYXllcnM7XG4gIH1cblxuICBpZiAoYWxsb3dMYXp5UXVldWVpbmcpIHtcbiAgICAvLyBsb2coJ2xhenkgcXVldWUgbGV2ZWwnLCBsdmwpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGxheWVycztcbn07IC8vIGEgbGF5ZXIgbWF5IHdhbnQgdG8gdXNlIGFuIGVsZSBjYWNoZSBvZiBhIGhpZ2hlciBsZXZlbCB0byBhdm9pZCBibHVycmluZXNzXG4vLyBzbyB0aGUgbGF5ZXIgbGV2ZWwgbWlnaHQgbm90IGVxdWFsIHRoZSBlbGUgbGV2ZWxcblxuXG5MVENwLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbCA9IGZ1bmN0aW9uIChsdmwsIHB4UmF0aW8pIHtcbiAgcmV0dXJuIGx2bDtcbn07XG5cbkxUQ3AuZHJhd0VsZUluTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICB2YXIgY29udGV4dCA9IGxheWVyLmNvbnRleHQ7XG4gIHZhciBiYiA9IGVsZS5ib3VuZGluZ0JveCgpO1xuXG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgIWVsZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsdmwgPSBzZWxmLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbChsdmwsIHB4UmF0aW8pO1xuXG4gIHtcbiAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBmYWxzZSk7XG4gIH1cblxuICB7XG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIG51bGwsIG51bGwsIGx2bCwgdXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzKTtcbiAgfVxuXG4gIHtcbiAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCB0cnVlKTtcbiAgfVxufTtcblxuTFRDcC5sZXZlbElzQ29tcGxldGUgPSBmdW5jdGlvbiAobHZsLCBlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxheWVycyA9IHNlbGYubGF5ZXJzQnlMZXZlbFtsdmxdO1xuXG4gIGlmICghbGF5ZXJzIHx8IGxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbnVtRWxlc0luTGF5ZXJzID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsYXllciA9IGxheWVyc1tpXTsgLy8gaWYgdGhlcmUgYXJlIGFueSBlbGVzIG5lZWRlZCB0byBiZSBkcmF3biB5ZXQsIHRoZSBsZXZlbCBpcyBub3QgY29tcGxldGVcblxuICAgIGlmIChsYXllci5yZXFzID4gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaWYgdGhlIGxheWVyIGlzIGludmFsaWQsIHRoZSBsZXZlbCBpcyBub3QgY29tcGxldGVcblxuXG4gICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBudW1FbGVzSW5MYXllcnMgKz0gbGF5ZXIuZWxlcy5sZW5ndGg7XG4gIH0gLy8gd2Ugc2hvdWxkIGhhdmUgZXhhY3RseSB0aGUgbnVtYmVyIG9mIGVsZXMgcGFzc2VkIGluIHRvIGJlIGNvbXBsZXRlXG5cblxuICBpZiAobnVtRWxlc0luTGF5ZXJzICE9PSBlbGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuTFRDcC52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyA9IGZ1bmN0aW9uIChsdmwsIGVsZXMpIHtcbiAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzQnlMZXZlbFtsdmxdO1xuXG4gIGlmICghbGF5ZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGlmIGluIGEgbGF5ZXIgdGhlIGVsZXMgYXJlIG5vdCBpbiB0aGUgc2FtZSBvcmRlciwgdGhlbiB0aGUgbGF5ZXIgaXMgaW52YWxpZFxuICAvLyAoaS5lLiB0aGVyZSBpcyBhbiBlbGUgaW4gYmV0d2VlbiB0aGUgZWxlcyBpbiB0aGUgbGF5ZXIpXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICB2YXIgb2Zmc2V0ID0gLTE7IC8vIGZpbmQgdGhlIG9mZnNldFxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAobGF5ZXIuZWxlc1swXSA9PT0gZWxlc1tqXSkge1xuICAgICAgICBvZmZzZXQgPSBqO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgLy8gdGhlbiB0aGUgbGF5ZXIgaGFzIG5vbmV4aXN0YW50IGVsZW1lbnRzIGFuZCBpcyBpbnZhbGlkXG4gICAgICB0aGlzLmludmFsaWRhdGVMYXllcihsYXllcik7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIHRoZSBlbGVzIGluIHRoZSBsYXllciBtdXN0IGJlIGluIHRoZSBzYW1lIGNvbnRpbnVvdXMgb3JkZXIsIGVsc2UgdGhlIGxheWVyIGlzIGludmFsaWRcblxuXG4gICAgdmFyIG8gPSBvZmZzZXQ7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxheWVyLmVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsYXllci5lbGVzW2pdICE9PSBlbGVzW28gKyBqXSkge1xuICAgICAgICAvLyBsb2coJ2ludmFsaWRhdGUgYmFzZWQgb24gb3JkZXJpbmcnLCBsYXllci5pZCk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5MVENwLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMgPSBmdW5jdGlvbiAoZWxlcywgdXBkYXRlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGlzRWxlcyA9IGVsZW1lbnQoZWxlc1swXSk7IC8vIGNvbGxlY3QgdWRwYXRlZCBlbGVtZW50cyAoY2FzY2FkZWQgZnJvbSB0aGUgbGF5ZXJzKSBhbmQgdXBkYXRlIGVhY2hcbiAgLy8gbGF5ZXIgaXRzZWxmIGFsb25nIHRoZSB3YXlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVxID0gaXNFbGVzID8gbnVsbCA6IGVsZXNbaV07XG4gICAgdmFyIGVsZSA9IGlzRWxlcyA/IGVsZXNbaV0gOiBlbGVzW2ldLmVsZTtcbiAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgfHwge307XG5cbiAgICBmb3IgKHZhciBsID0gbWluTHZsJDE7IGwgPD0gbWF4THZsJDE7IGwrKykge1xuICAgICAgdmFyIGxheWVyID0gY2FjaGVzW2xdO1xuXG4gICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBpZiB1cGRhdGUgaXMgYSByZXF1ZXN0IGZyb20gdGhlIGVsZSBjYWNoZSwgdGhlbiBpdCBhZmZlY3RzIG9ubHlcbiAgICAgIC8vIHRoZSBtYXRjaGluZyBsZXZlbFxuXG5cbiAgICAgIGlmIChyZXEgJiYgc2VsZi5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwobGF5ZXIubGV2ZWwpICE9PSByZXEubGV2ZWwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShsYXllciwgZWxlLCByZXEpO1xuICAgIH1cbiAgfVxufTtcblxuTFRDcC5oYXZlTGF5ZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBoYXZlTGF5ZXJzID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgbCA9IG1pbkx2bCQxOyBsIDw9IG1heEx2bCQxOyBsKyspIHtcbiAgICB2YXIgbGF5ZXJzID0gc2VsZi5sYXllcnNCeUxldmVsW2xdO1xuXG4gICAgaWYgKGxheWVycyAmJiBsYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgaGF2ZUxheWVycyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGF2ZUxheWVycztcbn07XG5cbkxUQ3AuaW52YWxpZGF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmIChlbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpOyAvLyBsb2coJ3VwZGF0ZSBpbnZhbGlkYXRlIGxheWVyIHRpbWUgZnJvbSBlbGVzJyk7XG5cbiAgaWYgKGVsZXMubGVuZ3RoID09PSAwIHx8ICFzZWxmLmhhdmVMYXllcnMoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlbGYudXBkYXRlRWxlbWVudHNJbkxheWVycyhlbGVzLCBmdW5jdGlvbiBpbnZhbEFzc29jTGF5ZXJzKGxheWVyLCBlbGUsIHJlcSkge1xuICAgIHNlbGYuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgfSk7XG59O1xuXG5MVENwLmludmFsaWRhdGVMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAvLyBsb2coJ3VwZGF0ZSBpbnZhbGlkYXRlIGxheWVyIHRpbWUnKTtcbiAgdGhpcy5sYXN0SW52YWxpZGF0aW9uVGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG5cbiAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gc2F2ZSBjeWNsZXNcblxuXG4gIHZhciBsdmwgPSBsYXllci5sZXZlbDtcbiAgdmFyIGVsZXMgPSBsYXllci5lbGVzO1xuICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsW2x2bF07IC8vIGxvZygnaW52YWxpZGF0ZSBsYXllcicsIGxheWVyLmlkICk7XG5cbiAgcmVtb3ZlRnJvbUFycmF5KGxheWVycywgbGF5ZXIpOyAvLyBsYXllci5lbGVzID0gW107XG5cbiAgbGF5ZXIuZWxlc1F1ZXVlID0gW107XG4gIGxheWVyLmludmFsaWQgPSB0cnVlO1xuXG4gIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgIGxheWVyLnJlcGxhY2VtZW50LmludmFsaWQgPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNhY2hlcyA9IGVsZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW1nTGF5ZXJDYWNoZXM7XG5cbiAgICBpZiAoY2FjaGVzKSB7XG4gICAgICBjYWNoZXNbbHZsXSA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG5MVENwLnJlZmluZUVsZW1lbnRUZXh0dXJlcyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpczsgLy8gbG9nKCdyZWZpbmUnLCBlbGVzLmxlbmd0aCk7XG5cbiAgc2VsZi51cGRhdGVFbGVtZW50c0luTGF5ZXJzKGVsZXMsIGZ1bmN0aW9uIHJlZmluZUVhY2hFbGUobGF5ZXIsIGVsZSwgcmVxKSB7XG4gICAgdmFyIHJMeXIgPSBsYXllci5yZXBsYWNlbWVudDtcblxuICAgIGlmICghckx5cikge1xuICAgICAgckx5ciA9IGxheWVyLnJlcGxhY2VtZW50ID0gc2VsZi5tYWtlTGF5ZXIobGF5ZXIuYmIsIGxheWVyLmxldmVsKTtcbiAgICAgIHJMeXIucmVwbGFjZXMgPSBsYXllcjtcbiAgICAgIHJMeXIuZWxlcyA9IGxheWVyLmVsZXM7IC8vIGxvZygnbWFrZSByZXBsYWNlbWVudCBsYXllciAlcyBmb3IgJXMgd2l0aCBsZXZlbCAlcycsIHJMeXIuaWQsIGxheWVyLmlkLCByTHlyLmxldmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXJMeXIucmVxcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByTHlyLmVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5xdWV1ZUxheWVyKHJMeXIsIHJMeXIuZWxlc1tpXSk7XG4gICAgICB9IC8vIGxvZygncXVldWUgcmVwbGFjZW1lbnQgbGF5ZXIgcmVmaW5lbWVudCcsIHJMeXIuaWQpO1xuXG4gICAgfVxuICB9KTtcbn07XG5cbkxUQ3AuZW5xdWV1ZUVsZW1lbnRSZWZpbmVtZW50ID0gZnVuY3Rpb24gKGVsZSkge1xuXG4gIHRoaXMuZWxlVHhyRGVxcy5tZXJnZShlbGUpO1xuICB0aGlzLnNjaGVkdWxlRWxlbWVudFJlZmluZW1lbnQoKTtcbn07XG5cbkxUQ3AucXVldWVMYXllciA9IGZ1bmN0aW9uIChsYXllciwgZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmxheWVyc1F1ZXVlO1xuICB2YXIgZWxlc1EgPSBsYXllci5lbGVzUXVldWU7XG4gIHZhciBoYXNJZCA9IGVsZXNRLmhhc0lkID0gZWxlc1EuaGFzSWQgfHwge307IC8vIGlmIGEgbGF5ZXIgaXMgZ29pbmcgdG8gYmUgcmVwbGFjZWQsIHF1ZXVpbmcgaXMgYSB3YXN0ZSBvZiB0aW1lXG5cbiAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVsZSkge1xuICAgIGlmIChoYXNJZFtlbGUuaWQoKV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVzUS5wdXNoKGVsZSk7XG4gICAgaGFzSWRbZWxlLmlkKCldID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChsYXllci5yZXFzKSB7XG4gICAgbGF5ZXIucmVxcysrO1xuICAgIHEudXBkYXRlSXRlbShsYXllcik7XG4gIH0gZWxzZSB7XG4gICAgbGF5ZXIucmVxcyA9IDE7XG4gICAgcS5wdXNoKGxheWVyKTtcbiAgfVxufTtcblxuTFRDcC5kZXF1ZXVlID0gZnVuY3Rpb24gKHB4UmF0aW8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYubGF5ZXJzUXVldWU7XG4gIHZhciBkZXFkID0gW107XG4gIHZhciBlbGVEZXFzID0gMDtcblxuICB3aGlsZSAoZWxlRGVxcyA8IG1heERlcVNpemUkMSkge1xuICAgIGlmIChxLnNpemUoKSA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGxheWVyID0gcS5wZWVrKCk7IC8vIGlmIGEgbGF5ZXIgaGFzIGJlZW4gb3Igd2lsbCBiZSByZXBsYWNlZCwgdGhlbiBkb24ndCB3YXN0ZSB0aW1lIHdpdGggaXRcblxuICAgIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgICAgLy8gbG9nKCdsYXllciAlcyBpbiBxdWV1ZSBza2lwcGVkIGIvYyBpdCBhbHJlYWR5IGhhcyBhIHJlcGxhY2VtZW50JywgbGF5ZXIuaWQpO1xuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gaWYgdGhpcyBpcyBhIHJlcGxhY2VtZW50IGxheWVyIHRoYXQgaGFzIGJlZW4gc3VwZXJjZWRlZCwgdGhlbiBmb3JnZXQgaXRcblxuXG4gICAgaWYgKGxheWVyLnJlcGxhY2VzICYmIGxheWVyICE9PSBsYXllci5yZXBsYWNlcy5yZXBsYWNlbWVudCkge1xuICAgICAgLy8gbG9nKCdsYXllciBpcyBubyBsb25nZXIgdGhlIG1vc3QgdXB0b2RhdGUgcmVwbGFjZW1lbnQ7IGRlcXVldWVkJywgbGF5ZXIuaWQpXG4gICAgICBxLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgIC8vIGxvZygncmVwbGFjZW1lbnQgbGF5ZXIgJXMgaXMgaW52YWxpZDsgZGVxdWV1ZWQnLCBsYXllci5pZCk7XG4gICAgICBxLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGVsZSA9IGxheWVyLmVsZXNRdWV1ZS5zaGlmdCgpO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgLy8gbG9nKCdkZXF1ZXVlIGxheWVyICVzJywgbGF5ZXIuaWQpO1xuICAgICAgc2VsZi5kcmF3RWxlSW5MYXllcihsYXllciwgZWxlLCBsYXllci5sZXZlbCwgcHhSYXRpbyk7XG4gICAgICBlbGVEZXFzKys7XG4gICAgfVxuXG4gICAgaWYgKGRlcWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyB3ZSBuZWVkIG9ubHkgb25lIGVudHJ5IGluIGRlcWQgdG8gcXVldWUgcmVkcmF3aW5nIGV0Y1xuICAgICAgZGVxZC5wdXNoKHRydWUpO1xuICAgIH0gLy8gaWYgdGhlIGxheWVyIGhhcyBhbGwgaXRzIGVsZXMgZG9uZSwgdGhlbiByZW1vdmUgZnJvbSB0aGUgcXVldWVcblxuXG4gICAgaWYgKGxheWVyLmVsZXNRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHEucG9wKCk7XG4gICAgICBsYXllci5yZXFzID0gMDsgLy8gbG9nKCdkZXF1ZXVlIG9mIGxheWVyICVzIGNvbXBsZXRlJywgbGF5ZXIuaWQpO1xuICAgICAgLy8gd2hlbiBhIHJlcGxhY2VtZW50IGxheWVyIGlzIGRlcXVldWVkLCBpdCByZXBsYWNlcyB0aGUgb2xkIGxheWVyIGluIHRoZSBsZXZlbFxuXG4gICAgICBpZiAobGF5ZXIucmVwbGFjZXMpIHtcbiAgICAgICAgc2VsZi5hcHBseUxheWVyUmVwbGFjZW1lbnQobGF5ZXIpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnJlcXVlc3RSZWRyYXcoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVxZDtcbn07XG5cbkxUQ3AuYXBwbHlMYXllclJlcGxhY2VtZW50ID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGxheWVyc0luTGV2ZWwgPSBzZWxmLmxheWVyc0J5TGV2ZWxbbGF5ZXIubGV2ZWxdO1xuICB2YXIgcmVwbGFjZWQgPSBsYXllci5yZXBsYWNlcztcbiAgdmFyIGluZGV4ID0gbGF5ZXJzSW5MZXZlbC5pbmRleE9mKHJlcGxhY2VkKTsgLy8gaWYgdGhlIHJlcGxhY2VkIGxheWVyIGlzIG5vdCBpbiB0aGUgYWN0aXZlIGxpc3QgZm9yIHRoZSBsZXZlbCwgdGhlbiByZXBsYWNpbmdcbiAgLy8gcmVmcyB3b3VsZCBiZSBhIG1pc3Rha2UgKGkuZS4gb3ZlcndyaXRpbmcgdGhlIHRydWUgYWN0aXZlIGxheWVyKVxuXG4gIGlmIChpbmRleCA8IDAgfHwgcmVwbGFjZWQuaW52YWxpZCkge1xuICAgIC8vIGxvZygncmVwbGFjZW1lbnQgbGF5ZXIgd291bGQgaGF2ZSBubyBlZmZlY3QnLCBsYXllci5pZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGF5ZXJzSW5MZXZlbFtpbmRleF0gPSBsYXllcjsgLy8gcmVwbGFjZSBsZXZlbCByZWZcbiAgLy8gcmVwbGFjZSByZWZzIGluIGVsZXNcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVyLmVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX3AgPSBsYXllci5lbGVzW2ldLl9wcml2YXRlO1xuICAgIHZhciBjYWNoZSA9IF9wLmltZ0xheWVyQ2FjaGVzID0gX3AuaW1nTGF5ZXJDYWNoZXMgfHwge307XG5cbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIGNhY2hlW2xheWVyLmxldmVsXSA9IGxheWVyO1xuICAgIH1cbiAgfSAvLyBsb2coJ2FwcGx5IHJlcGxhY2VtZW50IGxheWVyICVzIG92ZXIgJXMnLCBsYXllci5pZCwgcmVwbGFjZWQuaWQpO1xuXG5cbiAgc2VsZi5yZXF1ZXN0UmVkcmF3KCk7XG59O1xuXG5MVENwLnJlcXVlc3RSZWRyYXcgPSB1dGlsKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gIHIucmVkcmF3KCk7XG59LCAxMDApO1xuTFRDcC5zZXR1cERlcXVldWVpbmcgPSBkZWZzLnNldHVwRGVxdWV1ZWluZyh7XG4gIGRlcVJlZHJhd1RocmVzaG9sZDogZGVxUmVkcmF3VGhyZXNob2xkJDEsXG4gIGRlcUNvc3Q6IGRlcUNvc3QkMSxcbiAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCQxLFxuICBkZXFOb0RyYXdDb3N0OiBkZXFOb0RyYXdDb3N0JDEsXG4gIGRlcUZhc3RDb3N0OiBkZXFGYXN0Q29zdCQxLFxuICBkZXE6IGZ1bmN0aW9uIGRlcShzZWxmLCBweFJhdGlvKSB7XG4gICAgcmV0dXJuIHNlbGYuZGVxdWV1ZShweFJhdGlvKTtcbiAgfSxcbiAgb25EZXFkOiBub29wLFxuICBzaG91bGRSZWRyYXc6IHRydWVpZnksXG4gIHByaW9yaXR5OiBmdW5jdGlvbiBwcmlvcml0eShzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGYucmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5seXJUeHJEZXE7XG4gIH1cbn0pO1xuXG52YXIgQ1JwID0ge307XG52YXIgaW1wbDtcblxuZnVuY3Rpb24gcG9seWdvbihjb250ZXh0LCBwb2ludHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpYW5nbGVCYWNrY3VydmUoY29udGV4dCwgcG9pbnRzLCBjb250cm9sUG9pbnQpIHtcbiAgdmFyIGZpcnN0UHQ7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSBwb2ludHNbaV07XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgZmlyc3RQdCA9IHB0O1xuICAgIH1cblxuICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICB9XG5cbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xufVxuXG5mdW5jdGlvbiB0cmlhbmdsZVRlZShjb250ZXh0LCB0cmlhbmdsZVBvaW50cywgdGVlUG9pbnRzKSB7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICB2YXIgdHJpUHRzID0gdHJpYW5nbGVQb2ludHM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSB0cmlQdHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cblxuICB2YXIgdGVlUHRzID0gdGVlUG9pbnRzO1xuICB2YXIgZmlyc3RUZWVQdCA9IHRlZVBvaW50c1swXTtcbiAgY29udGV4dC5tb3ZlVG8oZmlyc3RUZWVQdC54LCBmaXJzdFRlZVB0LnkpO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGVlUHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ID0gdGVlUHRzW2ldO1xuICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICB9XG5cbiAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaXJjbGUoY29udGV4dCwgcngsIHJ5LCByKSB7XG4gIGNvbnRleHQuYXJjKHJ4LCByeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbn1cblxuQ1JwLmFycm93U2hhcGVJbXBsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIChpbXBsIHx8IChpbXBsID0ge1xuICAgICdwb2x5Z29uJzogcG9seWdvbixcbiAgICAndHJpYW5nbGUtYmFja2N1cnZlJzogdHJpYW5nbGVCYWNrY3VydmUsXG4gICAgJ3RyaWFuZ2xlLXRlZSc6IHRyaWFuZ2xlVGVlLFxuICAgICd0cmlhbmdsZS1jcm9zcyc6IHRyaWFuZ2xlVGVlLFxuICAgICdjaXJjbGUnOiBjaXJjbGVcbiAgfSkpW25hbWVdO1xufTtcblxudmFyIENScCQxID0ge307XG5cbkNScCQxLmRyYXdFbGVtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsLCBzaG93T3ZlcmxheSwgc2hvd09wYWNpdHkpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICByLmRyYXdOb2RlKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsLCBzaG93T3ZlcmxheSwgc2hvd09wYWNpdHkpO1xuICB9IGVsc2Uge1xuICAgIHIuZHJhd0VkZ2UoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwsIHNob3dPdmVybGF5LCBzaG93T3BhY2l0eSk7XG4gIH1cbn07XG5cbkNScCQxLmRyYXdFbGVtZW50T3ZlcmxheSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICByLmRyYXdOb2RlT3ZlcmxheShjb250ZXh0LCBlbGUpO1xuICB9IGVsc2Uge1xuICAgIHIuZHJhd0VkZ2VPdmVybGF5KGNvbnRleHQsIGVsZSk7XG4gIH1cbn07XG5cbkNScCQxLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbiA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIGVsZVR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0Um90YXRpb24sIGdldE9wYWNpdHkpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgYmIgPSBlbGVUeHJDYWNoZS5nZXRCb3VuZGluZ0JveChlbGUpO1xuXG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH0gLy8gaWdub3JlIHplcm8gc2l6ZSBjYXNlXG5cblxuICB2YXIgZWxlQ2FjaGUgPSBlbGVUeHJDYWNoZS5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIGx2bCwgcmVhc29uKTtcblxuICBpZiAoZWxlQ2FjaGUgIT0gbnVsbCkge1xuICAgIHZhciBvcGFjaXR5ID0gZ2V0T3BhY2l0eShyLCBlbGUpO1xuXG4gICAgaWYgKG9wYWNpdHkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGhldGEgPSBnZXRSb3RhdGlvbihyLCBlbGUpO1xuICAgIHZhciB4MSA9IGJiLngxLFxuICAgICAgICB5MSA9IGJiLnkxLFxuICAgICAgICB3ID0gYmIudyxcbiAgICAgICAgaCA9IGJiLmg7XG4gICAgdmFyIHgsIHksIHN4LCBzeSwgc21vb3RoO1xuXG4gICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICB2YXIgcm90UHQgPSBlbGVUeHJDYWNoZS5nZXRSb3RhdGlvblBvaW50KGVsZSk7XG4gICAgICBzeCA9IHJvdFB0Lng7XG4gICAgICBzeSA9IHJvdFB0Lnk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShzeCwgc3kpO1xuICAgICAgY29udGV4dC5yb3RhdGUodGhldGEpO1xuICAgICAgc21vb3RoID0gci5nZXRJbWdTbW9vdGhpbmcoY29udGV4dCk7XG5cbiAgICAgIGlmICghc21vb3RoKSB7XG4gICAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2ZmID0gZWxlVHhyQ2FjaGUuZ2V0Um90YXRpb25PZmZzZXQoZWxlKTtcbiAgICAgIHggPSBvZmYueDtcbiAgICAgIHkgPSBvZmYueTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHgxO1xuICAgICAgeSA9IHkxO1xuICAgIH1cblxuICAgIHZhciBvbGRHbG9iYWxBbHBoYTtcblxuICAgIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgICBvbGRHbG9iYWxBbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb2xkR2xvYmFsQWxwaGEgKiBvcGFjaXR5O1xuICAgIH1cblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGVsZUNhY2hlLnRleHR1cmUuY2FudmFzLCBlbGVDYWNoZS54LCAwLCBlbGVDYWNoZS53aWR0aCwgZWxlQ2FjaGUuaGVpZ2h0LCB4LCB5LCB3LCBoKTtcblxuICAgIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb2xkR2xvYmFsQWxwaGE7XG4gICAgfVxuXG4gICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICBjb250ZXh0LnJvdGF0ZSgtdGhldGEpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLXN4LCAtc3kpO1xuXG4gICAgICBpZiAoIXNtb290aCkge1xuICAgICAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVsZVR4ckNhY2hlLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSk7IC8vIGRpcmVjdCBkcmF3IGZhbGxiYWNrXG4gIH1cbn07XG5cbnZhciBnZXRaZXJvUm90YXRpb24gPSBmdW5jdGlvbiBnZXRaZXJvUm90YXRpb24oKSB7XG4gIHJldHVybiAwO1xufTtcblxudmFyIGdldExhYmVsUm90YXRpb24gPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uKHIsIGVsZSkge1xuICByZXR1cm4gci5nZXRUZXh0QW5nbGUoZWxlLCBudWxsKTtcbn07XG5cbnZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxSb3RhdGlvbihyLCBlbGUpIHtcbiAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgJ3NvdXJjZScpO1xufTtcblxudmFyIGdldFRhcmdldExhYmVsUm90YXRpb24gPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uKHIsIGVsZSkge1xuICByZXR1cm4gci5nZXRUZXh0QW5nbGUoZWxlLCAndGFyZ2V0Jyk7XG59O1xuXG52YXIgZ2V0T3BhY2l0eSA9IGZ1bmN0aW9uIGdldE9wYWNpdHkociwgZWxlKSB7XG4gIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xufTtcblxudmFyIGdldFRleHRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0VGV4dE9wYWNpdHkoZSwgZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS5wZlZhbHVlICogZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcbn07XG5cbkNScCQxLmRyYXdDYWNoZWRFbGVtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50LCBsdmwsIHJlcXVlc3RIaWdoUXVhbGl0eSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBfciRkYXRhID0gci5kYXRhLFxuICAgICAgZWxlVHhyQ2FjaGUgPSBfciRkYXRhLmVsZVR4ckNhY2hlLFxuICAgICAgbGJsVHhyQ2FjaGUgPSBfciRkYXRhLmxibFR4ckNhY2hlLFxuICAgICAgc2xiVHhyQ2FjaGUgPSBfciRkYXRhLnNsYlR4ckNhY2hlLFxuICAgICAgdGxiVHhyQ2FjaGUgPSBfciRkYXRhLnRsYlR4ckNhY2hlO1xuICB2YXIgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcbiAgdmFyIHJlYXNvbiA9IHJlcXVlc3RIaWdoUXVhbGl0eSA9PT0gdHJ1ZSA/IGVsZVR4ckNhY2hlLnJlYXNvbnMuaGlnaFF1YWxpdHkgOiBudWxsO1xuXG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgIWVsZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWV4dGVudCB8fCBib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJiLCBleHRlbnQpKSB7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcblxuICAgIHZhciBiYWRMaW5lID0gZWxlLmVsZW1lbnQoKS5fcHJpdmF0ZS5yc2NyYXRjaC5iYWRMaW5lO1xuXG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCBlbGVUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFplcm9Sb3RhdGlvbiwgZ2V0T3BhY2l0eSk7XG5cbiAgICBpZiAoIWlzRWRnZSB8fCAhYmFkTGluZSkge1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCBsYmxUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldExhYmVsUm90YXRpb24sIGdldFRleHRPcGFjaXR5KTtcbiAgICB9XG5cbiAgICBpZiAoaXNFZGdlICYmICFiYWRMaW5lKSB7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIHNsYlR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0U291cmNlTGFiZWxSb3RhdGlvbiwgZ2V0VGV4dE9wYWNpdHkpO1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCB0bGJUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFRhcmdldExhYmVsUm90YXRpb24sIGdldFRleHRPcGFjaXR5KTtcbiAgICB9XG5cbiAgICByLmRyYXdFbGVtZW50T3ZlcmxheShjb250ZXh0LCBlbGUpO1xuICB9XG59O1xuXG5DUnAkMS5kcmF3RWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcykge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgci5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUpO1xuICB9XG59O1xuXG5DUnAkMS5kcmF3Q2FjaGVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50KTtcbiAgfVxufTtcblxuQ1JwJDEuZHJhd0NhY2hlZE5vZGVzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCk7XG4gIH1cbn07XG5cbkNScCQxLmRyYXdMYXllcmVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGxheWVycyA9IHIuZGF0YS5seXJUeHJDYWNoZS5nZXRMYXllcnMoZWxlcywgcHhSYXRpbyk7XG5cbiAgaWYgKGxheWVycykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICB2YXIgYmIgPSBsYXllci5iYjtcblxuICAgICAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UobGF5ZXIuY2FudmFzLCBiYi54MSwgYmIueTEsIGJiLncsIGJiLmgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsIGJhY2sgb24gcGxhaW4gY2FjaGluZyBpZiBubyBsYXllcnNcbiAgICByLmRyYXdDYWNoZWRFbGVtZW50cyhjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpO1xuICB9XG59O1xuXG4vKiBnbG9iYWwgUGF0aDJEICovXG52YXIgQ1JwJDIgPSB7fTtcblxuQ1JwJDIuZHJhd0VkZ2UgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgc2hpZnRUb09yaWdpbldpdGhCYikge1xuICB2YXIgZHJhd0xhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICB2YXIgc2hvdWxkRHJhd092ZXJsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBzaG91bGREcmF3T3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gIGlmIChzaG91bGREcmF3T3BhY2l0eSAmJiAhZWRnZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gaWYgYmV6aWVyIGN0cmwgcHRzIGNhbiBub3QgYmUgY2FsY3VsYXRlZCwgdGhlbiBkaWVcblxuXG4gIGlmIChycy5iYWRMaW5lIHx8IHJzLmFsbHB0cyA9PSBudWxsIHx8IGlzTmFOKHJzLmFsbHB0c1swXSkpIHtcbiAgICAvLyBpc05hTiBpbiBjYXNlIGVkZ2UgaXMgaW1wb3NzaWJsZSBhbmQgYnJvd3NlciBidWdzIChlLmcuIHNhZmFyaSlcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYmI7XG5cbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBiYiA9IHNoaWZ0VG9PcmlnaW5XaXRoQmI7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLWJiLngxLCAtYmIueTEpO1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSBzaG91bGREcmF3T3BhY2l0eSA/IGVkZ2UucHN0eWxlKCdvcGFjaXR5JykudmFsdWUgOiAxO1xuICB2YXIgbGluZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2xpbmUtc3R5bGUnKS52YWx1ZTtcbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBsaW5lQ2FwID0gZWRnZS5wc3R5bGUoJ2xpbmUtY2FwJykudmFsdWU7XG5cbiAgdmFyIGRyYXdMaW5lID0gZnVuY3Rpb24gZHJhd0xpbmUoKSB7XG4gICAgdmFyIHN0cm9rZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG9wYWNpdHk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBlZGdlV2lkdGg7XG4gICAgY29udGV4dC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICByLmVsZVN0cm9rZVN0eWxlKGNvbnRleHQsIGVkZ2UsIHN0cm9rZU9wYWNpdHkpO1xuICAgIHIuZHJhd0VkZ2VQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cywgbGluZVN0eWxlKTtcbiAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7IC8vIHJlc2V0IGZvciBvdGhlciBkcmF3aW5nIGZ1bmN0aW9uc1xuICB9O1xuXG4gIHZhciBkcmF3T3ZlcmxheSA9IGZ1bmN0aW9uIGRyYXdPdmVybGF5KCkge1xuICAgIGlmICghc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByLmRyYXdFZGdlT3ZlcmxheShjb250ZXh0LCBlZGdlKTtcbiAgfTtcblxuICB2YXIgZHJhd0Fycm93cyA9IGZ1bmN0aW9uIGRyYXdBcnJvd3MoKSB7XG4gICAgdmFyIGFycm93T3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogb3BhY2l0eTtcbiAgICByLmRyYXdBcnJvd2hlYWRzKGNvbnRleHQsIGVkZ2UsIGFycm93T3BhY2l0eSk7XG4gIH07XG5cbiAgdmFyIGRyYXdUZXh0ID0gZnVuY3Rpb24gZHJhd1RleHQoKSB7XG4gICAgci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWRnZSwgbnVsbCwgZHJhd0xhYmVsKTtcbiAgfTtcblxuICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgdmFyIGdob3N0ID0gZWRnZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gIGlmIChnaG9zdCkge1xuICAgIHZhciBneCA9IGVkZ2UucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgdmFyIGd5ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICB2YXIgZ2hvc3RPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgZWZmZWN0aXZlR2hvc3RPcGFjaXR5ID0gb3BhY2l0eSAqIGdob3N0T3BhY2l0eTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIGRyYXdMaW5lKGVmZmVjdGl2ZUdob3N0T3BhY2l0eSk7XG4gICAgZHJhd0Fycm93cyhlZmZlY3RpdmVHaG9zdE9wYWNpdHkpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgfVxuXG4gIGRyYXdMaW5lKCk7XG4gIGRyYXdBcnJvd3MoKTtcbiAgZHJhd092ZXJsYXkoKTtcbiAgZHJhd1RleHQoKTtcblxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gIH1cbn07XG5cbkNScCQyLmRyYXdFZGdlT3ZlcmxheSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlKSB7XG4gIGlmICghZWRnZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3ZlcmxheU9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnb3ZlcmxheS1vcGFjaXR5JykudmFsdWU7XG5cbiAgaWYgKG92ZXJsYXlPcGFjaXR5ID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgdXNlUGF0aHMgPSByLnVzZVBhdGhzKCk7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBvdmVybGF5UGFkZGluZyA9IGVkZ2UucHN0eWxlKCdvdmVybGF5LXBhZGRpbmcnKS5wZlZhbHVlO1xuICB2YXIgb3ZlcmxheVdpZHRoID0gMiAqIG92ZXJsYXlQYWRkaW5nO1xuICB2YXIgb3ZlcmxheUNvbG9yID0gZWRnZS5wc3R5bGUoJ292ZXJsYXktY29sb3InKS52YWx1ZTtcbiAgY29udGV4dC5saW5lV2lkdGggPSBvdmVybGF5V2lkdGg7XG5cbiAgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VsZicgJiYgIXVzZVBhdGhzKSB7XG4gICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XG4gIH1cblxuICByLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgb3ZlcmxheUNvbG9yWzBdLCBvdmVybGF5Q29sb3JbMV0sIG92ZXJsYXlDb2xvclsyXSwgb3ZlcmxheU9wYWNpdHkpO1xuICByLmRyYXdFZGdlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMsICdzb2xpZCcpO1xufTtcblxuQ1JwJDIuZHJhd0VkZ2VQYXRoID0gZnVuY3Rpb24gKGVkZ2UsIGNvbnRleHQsIHB0cywgdHlwZSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgY2FudmFzQ3h0ID0gY29udGV4dDtcbiAgdmFyIHBhdGg7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuICB2YXIgbGluZURhc2hQYXR0ZXJuID0gZWRnZS5wc3R5bGUoJ2xpbmUtZGFzaC1wYXR0ZXJuJykucGZWYWx1ZTtcbiAgdmFyIGxpbmVEYXNoT2Zmc2V0ID0gZWRnZS5wc3R5bGUoJ2xpbmUtZGFzaC1vZmZzZXQnKS5wZlZhbHVlO1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBwdHMuam9pbignJCcpO1xuICAgIHZhciBrZXlNYXRjaGVzID0gcnMucGF0aENhY2hlS2V5ICYmIHJzLnBhdGhDYWNoZUtleSA9PT0gcGF0aENhY2hlS2V5O1xuXG4gICAgaWYgKGtleU1hdGNoZXMpIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gcnMucGF0aENhY2hlO1xuICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICBycy5wYXRoQ2FjaGVLZXkgPSBwYXRoQ2FjaGVLZXk7XG4gICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjYW52YXNDeHQuc2V0TGluZURhc2gpIHtcbiAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbMSwgMV0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKGxpbmVEYXNoUGF0dGVybik7XG4gICAgICAgIGNhbnZhc0N4dC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoIXBhdGhDYWNoZUhpdCAmJiAhcnMuYmFkTGluZSkge1xuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBjb250ZXh0Lm1vdmVUbyhwdHNbMF0sIHB0c1sxXSk7XG5cbiAgICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgICBjYXNlICdiZXppZXInOlxuICAgICAgY2FzZSAnc2VsZic6XG4gICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgIGZvciAodmFyIGkgPSAyOyBpICsgMyA8IHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmFpZ2h0JzpcbiAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSArIDEgPCBwdHMubGVuZ3RoOyBfaSArPSAyKSB7XG4gICAgICAgICAgY29udGV4dC5saW5lVG8ocHRzW19pXSwgcHRzW19pICsgMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29udGV4dCA9IGNhbnZhc0N4dDtcblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9IC8vIHJlc2V0IGFueSBsaW5lIGRhc2hlc1xuXG5cbiAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgfVxufTtcblxuQ1JwJDIuZHJhd0Fycm93aGVhZHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgb3BhY2l0eSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuXG4gIGlmICghaXNIYXlzdGFjaykge1xuICAgIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnc291cmNlJywgcnMuYXJyb3dTdGFydFgsIHJzLmFycm93U3RhcnRZLCBycy5zcmNBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgfVxuXG4gIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnbWlkLXRhcmdldCcsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHRndEFycm93QW5nbGUsIG9wYWNpdHkpO1xuICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ21pZC1zb3VyY2UnLCBycy5taWRYLCBycy5taWRZLCBycy5taWRzcmNBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcblxuICBpZiAoIWlzSGF5c3RhY2spIHtcbiAgICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ3RhcmdldCcsIHJzLmFycm93RW5kWCwgcnMuYXJyb3dFbmRZLCBycy50Z3RBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgfVxufTtcblxuQ1JwJDIuZHJhd0Fycm93aGVhZCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlLCBwcmVmaXgsIHgsIHksIGFuZ2xlLCBvcGFjaXR5KSB7XG4gIGlmIChpc05hTih4KSB8fCB4ID09IG51bGwgfHwgaXNOYU4oeSkgfHwgeSA9PSBudWxsIHx8IGlzTmFOKGFuZ2xlKSB8fCBhbmdsZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJyb3dTaGFwZSA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctc2hhcGUnKS52YWx1ZTtcblxuICBpZiAoYXJyb3dTaGFwZSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFycm93Q2xlYXJGaWxsID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1maWxsJykudmFsdWUgPT09ICdob2xsb3cnID8gJ2JvdGgnIDogJ2ZpbGxlZCc7XG4gIHZhciBhcnJvd0ZpbGwgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LWZpbGwnKS52YWx1ZTtcbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBlZGdlT3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG5cbiAgaWYgKG9wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wYWNpdHkgPSBlZGdlT3BhY2l0eTtcbiAgfVxuXG4gIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblxuICBpZiAob3BhY2l0eSAhPT0gMSB8fCBhcnJvd0ZpbGwgPT09ICdob2xsb3cnKSB7XG4gICAgLy8gdGhlbiBleHRyYSBjbGVhciBpcyBuZWVkZWRcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgIHNlbGYuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgc2VsZi5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDEpO1xuICAgIHNlbGYuZHJhd0Fycm93U2hhcGUoZWRnZSwgY29udGV4dCwgYXJyb3dDbGVhckZpbGwsIGVkZ2VXaWR0aCwgYXJyb3dTaGFwZSwgeCwgeSwgYW5nbGUpO1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICB9IC8vIG90aGVyd2lzZSwgdGhlIG9wYXF1ZSBhcnJvdyBjbGVhcnMgaXQgZm9yIGZyZWUgOilcblxuXG4gIHZhciBjb2xvciA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctY29sb3InKS52YWx1ZTtcbiAgc2VsZi5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgc2VsZi5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICBzZWxmLmRyYXdBcnJvd1NoYXBlKGVkZ2UsIGNvbnRleHQsIGFycm93RmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCB4LCB5LCBhbmdsZSk7XG59O1xuXG5DUnAkMi5kcmF3QXJyb3dTaGFwZSA9IGZ1bmN0aW9uIChlZGdlLCBjb250ZXh0LCBmaWxsLCBlZGdlV2lkdGgsIHNoYXBlLCB4LCB5LCBhbmdsZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKSAmJiBzaGFwZSAhPT0gJ3RyaWFuZ2xlLWNyb3NzJztcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICB2YXIgcGF0aDtcbiAgdmFyIGNhbnZhc0NvbnRleHQgPSBjb250ZXh0O1xuICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG4gIHZhciBzY2FsZSA9IGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICB2YXIgc2l6ZSA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlV2lkdGgsIHNjYWxlKTtcbiAgdmFyIHNoYXBlSW1wbCA9IHIuYXJyb3dTaGFwZXNbc2hhcGVdO1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIHZhciBjYWNoZSA9IHIuYXJyb3dQYXRoQ2FjaGUgPSByLmFycm93UGF0aENhY2hlIHx8IFtdO1xuICAgIHZhciBrZXkgPSBoYXNoU3RyaW5nKHNoYXBlKTtcbiAgICB2YXIgY2FjaGVkUGF0aCA9IGNhY2hlW2tleV07XG5cbiAgICBpZiAoY2FjaGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IGNhY2hlZFBhdGg7XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIGNhY2hlW2tleV0gPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICBpZiAoIXBhdGhDYWNoZUhpdCkge1xuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgLy8gc3RvcmUgaW4gdGhlIHBhdGggY2FjaGUgd2l0aCB2YWx1ZXMgZWFzaWx5IG1hbmlwdWxhdGVkIGxhdGVyXG4gICAgICBzaGFwZUltcGwuZHJhdyhjb250ZXh0LCAxLCAwLCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGFwZUltcGwuZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxuXG4gIGNvbnRleHQgPSBjYW52YXNDb250ZXh0O1xuXG4gIGlmICh1c2VQYXRocykge1xuICAgIC8vIHNldCB0cmFuc2Zvcm0gdG8gYXJyb3cgcG9zaXRpb24vb3JpZW50YXRpb25cbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LnJvdGF0ZShhbmdsZSk7XG4gICAgY29udGV4dC5zY2FsZShzaXplLCBzaXplKTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSAnZmlsbGVkJyB8fCBmaWxsID09PSAnYm90aCcpIHtcbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdob2xsb3cnIHx8IGZpbGwgPT09ICdib3RoJykge1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gKHNoYXBlSW1wbC5tYXRjaEVkZ2VXaWR0aCA/IGVkZ2VXaWR0aCA6IDEpIC8gKHVzZVBhdGhzID8gc2l6ZSA6IDEpO1xuICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInO1xuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICAvLyByZXNldCB0cmFuc2Zvcm0gYnkgYXBwbHlpbmcgaW52ZXJzZVxuICAgIGNvbnRleHQuc2NhbGUoMSAvIHNpemUsIDEgLyBzaXplKTtcbiAgICBjb250ZXh0LnJvdGF0ZSgtYW5nbGUpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gIH1cbn07XG5cbnZhciBDUnAkMyA9IHt9O1xuXG5DUnAkMy5zYWZlRHJhd0ltYWdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGgpIHtcbiAgLy8gZGV0ZWN0IHByb2JsZW1hdGljIGNhc2VzIGZvciBvbGQgYnJvd3NlcnMgd2l0aCBiYWQgaW1hZ2VzIChjaGVhcGVyIHRoYW4gdHJ5LWNhdGNoKVxuICBpZiAoaXcgPD0gMCB8fCBpaCA8PSAwIHx8IHcgPD0gMCB8fCBoIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIGl4LCBpeSwgaXcsIGloLCB4LCB5LCB3LCBoKTtcbn07XG5cbkNScCQzLmRyYXdJbnNjcmliZWRJbWFnZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBpbWcsIG5vZGUsIGluZGV4LCBub2RlT3BhY2l0eSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciBub2RlWCA9IHBvcy54O1xuICB2YXIgbm9kZVkgPSBwb3MueTtcbiAgdmFyIHN0eWxlT2JqID0gbm9kZS5jeSgpLnN0eWxlKCk7XG4gIHZhciBnZXRJbmRleGVkU3R5bGUgPSBzdHlsZU9iai5nZXRJbmRleGVkU3R5bGUuYmluZChzdHlsZU9iaik7XG4gIHZhciBmaXQgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtZml0JywgJ3ZhbHVlJywgaW5kZXgpO1xuICB2YXIgcmVwZWF0ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXJlcGVhdCcsICd2YWx1ZScsIGluZGV4KTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcGFkZGluZ1gyID0gbm9kZS5wYWRkaW5nKCkgKiAyO1xuICB2YXIgbm9kZVRXID0gbm9kZVcgKyAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJywgJ3ZhbHVlJywgaW5kZXgpID09PSAnaW5uZXInID8gMCA6IHBhZGRpbmdYMik7XG4gIHZhciBub2RlVEggPSBub2RlSCArIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJywgJ3ZhbHVlJywgaW5kZXgpID09PSAnaW5uZXInID8gMCA6IHBhZGRpbmdYMik7XG4gIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBjbGlwID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWNsaXAnLCAndmFsdWUnLCBpbmRleCk7XG4gIHZhciBzaG91bGRDbGlwID0gY2xpcCA9PT0gJ25vZGUnO1xuICB2YXIgaW1nT3BhY2l0eSA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JywgJ3ZhbHVlJywgaW5kZXgpICogbm9kZU9wYWNpdHk7XG4gIHZhciBpbWdXID0gaW1nLndpZHRoIHx8IGltZy5jYWNoZWRXO1xuICB2YXIgaW1nSCA9IGltZy5oZWlnaHQgfHwgaW1nLmNhY2hlZEg7IC8vIHdvcmthcm91bmQgZm9yIGJyb2tlbiBicm93c2VycyBsaWtlIGllXG5cbiAgaWYgKG51bGwgPT0gaW1nVyB8fCBudWxsID09IGltZ0gpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGltZ1cgPSBpbWcuY2FjaGVkVyA9IGltZy53aWR0aCB8fCBpbWcub2Zmc2V0V2lkdGg7XG4gICAgaW1nSCA9IGltZy5jYWNoZWRIID0gaW1nLmhlaWdodCB8fCBpbWcub2Zmc2V0SGVpZ2h0O1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB9XG5cbiAgdmFyIHcgPSBpbWdXO1xuICB2YXIgaCA9IGltZ0g7XG5cbiAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICd2YWx1ZScsIGluZGV4KSAhPT0gJ2F1dG8nKSB7XG4gICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICd1bml0cycsIGluZGV4KSA9PT0gJyUnKSB7XG4gICAgICB3ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3BmVmFsdWUnLCBpbmRleCkgKiBub2RlVFc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICd2YWx1ZScsIGluZGV4KSAhPT0gJ2F1dG8nKSB7XG4gICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAndW5pdHMnLCBpbmRleCkgPT09ICclJykge1xuICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAncGZWYWx1ZScsIGluZGV4KSAqIG5vZGVUSDtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBpZiAodyA9PT0gMCB8fCBoID09PSAwKSB7XG4gICAgcmV0dXJuOyAvLyBubyBwb2ludCBpbiBkcmF3aW5nIGVtcHR5IGltYWdlIChhbmQgY2hyb21lIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UpXG4gIH1cblxuICBpZiAoZml0ID09PSAnY29udGFpbicpIHtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihub2RlVFcgLyB3LCBub2RlVEggLyBoKTtcbiAgICB3ICo9IHNjYWxlO1xuICAgIGggKj0gc2NhbGU7XG4gIH0gZWxzZSBpZiAoZml0ID09PSAnY292ZXInKSB7XG4gICAgdmFyIHNjYWxlID0gTWF0aC5tYXgobm9kZVRXIC8gdywgbm9kZVRIIC8gaCk7XG4gICAgdyAqPSBzY2FsZTtcbiAgICBoICo9IHNjYWxlO1xuICB9XG5cbiAgdmFyIHggPSBub2RlWCAtIG5vZGVUVyAvIDI7IC8vIGxlZnRcblxuICB2YXIgcG9zWFVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAndW5pdHMnLCBpbmRleCk7XG4gIHZhciBwb3NYUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teCcsICdwZlZhbHVlJywgaW5kZXgpO1xuXG4gIGlmIChwb3NYVW5pdHMgPT09ICclJykge1xuICAgIHggKz0gKG5vZGVUVyAtIHcpICogcG9zWFBmVmFsO1xuICB9IGVsc2Uge1xuICAgIHggKz0gcG9zWFBmVmFsO1xuICB9XG5cbiAgdmFyIG9mZlhVbml0cyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteCcsICd1bml0cycsIGluZGV4KTtcbiAgdmFyIG9mZlhQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteCcsICdwZlZhbHVlJywgaW5kZXgpO1xuXG4gIGlmIChvZmZYVW5pdHMgPT09ICclJykge1xuICAgIHggKz0gKG5vZGVUVyAtIHcpICogb2ZmWFBmVmFsO1xuICB9IGVsc2Uge1xuICAgIHggKz0gb2ZmWFBmVmFsO1xuICB9XG5cbiAgdmFyIHkgPSBub2RlWSAtIG5vZGVUSCAvIDI7IC8vIHRvcFxuXG4gIHZhciBwb3NZVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teScsICd1bml0cycsIGluZGV4KTtcbiAgdmFyIHBvc1lQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ3BmVmFsdWUnLCBpbmRleCk7XG5cbiAgaWYgKHBvc1lVbml0cyA9PT0gJyUnKSB7XG4gICAgeSArPSAobm9kZVRIIC0gaCkgKiBwb3NZUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeSArPSBwb3NZUGZWYWw7XG4gIH1cblxuICB2YXIgb2ZmWVVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC15JywgJ3VuaXRzJywgaW5kZXgpO1xuICB2YXIgb2ZmWVBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC15JywgJ3BmVmFsdWUnLCBpbmRleCk7XG5cbiAgaWYgKG9mZllVbml0cyA9PT0gJyUnKSB7XG4gICAgeSArPSAobm9kZVRIIC0gaCkgKiBvZmZZUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeSArPSBvZmZZUGZWYWw7XG4gIH1cblxuICBpZiAocnMucGF0aENhY2hlKSB7XG4gICAgeCAtPSBub2RlWDtcbiAgICB5IC09IG5vZGVZO1xuICAgIG5vZGVYID0gMDtcbiAgICBub2RlWSA9IDA7XG4gIH1cblxuICB2YXIgZ0FscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGltZ09wYWNpdHk7XG5cbiAgaWYgKHJlcGVhdCA9PT0gJ25vLXJlcGVhdCcpIHtcbiAgICBpZiAoc2hvdWxkQ2xpcCkge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgIGlmIChycy5wYXRoQ2FjaGUpIHtcbiAgICAgICAgY29udGV4dC5jbGlwKHJzLnBhdGhDYWNoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgbm9kZVgsIG5vZGVZLCBub2RlVFcsIG5vZGVUSCk7XG4gICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHIuc2FmZURyYXdJbWFnZShjb250ZXh0LCBpbWcsIDAsIDAsIGltZ1csIGltZ0gsIHgsIHksIHcsIGgpO1xuXG4gICAgaWYgKHNob3VsZENsaXApIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihpbWcsIHJlcGVhdCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBub2RlWCwgbm9kZVksIG5vZGVUVywgbm9kZVRIKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG5cbiAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGdBbHBoYTtcbn07XG5cbnZhciBDUnAkNCA9IHt9O1xuXG5DUnAkNC5lbGVUZXh0QmlnZ2VyVGhhbk1pbiA9IGZ1bmN0aW9uIChlbGUsIHNjYWxlKSB7XG4gIGlmICghc2NhbGUpIHtcbiAgICB2YXIgem9vbSA9IGVsZS5jeSgpLnpvb20oKTtcbiAgICB2YXIgcHhSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHZhciBsdmwgPSBNYXRoLmNlaWwobG9nMih6b29tICogcHhSYXRpbykpOyAvLyB0aGUgZWZmZWN0aXZlIHRleHR1cmUgbGV2ZWxcblxuICAgIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgfVxuXG4gIHZhciBjb21wdXRlZFNpemUgPSBlbGUucHN0eWxlKCdmb250LXNpemUnKS5wZlZhbHVlICogc2NhbGU7XG4gIHZhciBtaW5TaXplID0gZWxlLnBzdHlsZSgnbWluLXpvb21lZC1mb250LXNpemUnKS5wZlZhbHVlO1xuXG4gIGlmIChjb21wdXRlZFNpemUgPCBtaW5TaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5DUnAkNC5kcmF3RWxlbWVudFRleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBmb3JjZSwgcHJlZml4KSB7XG4gIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuICB2YXIgciA9IHRoaXM7XG5cbiAgaWYgKGZvcmNlID09IG51bGwpIHtcbiAgICBpZiAodXNlRWxlT3BhY2l0eSAmJiAhci5lbGVUZXh0QmlnZ2VyVGhhbk1pbihlbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKGZvcmNlID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICB2YXIgbGFiZWwgPSBlbGUucHN0eWxlKCdsYWJlbCcpO1xuXG4gICAgaWYgKCFsYWJlbCB8fCAhbGFiZWwudmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIganVzdGlmaWNhdGlvbiA9IHIuZ2V0TGFiZWxKdXN0aWZpY2F0aW9uKGVsZSk7XG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSBqdXN0aWZpY2F0aW9uO1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJhZExpbmUgPSBlbGUuZWxlbWVudCgpLl9wcml2YXRlLnJzY3JhdGNoLmJhZExpbmU7XG5cbiAgICB2YXIgX2xhYmVsID0gZWxlLnBzdHlsZSgnbGFiZWwnKTtcblxuICAgIHZhciBzcmNMYWJlbCA9IGVsZS5wc3R5bGUoJ3NvdXJjZS1sYWJlbCcpO1xuICAgIHZhciB0Z3RMYWJlbCA9IGVsZS5wc3R5bGUoJ3RhcmdldC1sYWJlbCcpO1xuXG4gICAgaWYgKGJhZExpbmUgfHwgKCFfbGFiZWwgfHwgIV9sYWJlbC52YWx1ZSkgJiYgKCFzcmNMYWJlbCB8fCAhc3JjTGFiZWwudmFsdWUpICYmICghdGd0TGFiZWwgfHwgIXRndExhYmVsLnZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgfVxuXG4gIHZhciBhcHBseVJvdGF0aW9uID0gIXNoaWZ0VG9PcmlnaW5XaXRoQmI7XG4gIHZhciBiYjtcblxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH1cblxuICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgbnVsbCwgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG5cbiAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgJ3NvdXJjZScsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICAgICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsICd0YXJnZXQnLCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsIHByZWZpeCwgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG4gIH1cblxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gIH1cbn07XG5cbkNScCQ0LmdldEZvbnRDYWNoZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBjYWNoZTtcbiAgdGhpcy5mb250Q2FjaGVzID0gdGhpcy5mb250Q2FjaGVzIHx8IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mb250Q2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FjaGUgPSB0aGlzLmZvbnRDYWNoZXNbaV07XG5cbiAgICBpZiAoY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCkge1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlID0ge1xuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdGhpcy5mb250Q2FjaGVzLnB1c2goY2FjaGUpO1xuICByZXR1cm4gY2FjaGU7XG59OyAvLyBzZXQgdXAgY2FudmFzIGNvbnRleHQgd2l0aCBmb250XG4vLyByZXR1cm5zIHRyYW5zZm9ybWVkIHRleHQgc3RyaW5nXG5cblxuQ1JwJDQuc2V0dXBUZXh0U3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlKSB7XG4gIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAvLyBGb250IHN0eWxlXG4gIHZhciBsYWJlbFN0eWxlID0gZWxlLnBzdHlsZSgnZm9udC1zdHlsZScpLnN0clZhbHVlO1xuICB2YXIgbGFiZWxTaXplID0gZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZSArICdweCc7XG4gIHZhciBsYWJlbEZhbWlseSA9IGVsZS5wc3R5bGUoJ2ZvbnQtZmFtaWx5Jykuc3RyVmFsdWU7XG4gIHZhciBsYWJlbFdlaWdodCA9IGVsZS5wc3R5bGUoJ2ZvbnQtd2VpZ2h0Jykuc3RyVmFsdWU7XG4gIHZhciBvcGFjaXR5ID0gdXNlRWxlT3BhY2l0eSA/IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgKiBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS52YWx1ZSA6IDE7XG4gIHZhciBvdXRsaW5lT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS1vcGFjaXR5JykudmFsdWUgKiBvcGFjaXR5O1xuICB2YXIgY29sb3IgPSBlbGUucHN0eWxlKCdjb2xvcicpLnZhbHVlO1xuICB2YXIgb3V0bGluZUNvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLWNvbG9yJykudmFsdWU7XG4gIGNvbnRleHQuZm9udCA9IGxhYmVsU3R5bGUgKyAnICcgKyBsYWJlbFdlaWdodCArICcgJyArIGxhYmVsU2l6ZSArICcgJyArIGxhYmVsRmFtaWx5O1xuICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJzsgLy8gc28gdGV4dCBvdXRsaW5lcyBhcmVuJ3QgamFnZ2VkXG5cbiAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgdGhpcy5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIG91dGxpbmVDb2xvclswXSwgb3V0bGluZUNvbG9yWzFdLCBvdXRsaW5lQ29sb3JbMl0sIG91dGxpbmVPcGFjaXR5KTtcbn07IC8vIFRPRE8gZW5zdXJlIHJlLXVzZWRcblxuXG5mdW5jdGlvbiByb3VuZFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDU7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICBjdHgubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmZpbGwoKTtcbn1cblxuQ1JwJDQuZ2V0VGV4dEFuZ2xlID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gIHZhciB0aGV0YTtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnNjcmF0Y2ggPSBfcC5yc2NyYXRjaDtcbiAgdmFyIHBkYXNoID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gIHZhciByb3RhdGlvbiA9IGVsZS5wc3R5bGUocGRhc2ggKyAndGV4dC1yb3RhdGlvbicpO1xuICB2YXIgdGV4dEFuZ2xlID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpO1xuXG4gIGlmIChyb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgdGhldGEgPSBlbGUuaXNFZGdlKCkgPyB0ZXh0QW5nbGUgOiAwO1xuICB9IGVsc2UgaWYgKHJvdGF0aW9uLnN0clZhbHVlID09PSAnbm9uZScpIHtcbiAgICB0aGV0YSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdGhldGEgPSByb3RhdGlvbi5wZlZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHRoZXRhO1xufTtcblxuQ1JwJDQuZHJhd1RleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBwcmVmaXgpIHtcbiAgdmFyIGFwcGx5Um90YXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcGFyZW50T3BhY2l0eSA9IHVzZUVsZU9wYWNpdHkgPyBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpIDogMTtcblxuICBpZiAodXNlRWxlT3BhY2l0eSAmJiAocGFyZW50T3BhY2l0eSA9PT0gMCB8fCBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS52YWx1ZSA9PT0gMCkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gdXNlICdtYWluJyBhcyBhbiBhbGlhcyBmb3IgdGhlIG1haW4gbGFiZWwgKGkuZS4gbnVsbCBwcmVmaXgpXG5cblxuICBpZiAocHJlZml4ID09PSAnbWFpbicpIHtcbiAgICBwcmVmaXggPSBudWxsO1xuICB9XG5cbiAgdmFyIHRleHRYID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsWCcsIHByZWZpeCk7XG4gIHZhciB0ZXh0WSA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFknLCBwcmVmaXgpO1xuICB2YXIgb3JnVGV4dFgsIG9yZ1RleHRZOyAvLyB1c2VkIGZvciByb3RhdGlvblxuXG4gIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoZWxlLCBwcmVmaXgpO1xuXG4gIGlmICh0ZXh0ICE9IG51bGwgJiYgdGV4dCAhPT0gJycgJiYgIWlzTmFOKHRleHRYKSAmJiAhaXNOYU4odGV4dFkpKSB7XG4gICAgdGhpcy5zZXR1cFRleHRTdHlsZShjb250ZXh0LCBlbGUsIHVzZUVsZU9wYWNpdHkpO1xuICAgIHZhciBwZGFzaCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICAgIHZhciB0ZXh0VyA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFdpZHRoJywgcHJlZml4KTtcbiAgICB2YXIgdGV4dEggPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgpO1xuICAgIHZhciBtYXJnaW5YID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICB2YXIgbWFyZ2luWSA9IGVsZS5wc3R5bGUocGRhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgaGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcbiAgICB2YXIgdmFsaWduID0gZWxlLnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcblxuICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgIGhhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdmFsaWduID0gJ2NlbnRlcic7XG4gICAgfVxuXG4gICAgdGV4dFggKz0gbWFyZ2luWDtcbiAgICB0ZXh0WSArPSBtYXJnaW5ZO1xuICAgIHZhciB0aGV0YTtcblxuICAgIGlmICghYXBwbHlSb3RhdGlvbikge1xuICAgICAgdGhldGEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGV0YSA9IHRoaXMuZ2V0VGV4dEFuZ2xlKGVsZSwgcHJlZml4KTtcbiAgICB9XG5cbiAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgIG9yZ1RleHRYID0gdGV4dFg7XG4gICAgICBvcmdUZXh0WSA9IHRleHRZO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUob3JnVGV4dFgsIG9yZ1RleHRZKTtcbiAgICAgIGNvbnRleHQucm90YXRlKHRoZXRhKTtcbiAgICAgIHRleHRYID0gMDtcbiAgICAgIHRleHRZID0gMDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbGlnbikge1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIHRleHRZICs9IHRleHRIIC8gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHRleHRZICs9IHRleHRIO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgYmFja2dyb3VuZE9wYWNpdHkgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciBib3JkZXJPcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGJhY2tncm91bmRQYWRkaW5nID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnKS5wZlZhbHVlO1xuXG4gICAgaWYgKGJhY2tncm91bmRPcGFjaXR5ID4gMCB8fCB0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwKSB7XG4gICAgICB2YXIgYmdYID0gdGV4dFggLSBiYWNrZ3JvdW5kUGFkZGluZztcblxuICAgICAgc3dpdGNoIChoYWxpZ24pIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgYmdYIC09IHRleHRXO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgYmdYIC09IHRleHRXIC8gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBiZ1kgPSB0ZXh0WSAtIHRleHRIIC0gYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICB2YXIgYmdXID0gdGV4dFcgKyAyICogYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICB2YXIgYmdIID0gdGV4dEggKyAyICogYmFja2dyb3VuZFBhZGRpbmc7XG5cbiAgICAgIGlmIChiYWNrZ3JvdW5kT3BhY2l0eSA+IDApIHtcbiAgICAgICAgdmFyIHRleHRGaWxsID0gY29udGV4dC5maWxsU3R5bGU7XG4gICAgICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMF0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzFdICsgJywnICsgdGV4dEJhY2tncm91bmRDb2xvclsyXSArICcsJyArIGJhY2tncm91bmRPcGFjaXR5ICogcGFyZW50T3BhY2l0eSArICcpJztcbiAgICAgICAgdmFyIHN0eWxlU2hhcGUgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtc2hhcGUnKS5zdHJWYWx1ZTtcblxuICAgICAgICBpZiAoc3R5bGVTaGFwZS5pbmRleE9mKCdyb3VuZCcpID09PSAwKSB7XG4gICAgICAgICAgcm91bmRSZWN0KGNvbnRleHQsIGJnWCwgYmdZLCBiZ1csIGJnSCwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5maWxsUmVjdChiZ1gsIGJnWSwgYmdXLCBiZ0gpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0ZXh0RmlsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDApIHtcbiAgICAgICAgdmFyIHRleHRTdHJva2UgPSBjb250ZXh0LnN0cm9rZVN0eWxlO1xuICAgICAgICB2YXIgdGV4dExpbmVXaWR0aCA9IGNvbnRleHQubGluZVdpZHRoO1xuICAgICAgICB2YXIgdGV4dEJvcmRlckNvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItY29sb3InKS52YWx1ZTtcbiAgICAgICAgdmFyIHRleHRCb3JkZXJTdHlsZSA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXN0eWxlJykudmFsdWU7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgdGV4dEJvcmRlckNvbG9yWzBdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWzFdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWzJdICsgJywnICsgYm9yZGVyT3BhY2l0eSAqIHBhcmVudE9wYWNpdHkgKyAnKSc7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoO1xuXG4gICAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgc3dpdGNoICh0ZXh0Qm9yZGVyU3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzQsIDJdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoIC8gNDsgLy8gNTAlIHJlc2VydmVkIGZvciB3aGl0ZSBiZXR3ZWVuIHRoZSB0d28gYm9yZGVyc1xuXG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGJnWCwgYmdZLCBiZ1csIGJnSCk7XG5cbiAgICAgICAgaWYgKHRleHRCb3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScpIHtcbiAgICAgICAgICB2YXIgd2hpdGVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aCAvIDI7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGJnWCArIHdoaXRlV2lkdGgsIGJnWSArIHdoaXRlV2lkdGgsIGJnVyAtIHdoaXRlV2lkdGggKiAyLCBiZ0ggLSB3aGl0ZVdpZHRoICogMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0TGluZVdpZHRoO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGluZVdpZHRoID0gMiAqIGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS13aWR0aCcpLnBmVmFsdWU7IC8vICoyIGIvYyB0aGUgc3Ryb2tlIGlzIGRyYXduIGNlbnRyZWQgb24gdGhlIG1pZGRsZVxuXG4gICAgaWYgKGxpbmVXaWR0aCA+IDApIHtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIH1cblxuICAgIGlmIChlbGUucHN0eWxlKCd0ZXh0LXdyYXAnKS52YWx1ZSA9PT0gJ3dyYXAnKSB7XG4gICAgICB2YXIgbGluZXMgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCBwcmVmaXgpO1xuICAgICAgdmFyIGxpbmVIZWlnaHQgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxMaW5lSGVpZ2h0JywgcHJlZml4KTtcbiAgICAgIHZhciBoYWxmVGV4dFcgPSB0ZXh0VyAvIDI7XG4gICAgICB2YXIganVzdGlmaWNhdGlvbiA9IHRoaXMuZ2V0TGFiZWxKdXN0aWZpY2F0aW9uKGVsZSk7XG5cbiAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnYXV0bycpIDsgZWxzZSBpZiAoaGFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgLy8gYXV0byBqdXN0aWZpY2F0aW9uIDogcmlnaHRcbiAgICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRleHRYICs9IC10ZXh0VztcbiAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRYICs9IC1oYWxmVGV4dFc7XG4gICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cblxuICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIC8vIGF1dG8ganVzdGZpY2F0aW9uIDogY2VudGVyXG4gICAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0ZXh0WCArPSAtaGFsZlRleHRXO1xuICAgICAgICB9IGVsc2UgaWYgKGp1c3RpZmljYXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0ZXh0WCArPSBoYWxmVGV4dFc7XG4gICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cblxuICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgLy8gYXV0byBqdXN0aWZpY2F0aW9uIDogbGVmdFxuICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0WCArPSBoYWxmVGV4dFc7XG4gICAgICAgIH0gZWxzZSBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRleHRYICs9IHRleHRXO1xuICAgICAgICB9IC8vIGVsc2Ugc2FtZSBhcyBhdXRvXG5cbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh2YWxpZ24pIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICB0ZXh0WSAtPSAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdGV4dFkgLT0gKGxpbmVzLmxlbmd0aCAtIDEpICogbGluZUhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKykge1xuICAgICAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChsaW5lc1tsXSwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQobGluZXNbbF0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgIHRleHRZICs9IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIHRleHRYLCB0ZXh0WSk7XG4gICAgfVxuXG4gICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICBjb250ZXh0LnJvdGF0ZSgtdGhldGEpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLW9yZ1RleHRYLCAtb3JnVGV4dFkpO1xuICAgIH1cbiAgfVxufTtcblxuLyogZ2xvYmFsIFBhdGgyRCAqL1xudmFyIENScCQ1ID0ge307XG5cbkNScCQ1LmRyYXdOb2RlID0gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgdmFyIGRyYXdMYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHNob3VsZERyYXdPdmVybGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICB2YXIgc2hvdWxkRHJhd09wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIG5vZGVXaWR0aCwgbm9kZUhlaWdodDtcbiAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG5cbiAgaWYgKCFudW1iZXIocG9zLngpIHx8ICFudW1iZXIocG9zLnkpKSB7XG4gICAgcmV0dXJuOyAvLyBjYW4ndCBkcmF3IG5vZGUgd2l0aCB1bmRlZmluZWQgcG9zaXRpb25cbiAgfVxuXG4gIGlmIChzaG91bGREcmF3T3BhY2l0eSAmJiAhbm9kZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZWxlT3BhY2l0eSA9IHNob3VsZERyYXdPcGFjaXR5ID8gbm9kZS5lZmZlY3RpdmVPcGFjaXR5KCkgOiAxO1xuICB2YXIgdXNlUGF0aHMgPSByLnVzZVBhdGhzKCk7XG4gIHZhciBwYXRoO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gIHZhciBwYWRkaW5nID0gbm9kZS5wYWRkaW5nKCk7XG4gIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKSArIDIgKiBwYWRkaW5nO1xuICBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKSArIDIgKiBwYWRkaW5nOyAvL1xuICAvLyBzZXR1cCBzaGlmdFxuXG4gIHZhciBiYjtcblxuICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gIH0gLy9cbiAgLy8gbG9hZCBiZyBpbWFnZVxuXG5cbiAgdmFyIGJnSW1nUHJvcCA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWltYWdlJyk7XG4gIHZhciB1cmxzID0gYmdJbWdQcm9wLnZhbHVlO1xuICB2YXIgdXJsRGVmaW5lZCA9IG5ldyBBcnJheSh1cmxzLmxlbmd0aCk7XG4gIHZhciBpbWFnZSA9IG5ldyBBcnJheSh1cmxzLmxlbmd0aCk7XG4gIHZhciBudW1JbWFnZXMgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB1cmwgPSB1cmxzW2ldO1xuICAgIHZhciBkZWZkID0gdXJsRGVmaW5lZFtpXSA9IHVybCAhPSBudWxsICYmIHVybCAhPT0gJ25vbmUnO1xuXG4gICAgaWYgKGRlZmQpIHtcbiAgICAgIHZhciBiZ0ltZ0Nyb3NzT3JpZ2luID0gbm9kZS5jeSgpLnN0eWxlKCkuZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJywgJ3ZhbHVlJywgaSk7XG4gICAgICBudW1JbWFnZXMrKzsgLy8gZ2V0IGltYWdlLCBhbmQgaWYgbm90IGxvYWRlZCB0aGVuIGFzayB0byByZWRyYXcgd2hlbiBsYXRlciBsb2FkZWRcblxuICAgICAgaW1hZ2VbaV0gPSByLmdldENhY2hlZEltYWdlKHVybCwgYmdJbWdDcm9zc09yaWdpbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbm9kZS5lbWl0QW5kTm90aWZ5KCdiYWNrZ3JvdW5kJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy9cbiAgLy8gc2V0dXAgc3R5bGVzXG5cblxuICB2YXIgZGFya25lc3MgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1ibGFja2VuJykudmFsdWU7XG4gIHZhciBib3JkZXJXaWR0aCA9IG5vZGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgYmdPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlICogZWxlT3BhY2l0eTtcbiAgdmFyIGJvcmRlckNvbG9yID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1jb2xvcicpLnZhbHVlO1xuICB2YXIgYm9yZGVyU3R5bGUgPSBub2RlLnBzdHlsZSgnYm9yZGVyLXN0eWxlJykudmFsdWU7XG4gIHZhciBib3JkZXJPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1vcGFjaXR5JykudmFsdWUgKiBlbGVPcGFjaXR5O1xuICBjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJzsgLy8gc28gYm9yZGVycyBhcmUgc3F1YXJlIHdpdGggdGhlIG5vZGUgc2hhcGVcblxuICB2YXIgc2V0dXBTaGFwZUNvbG9yID0gZnVuY3Rpb24gc2V0dXBTaGFwZUNvbG9yKCkge1xuICAgIHZhciBiZ09weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogYmdPcGFjaXR5O1xuICAgIHIuZWxlRmlsbFN0eWxlKGNvbnRleHQsIG5vZGUsIGJnT3B5KTtcbiAgfTtcblxuICB2YXIgc2V0dXBCb3JkZXJDb2xvciA9IGZ1bmN0aW9uIHNldHVwQm9yZGVyQ29sb3IoKSB7XG4gICAgdmFyIGJkck9weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogYm9yZGVyT3BhY2l0eTtcbiAgICByLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgYm9yZGVyQ29sb3JbMF0sIGJvcmRlckNvbG9yWzFdLCBib3JkZXJDb2xvclsyXSwgYmRyT3B5KTtcbiAgfTsgLy9cbiAgLy8gc2V0dXAgc2hhcGVcblxuXG4gIHZhciBzdHlsZVNoYXBlID0gbm9kZS5wc3R5bGUoJ3NoYXBlJykuc3RyVmFsdWU7XG4gIHZhciBzaGFwZVB0cyA9IG5vZGUucHN0eWxlKCdzaGFwZS1wb2x5Z29uLXBvaW50cycpLnBmVmFsdWU7XG5cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUocG9zLngsIHBvcy55KTtcbiAgICB2YXIgcGF0aENhY2hlID0gci5ub2RlUGF0aENhY2hlID0gci5ub2RlUGF0aENhY2hlIHx8IFtdO1xuICAgIHZhciBrZXkgPSBoYXNoU3RyaW5ncyhzdHlsZVNoYXBlID09PSAncG9seWdvbicgPyBzdHlsZVNoYXBlICsgJywnICsgc2hhcGVQdHMuam9pbignLCcpIDogc3R5bGVTaGFwZSwgJycgKyBub2RlSGVpZ2h0LCAnJyArIG5vZGVXaWR0aCk7XG4gICAgdmFyIGNhY2hlZFBhdGggPSBwYXRoQ2FjaGVba2V5XTtcblxuICAgIGlmIChjYWNoZWRQYXRoICE9IG51bGwpIHtcbiAgICAgIHBhdGggPSBjYWNoZWRQYXRoO1xuICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICBwYXRoQ2FjaGVba2V5XSA9IHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRyYXdTaGFwZSA9IGZ1bmN0aW9uIGRyYXdTaGFwZSgpIHtcbiAgICBpZiAoIXBhdGhDYWNoZUhpdCkge1xuICAgICAgdmFyIG5wb3MgPSBwb3M7XG5cbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBucG9zID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcocGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3SW1hZ2VzID0gZnVuY3Rpb24gZHJhd0ltYWdlcygpIHtcbiAgICB2YXIgbm9kZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVsZU9wYWNpdHk7XG4gICAgdmFyIHByZXZCZ2luZyA9IF9wLmJhY2tncm91bmRpbmc7XG4gICAgdmFyIHRvdGFsQ29tcGxldGVkID0gMDtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbWFnZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGlmICh1cmxEZWZpbmVkW19pXSAmJiBpbWFnZVtfaV0uY29tcGxldGUgJiYgIWltYWdlW19pXS5lcnJvcikge1xuICAgICAgICB0b3RhbENvbXBsZXRlZCsrO1xuICAgICAgICByLmRyYXdJbnNjcmliZWRJbWFnZShjb250ZXh0LCBpbWFnZVtfaV0sIG5vZGUsIF9pLCBub2RlT3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3AuYmFja2dyb3VuZGluZyA9ICEodG90YWxDb21wbGV0ZWQgPT09IG51bUltYWdlcyk7XG5cbiAgICBpZiAocHJldkJnaW5nICE9PSBfcC5iYWNrZ3JvdW5kaW5nKSB7XG4gICAgICAvLyB1cGRhdGUgc3R5bGUgYi9jIDpiYWNrZ3JvdW5kaW5nIHN0YXRlIGNoYW5nZWRcbiAgICAgIG5vZGUudXBkYXRlU3R5bGUoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZHJhd1BpZSA9IGZ1bmN0aW9uIGRyYXdQaWUoKSB7XG4gICAgdmFyIHJlZHJhd1NoYXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgcGllT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZWxlT3BhY2l0eTtcblxuICAgIGlmIChyLmhhc1BpZShub2RlKSkge1xuICAgICAgci5kcmF3UGllKGNvbnRleHQsIG5vZGUsIHBpZU9wYWNpdHkpOyAvLyByZWRyYXcvcmVzdG9yZSBwYXRoIGlmIHN0ZXBzIGFmdGVyIHBpZSBuZWVkIGl0XG5cbiAgICAgIGlmIChyZWRyYXdTaGFwZSkge1xuICAgICAgICBpZiAoIXVzZVBhdGhzKSB7XG4gICAgICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIHBvcy54LCBwb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZGFya2VuID0gZnVuY3Rpb24gZGFya2VuKCkge1xuICAgIHZhciBkYXJrZW5PcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlbGVPcGFjaXR5O1xuICAgIHZhciBvcGFjaXR5ID0gKGRhcmtuZXNzID4gMCA/IGRhcmtuZXNzIDogLWRhcmtuZXNzKSAqIGRhcmtlbk9wYWNpdHk7XG4gICAgdmFyIGMgPSBkYXJrbmVzcyA+IDAgPyAwIDogMjU1O1xuXG4gICAgaWYgKGRhcmtuZXNzICE9PSAwKSB7XG4gICAgICByLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGMsIGMsIGMsIG9wYWNpdHkpO1xuXG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5maWxsKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3Qm9yZGVyID0gZnVuY3Rpb24gZHJhd0JvcmRlcigpIHtcbiAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuXG4gICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgc3dpdGNoIChib3JkZXJTdHlsZSkge1xuICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFs0LCAyXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm9yZGVyU3R5bGUgPT09ICdkb3VibGUnKSB7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGggLyAzO1xuICAgICAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG5cbiAgICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICAgICAgfSAvLyByZXNldCBpbiBjYXNlIHdlIGNoYW5nZWQgdGhlIGJvcmRlciBzdHlsZVxuXG5cbiAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdPdmVybGF5ID0gZnVuY3Rpb24gZHJhd092ZXJsYXkoKSB7XG4gICAgaWYgKHNob3VsZERyYXdPdmVybGF5KSB7XG4gICAgICByLmRyYXdOb2RlT3ZlcmxheShjb250ZXh0LCBub2RlLCBwb3MsIG5vZGVXaWR0aCwgbm9kZUhlaWdodCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3VGV4dCA9IGZ1bmN0aW9uIGRyYXdUZXh0KCkge1xuICAgIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIG5vZGUsIG51bGwsIGRyYXdMYWJlbCk7XG4gIH07XG5cbiAgdmFyIGdob3N0ID0gbm9kZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gIGlmIChnaG9zdCkge1xuICAgIHZhciBneCA9IG5vZGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgdmFyIGd5ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICB2YXIgZ2hvc3RPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgZWZmR2hvc3RPcGFjaXR5ID0gZ2hvc3RPcGFjaXR5ICogZWxlT3BhY2l0eTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIHNldHVwU2hhcGVDb2xvcihnaG9zdE9wYWNpdHkgKiBiZ09wYWNpdHkpO1xuICAgIGRyYXdTaGFwZSgpO1xuICAgIGRyYXdJbWFnZXMoZWZmR2hvc3RPcGFjaXR5KTtcbiAgICBkcmF3UGllKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgICBkYXJrZW4oZWZmR2hvc3RPcGFjaXR5KTtcbiAgICBzZXR1cEJvcmRlckNvbG9yKGdob3N0T3BhY2l0eSAqIGJvcmRlck9wYWNpdHkpO1xuICAgIGRyYXdCb3JkZXIoKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtZ3gsIC1neSk7XG4gIH1cblxuICBzZXR1cFNoYXBlQ29sb3IoKTtcbiAgZHJhd1NoYXBlKCk7XG4gIGRyYXdJbWFnZXMoKTtcbiAgZHJhd1BpZShkYXJrbmVzcyAhPT0gMCB8fCBib3JkZXJXaWR0aCAhPT0gMCk7XG4gIGRhcmtlbigpO1xuICBzZXR1cEJvcmRlckNvbG9yKCk7XG4gIGRyYXdCb3JkZXIoKTtcblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtcG9zLngsIC1wb3MueSk7XG4gIH1cblxuICBkcmF3VGV4dCgpO1xuICBkcmF3T3ZlcmxheSgpOyAvL1xuICAvLyBjbGVhbiB1cCBzaGlmdFxuXG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoYmIueDEsIGJiLnkxKTtcbiAgfVxufTtcblxuQ1JwJDUuZHJhd05vZGVPdmVybGF5ID0gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIHBvcywgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KSB7XG4gIHZhciByID0gdGhpcztcblxuICBpZiAoIW5vZGUudmlzaWJsZSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG92ZXJsYXlQYWRkaW5nID0gbm9kZS5wc3R5bGUoJ292ZXJsYXktcGFkZGluZycpLnBmVmFsdWU7XG4gIHZhciBvdmVybGF5T3BhY2l0eSA9IG5vZGUucHN0eWxlKCdvdmVybGF5LW9wYWNpdHknKS52YWx1ZTtcbiAgdmFyIG92ZXJsYXlDb2xvciA9IG5vZGUucHN0eWxlKCdvdmVybGF5LWNvbG9yJykudmFsdWU7XG5cbiAgaWYgKG92ZXJsYXlPcGFjaXR5ID4gMCkge1xuICAgIHBvcyA9IHBvcyB8fCBub2RlLnBvc2l0aW9uKCk7XG5cbiAgICBpZiAobm9kZVdpZHRoID09IG51bGwgfHwgbm9kZUhlaWdodCA9PSBudWxsKSB7XG4gICAgICB2YXIgcGFkZGluZyA9IG5vZGUucGFkZGluZygpO1xuICAgICAgbm9kZVdpZHRoID0gbm9kZS53aWR0aCgpICsgMiAqIHBhZGRpbmc7XG4gICAgICBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKSArIDIgKiBwYWRkaW5nO1xuICAgIH1cblxuICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgb3ZlcmxheUNvbG9yWzBdLCBvdmVybGF5Q29sb3JbMV0sIG92ZXJsYXlDb2xvclsyXSwgb3ZlcmxheU9wYWNpdHkpO1xuICAgIHIubm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXS5kcmF3KGNvbnRleHQsIHBvcy54LCBwb3MueSwgbm9kZVdpZHRoICsgb3ZlcmxheVBhZGRpbmcgKiAyLCBub2RlSGVpZ2h0ICsgb3ZlcmxheVBhZGRpbmcgKiAyKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxufTsgLy8gZG9lcyB0aGUgbm9kZSBoYXZlIGF0IGxlYXN0IG9uZSBwaWUgcGllY2U/XG5cblxuQ1JwJDUuaGFzUGllID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG5cbiAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuaGFzUGllO1xufTtcblxuQ1JwJDUuZHJhd1BpZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBub2RlT3BhY2l0eSwgcG9zKSB7XG4gIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuXG4gIHBvcyA9IHBvcyB8fCBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciBjeVN0eWxlID0gbm9kZS5jeSgpLnN0eWxlKCk7XG4gIHZhciBwaWVTaXplID0gbm9kZS5wc3R5bGUoJ3BpZS1zaXplJyk7XG4gIHZhciB4ID0gcG9zLng7XG4gIHZhciB5ID0gcG9zLnk7XG4gIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHJhZGl1cyA9IE1hdGgubWluKG5vZGVXLCBub2RlSCkgLyAyOyAvLyBtdXN0IGZpdCBpbiBub2RlXG5cbiAgdmFyIGxhc3RQZXJjZW50ID0gMDsgLy8gd2hhdCAlIHRvIGNvbnRpbnVlIGRyYXdpbmcgcGllIHNsaWNlcyBmcm9tIG9uIFswLCAxXVxuXG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcblxuICBpZiAodXNlUGF0aHMpIHtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcbiAgfVxuXG4gIGlmIChwaWVTaXplLnVuaXRzID09PSAnJScpIHtcbiAgICByYWRpdXMgPSByYWRpdXMgKiBwaWVTaXplLnBmVmFsdWU7XG4gIH0gZWxzZSBpZiAocGllU2l6ZS5wZlZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByYWRpdXMgPSBwaWVTaXplLnBmVmFsdWUgLyAyO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gY3lTdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgLy8gMS4uTlxuICAgIHZhciBzaXplID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJykudmFsdWU7XG4gICAgdmFyIGNvbG9yID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWUgKiBub2RlT3BhY2l0eTtcbiAgICB2YXIgcGVyY2VudCA9IHNpemUgLyAxMDA7IC8vIG1hcCBpbnRlZ2VyIHJhbmdlIFswLCAxMDBdIHRvIFswLCAxXVxuICAgIC8vIHBlcmNlbnQgY2FuJ3QgcHVzaCBiZXlvbmQgMVxuXG4gICAgaWYgKHBlcmNlbnQgKyBsYXN0UGVyY2VudCA+IDEpIHtcbiAgICAgIHBlcmNlbnQgPSAxIC0gbGFzdFBlcmNlbnQ7XG4gICAgfVxuXG4gICAgdmFyIGFuZ2xlU3RhcnQgPSAxLjUgKiBNYXRoLlBJICsgMiAqIE1hdGguUEkgKiBsYXN0UGVyY2VudDsgLy8gc3RhcnQgYXQgMTIgbydjbG9jayBhbmQgZ28gY2xvY2t3aXNlXG5cbiAgICB2YXIgYW5nbGVEZWx0YSA9IDIgKiBNYXRoLlBJICogcGVyY2VudDtcbiAgICB2YXIgYW5nbGVFbmQgPSBhbmdsZVN0YXJ0ICsgYW5nbGVEZWx0YTsgLy8gaWdub3JlIGlmXG4gICAgLy8gLSB6ZXJvIHNpemVcbiAgICAvLyAtIHdlJ3JlIGFscmVhZHkgYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgIC8vIC0gYWRkaW5nIHRoZSBjdXJyZW50IHNsaWNlIHdvdWxkIGdvIGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcblxuICAgIGlmIChzaXplID09PSAwIHx8IGxhc3RQZXJjZW50ID49IDEgfHwgbGFzdFBlcmNlbnQgKyBwZXJjZW50ID4gMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIGFuZ2xlU3RhcnQsIGFuZ2xlRW5kKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgbGFzdFBlcmNlbnQgKz0gcGVyY2VudDtcbiAgfVxufTtcblxudmFyIENScCQ2ID0ge307XG52YXIgbW90aW9uQmx1ckRlbGF5ID0gMTAwOyAvLyB2YXIgaXNGaXJlZm94ID0gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcblxuQ1JwJDYuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmRhdGEuY29udGV4dHNbMF07XG5cbiAgaWYgKHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbztcbiAgfVxuXG4gIHZhciBiYWNraW5nU3RvcmUgPSBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gYmFja2luZ1N0b3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG59O1xuXG5DUnAkNi5wYWludENhY2hlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGNhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzIHx8IFtdO1xuICB2YXIgbmVlZFRvQ3JlYXRlQ2FjaGUgPSB0cnVlO1xuICB2YXIgY2FjaGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZSA9IGNhY2hlc1tpXTtcblxuICAgIGlmIChjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICBuZWVkVG9DcmVhdGVDYWNoZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5lZWRUb0NyZWF0ZUNhY2hlKSB7XG4gICAgY2FjaGUgPSB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfTtcbiAgICBjYWNoZXMucHVzaChjYWNoZSk7XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59O1xuXG5DUnAkNi5jcmVhdGVHcmFkaWVudFN0eWxlRm9yID0gZnVuY3Rpb24gKGNvbnRleHQsIHNoYXBlU3R5bGVOYW1lLCBlbGUsIGZpbGwsIG9wYWNpdHkpIHtcbiAgdmFyIGdyYWRpZW50U3R5bGU7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgdmFyIGNvbG9ycyA9IGVsZS5wc3R5bGUoc2hhcGVTdHlsZU5hbWUgKyAnLWdyYWRpZW50LXN0b3AtY29sb3JzJykudmFsdWUsXG4gICAgICBwb3NpdGlvbnMgPSBlbGUucHN0eWxlKHNoYXBlU3R5bGVOYW1lICsgJy1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucycpLnBmVmFsdWU7XG5cbiAgaWYgKGZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdmFyIHN0YXJ0ID0gZWxlLnNvdXJjZUVuZHBvaW50KCksXG4gICAgICAgICAgZW5kID0gZWxlLnRhcmdldEVuZHBvaW50KCksXG4gICAgICAgICAgbWlkID0gZWxlLm1pZHBvaW50KCk7XG4gICAgICB2YXIgZDEgPSBkaXN0KHN0YXJ0LCBtaWQpO1xuICAgICAgdmFyIGQyID0gZGlzdChlbmQsIG1pZCk7XG4gICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChtaWQueCwgbWlkLnksIDAsIG1pZC54LCBtaWQueSwgTWF0aC5tYXgoZDEsIGQyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwb3MgPSB1c2VQYXRocyA/IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSA6IGVsZS5wb3NpdGlvbigpLFxuICAgICAgICAgIHdpZHRoID0gZWxlLnBhZGRlZFdpZHRoKCksXG4gICAgICAgICAgaGVpZ2h0ID0gZWxlLnBhZGRlZEhlaWdodCgpO1xuICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQocG9zLngsIHBvcy55LCAwLCBwb3MueCwgcG9zLnksIE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdmFyIF9zdGFydCA9IGVsZS5zb3VyY2VFbmRwb2ludCgpLFxuICAgICAgICAgIF9lbmQgPSBlbGUudGFyZ2V0RW5kcG9pbnQoKTtcblxuICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3N0YXJ0LngsIF9zdGFydC55LCBfZW5kLngsIF9lbmQueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfcG9zID0gdXNlUGF0aHMgPyB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0gOiBlbGUucG9zaXRpb24oKSxcbiAgICAgICAgICBfd2lkdGggPSBlbGUucGFkZGVkV2lkdGgoKSxcbiAgICAgICAgICBfaGVpZ2h0ID0gZWxlLnBhZGRlZEhlaWdodCgpLFxuICAgICAgICAgIGhhbGZXaWR0aCA9IF93aWR0aCAvIDIsXG4gICAgICAgICAgaGFsZkhlaWdodCA9IF9oZWlnaHQgLyAyO1xuXG4gICAgICB2YXIgZGlyZWN0aW9uID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nKS52YWx1ZTtcblxuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSAndG8tYm90dG9tJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLngsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG8tdG9wJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLngsIF9wb3MueSArIGhhbGZIZWlnaHQsIF9wb3MueCwgX3Bvcy55IC0gaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG8tbGVmdCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnksIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by1yaWdodCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnksIF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by1ib3R0b20tcmlnaHQnOlxuICAgICAgICBjYXNlICd0by1yaWdodC1ib3R0b20nOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by10b3AtcmlnaHQnOlxuICAgICAgICBjYXNlICd0by1yaWdodC10b3AnOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0by1ib3R0b20tbGVmdCc6XG4gICAgICAgIGNhc2UgJ3RvLWxlZnQtYm90dG9tJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndG8tdG9wLWxlZnQnOlxuICAgICAgICBjYXNlICd0by1sZWZ0LXRvcCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0LCBfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghZ3JhZGllbnRTdHlsZSkgcmV0dXJuIG51bGw7IC8vIGludmFsaWQgZ3JhZGllbnQgc3R5bGVcblxuICB2YXIgaGFzUG9zaXRpb25zID0gcG9zaXRpb25zLmxlbmd0aCA9PT0gY29sb3JzLmxlbmd0aDtcbiAgdmFyIGxlbmd0aCA9IGNvbG9ycy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGdyYWRpZW50U3R5bGUuYWRkQ29sb3JTdG9wKGhhc1Bvc2l0aW9ucyA/IHBvc2l0aW9uc1tpXSA6IGkgLyAobGVuZ3RoIC0gMSksICdyZ2JhKCcgKyBjb2xvcnNbaV1bMF0gKyAnLCcgKyBjb2xvcnNbaV1bMV0gKyAnLCcgKyBjb2xvcnNbaV1bMl0gKyAnLCcgKyBvcGFjaXR5ICsgJyknKTtcbiAgfVxuXG4gIHJldHVybiBncmFkaWVudFN0eWxlO1xufTtcblxuQ1JwJDYuZ3JhZGllbnRGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gIHZhciBncmFkaWVudFN0eWxlID0gdGhpcy5jcmVhdGVHcmFkaWVudFN0eWxlRm9yKGNvbnRleHQsICdiYWNrZ3JvdW5kJywgZWxlLCBmaWxsLCBvcGFjaXR5KTtcbiAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gZXJyb3JcblxuICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50U3R5bGU7XG59O1xuXG5DUnAkNi5jb2xvckZpbGxTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCByLCBnLCBiLCBhKSB7XG4gIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7IC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuICAvLyB2YXIgZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gIC8vIGlmKCBjYWNoZS5maWxsU3R5bGUgIT09IGZpbGxTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuZmlsbFN0eWxlID0gY2FjaGUuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAvLyB9XG59O1xuXG5DUnAkNi5lbGVGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBvcGFjaXR5KSB7XG4gIHZhciBiYWNrZ3JvdW5kRmlsbCA9IGVsZS5wc3R5bGUoJ2JhY2tncm91bmQtZmlsbCcpLnZhbHVlO1xuXG4gIGlmIChiYWNrZ3JvdW5kRmlsbCA9PT0gJ2xpbmVhci1ncmFkaWVudCcgfHwgYmFja2dyb3VuZEZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgdGhpcy5ncmFkaWVudEZpbGxTdHlsZShjb250ZXh0LCBlbGUsIGJhY2tncm91bmRGaWxsLCBvcGFjaXR5KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgYmFja2dyb3VuZENvbG9yWzBdLCBiYWNrZ3JvdW5kQ29sb3JbMV0sIGJhY2tncm91bmRDb2xvclsyXSwgb3BhY2l0eSk7XG4gIH1cbn07XG5cbkNScCQ2LmdyYWRpZW50U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gIHZhciBncmFkaWVudFN0eWxlID0gdGhpcy5jcmVhdGVHcmFkaWVudFN0eWxlRm9yKGNvbnRleHQsICdsaW5lJywgZWxlLCBmaWxsLCBvcGFjaXR5KTtcbiAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gZXJyb3JcblxuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZ3JhZGllbnRTdHlsZTtcbn07XG5cbkNScCQ2LmNvbG9yU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgciwgZywgYiwgYSkge1xuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7IC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuICAvLyB2YXIgc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgLy8gaWYoIGNhY2hlLnN0cm9rZVN0eWxlICE9PSBzdHJva2VTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjYWNoZS5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAvLyB9XG59O1xuXG5DUnAkNi5lbGVTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIG9wYWNpdHkpIHtcbiAgdmFyIGxpbmVGaWxsID0gZWxlLnBzdHlsZSgnbGluZS1maWxsJykudmFsdWU7XG5cbiAgaWYgKGxpbmVGaWxsID09PSAnbGluZWFyLWdyYWRpZW50JyB8fCBsaW5lRmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICB0aGlzLmdyYWRpZW50U3Ryb2tlU3R5bGUoY29udGV4dCwgZWxlLCBsaW5lRmlsbCwgb3BhY2l0eSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxpbmVDb2xvciA9IGVsZS5wc3R5bGUoJ2xpbmUtY29sb3InKS52YWx1ZTtcbiAgICB0aGlzLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgbGluZUNvbG9yWzBdLCBsaW5lQ29sb3JbMV0sIGxpbmVDb2xvclsyXSwgb3BhY2l0eSk7XG4gIH1cbn07IC8vIFJlc2l6ZSBjYW52YXNcblxuXG5DUnAkNi5tYXRjaENhbnZhc1NpemUgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGRhdGEgPSByLmRhdGE7XG4gIHZhciBiYiA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgd2lkdGggPSBiYlsyXTtcbiAgdmFyIGhlaWdodCA9IGJiWzNdO1xuICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpO1xuICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcblxuICBpZiAoY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250YWluZXIgPT09IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddKSB7XG4gICAgcGl4ZWxSYXRpbyA9IG1iUHhSYXRpbztcbiAgfVxuXG4gIHZhciBjYW52YXNXaWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgdmFyIGNhbnZhc0hlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gIHZhciBjYW52YXM7XG5cbiAgaWYgKGNhbnZhc1dpZHRoID09PSByLmNhbnZhc1dpZHRoICYmIGNhbnZhc0hlaWdodCA9PT0gci5jYW52YXNIZWlnaHQpIHtcbiAgICByZXR1cm47IC8vIHNhdmUgY3ljbGVzIGlmIHNhbWVcbiAgfVxuXG4gIHIuZm9udENhY2hlcyA9IG51bGw7IC8vIHJlc2l6aW5nIHJlc2V0cyB0aGUgc3R5bGVcblxuICB2YXIgY2FudmFzQ29udGFpbmVyID0gZGF0YS5jYW52YXNDb250YWluZXI7XG4gIGNhbnZhc0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgY2FudmFzQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgIGNhbnZhcyA9IGRhdGEuY2FudmFzZXNbaV07XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuQlVGRkVSX0NPVU5UOyBpKyspIHtcbiAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzW2ldO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICB9XG5cbiAgci50ZXh0dXJlTXVsdCA9IDE7XG5cbiAgaWYgKHBpeGVsUmF0aW8gPD0gMSkge1xuICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgci50ZXh0dXJlTXVsdCA9IDI7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGggKiByLnRleHR1cmVNdWx0O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0O1xuICB9XG5cbiAgci5jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICByLmNhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodDtcbn07XG5cbkNScCQ2LnJlbmRlclRvID0gZnVuY3Rpb24gKGN4dCwgem9vbSwgcGFuLCBweFJhdGlvKSB7XG4gIHRoaXMucmVuZGVyKHtcbiAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgZm9yY2VkWm9vbTogem9vbSxcbiAgICBmb3JjZWRQYW46IHBhbixcbiAgICBkcmF3QWxsTGF5ZXJzOiB0cnVlLFxuICAgIGZvcmNlZFB4UmF0aW86IHB4UmF0aW9cbiAgfSk7XG59O1xuXG5DUnAkNi5yZW5kZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBzdGF0aWNFbXB0eU9iamVjdCgpO1xuICB2YXIgZm9yY2VkQ29udGV4dCA9IG9wdGlvbnMuZm9yY2VkQ29udGV4dDtcbiAgdmFyIGRyYXdBbGxMYXllcnMgPSBvcHRpb25zLmRyYXdBbGxMYXllcnM7XG4gIHZhciBkcmF3T25seU5vZGVMYXllciA9IG9wdGlvbnMuZHJhd09ubHlOb2RlTGF5ZXI7XG4gIHZhciBmb3JjZWRab29tID0gb3B0aW9ucy5mb3JjZWRab29tO1xuICB2YXIgZm9yY2VkUGFuID0gb3B0aW9ucy5mb3JjZWRQYW47XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHBpeGVsUmF0aW8gPSBvcHRpb25zLmZvcmNlZFB4UmF0aW8gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0UGl4ZWxSYXRpbygpIDogb3B0aW9ucy5mb3JjZWRQeFJhdGlvO1xuICB2YXIgY3kgPSByLmN5O1xuICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIG5lZWREcmF3ID0gZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcbiAgdmFyIHRleHR1cmVEcmF3ID0gci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCAmJiAoci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nKTtcbiAgdmFyIG1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubW90aW9uQmx1ciA6IHIubW90aW9uQmx1cjtcbiAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICB2YXIgaW5Ob2RlRHJhZ0dlc3R1cmUgPSByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXM7XG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPyB0cnVlIDogZmFsc2U7XG4gIG1vdGlvbkJsdXIgPSBtb3Rpb25CbHVyICYmICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1ckVuYWJsZWQgJiYgIWluQm94U2VsZWN0aW9uO1xuICB2YXIgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBtb3Rpb25CbHVyO1xuXG4gIGlmICghZm9yY2VkQ29udGV4dCkge1xuICAgIGlmIChyLnByZXZQeFJhdGlvICE9PSBwaXhlbFJhdGlvKSB7XG4gICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgICAgci5tYXRjaENhbnZhc1NpemUoci5jb250YWluZXIpO1xuICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICB9XG5cbiAgICByLnByZXZQeFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgfVxuXG4gIGlmICghZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJUaW1lb3V0KSB7XG4gICAgY2xlYXJUaW1lb3V0KHIubW90aW9uQmx1clRpbWVvdXQpO1xuICB9XG5cbiAgaWYgKG1vdGlvbkJsdXIpIHtcbiAgICBpZiAoci5tYkZyYW1lcyA9PSBudWxsKSB7XG4gICAgICByLm1iRnJhbWVzID0gMDtcbiAgICB9XG5cbiAgICByLm1iRnJhbWVzKys7XG5cbiAgICBpZiAoci5tYkZyYW1lcyA8IDMpIHtcbiAgICAgIC8vIG5lZWQgc2V2ZXJhbCBmcmFtZXMgYmVmb3JlIGV2ZW4gaGlnaCBxdWFsaXR5IG1vdGlvbmJsdXJcbiAgICAgIG1vdGlvbkJsdXJGYWRlRWZmZWN0ID0gZmFsc2U7XG4gICAgfSAvLyBnbyB0byBsb3dlciBxdWFsaXR5IGJsdXJyeSBmcmFtZXMgd2hlbiBzZXZlcmFsIG0vYiBmcmFtZXMgaGF2ZSBiZWVuIHJlbmRlcmVkIChhdm9pZHMgZmxhc2hpbmcpXG5cblxuICAgIGlmIChyLm1iRnJhbWVzID4gci5taW5NYkxvd1F1YWxGcmFtZXMpIHtcbiAgICAgIC8vci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gICAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gci5tYlB4UkJsdXJyeTtcbiAgICB9XG4gIH1cblxuICBpZiAoci5jbGVhcmluZ01vdGlvbkJsdXIpIHtcbiAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgfSAvLyBiL2MgZHJhd1RvQ29udGV4dCgpIG1heSBiZSBhc3luYyB3LnIudC4gcmVkcmF3KCksIGtlZXAgdHJhY2sgb2YgbGFzdCB0ZXh0dXJlIGZyYW1lXG4gIC8vIGJlY2F1c2UgYSByb2d1ZSBhc3luYyB0ZXh0dXJlIGZyYW1lIHdvdWxkIGNsZWFyIG5lZWREcmF3XG5cblxuICBpZiAoci50ZXh0dXJlRHJhd0xhc3RGcmFtZSAmJiAhdGV4dHVyZURyYXcpIHtcbiAgICBuZWVkRHJhd1tyLk5PREVdID0gdHJ1ZTtcbiAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgZWZmZWN0aXZlWm9vbSA9IGZvcmNlZFpvb20gIT09IHVuZGVmaW5lZCA/IGZvcmNlZFpvb20gOiB6b29tO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciBlZmZlY3RpdmVQYW4gPSB7XG4gICAgeDogcGFuLngsXG4gICAgeTogcGFuLnlcbiAgfTtcbiAgdmFyIHZwID0ge1xuICAgIHpvb206IHpvb20sXG4gICAgcGFuOiB7XG4gICAgICB4OiBwYW4ueCxcbiAgICAgIHk6IHBhbi55XG4gICAgfVxuICB9O1xuICB2YXIgcHJldlZwID0gci5wcmV2Vmlld3BvcnQ7XG4gIHZhciB2aWV3cG9ydElzRGlmZiA9IHByZXZWcCA9PT0gdW5kZWZpbmVkIHx8IHZwLnpvb20gIT09IHByZXZWcC56b29tIHx8IHZwLnBhbi54ICE9PSBwcmV2VnAucGFuLnggfHwgdnAucGFuLnkgIT09IHByZXZWcC5wYW4ueTsgLy8gd2Ugd2FudCB0aGUgbG93IHF1YWxpdHkgbW90aW9uYmx1ciBvbmx5IHdoZW4gdGhlIHZpZXdwb3J0IGlzIGJlaW5nIG1hbmlwdWxhdGVkIGV0YyAod2hlcmUgaXQncyBub3Qgbm90aWNlZClcblxuICBpZiAoIXZpZXdwb3J0SXNEaWZmICYmICEoaW5Ob2RlRHJhZ0dlc3R1cmUgJiYgIWhhc0NvbXBvdW5kTm9kZXMpKSB7XG4gICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIH1cblxuICBpZiAoZm9yY2VkUGFuKSB7XG4gICAgZWZmZWN0aXZlUGFuID0gZm9yY2VkUGFuO1xuICB9IC8vIGFwcGx5IHBpeGVsIHJhdGlvXG5cblxuICBlZmZlY3RpdmVab29tICo9IHBpeGVsUmF0aW87XG4gIGVmZmVjdGl2ZVBhbi54ICo9IHBpeGVsUmF0aW87XG4gIGVmZmVjdGl2ZVBhbi55ICo9IHBpeGVsUmF0aW87XG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuXG4gIGZ1bmN0aW9uIG1iY2xlYXIoY29udGV4dCwgeCwgeSwgdywgaCkge1xuICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgci5tb3Rpb25CbHVyVHJhbnNwYXJlbmN5KTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBjbGVhcikge1xuICAgIHZhciBlUGFuLCBlWm9vbSwgdywgaDtcblxuICAgIGlmICghci5jbGVhcmluZ01vdGlvbkJsdXIgJiYgKGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10pKSB7XG4gICAgICBlUGFuID0ge1xuICAgICAgICB4OiBwYW4ueCAqIG1iUHhSYXRpbyxcbiAgICAgICAgeTogcGFuLnkgKiBtYlB4UmF0aW9cbiAgICAgIH07XG4gICAgICBlWm9vbSA9IHpvb20gKiBtYlB4UmF0aW87XG4gICAgICB3ID0gci5jYW52YXNXaWR0aCAqIG1iUHhSYXRpbztcbiAgICAgIGggPSByLmNhbnZhc0hlaWdodCAqIG1iUHhSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgZVBhbiA9IGVmZmVjdGl2ZVBhbjtcbiAgICAgIGVab29tID0gZWZmZWN0aXZlWm9vbTtcbiAgICAgIHcgPSByLmNhbnZhc1dpZHRoO1xuICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0O1xuICAgIH1cblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgaWYgKGNsZWFyID09PSAnbW90aW9uQmx1cicpIHtcbiAgICAgIG1iY2xlYXIoY29udGV4dCwgMCwgMCwgdywgaCk7XG4gICAgfSBlbHNlIGlmICghZm9yY2VkQ29udGV4dCAmJiAoY2xlYXIgPT09IHVuZGVmaW5lZCB8fCBjbGVhcikpIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgIH1cblxuICAgIGlmICghZHJhd0FsbExheWVycykge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoZVBhbi54LCBlUGFuLnkpO1xuICAgICAgY29udGV4dC5zY2FsZShlWm9vbSwgZVpvb20pO1xuICAgIH1cblxuICAgIGlmIChmb3JjZWRQYW4pIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKGZvcmNlZFBhbi54LCBmb3JjZWRQYW4ueSk7XG4gICAgfVxuXG4gICAgaWYgKGZvcmNlZFpvb20pIHtcbiAgICAgIGNvbnRleHQuc2NhbGUoZm9yY2VkWm9vbSwgZm9yY2VkWm9vbSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0ZXh0dXJlRHJhdykge1xuICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0ZXh0dXJlRHJhdykge1xuICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSB0cnVlO1xuXG4gICAgaWYgKCFyLnRleHR1cmVDYWNoZSkge1xuICAgICAgci50ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgICAgIHIudGV4dHVyZUNhY2hlLmJiID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuYm91bmRpbmdCb3goKTtcbiAgICAgIHIudGV4dHVyZUNhY2hlLnRleHR1cmUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgICB2YXIgY3h0ID0gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuVEVYVFVSRV9CVUZGRVJdO1xuICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQsIHIuY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdCk7XG4gICAgICByLnJlbmRlcih7XG4gICAgICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICAgICAgZHJhd09ubHlOb2RlTGF5ZXI6IHRydWUsXG4gICAgICAgIGZvcmNlZFB4UmF0aW86IHBpeGVsUmF0aW8gKiByLnRleHR1cmVNdWx0XG4gICAgICB9KTtcbiAgICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0ID0ge1xuICAgICAgICB6b29tOiBjeS56b29tKCksXG4gICAgICAgIHBhbjogY3kucGFuKCksXG4gICAgICAgIHdpZHRoOiByLmNhbnZhc1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHIuY2FudmFzSGVpZ2h0XG4gICAgICB9O1xuICAgICAgdnAubXBhbiA9IHtcbiAgICAgICAgeDogKDAgLSB2cC5wYW4ueCkgLyB2cC56b29tLFxuICAgICAgICB5OiAoMCAtIHZwLnBhbi55KSAvIHZwLnpvb21cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dHNbci5OT0RFXTtcbiAgICB2YXIgdGV4dHVyZSA9IHIudGV4dHVyZUNhY2hlLnRleHR1cmU7XG4gICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQ7XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICBpZiAobW90aW9uQmx1cikge1xuICAgICAgbWJjbGVhcihjb250ZXh0LCAwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG4gICAgfVxuXG4gICAgdmFyIG91dHNpZGVCZ0NvbG9yID0gc3R5bGUuY29yZSgnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJykudmFsdWU7XG4gICAgdmFyIG91dHNpZGVCZ09wYWNpdHkgPSBzdHlsZS5jb3JlKCdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScpLnZhbHVlO1xuICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgb3V0c2lkZUJnQ29sb3JbMF0sIG91dHNpZGVCZ0NvbG9yWzFdLCBvdXRzaWRlQmdDb2xvclsyXSwgb3V0c2lkZUJnT3BhY2l0eSk7XG4gICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGZhbHNlKTtcbiAgICBjb250ZXh0LmNsZWFyUmVjdCh2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGggLyB2cC56b29tIC8gcGl4ZWxSYXRpbywgdnAuaGVpZ2h0IC8gdnAuem9vbSAvIHBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKHRleHR1cmUsIHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvLCB2cC5oZWlnaHQgLyB2cC56b29tIC8gcGl4ZWxSYXRpbyk7XG4gIH0gZWxzZSBpZiAoci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCkge1xuICAgIC8vIGNsZWFyIHRoZSBjYWNoZSBzaW5jZSB3ZSBkb24ndCBuZWVkIGl0XG4gICAgci50ZXh0dXJlQ2FjaGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGV4dGVudCA9IGN5LmV4dGVudCgpO1xuICB2YXIgdnBNYW5pcCA9IHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5jeS5hbmltYXRlZCgpO1xuICB2YXIgaGlkZUVkZ2VzID0gci5oaWRlRWRnZXNPblZpZXdwb3J0ICYmIHZwTWFuaXA7XG4gIHZhciBuZWVkTWJDbGVhciA9IFtdO1xuICBuZWVkTWJDbGVhcltyLk5PREVdID0gIW5lZWREcmF3W3IuTk9ERV0gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdIHx8IHIuY2xlYXJpbmdNb3Rpb25CbHVyO1xuXG4gIGlmIChuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdID0gdHJ1ZTtcbiAgfVxuXG4gIG5lZWRNYkNsZWFyW3IuRFJBR10gPSAhbmVlZERyYXdbci5EUkFHXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG5cbiAgaWYgKG5lZWRNYkNsZWFyW3IuRFJBR10pIHtcbiAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gPSB0cnVlO1xuICB9XG5cbiAgaWYgKG5lZWREcmF3W3IuTk9ERV0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllciB8fCBuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyW3IuTk9ERV0gJiYgbWJQeFJhdGlvICE9PSAxO1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCAodXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gOiBkYXRhLmNvbnRleHRzW3IuTk9ERV0pO1xuICAgIHZhciBjbGVhciA9IG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZDtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGNsZWFyKTtcblxuICAgIGlmIChoaWRlRWRnZXMpIHtcbiAgICAgIHIuZHJhd0NhY2hlZE5vZGVzKGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3TGF5ZXJlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoci5kZWJ1Zykge1xuICAgICAgci5kcmF3RGVidWdQb2ludHMoY29udGV4dCwgZWxlcy5ub25kcmFnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIpIHtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWRyYXdPbmx5Tm9kZUxheWVyICYmIChuZWVkRHJhd1tyLkRSQUddIHx8IGRyYXdBbGxMYXllcnMgfHwgbmVlZE1iQ2xlYXJbci5EUkFHXSkpIHtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbci5EUkFHXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICh1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSA6IGRhdGEuY29udGV4dHNbci5EUkFHXSk7XG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQpO1xuXG4gICAgaWYgKGhpZGVFZGdlcykge1xuICAgICAgci5kcmF3Q2FjaGVkTm9kZXMoY29udGV4dCwgZWxlcy5kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50cyhjb250ZXh0LCBlbGVzLmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgfVxuXG4gICAgaWYgKHIuZGVidWcpIHtcbiAgICAgIHIuZHJhd0RlYnVnUG9pbnRzKGNvbnRleHQsIGVsZXMuZHJhZyk7XG4gICAgfVxuXG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyKSB7XG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHIuc2hvd0ZwcyB8fCAhZHJhd09ubHlOb2RlTGF5ZXIgJiYgbmVlZERyYXdbci5TRUxFQ1RfQk9YXSAmJiAhZHJhd0FsbExheWVycykge1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCBkYXRhLmNvbnRleHRzW3IuU0VMRUNUX0JPWF07XG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0KTtcblxuICAgIGlmIChyLnNlbGVjdGlvbls0XSA9PSAxICYmIChyLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nKSkge1xuICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJykudmFsdWUgLyB6b29tO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVsxXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtY29sb3InKS52YWx1ZVsyXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScpLnZhbHVlICsgJyknO1xuICAgICAgY29udGV4dC5maWxsUmVjdChyLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bMV0sIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuXG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChyLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bMV0sIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhLmJnQWN0aXZlUG9zaXN0aW9uICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICB2YXIgcG9zID0gZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbjtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1jb2xvcicpLnZhbHVlWzBdICsgJywnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctY29sb3InKS52YWx1ZVsyXSArICcsJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMocG9zLngsIHBvcy55LCBzdHlsZS5jb3JlKCdhY3RpdmUtYmctc2l6ZScpLnBmVmFsdWUgLyB6b29tLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG5cbiAgICB2YXIgdGltZVRvUmVuZGVyID0gci5sYXN0UmVkcmF3VGltZTtcblxuICAgIGlmIChyLnNob3dGcHMgJiYgdGltZVRvUmVuZGVyKSB7XG4gICAgICB0aW1lVG9SZW5kZXIgPSBNYXRoLnJvdW5kKHRpbWVUb1JlbmRlcik7XG4gICAgICB2YXIgZnBzID0gTWF0aC5yb3VuZCgxMDAwIC8gdGltZVRvUmVuZGVyKTtcbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgIGNvbnRleHQuZmlsbFRleHQoJzEgZnJhbWUgPSAnICsgdGltZVRvUmVuZGVyICsgJyBtcyA9ICcgKyBmcHMgKyAnIGZwcycsIDAsIDIwKTtcbiAgICAgIHZhciBtYXhGcHMgPSA2MDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCgwLCAzMCwgMjUwLCAyMCk7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDMwLCAyNTAgKiBNYXRoLm1pbihmcHMgLyBtYXhGcHMsIDEpLCAyMCk7XG4gICAgfVxuXG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzKSB7XG4gICAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gZmFsc2U7XG4gICAgfVxuICB9IC8vIG1vdGlvbmJsdXI6IGJsaXQgcmVuZGVyZWQgYmx1cnJ5IGZyYW1lc1xuXG5cbiAgaWYgKG1vdGlvbkJsdXIgJiYgbWJQeFJhdGlvICE9PSAxKSB7XG4gICAgdmFyIGN4dE5vZGUgPSBkYXRhLmNvbnRleHRzW3IuTk9ERV07XG4gICAgdmFyIHR4dE5vZGUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXTtcbiAgICB2YXIgY3h0RHJhZyA9IGRhdGEuY29udGV4dHNbci5EUkFHXTtcbiAgICB2YXIgdHh0RHJhZyA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddO1xuXG4gICAgdmFyIGRyYXdNb3Rpb25CbHVyID0gZnVuY3Rpb24gZHJhd01vdGlvbkJsdXIoY3h0LCB0eHQsIG5lZWRDbGVhcikge1xuICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgaWYgKG5lZWRDbGVhciB8fCAhbW90aW9uQmx1ckZhZGVFZmZlY3QpIHtcbiAgICAgICAgY3h0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYmNsZWFyKGN4dCwgMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHhyID0gbWJQeFJhdGlvO1xuICAgICAgY3h0LmRyYXdJbWFnZSh0eHQsIC8vIGltZ1xuICAgICAgMCwgMCwgLy8gc3gsIHN5XG4gICAgICByLmNhbnZhc1dpZHRoICogcHhyLCByLmNhbnZhc0hlaWdodCAqIHB4ciwgLy8gc3csIHNoXG4gICAgICAwLCAwLCAvLyB4LCB5XG4gICAgICByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCAvLyB3LCBoXG4gICAgICApO1xuICAgIH07XG5cbiAgICBpZiAobmVlZERyYXdbci5OT0RFXSB8fCBuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgICBkcmF3TW90aW9uQmx1cihjeHROb2RlLCB0eHROb2RlLCBuZWVkTWJDbGVhcltyLk5PREVdKTtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobmVlZERyYXdbci5EUkFHXSB8fCBuZWVkTWJDbGVhcltyLkRSQUddKSB7XG4gICAgICBkcmF3TW90aW9uQmx1cihjeHREcmFnLCB0eHREcmFnLCBuZWVkTWJDbGVhcltyLkRSQUddKTtcbiAgICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByLnByZXZWaWV3cG9ydCA9IHZwO1xuXG4gIGlmIChyLmNsZWFyaW5nTW90aW9uQmx1cikge1xuICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgci5tb3Rpb25CbHVyQ2xlYXJlZCA9IHRydWU7XG4gICAgci5tb3Rpb25CbHVyID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgci5tb3Rpb25CbHVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgci5tb3Rpb25CbHVyVGltZW91dCA9IG51bGw7XG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gPSBmYWxzZTtcbiAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSA9IGZhbHNlO1xuICAgICAgci5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9ICF0ZXh0dXJlRHJhdztcbiAgICAgIHIubWJGcmFtZXMgPSAwO1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IHRydWU7XG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gdHJ1ZTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfSwgbW90aW9uQmx1ckRlbGF5KTtcbiAgfVxuXG4gIGlmICghZm9yY2VkQ29udGV4dCkge1xuICAgIGN5LmVtaXQoJ3JlbmRlcicpO1xuICB9XG59O1xuXG52YXIgQ1JwJDcgPSB7fTsgLy8gQE8gUG9seWdvbiBkcmF3aW5nXG5cbkNScCQ3LmRyYXdQb2x5Z29uUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpIHtcbiAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuXG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICBjb250ZXh0Lm1vdmVUbyh4ICsgaGFsZlcgKiBwb2ludHNbMF0sIHkgKyBoYWxmSCAqIHBvaW50c1sxXSk7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXICogcG9pbnRzW2kgKiAyXSwgeSArIGhhbGZIICogcG9pbnRzW2kgKiAyICsgMV0pO1xuICB9XG5cbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbkNScCQ3LmRyYXdSb3VuZFBvbHlnb25QYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFBvbHlnb25SYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBwb2ludHMubGVuZ3RoIC8gNDsgX2krKykge1xuICAgIHZhciBzb3VyY2VVdiA9IHZvaWQgMCxcbiAgICAgICAgZGVzdFV2ID0gdm9pZCAwO1xuXG4gICAgaWYgKF9pID09PSAwKSB7XG4gICAgICBzb3VyY2VVdiA9IHBvaW50cy5sZW5ndGggLSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2VVdiA9IF9pICogNCAtIDI7XG4gICAgfVxuXG4gICAgZGVzdFV2ID0gX2kgKiA0ICsgMjtcbiAgICB2YXIgcHggPSB4ICsgaGFsZlcgKiBwb2ludHNbX2kgKiA0XTtcbiAgICB2YXIgcHkgPSB5ICsgaGFsZkggKiBwb2ludHNbX2kgKiA0ICsgMV07XG4gICAgdmFyIGNvc1RoZXRhID0gLXBvaW50c1tzb3VyY2VVdl0gKiBwb2ludHNbZGVzdFV2XSAtIHBvaW50c1tzb3VyY2VVdiArIDFdICogcG9pbnRzW2Rlc3RVdiArIDFdO1xuICAgIHZhciBvZmZzZXQgPSBjb3JuZXJSYWRpdXMgLyBNYXRoLnRhbihNYXRoLmFjb3MoY29zVGhldGEpIC8gMik7XG4gICAgdmFyIGNwMHggPSBweCAtIG9mZnNldCAqIHBvaW50c1tzb3VyY2VVdl07XG4gICAgdmFyIGNwMHkgPSBweSAtIG9mZnNldCAqIHBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgIHZhciBjcDF4ID0gcHggKyBvZmZzZXQgKiBwb2ludHNbZGVzdFV2XTtcbiAgICB2YXIgY3AxeSA9IHB5ICsgb2Zmc2V0ICogcG9pbnRzW2Rlc3RVdiArIDFdO1xuXG4gICAgaWYgKF9pID09PSAwKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhjcDB4LCBjcDB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5saW5lVG8oY3AweCwgY3AweSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5hcmNUbyhweCwgcHksIGNwMXgsIGNwMXksIGNvcm5lclJhZGl1cyk7XG4gIH1cblxuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTsgLy8gUm91bmQgcmVjdGFuZ2xlIGRyYXdpbmdcblxuXG5DUnAkNy5kcmF3Um91bmRSZWN0YW5nbGVQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfSAvLyBTdGFydCBhdCB0b3AgbWlkZGxlXG5cblxuICBjb250ZXh0Lm1vdmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7IC8vIEFyYyBmcm9tIG1pZGRsZSB0b3AgdG8gcmlnaHQgc2lkZVxuXG4gIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQsIHggKyBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7IC8vIEFyYyBmcm9tIHJpZ2h0IHNpZGUgdG8gYm90dG9tXG5cbiAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7IC8vIEFyYyBmcm9tIGJvdHRvbSB0byBsZWZ0IHNpZGVcblxuICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpOyAvLyBBcmMgZnJvbSBsZWZ0IHNpZGUgdG8gdG9wQm9yZGVyXG5cbiAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCwgeSAtIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7IC8vIEpvaW4gbGluZVxuXG4gIGNvbnRleHQubGluZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbkNScCQ3LmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9IC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcblxuXG4gIGNvbnRleHQubW92ZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5KTtcbiAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcblxuQ1JwJDcuZHJhd0N1dFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJMZW5ndGggPSBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKTtcblxuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG5cbiAgY29udGV4dC5tb3ZlVG8oeCAtIGhhbGZXaWR0aCArIGNvcm5lckxlbmd0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoIC0gY29ybmVyTGVuZ3RoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyTGVuZ3RoKTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoIC0gY29ybmVyTGVuZ3RoLCB5ICsgaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGggKyBjb3JuZXJMZW5ndGgsIHkgKyBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCArIGNvcm5lckxlbmd0aCk7XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG5DUnAkNy5kcmF3QmFycmVsUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIHhCZWdpbiA9IHggLSBoYWxmV2lkdGg7XG4gIHZhciB4RW5kID0geCArIGhhbGZXaWR0aDtcbiAgdmFyIHlCZWdpbiA9IHkgLSBoYWxmSGVpZ2h0O1xuICB2YXIgeUVuZCA9IHkgKyBoYWxmSGVpZ2h0O1xuICB2YXIgYmFycmVsQ3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHdPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDtcbiAgdmFyIGhPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gIHZhciBjdHJsUHRYT2Zmc2V0ID0gYmFycmVsQ3VydmVDb25zdGFudHMuY3RybFB0T2Zmc2V0UGN0ICogd09mZnNldDtcblxuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG5cbiAgY29udGV4dC5tb3ZlVG8oeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgY29udGV4dC5saW5lVG8oeEJlZ2luLCB5RW5kIC0gaE9mZnNldCk7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4QmVnaW4gKyB3T2Zmc2V0LCB5RW5kKTtcbiAgY29udGV4dC5saW5lVG8oeEVuZCAtIHdPZmZzZXQsIHlFbmQpO1xuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhFbmQsIHlFbmQgLSBoT2Zmc2V0KTtcbiAgY29udGV4dC5saW5lVG8oeEVuZCwgeUJlZ2luICsgaE9mZnNldCk7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4RW5kIC0gY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4RW5kIC0gd09mZnNldCwgeUJlZ2luKTtcbiAgY29udGV4dC5saW5lVG8oeEJlZ2luICsgd09mZnNldCwgeUJlZ2luKTtcbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbnZhciBzaW4wID0gTWF0aC5zaW4oMCk7XG52YXIgY29zMCA9IE1hdGguY29zKDApO1xudmFyIHNpbiA9IHt9O1xudmFyIGNvcyA9IHt9O1xudmFyIGVsbGlwc2VTdGVwU2l6ZSA9IE1hdGguUEkgLyA0MDtcblxuZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplKSB7XG4gIHNpbltpXSA9IE1hdGguc2luKGkpO1xuICBjb3NbaV0gPSBNYXRoLmNvcyhpKTtcbn1cblxuQ1JwJDcuZHJhd0VsbGlwc2VQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIGlmIChjb250ZXh0LmVsbGlwc2UpIHtcbiAgICBjb250ZXh0LmVsbGlwc2UoY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAwLCAwLCAyICogTWF0aC5QSSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHhQb3MsIHlQb3M7XG4gICAgdmFyIHJ3ID0gd2lkdGggLyAyO1xuICAgIHZhciByaCA9IGhlaWdodCAvIDI7XG5cbiAgICBmb3IgKHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUpIHtcbiAgICAgIHhQb3MgPSBjZW50ZXJYIC0gcncgKiBzaW5baV0gKiBzaW4wICsgcncgKiBjb3NbaV0gKiBjb3MwO1xuICAgICAgeVBvcyA9IGNlbnRlclkgKyByaCAqIGNvc1tpXSAqIHNpbjAgKyByaCAqIHNpbltpXSAqIGNvczA7XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbi8qIGdsb2JhbCBhdG9iLCBBcnJheUJ1ZmZlciwgVWludDhBcnJheSwgQmxvYiAqL1xudmFyIENScCQ4ID0ge307XG5cbkNScCQ4LmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uICh3LCBoKSB7XG4gIHZhciBidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGJ1ZmZlci53aWR0aCA9IHc7XG4gIGJ1ZmZlci5oZWlnaHQgPSBoO1xuICByZXR1cm4gW2J1ZmZlciwgYnVmZmVyLmdldENvbnRleHQoJzJkJyldO1xufTtcblxuQ1JwJDguYnVmZmVyQ2FudmFzSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuICB2YXIgYmIgPSBlbGVzLmJvdW5kaW5nQm94KCk7XG4gIHZhciBjdHJSZWN0ID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciB3aWR0aCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi53KSA6IGN0clJlY3RbMl07XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoYmIuaCkgOiBjdHJSZWN0WzNdO1xuICB2YXIgc3BlY2RNYXhEaW1zID0gbnVtYmVyKG9wdGlvbnMubWF4V2lkdGgpIHx8IG51bWJlcihvcHRpb25zLm1heEhlaWdodCk7XG4gIHZhciBweFJhdGlvID0gdGhpcy5nZXRQaXhlbFJhdGlvKCk7XG4gIHZhciBzY2FsZSA9IDE7XG5cbiAgaWYgKG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHdpZHRoICo9IG9wdGlvbnMuc2NhbGU7XG4gICAgaGVpZ2h0ICo9IG9wdGlvbnMuc2NhbGU7XG4gICAgc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuICB9IGVsc2UgaWYgKHNwZWNkTWF4RGltcykge1xuICAgIHZhciBtYXhTY2FsZVcgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4U2NhbGVIID0gSW5maW5pdHk7XG5cbiAgICBpZiAobnVtYmVyKG9wdGlvbnMubWF4V2lkdGgpKSB7XG4gICAgICBtYXhTY2FsZVcgPSBzY2FsZSAqIG9wdGlvbnMubWF4V2lkdGggLyB3aWR0aDtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyKG9wdGlvbnMubWF4SGVpZ2h0KSkge1xuICAgICAgbWF4U2NhbGVIID0gc2NhbGUgKiBvcHRpb25zLm1heEhlaWdodCAvIGhlaWdodDtcbiAgICB9XG5cbiAgICBzY2FsZSA9IE1hdGgubWluKG1heFNjYWxlVywgbWF4U2NhbGVIKTtcbiAgICB3aWR0aCAqPSBzY2FsZTtcbiAgICBoZWlnaHQgKj0gc2NhbGU7XG4gIH1cblxuICBpZiAoIXNwZWNkTWF4RGltcykge1xuICAgIHdpZHRoICo9IHB4UmF0aW87XG4gICAgaGVpZ2h0ICo9IHB4UmF0aW87XG4gICAgc2NhbGUgKj0gcHhSYXRpbztcbiAgfVxuXG4gIHZhciBidWZmQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBidWZmQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGJ1ZmZDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICBidWZmQ2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBidWZmQ2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIHZhciBidWZmQ3h0ID0gYnVmZkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyAvLyBSYXN0ZXJpemUgdGhlIGxheWVycywgYnV0IG9ubHkgaWYgY29udGFpbmVyIGhhcyBub256ZXJvIHNpemVcblxuICBpZiAod2lkdGggPiAwICYmIGhlaWdodCA+IDApIHtcbiAgICBidWZmQ3h0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBidWZmQ3h0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgdmFyIHpzb3J0ZWRFbGVzID0gdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuXG4gICAgaWYgKG9wdGlvbnMuZnVsbCkge1xuICAgICAgLy8gZHJhdyB0aGUgZnVsbCBib3VuZHMgb2YgdGhlIGdyYXBoXG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZSgtYmIueDEgKiBzY2FsZSwgLWJiLnkxICogc2NhbGUpO1xuICAgICAgYnVmZkN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgdGhpcy5kcmF3RWxlbWVudHMoYnVmZkN4dCwgenNvcnRlZEVsZXMpO1xuICAgICAgYnVmZkN4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZShiYi54MSAqIHNjYWxlLCBiYi55MSAqIHNjYWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZHJhdyB0aGUgY3VycmVudCB2aWV3XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHBhbi54ICogc2NhbGUsXG4gICAgICAgIHk6IHBhbi55ICogc2NhbGVcbiAgICAgIH07XG4gICAgICBzY2FsZSAqPSBjeS56b29tKCk7XG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZSh0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55KTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgIHRoaXMuZHJhd0VsZW1lbnRzKGJ1ZmZDeHQsIHpzb3J0ZWRFbGVzKTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoMSAvIHNjYWxlLCAxIC8gc2NhbGUpO1xuICAgICAgYnVmZkN4dC50cmFuc2xhdGUoLXRyYW5zbGF0aW9uLngsIC10cmFuc2xhdGlvbi55KTtcbiAgICB9IC8vIG5lZWQgdG8gZmlsbCBiZyBhdCBlbmQgbGlrZSB0aGlzIGluIG9yZGVyIHRvIGZpbGwgY2xlYXJlZCB0cmFuc3BhcmVudCBwaXhlbHMgaW4ganBnc1xuXG5cbiAgICBpZiAob3B0aW9ucy5iZykge1xuICAgICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3Zlcic7XG4gICAgICBidWZmQ3h0LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmc7XG4gICAgICBidWZmQ3h0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBidWZmQ3h0LmZpbGwoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmZkNhbnZhcztcbn07XG5cbmZ1bmN0aW9uIGI2NFRvQmxvYihiNjQsIG1pbWVUeXBlKSB7XG4gIHZhciBieXRlcyA9IGF0b2IoYjY0KTtcbiAgdmFyIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMubGVuZ3RoKTtcbiAgdmFyIGJ1ZmZVaW50OCA9IG5ldyBVaW50OEFycmF5KGJ1ZmYpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBidWZmVWludDhbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBCbG9iKFtidWZmXSwge1xuICAgIHR5cGU6IG1pbWVUeXBlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBiNjRVcmlUb0I2NChiNjR1cmkpIHtcbiAgdmFyIGkgPSBiNjR1cmkuaW5kZXhPZignLCcpO1xuICByZXR1cm4gYjY0dXJpLnN1YnN0cihpICsgMSk7XG59XG5cbmZ1bmN0aW9uIG91dHB1dChvcHRpb25zLCBjYW52YXMsIG1pbWVUeXBlKSB7XG4gIHZhciBnZXRCNjRVcmkgPSBmdW5jdGlvbiBnZXRCNjRVcmkoKSB7XG4gICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIG9wdGlvbnMucXVhbGl0eSk7XG4gIH07XG5cbiAgc3dpdGNoIChvcHRpb25zLm91dHB1dCkge1xuICAgIGNhc2UgJ2Jsb2ItcHJvbWlzZSc6XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FudmFzLnRvQmxvYihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICAgICAgaWYgKGJsb2IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXNvbHZlKGJsb2IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignYGNhbnZhcy50b0Jsb2IoKWAgc2VudCBhIG51bGwgdmFsdWUgaW4gaXRzIGNhbGxiYWNrJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIG1pbWVUeXBlLCBvcHRpb25zLnF1YWxpdHkpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICBjYXNlICdibG9iJzpcbiAgICAgIHJldHVybiBiNjRUb0Jsb2IoYjY0VXJpVG9CNjQoZ2V0QjY0VXJpKCkpLCBtaW1lVHlwZSk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIGI2NFVyaVRvQjY0KGdldEI2NFVyaSgpKTtcblxuICAgIGNhc2UgJ2Jhc2U2NHVyaSc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBnZXRCNjRVcmkoKTtcbiAgfVxufVxuXG5DUnAkOC5wbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gb3V0cHV0KG9wdGlvbnMsIHRoaXMuYnVmZmVyQ2FudmFzSW1hZ2Uob3B0aW9ucyksICdpbWFnZS9wbmcnKTtcbn07XG5cbkNScCQ4LmpwZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBvdXRwdXQob3B0aW9ucywgdGhpcy5idWZmZXJDYW52YXNJbWFnZShvcHRpb25zKSwgJ2ltYWdlL2pwZWcnKTtcbn07XG5cbnZhciBDUnAkOSA9IHt9O1xuXG5DUnAkOS5ub2RlU2hhcGVJbXBsID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdlbGxpcHNlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdFbGxpcHNlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGNhc2UgJ3BvbHlnb24nOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd1BvbHlnb25QYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyk7XG5cbiAgICBjYXNlICdyb3VuZC1wb2x5Z29uJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdSb3VuZFBvbHlnb25QYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyk7XG5cbiAgICBjYXNlICdyb3VuZHJlY3RhbmdsZSc6XG4gICAgY2FzZSAncm91bmQtcmVjdGFuZ2xlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBjYXNlICdjdXRyZWN0YW5nbGUnOlxuICAgIGNhc2UgJ2N1dC1yZWN0YW5nbGUnOlxuICAgICAgcmV0dXJuIHRoaXMuZHJhd0N1dFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBjYXNlICdib3R0b21yb3VuZHJlY3RhbmdsZSc6XG4gICAgY2FzZSAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3Qm90dG9tUm91bmRSZWN0YW5nbGVQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgY2FzZSAnYmFycmVsJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdCYXJyZWxQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG59O1xuXG52YXIgQ1IgPSBDYW52YXNSZW5kZXJlcjtcbnZhciBDUnAkYSA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcbkNScCRhLkNBTlZBU19MQVlFUlMgPSAzOyAvL1xuXG5DUnAkYS5TRUxFQ1RfQk9YID0gMDtcbkNScCRhLkRSQUcgPSAxO1xuQ1JwJGEuTk9ERSA9IDI7XG5DUnAkYS5CVUZGRVJfQ09VTlQgPSAzOyAvL1xuXG5DUnAkYS5URVhUVVJFX0JVRkZFUiA9IDA7XG5DUnAkYS5NT1RJT05CTFVSX0JVRkZFUl9OT0RFID0gMTtcbkNScCRhLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgPSAyO1xuXG5mdW5jdGlvbiBDYW52YXNSZW5kZXJlcihvcHRpb25zKSB7XG4gIHZhciByID0gdGhpcztcbiAgci5kYXRhID0ge1xuICAgIGNhbnZhc2VzOiBuZXcgQXJyYXkoQ1JwJGEuQ0FOVkFTX0xBWUVSUyksXG4gICAgY29udGV4dHM6IG5ldyBBcnJheShDUnAkYS5DQU5WQVNfTEFZRVJTKSxcbiAgICBjYW52YXNOZWVkc1JlZHJhdzogbmV3IEFycmF5KENScCRhLkNBTlZBU19MQVlFUlMpLFxuICAgIGJ1ZmZlckNhbnZhc2VzOiBuZXcgQXJyYXkoQ1JwJGEuQlVGRkVSX0NPVU5UKSxcbiAgICBidWZmZXJDb250ZXh0czogbmV3IEFycmF5KENScCRhLkNBTlZBU19MQVlFUlMpXG4gIH07XG4gIHZhciB0YXBIbE9mZkF0dHIgPSAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJztcbiAgdmFyIHRhcEhsT2ZmU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gIHIuZGF0YS5jYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIHZhciBjb250YWluZXJTdHlsZSA9IHIuZGF0YS5jYW52YXNDb250YWluZXIuc3R5bGU7XG4gIHIuZGF0YS5jYW52YXNDb250YWluZXIuc3R5bGVbdGFwSGxPZmZBdHRyXSA9IHRhcEhsT2ZmU3R5bGU7XG4gIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgY29udGFpbmVyU3R5bGUuekluZGV4ID0gJzAnO1xuICBjb250YWluZXJTdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKHIuZGF0YS5jYW52YXNDb250YWluZXIpO1xuICBjb250YWluZXIuc3R5bGVbdGFwSGxPZmZBdHRyXSA9IHRhcEhsT2ZmU3R5bGU7XG4gIHZhciBzdHlsZU1hcCA9IHtcbiAgICAnLXdlYmtpdC11c2VyLXNlbGVjdCc6ICdub25lJyxcbiAgICAnLW1vei11c2VyLXNlbGVjdCc6ICctbW96LW5vbmUnLFxuICAgICd1c2VyLXNlbGVjdCc6ICdub25lJyxcbiAgICAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJzogJ3JnYmEoMCwwLDAsMCknLFxuICAgICdvdXRsaW5lLXN0eWxlJzogJ25vbmUnXG4gIH07XG5cbiAgaWYgKG1zKCkpIHtcbiAgICBzdHlsZU1hcFsnLW1zLXRvdWNoLWFjdGlvbiddID0gJ25vbmUnO1xuICAgIHN0eWxlTWFwWyd0b3VjaC1hY3Rpb24nXSA9ICdub25lJztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQ1JwJGEuQ0FOVkFTX0xBWUVSUzsgaSsrKSB7XG4gICAgdmFyIGNhbnZhcyA9IHIuZGF0YS5jYW52YXNlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICByLmRhdGEuY29udGV4dHNbaV0gPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZU1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgY2FudmFzLnN0eWxlW2tdID0gc3R5bGVNYXBba107XG4gICAgfSk7XG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIGkpO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBTdHJpbmcoQ1JwJGEuQ0FOVkFTX0xBWUVSUyAtIGkpO1xuICAgIHIuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbaV0gPSBmYWxzZTtcbiAgfVxuXG4gIHIuZGF0YS50b3BDYW52YXMgPSByLmRhdGEuY2FudmFzZXNbMF07XG4gIHIuZGF0YS5jYW52YXNlc1tDUnAkYS5OT0RFXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwJGEuTk9ERSArICctbm9kZScpO1xuICByLmRhdGEuY2FudmFzZXNbQ1JwJGEuU0VMRUNUX0JPWF0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScCRhLlNFTEVDVF9CT1ggKyAnLXNlbGVjdGJveCcpO1xuICByLmRhdGEuY2FudmFzZXNbQ1JwJGEuRFJBR10uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScCRhLkRSQUcgKyAnLWRyYWcnKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IENScCRhLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIHIuZGF0YS5idWZmZXJDb250ZXh0c1tpXSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdidWZmZXInICsgaSk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnpJbmRleCA9IFN0cmluZygtaSAtIDEpO1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7IC8vci5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZChyLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0pO1xuICB9XG5cbiAgci5wYXRoc0VuYWJsZWQgPSB0cnVlO1xuICB2YXIgZW1wdHlCYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuXG4gIHZhciBnZXRCb3hDZW50ZXIgPSBmdW5jdGlvbiBnZXRCb3hDZW50ZXIoYmIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogKGJiLngxICsgYmIueDIpIC8gMixcbiAgICAgIHk6IChiYi55MSArIGJiLnkyKSAvIDJcbiAgICB9O1xuICB9O1xuXG4gIHZhciBnZXRDZW50ZXJPZmZzZXQgPSBmdW5jdGlvbiBnZXRDZW50ZXJPZmZzZXQoYmIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogLWJiLncgLyAyLFxuICAgICAgeTogLWJiLmggLyAyXG4gICAgfTtcbiAgfTtcblxuICB2YXIgYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQgPSBmdW5jdGlvbiBiYWNrZ3JvdW5kVGltZXN0YW1wSGFzQ2hhbmdlZChlbGUpIHtcbiAgICB2YXIgX3AgPSBlbGVbMF0uX3ByaXZhdGU7XG4gICAgdmFyIHNhbWUgPSBfcC5vbGRCYWNrZ3JvdW5kVGltZXN0YW1wID09PSBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wO1xuICAgIHJldHVybiAhc2FtZTtcbiAgfTtcblxuICB2YXIgZ2V0U3R5bGVLZXkgPSBmdW5jdGlvbiBnZXRTdHlsZUtleShlbGUpIHtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLm5vZGVLZXk7XG4gIH07XG5cbiAgdmFyIGdldExhYmVsS2V5ID0gZnVuY3Rpb24gZ2V0TGFiZWxLZXkoZWxlKSB7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbFN0eWxlS2V5O1xuICB9O1xuXG4gIHZhciBnZXRTb3VyY2VMYWJlbEtleSA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsS2V5KGVsZSkge1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUuc291cmNlTGFiZWxTdHlsZUtleTtcbiAgfTtcblxuICB2YXIgZ2V0VGFyZ2V0TGFiZWxLZXkgPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbEtleShlbGUpIHtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLnRhcmdldExhYmVsU3R5bGVLZXk7XG4gIH07XG5cbiAgdmFyIGRyYXdFbGVtZW50ID0gZnVuY3Rpb24gZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgIHJldHVybiByLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSwgYmIsIGZhbHNlLCBmYWxzZSwgdXNlRWxlT3BhY2l0eSk7XG4gIH07XG5cbiAgdmFyIGRyYXdMYWJlbCA9IGZ1bmN0aW9uIGRyYXdMYWJlbChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgcmV0dXJuIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sICdtYWluJywgdXNlRWxlT3BhY2l0eSk7XG4gIH07XG5cbiAgdmFyIGRyYXdTb3VyY2VMYWJlbCA9IGZ1bmN0aW9uIGRyYXdTb3VyY2VMYWJlbChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgcmV0dXJuIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sICdzb3VyY2UnLCB1c2VFbGVPcGFjaXR5KTtcbiAgfTtcblxuICB2YXIgZHJhd1RhcmdldExhYmVsID0gZnVuY3Rpb24gZHJhd1RhcmdldExhYmVsKGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICByZXR1cm4gci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgJ3RhcmdldCcsIHVzZUVsZU9wYWNpdHkpO1xuICB9O1xuXG4gIHZhciBnZXRFbGVtZW50Qm94ID0gZnVuY3Rpb24gZ2V0RWxlbWVudEJveChlbGUpIHtcbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmJvZHlCb3VuZHM7XG4gIH07XG5cbiAgdmFyIGdldExhYmVsQm94ID0gZnVuY3Rpb24gZ2V0TGFiZWxCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy5tYWluIHx8IGVtcHR5QmI7XG4gIH07XG5cbiAgdmFyIGdldFNvdXJjZUxhYmVsQm94ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy5zb3VyY2UgfHwgZW1wdHlCYjtcbiAgfTtcblxuICB2YXIgZ2V0VGFyZ2V0TGFiZWxCb3ggPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbEJveChlbGUpIHtcbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsQm91bmRzLnRhcmdldCB8fCBlbXB0eUJiO1xuICB9O1xuXG4gIHZhciBpc0xhYmVsVmlzaWJsZUF0U2NhbGUgPSBmdW5jdGlvbiBpc0xhYmVsVmlzaWJsZUF0U2NhbGUoZWxlLCBzY2FsZWRMYWJlbFNob3duKSB7XG4gICAgcmV0dXJuIHNjYWxlZExhYmVsU2hvd247XG4gIH07XG5cbiAgdmFyIGdldEVsZW1lbnRSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGdldEJveENlbnRlcihnZXRFbGVtZW50Qm94KGVsZSkpO1xuICB9O1xuXG4gIHZhciBhZGRUZXh0TWFyZ2luID0gZnVuY3Rpb24gYWRkVGV4dE1hcmdpbihwcmVmaXgsIHB0LCBlbGUpIHtcbiAgICB2YXIgcHJlID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHB0LnggKyBlbGUucHN0eWxlKHByZSArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZSxcbiAgICAgIHk6IHB0LnkgKyBlbGUucHN0eWxlKHByZSArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGdldFJzUHQgPSBmdW5jdGlvbiBnZXRSc1B0KGVsZSwgeCwgeSkge1xuICAgIHZhciBycyA9IGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcnNbeF0sXG4gICAgICB5OiByc1t5XVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGdldExhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICByZXR1cm4gYWRkVGV4dE1hcmdpbignJywgZ2V0UnNQdChlbGUsICdsYWJlbFgnLCAnbGFiZWxZJyksIGVsZSk7XG4gIH07XG5cbiAgdmFyIGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICByZXR1cm4gYWRkVGV4dE1hcmdpbignc291cmNlJywgZ2V0UnNQdChlbGUsICdzb3VyY2VMYWJlbFgnLCAnc291cmNlTGFiZWxZJyksIGVsZSk7XG4gIH07XG5cbiAgdmFyIGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICByZXR1cm4gYWRkVGV4dE1hcmdpbigndGFyZ2V0JywgZ2V0UnNQdChlbGUsICd0YXJnZXRMYWJlbFgnLCAndGFyZ2V0TGFiZWxZJyksIGVsZSk7XG4gIH07XG5cbiAgdmFyIGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICByZXR1cm4gZ2V0Q2VudGVyT2Zmc2V0KGdldEVsZW1lbnRCb3goZWxlKSk7XG4gIH07XG5cbiAgdmFyIGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgIHJldHVybiBnZXRDZW50ZXJPZmZzZXQoZ2V0U291cmNlTGFiZWxCb3goZWxlKSk7XG4gIH07XG5cbiAgdmFyIGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgIHJldHVybiBnZXRDZW50ZXJPZmZzZXQoZ2V0VGFyZ2V0TGFiZWxCb3goZWxlKSk7XG4gIH07XG5cbiAgdmFyIGdldExhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgIHZhciBiYiA9IGdldExhYmVsQm94KGVsZSk7XG4gICAgdmFyIHAgPSBnZXRDZW50ZXJPZmZzZXQoZ2V0TGFiZWxCb3goZWxlKSk7XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICBzd2l0Y2ggKGVsZS5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgcC54ID0gLWJiLnc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHAueCA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZWxlLnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHAueSA9IC1iYi5oO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgcC55ID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICB2YXIgZWxlVHhyQ2FjaGUgPSByLmRhdGEuZWxlVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgZ2V0S2V5OiBnZXRTdHlsZUtleSxcbiAgICBkb2VzRWxlSW52YWxpZGF0ZUtleTogYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQsXG4gICAgZHJhd0VsZW1lbnQ6IGRyYXdFbGVtZW50LFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRFbGVtZW50Qm94LFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldEVsZW1lbnRSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRFbGVtZW50Um90YXRpb25PZmZzZXQsXG4gICAgYWxsb3dFZGdlVHhyQ2FjaGluZzogZmFsc2UsXG4gICAgYWxsb3dQYXJlbnRUeHJDYWNoaW5nOiBmYWxzZVxuICB9KTtcbiAgdmFyIGxibFR4ckNhY2hlID0gci5kYXRhLmxibFR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgIGdldEtleTogZ2V0TGFiZWxLZXksXG4gICAgZHJhd0VsZW1lbnQ6IGRyYXdMYWJlbCxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0TGFiZWxCb3gsXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0TGFiZWxSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGVBdFNjYWxlXG4gIH0pO1xuICB2YXIgc2xiVHhyQ2FjaGUgPSByLmRhdGEuc2xiVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgZ2V0S2V5OiBnZXRTb3VyY2VMYWJlbEtleSxcbiAgICBkcmF3RWxlbWVudDogZHJhd1NvdXJjZUxhYmVsLFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRTb3VyY2VMYWJlbEJveCxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZUF0U2NhbGVcbiAgfSk7XG4gIHZhciB0bGJUeHJDYWNoZSA9IHIuZGF0YS50bGJUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICBnZXRLZXk6IGdldFRhcmdldExhYmVsS2V5LFxuICAgIGRyYXdFbGVtZW50OiBkcmF3VGFyZ2V0TGFiZWwsXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldFRhcmdldExhYmVsQm94LFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlQXRTY2FsZVxuICB9KTtcbiAgdmFyIGx5clR4ckNhY2hlID0gci5kYXRhLmx5clR4ckNhY2hlID0gbmV3IExheWVyZWRUZXh0dXJlQ2FjaGUocik7XG4gIHIub25VcGRhdGVFbGVDYWxjcyhmdW5jdGlvbiBpbnZhbGlkYXRlVGV4dHVyZUNhY2hlcyh3aWxsRHJhdywgZWxlcykge1xuICAgIC8vIGVhY2ggY2FjaGUgc2hvdWxkIGNoZWNrIGZvciBzdWIta2V5IGRpZmYgdG8gc2VlIHRoYXQgdGhlIHVwZGF0ZSBhZmZlY3RzIHRoYXQgY2FjaGUgcGFydGljdWxhcmx5XG4gICAgZWxlVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuICAgIGxibFR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcbiAgICBzbGJUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG4gICAgdGxiVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpOyAvLyBhbnkgY2hhbmdlIGludmFsaWRhdGVzIHRoZSBsYXllcnNcblxuICAgIGx5clR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTsgLy8gdXBkYXRlIHRoZSBvbGQgYmcgdGltZXN0YW1wIHNvIGRpZmZzIGNhbiBiZSBkb25lIGluIHRoZSBlbGUgdHhyIGNhY2hlc1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3AgPSBlbGVzW19pXS5fcHJpdmF0ZTtcbiAgICAgIF9wLm9sZEJhY2tncm91bmRUaW1lc3RhbXAgPSBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHJlZmluZUluTGF5ZXJzID0gZnVuY3Rpb24gcmVmaW5lSW5MYXllcnMocmVxcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVxcy5sZW5ndGg7IGkrKykge1xuICAgICAgbHlyVHhyQ2FjaGUuZW5xdWV1ZUVsZW1lbnRSZWZpbmVtZW50KHJlcXNbaV0uZWxlKTtcbiAgICB9XG4gIH07XG5cbiAgZWxlVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgbGJsVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgc2xiVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgdGxiVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbn1cblxuQ1JwJGEucmVkcmF3SGludCA9IGZ1bmN0aW9uIChncm91cCwgYm9vbCkge1xuICB2YXIgciA9IHRoaXM7XG5cbiAgc3dpdGNoIChncm91cCkge1xuICAgIGNhc2UgJ2VsZXMnOlxuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NScCRhLk5PREVdID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZHJhZyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwJGEuRFJBR10gPSBib29sO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NScCRhLlNFTEVDVF9CT1hdID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuICB9XG59OyAvLyB3aGV0aGVyIHRvIHVzZSBQYXRoMkQgY2FjaGluZyBmb3IgZHJhd2luZ1xuXG5cbnZhciBwYXRoc0ltcGxkID0gdHlwZW9mIFBhdGgyRCAhPT0gJ3VuZGVmaW5lZCc7XG5cbkNScCRhLnBhdGgyZEVuYWJsZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoc0VuYWJsZWQ7XG4gIH1cblxuICB0aGlzLnBhdGhzRW5hYmxlZCA9IG9uID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxuQ1JwJGEudXNlUGF0aHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwYXRoc0ltcGxkICYmIHRoaXMucGF0aHNFbmFibGVkO1xufTtcblxuQ1JwJGEuc2V0SW1nU21vb3RoaW5nID0gZnVuY3Rpb24gKGNvbnRleHQsIGJvb2wpIHtcbiAgaWYgKGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9IG51bGwpIHtcbiAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgICBjb250ZXh0Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgfVxufTtcblxuQ1JwJGEuZ2V0SW1nU21vb3RoaW5nID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9IG51bGwpIHtcbiAgICByZXR1cm4gY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRleHQud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gIH1cbn07XG5cbkNScCRhLm1ha2VPZmZzY3JlZW5DYW52YXMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICB2YXIgY2FudmFzO1xuXG4gIGlmICgodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKE9mZnNjcmVlbkNhbnZhcykpICE9PSAoIFwidW5kZWZpbmVkXCIgKSkge1xuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICByZXR1cm4gY2FudmFzO1xufTtcblxuW0NScCwgQ1JwJDEsIENScCQyLCBDUnAkMywgQ1JwJDQsIENScCQ1LCBDUnAkNiwgQ1JwJDcsIENScCQ4LCBDUnAkOV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKENScCRhLCBwcm9wcyk7XG59KTtcblxudmFyIHJlbmRlcmVyID0gW3tcbiAgbmFtZTogJ251bGwnLFxuICBpbXBsOiBOdWxsUmVuZGVyZXJcbn0sIHtcbiAgbmFtZTogJ2Jhc2UnLFxuICBpbXBsOiBCUlxufSwge1xuICBuYW1lOiAnY2FudmFzJyxcbiAgaW1wbDogQ1Jcbn1dO1xuXG52YXIgaW5jRXh0cyA9IFt7XG4gIHR5cGU6ICdsYXlvdXQnLFxuICBleHRlbnNpb25zOiBsYXlvdXRcbn0sIHtcbiAgdHlwZTogJ3JlbmRlcmVyJyxcbiAgZXh0ZW5zaW9uczogcmVuZGVyZXJcbn1dO1xuXG52YXIgZXh0ZW5zaW9ucyA9IHt9OyAvLyByZWdpc3RlcmVkIG1vZHVsZXMgZm9yIGV4dGVuc2lvbnMsIGluZGV4ZWQgYnkgbmFtZVxuXG52YXIgbW9kdWxlcyA9IHt9O1xuXG5mdW5jdGlvbiBzZXRFeHRlbnNpb24odHlwZSwgbmFtZSwgcmVnaXN0cmFudCkge1xuICB2YXIgZXh0ID0gcmVnaXN0cmFudDtcblxuICB2YXIgb3ZlcnJpZGVFcnIgPSBmdW5jdGlvbiBvdmVycmlkZUVycihmaWVsZCkge1xuICAgIGVycm9yKCdDYW4gbm90IHJlZ2lzdGVyIGAnICsgbmFtZSArICdgIGZvciBgJyArIHR5cGUgKyAnYCBzaW5jZSBgJyArIGZpZWxkICsgJ2AgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHByb3RvdHlwZSBhbmQgY2FuIG5vdCBiZSBvdmVycmlkZGVuJyk7XG4gIH07XG5cbiAgaWYgKHR5cGUgPT09ICdjb3JlJykge1xuICAgIGlmIChDb3JlLnByb3RvdHlwZVtuYW1lXSkge1xuICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb3JlLnByb3RvdHlwZVtuYW1lXSA9IHJlZ2lzdHJhbnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb2xsZWN0aW9uJykge1xuICAgIGlmIChDb2xsZWN0aW9uLnByb3RvdHlwZVtuYW1lXSkge1xuICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVtuYW1lXSA9IHJlZ2lzdHJhbnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsYXlvdXQnKSB7XG4gICAgLy8gZmlsbCBpbiBtaXNzaW5nIGxheW91dCBmdW5jdGlvbnMgaW4gdGhlIHByb3RvdHlwZVxuICAgIHZhciBMYXlvdXQgPSBmdW5jdGlvbiBMYXlvdXQob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHJlZ2lzdHJhbnQuY2FsbCh0aGlzLCBvcHRpb25zKTsgLy8gbWFrZSBzdXJlIGxheW91dCBoYXMgX3ByaXZhdGUgZm9yIHVzZSB3LyBzdGQgYXBpcyBsaWtlIC5vbigpXG5cbiAgICAgIGlmICghcGxhaW5PYmplY3QodGhpcy5fcHJpdmF0ZSkpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcml2YXRlLmN5ID0gb3B0aW9ucy5jeTtcbiAgICAgIHRoaXMuX3ByaXZhdGUubGlzdGVuZXJzID0gW107XG4gICAgICB0aGlzLmNyZWF0ZUVtaXR0ZXIoKTtcbiAgICB9O1xuXG4gICAgdmFyIGxheW91dFByb3RvID0gTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocmVnaXN0cmFudC5wcm90b3R5cGUpO1xuICAgIHZhciBvcHRMYXlvdXRGbnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0TGF5b3V0Rm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZm5OYW1lID0gb3B0TGF5b3V0Rm5zW2ldO1xuXG4gICAgICBsYXlvdXRQcm90b1tmbk5hbWVdID0gbGF5b3V0UHJvdG9bZm5OYW1lXSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9IC8vIGVpdGhlciAuc3RhcnQoKSBvciAucnVuKCkgaXMgZGVmaW5lZCwgc28gYXV0b2dlbiB0aGUgb3RoZXJcblxuXG4gICAgaWYgKGxheW91dFByb3RvLnN0YXJ0ICYmICFsYXlvdXRQcm90by5ydW4pIHtcbiAgICAgIGxheW91dFByb3RvLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICghbGF5b3V0UHJvdG8uc3RhcnQgJiYgbGF5b3V0UHJvdG8ucnVuKSB7XG4gICAgICBsYXlvdXRQcm90by5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciByZWdTdG9wID0gcmVnaXN0cmFudC5wcm90b3R5cGUuc3RvcDtcblxuICAgIGxheW91dFByb3RvLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5hbmltYXRlKSB7XG4gICAgICAgIHZhciBhbmlzID0gdGhpcy5hbmltYXRpb25zO1xuXG4gICAgICAgIGlmIChhbmlzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFuaXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhbmlzW19pXS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWdTdG9wKSB7XG4gICAgICAgIHJlZ1N0b3AuY2FsbCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbGF5b3V0c3RvcCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgaWYgKCFsYXlvdXRQcm90by5kZXN0cm95KSB7XG4gICAgICBsYXlvdXRQcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGF5b3V0UHJvdG8uY3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEN5ID0gZnVuY3Rpb24gZ2V0Q3kobGF5b3V0KSB7XG4gICAgICByZXR1cm4gbGF5b3V0Ll9wcml2YXRlLmN5O1xuICAgIH07XG5cbiAgICB2YXIgZW1pdHRlck9wdHMgPSB7XG4gICAgICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMobGF5b3V0LCBldnQpIHtcbiAgICAgICAgZXZ0LmxheW91dCA9IGxheW91dDtcbiAgICAgICAgZXZ0LmN5ID0gZ2V0Q3kobGF5b3V0KTtcbiAgICAgICAgZXZ0LnRhcmdldCA9IGxheW91dDtcbiAgICAgIH0sXG4gICAgICBidWJibGU6IGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQobGF5b3V0KSB7XG4gICAgICAgIHJldHVybiBnZXRDeShsYXlvdXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXh0ZW5kKGxheW91dFByb3RvLCB7XG4gICAgICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcihlbWl0dGVyT3B0cywgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGVtaXR0ZXI6IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gICAgICB9LFxuICAgICAgb246IGZ1bmN0aW9uIG9uKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub24oZXZ0LCBjYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG9uZTogZnVuY3Rpb24gb25lKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2dCwgY2IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2dCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2dCwgY2IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihldnQsIGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2dCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoZXZ0LCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmUkMy5ldmVudEFsaWFzZXNPbihsYXlvdXRQcm90byk7XG4gICAgZXh0ID0gTGF5b3V0OyAvLyByZXBsYWNlIHdpdGggb3VyIHdyYXBwZWQgbGF5b3V0XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlbmRlcmVyJyAmJiBuYW1lICE9PSAnbnVsbCcgJiYgbmFtZSAhPT0gJ2Jhc2UnKSB7XG4gICAgLy8gdXNlciByZWdpc3RlcmVkIHJlbmRlcmVycyBpbmhlcml0IGZyb20gYmFzZVxuICAgIHZhciBCYXNlUmVuZGVyZXIgPSBnZXRFeHRlbnNpb24oJ3JlbmRlcmVyJywgJ2Jhc2UnKTtcbiAgICB2YXIgYlByb3RvID0gQmFzZVJlbmRlcmVyLnByb3RvdHlwZTtcbiAgICB2YXIgUmVnaXN0cmFudFJlbmRlcmVyID0gcmVnaXN0cmFudDtcbiAgICB2YXIgclByb3RvID0gcmVnaXN0cmFudC5wcm90b3R5cGU7XG5cbiAgICB2YXIgUmVuZGVyZXIgPSBmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgICAgIEJhc2VSZW5kZXJlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgUmVnaXN0cmFudFJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHZhciBwcm90byA9IFJlbmRlcmVyLnByb3RvdHlwZTtcblxuICAgIGZvciAodmFyIHBOYW1lIGluIGJQcm90bykge1xuICAgICAgdmFyIHBWYWwgPSBiUHJvdG9bcE5hbWVdO1xuICAgICAgdmFyIGV4aXN0c0luUiA9IHJQcm90b1twTmFtZV0gIT0gbnVsbDtcblxuICAgICAgaWYgKGV4aXN0c0luUikge1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGVFcnIocE5hbWUpO1xuICAgICAgfVxuXG4gICAgICBwcm90b1twTmFtZV0gPSBwVmFsOyAvLyB0YWtlIGltcGwgZnJvbSBiYXNlXG4gICAgfVxuXG4gICAgZm9yICh2YXIgX3BOYW1lIGluIHJQcm90bykge1xuICAgICAgcHJvdG9bX3BOYW1lXSA9IHJQcm90b1tfcE5hbWVdOyAvLyB0YWtlIGltcGwgZnJvbSByZWdpc3RyYW50XG4gICAgfVxuXG4gICAgYlByb3RvLmNsaWVudEZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBwcm90b1tuYW1lXSA9IHByb3RvW25hbWVdIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXJyb3IoJ1JlbmRlcmVyIGRvZXMgbm90IGltcGxlbWVudCBgcmVuZGVyZXIuJyArIG5hbWUgKyAnKClgIG9uIGl0cyBwcm90b3R5cGUnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgZXh0ID0gUmVuZGVyZXI7XG4gIH1cblxuICByZXR1cm4gc2V0TWFwKHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogW3R5cGUsIG5hbWVdLFxuICAgIHZhbHVlOiBleHRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbih0eXBlLCBuYW1lKSB7XG4gIHJldHVybiBnZXRNYXAoe1xuICAgIG1hcDogZXh0ZW5zaW9ucyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZV1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lLCByZWdpc3RyYW50KSB7XG4gIHJldHVybiBzZXRNYXAoe1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZV0sXG4gICAgdmFsdWU6IHJlZ2lzdHJhbnRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lKSB7XG4gIHJldHVybiBnZXRNYXAoe1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZV1cbiAgfSk7XG59XG5cbnZhciBleHRlbnNpb24gPSBmdW5jdGlvbiBleHRlbnNpb24oKSB7XG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnKVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBnZXRFeHRlbnNpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfSAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgeyAuLi4gfSlcbiAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIHNldEV4dGVuc2lvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0gLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScpXG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gZ2V0TW9kdWxlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9IC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZVNoYXBlJywgJ2VsbGlwc2UnLCB7IC4uLiB9KVxuICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgIHJldHVybiBzZXRNb2R1bGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcignSW52YWxpZCBleHRlbnNpb24gYWNjZXNzIHN5bnRheCcpO1xuICAgICAgICB9XG59OyAvLyBhbGxvd3MgYSBjb3JlIGluc3RhbmNlIHRvIGFjY2VzcyBleHRlbnNpb25zIGludGVybmFsbHlcblxuXG5Db3JlLnByb3RvdHlwZS5leHRlbnNpb24gPSBleHRlbnNpb247IC8vIGluY2x1ZGVkIGV4dGVuc2lvbnNcblxuaW5jRXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICBncm91cC5leHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuICAgIHNldEV4dGVuc2lvbihncm91cC50eXBlLCBleHQubmFtZSwgZXh0LmltcGwpO1xuICB9KTtcbn0pO1xuXG4vLyAodXNlZnVsIGZvciBpbml0KVxuXG52YXIgU3R5bGVzaGVldCA9IGZ1bmN0aW9uIFN0eWxlc2hlZXQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHlsZXNoZWV0KSkge1xuICAgIHJldHVybiBuZXcgU3R5bGVzaGVldCgpO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxudmFyIHNoZWV0Zm4gPSBTdHlsZXNoZWV0LnByb3RvdHlwZTtcblxuc2hlZXRmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdzdHlsZXNoZWV0Jztcbn07IC8vIGp1c3Qgc3RvcmUgdGhlIHNlbGVjdG9yIHRvIGJlIHBhcnNlZCBsYXRlclxuXG5cbnNoZWV0Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrO1xuICB0aGlzW2ldID0ge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBwcm9wZXJ0aWVzOiBbXVxuICB9O1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07IC8vIGp1c3Qgc3RvcmUgdGhlIHByb3BlcnR5IHRvIGJlIHBhcnNlZCBsYXRlclxuXG5cbnNoZWV0Zm4uY3NzID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuXG4gIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICB2YXIgbWFwID0gbmFtZTtcbiAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcE5hbWVzW2pdO1xuICAgICAgdmFyIG1hcFZhbCA9IG1hcFtrZXldO1xuXG4gICAgICBpZiAobWFwVmFsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wID0gU3R5bGUucHJvcGVydGllc1trZXldIHx8IFN0eWxlLnByb3BlcnRpZXNbZGFzaDJjYW1lbChrZXkpXTtcblxuICAgICAgaWYgKHByb3AgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgdmFyIF92YWx1ZSA9IG1hcFZhbDtcbiAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogX25hbWUsXG4gICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc2hlZXRmbi5zdHlsZSA9IHNoZWV0Zm4uY3NzOyAvLyBnZW5lcmF0ZSBhIHJlYWwgc3R5bGUgb2JqZWN0IGZyb20gdGhlIGR1bW15IHN0eWxlc2hlZXRcblxuc2hlZXRmbi5nZW5lcmF0ZVN0eWxlID0gZnVuY3Rpb24gKGN5KSB7XG4gIHZhciBzdHlsZSA9IG5ldyBTdHlsZShjeSk7XG4gIHJldHVybiB0aGlzLmFwcGVuZFRvU3R5bGUoc3R5bGUpO1xufTsgLy8gYXBwZW5kIGEgZHVtbXkgc3R5bGVzaGVldCBvYmplY3Qgb24gYSByZWFsIHN0eWxlIG9iamVjdFxuXG5cbnNoZWV0Zm4uYXBwZW5kVG9TdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXNbaV07XG4gICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnByb3BlcnRpZXM7XG4gICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3IpOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgIHN0eWxlLmNzcyhwcm9wLm5hbWUsIHByb3AudmFsdWUpOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnZhciB2ZXJzaW9uID0gXCIzLjEyLjFcIjtcblxudmFyIGN5dG9zY2FwZSA9IGZ1bmN0aW9uIGN5dG9zY2FwZShvcHRpb25zKSB7XG4gIC8vIGlmIG5vIG9wdGlvbnMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdFxuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IC8vIGNyZWF0ZSBpbnN0YW5jZVxuXG5cbiAgaWYgKHBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb3JlKG9wdGlvbnMpO1xuICB9IC8vIGFsbG93IGZvciByZWdpc3RyYXRpb24gb2YgZXh0ZW5zaW9uc1xuICBlbHNlIGlmIChzdHJpbmcob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBleHRlbnNpb24uYXBwbHkoZXh0ZW5zaW9uLCBhcmd1bWVudHMpO1xuICAgIH1cbn07IC8vIGUuZy4gY3l0b3NjYXBlLnVzZSggcmVxdWlyZSgnY3l0b3NjYXBlLWZvbycpLCBiYXIgKVxuXG5cbmN5dG9zY2FwZS51c2UgPSBmdW5jdGlvbiAoZXh0KSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gYXJncyB0byBwYXNzIHRvIGV4dFxuXG4gIGFyZ3MudW5zaGlmdChjeXRvc2NhcGUpOyAvLyBjeXRvc2NhcGUgaXMgZmlyc3QgYXJnIHRvIGV4dFxuXG4gIGV4dC5hcHBseShudWxsLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5jeXRvc2NhcGUud2FybmluZ3MgPSBmdW5jdGlvbiAoYm9vbCkge1xuICByZXR1cm4gd2FybmluZ3MoYm9vbCk7XG59OyAvLyByZXBsYWNlZCBieSBidWlsZCBzeXN0ZW1cblxuXG5jeXRvc2NhcGUudmVyc2lvbiA9IHZlcnNpb247IC8vIGV4cG9zZSBwdWJsaWMgYXBpcyAobW9zdGx5IGZvciBleHRlbnNpb25zKVxuXG5jeXRvc2NhcGUuc3R5bGVzaGVldCA9IGN5dG9zY2FwZS5TdHlsZXNoZWV0ID0gU3R5bGVzaGVldDtcblxubW9kdWxlLmV4cG9ydHMgPSBjeXRvc2NhcGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2hlYXAnKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS44LjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIEhlYXAsIGRlZmF1bHRDbXAsIGZsb29yLCBoZWFwaWZ5LCBoZWFwcG9wLCBoZWFwcHVzaCwgaGVhcHB1c2hwb3AsIGhlYXByZXBsYWNlLCBpbnNvcnQsIG1pbiwgbmxhcmdlc3QsIG5zbWFsbGVzdCwgdXBkYXRlSXRlbSwgX3NpZnRkb3duLCBfc2lmdHVwO1xuXG4gIGZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XG5cblxuICAvKlxuICBEZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gYmUgdXNlZFxuICAgKi9cblxuICBkZWZhdWx0Q21wID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoeCA+IHkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuXG4gIC8qXG4gIEluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXG4gIFxuICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXG4gIFxuICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBhLmxlbmd0aCkgYm91bmQgdGhlIHNsaWNlXG4gIG9mIGEgdG8gYmUgc2VhcmNoZWQuXG4gICAqL1xuXG4gIGluc29ydCA9IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSwgY21wKSB7XG4gICAgdmFyIG1pZDtcbiAgICBpZiAobG8gPT0gbnVsbCkge1xuICAgICAgbG8gPSAwO1xuICAgIH1cbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChsbyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICB9XG4gICAgaWYgKGhpID09IG51bGwpIHtcbiAgICAgIGhpID0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBtaWQgPSBmbG9vcigobG8gKyBoaSkgLyAyKTtcbiAgICAgIGlmIChjbXAoeCwgYVttaWRdKSA8IDApIHtcbiAgICAgICAgaGkgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoW10uc3BsaWNlLmFwcGx5KGEsIFtsbywgbG8gLSBsb10uY29uY2F0KHgpKSwgeCk7XG4gIH07XG5cblxuICAvKlxuICBQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwdXNoID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgYXJyYXkucHVzaChpdGVtKTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAxLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcG9wID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbGFzdGVsdCA9IGFycmF5LnBvcCgpO1xuICAgIGlmIChhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICAgIGFycmF5WzBdID0gbGFzdGVsdDtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cbiAgXG4gIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoZWFwcG9wKCkgZm9sbG93ZWQgYnkgaGVhcHB1c2goKSwgYW5kIGNhbiBiZVxuICBtb3JlIGFwcHJvcHJpYXRlIHdoZW4gdXNpbmcgYSBmaXhlZCBzaXplIGhlYXAuIE5vdGUgdGhhdCB0aGUgdmFsdWVcbiAgcmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZSBvZlxuICB0aGlzIHJvdXRpbmUgdW5sZXNzIHdyaXR0ZW4gYXMgcGFydCBvZiBhIGNvbmRpdGlvbmFsIHJlcGxhY2VtZW50OlxuICAgICAgaWYgaXRlbSA+IGFycmF5WzBdXG4gICAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShhcnJheSwgaXRlbSlcbiAgICovXG5cbiAgaGVhcHJlcGxhY2UgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgYXJyYXlbMF0gPSBpdGVtO1xuICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBGYXN0IHZlcnNpb24gb2YgYSBoZWFwcHVzaCBmb2xsb3dlZCBieSBhIGhlYXBwb3AuXG4gICAqL1xuXG4gIGhlYXBwdXNocG9wID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGFycmF5Lmxlbmd0aCAmJiBjbXAoYXJyYXlbMF0sIGl0ZW0pIDwgMCkge1xuICAgICAgX3JlZiA9IFthcnJheVswXSwgaXRlbV0sIGl0ZW0gPSBfcmVmWzBdLCBhcnJheVswXSA9IF9yZWZbMV07XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFRyYW5zZm9ybSBsaXN0IGludG8gYSBoZWFwLCBpbi1wbGFjZSwgaW4gTyhhcnJheS5sZW5ndGgpIHRpbWUuXG4gICAqL1xuXG4gIGhlYXBpZnkgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgdmFyIGksIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBfcmVmMSA9IChmdW5jdGlvbigpIHtcbiAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgZm9yICh2YXIgX2ogPSAwLCBfcmVmID0gZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0peyBfcmVzdWx0czEucHVzaChfaik7IH1cbiAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgfSkuYXBwbHkodGhpcykucmV2ZXJzZSgpO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgaSA9IF9yZWYxW19pXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goX3NpZnR1cChhcnJheSwgaSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuXG4gIC8qXG4gIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGl0ZW0gaW4gdGhlIGhlYXAuXG4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBpdGVtIGlzIGJlaW5nIG1vZGlmaWVkLlxuICAgKi9cblxuICB1cGRhdGVJdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBwb3MgPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9zaWZ0ZG93bihhcnJheSwgMCwgcG9zLCBjbXApO1xuICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBubGFyZ2VzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pO1xuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShyZXN1bHQsIGNtcCk7XG4gICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgaGVhcHB1c2hwb3AocmVzdWx0LCBlbGVtLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKS5yZXZlcnNlKCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbnNtYWxsZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCBpLCBsb3MsIHJlc3VsdCwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobiAqIDEwIDw9IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbikuc29ydChjbXApO1xuICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKGNtcChlbGVtLCBsb3MpIDwgMCkge1xuICAgICAgICAgIGluc29ydChyZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCk7XG4gICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkoYXJyYXksIGNtcCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGkgPSBfaiA9IDAsIF9yZWYxID0gbWluKG4sIGFycmF5Lmxlbmd0aCk7IDAgPD0gX3JlZjEgPyBfaiA8IF9yZWYxIDogX2ogPiBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19qIDogLS1faikge1xuICAgICAgX3Jlc3VsdHMucHVzaChoZWFwcG9wKGFycmF5LCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIF9zaWZ0ZG93biA9IGZ1bmN0aW9uKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApIHtcbiAgICB2YXIgbmV3aXRlbSwgcGFyZW50LCBwYXJlbnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICB3aGlsZSAocG9zID4gc3RhcnRwb3MpIHtcbiAgICAgIHBhcmVudHBvcyA9IChwb3MgLSAxKSA+PiAxO1xuICAgICAgcGFyZW50ID0gYXJyYXlbcGFyZW50cG9zXTtcbiAgICAgIGlmIChjbXAobmV3aXRlbSwgcGFyZW50KSA8IDApIHtcbiAgICAgICAgYXJyYXlbcG9zXSA9IHBhcmVudDtcbiAgICAgICAgcG9zID0gcGFyZW50cG9zO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gIH07XG5cbiAgX3NpZnR1cCA9IGZ1bmN0aW9uKGFycmF5LCBwb3MsIGNtcCkge1xuICAgIHZhciBjaGlsZHBvcywgZW5kcG9zLCBuZXdpdGVtLCByaWdodHBvcywgc3RhcnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBlbmRwb3MgPSBhcnJheS5sZW5ndGg7XG4gICAgc3RhcnRwb3MgPSBwb3M7XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB3aGlsZSAoY2hpbGRwb3MgPCBlbmRwb3MpIHtcbiAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xuICAgICAgaWYgKHJpZ2h0cG9zIDwgZW5kcG9zICYmICEoY21wKGFycmF5W2NoaWxkcG9zXSwgYXJyYXlbcmlnaHRwb3NdKSA8IDApKSB7XG4gICAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3M7XG4gICAgICB9XG4gICAgICBhcnJheVtwb3NdID0gYXJyYXlbY2hpbGRwb3NdO1xuICAgICAgcG9zID0gY2hpbGRwb3M7XG4gICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIH1cbiAgICBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApO1xuICB9O1xuXG4gIEhlYXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgSGVhcC5wdXNoID0gaGVhcHB1c2g7XG5cbiAgICBIZWFwLnBvcCA9IGhlYXBwb3A7XG5cbiAgICBIZWFwLnJlcGxhY2UgPSBoZWFwcmVwbGFjZTtcblxuICAgIEhlYXAucHVzaHBvcCA9IGhlYXBwdXNocG9wO1xuXG4gICAgSGVhcC5oZWFwaWZ5ID0gaGVhcGlmeTtcblxuICAgIEhlYXAudXBkYXRlSXRlbSA9IHVwZGF0ZUl0ZW07XG5cbiAgICBIZWFwLm5sYXJnZXN0ID0gbmxhcmdlc3Q7XG5cbiAgICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcblxuICAgIGZ1bmN0aW9uIEhlYXAoY21wKSB7XG4gICAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNoKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcHBvcCh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2YoeCkgIT09IC0xO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXByZXBsYWNlKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaHBvcCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmhlYXBpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwaWZ5KHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB1cGRhdGVJdGVtKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggPT09IDA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoZWFwO1xuICAgICAgaGVhcCA9IG5ldyBIZWFwKCk7XG4gICAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgIHJldHVybiBoZWFwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gSGVhcC5wcm90b3R5cGUucHVzaDtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5mcm9udCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oYXMgPSBIZWFwLnByb3RvdHlwZS5jb250YWlucztcblxuICAgIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuICAgIHJldHVybiBIZWFwO1xuXG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICByZXR1cm4gZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm9vdC5IZWFwID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgfSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEhlYXA7XG4gIH0pO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xuICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEFzc2lnbiBjYWNoZSB0byBgXy5tZW1vaXplYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcbiIsInZhciBuLGwsdSx0LGksbyxyLGY9e30sZT1bXSxjPS9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkL2k7ZnVuY3Rpb24gcyhuLGwpe2Zvcih2YXIgdSBpbiBsKW5bdV09bFt1XTtyZXR1cm4gbn1mdW5jdGlvbiBhKG4pe3ZhciBsPW4ucGFyZW50Tm9kZTtsJiZsLnJlbW92ZUNoaWxkKG4pfWZ1bmN0aW9uIGgobixsLHUpe3ZhciB0LGksbyxyLGY9YXJndW1lbnRzO2lmKGw9cyh7fSxsKSxhcmd1bWVudHMubGVuZ3RoPjMpZm9yKHU9W3VdLHQ9Mzt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXUucHVzaChmW3RdKTtpZihudWxsIT11JiYobC5jaGlsZHJlbj11KSxudWxsIT1uJiZudWxsIT1uLmRlZmF1bHRQcm9wcylmb3IoaSBpbiBuLmRlZmF1bHRQcm9wcyl2b2lkIDA9PT1sW2ldJiYobFtpXT1uLmRlZmF1bHRQcm9wc1tpXSk7cmV0dXJuIHI9bC5rZXksbnVsbCE9KG89bC5yZWYpJiZkZWxldGUgbC5yZWYsbnVsbCE9ciYmZGVsZXRlIGwua2V5LHYobixsLHIsbyl9ZnVuY3Rpb24gdihsLHUsdCxpKXt2YXIgbz17dHlwZTpsLHByb3BzOnUsa2V5OnQscmVmOmksX19rOm51bGwsX186bnVsbCxfX2I6MCxfX2U6bnVsbCxfX2Q6bnVsbCxfX2M6bnVsbCxjb25zdHJ1Y3Rvcjp2b2lkIDB9O3JldHVybiBuLnZub2RlJiZuLnZub2RlKG8pLG99ZnVuY3Rpb24gcCgpe3JldHVybnt9fWZ1bmN0aW9uIGQobil7cmV0dXJuIG4uY2hpbGRyZW59ZnVuY3Rpb24geShuLGwpe3RoaXMucHJvcHM9bix0aGlzLmNvbnRleHQ9bH1mdW5jdGlvbiBtKG4sbCl7aWYobnVsbD09bClyZXR1cm4gbi5fXz9tKG4uX18sbi5fXy5fX2suaW5kZXhPZihuKSsxKTpudWxsO2Zvcih2YXIgdTtsPG4uX19rLmxlbmd0aDtsKyspaWYobnVsbCE9KHU9bi5fX2tbbF0pJiZudWxsIT11Ll9fZSlyZXR1cm4gdS5fX2U7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2Ygbi50eXBlP20obik6bnVsbH1mdW5jdGlvbiB3KG4pe3ZhciBsLHU7aWYobnVsbCE9KG49bi5fXykmJm51bGwhPW4uX19jKXtmb3Iobi5fX2U9bi5fX2MuYmFzZT1udWxsLGw9MDtsPG4uX19rLmxlbmd0aDtsKyspaWYobnVsbCE9KHU9bi5fX2tbbF0pJiZudWxsIT11Ll9fZSl7bi5fX2U9bi5fX2MuYmFzZT11Ll9fZTticmVha31yZXR1cm4gdyhuKX19ZnVuY3Rpb24gZyhsKXsoIWwuX19kJiYobC5fX2Q9ITApJiYxPT09dS5wdXNoKGwpfHxpIT09bi5kZWJvdW5jZVJlbmRlcmluZykmJigoaT1uLmRlYm91bmNlUmVuZGVyaW5nKXx8dCkoayl9ZnVuY3Rpb24gaygpe3ZhciBuLGwsdCxpLG8scixmO2Zvcih1LnNvcnQoZnVuY3Rpb24obixsKXtyZXR1cm4gbC5fX3YuX19iLW4uX192Ll9fYn0pO249dS5wb3AoKTspbi5fX2QmJih0PXZvaWQgMCxpPXZvaWQgMCxyPShvPShsPW4pLl9fdikuX19lLChmPWwuX19QKSYmKHQ9W10saT1UKGYsbyxzKHt9LG8pLGwuX19uLHZvaWQgMCE9PWYub3duZXJTVkdFbGVtZW50LG51bGwsdCxudWxsPT1yP20obyk6ciksJCh0LG8pLGkhPXImJncobykpKX1mdW5jdGlvbiBfKG4sbCx1LHQsaSxvLHIsYyxzKXt2YXIgaCx2LHAsZCx5LHcsZyxrPXUmJnUuX19rfHxlLF89ay5sZW5ndGg7aWYoYz09ZiYmKGM9bnVsbCE9bz9vWzBdOl8/bSh1LDApOm51bGwpLGg9MCxsLl9faz1iKGwuX19rLGZ1bmN0aW9uKHUpe2lmKG51bGwhPXUpe2lmKHUuX189bCx1Ll9fYj1sLl9fYisxLG51bGw9PT0ocD1rW2hdKXx8cCYmdS5rZXk9PXAua2V5JiZ1LnR5cGU9PT1wLnR5cGUpa1toXT12b2lkIDA7ZWxzZSBmb3Iodj0wO3Y8Xzt2Kyspe2lmKChwPWtbdl0pJiZ1LmtleT09cC5rZXkmJnUudHlwZT09PXAudHlwZSl7a1t2XT12b2lkIDA7YnJlYWt9cD1udWxsfWlmKGQ9VChuLHUscD1wfHxmLHQsaSxvLHIsYyxzKSwodj11LnJlZikmJnAucmVmIT12JiYoZ3x8KGc9W10pLHAucmVmJiZnLnB1c2gocC5yZWYsbnVsbCx1KSxnLnB1c2godix1Ll9fY3x8ZCx1KSksbnVsbCE9ZCl7aWYobnVsbD09dyYmKHc9ZCksbnVsbCE9dS5fX2QpZD11Ll9fZCx1Ll9fZD1udWxsO2Vsc2UgaWYobz09cHx8ZCE9Y3x8bnVsbD09ZC5wYXJlbnROb2RlKXtuOmlmKG51bGw9PWN8fGMucGFyZW50Tm9kZSE9PW4pbi5hcHBlbmRDaGlsZChkKTtlbHNle2Zvcih5PWMsdj0wOyh5PXkubmV4dFNpYmxpbmcpJiZ2PF87dis9MilpZih5PT1kKWJyZWFrIG47bi5pbnNlcnRCZWZvcmUoZCxjKX1cIm9wdGlvblwiPT1sLnR5cGUmJihuLnZhbHVlPVwiXCIpfWM9ZC5uZXh0U2libGluZyxcImZ1bmN0aW9uXCI9PXR5cGVvZiBsLnR5cGUmJihsLl9fZD1kKX19cmV0dXJuIGgrKyx1fSksbC5fX2U9dyxudWxsIT1vJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBsLnR5cGUpZm9yKGg9by5sZW5ndGg7aC0tOyludWxsIT1vW2hdJiZhKG9baF0pO2ZvcihoPV87aC0tOyludWxsIT1rW2hdJiZBKGtbaF0sa1toXSk7aWYoZylmb3IoaD0wO2g8Zy5sZW5ndGg7aCsrKXooZ1toXSxnWysraF0sZ1srK2hdKX1mdW5jdGlvbiBiKG4sbCx1KXtpZihudWxsPT11JiYodT1bXSksbnVsbD09bnx8XCJib29sZWFuXCI9PXR5cGVvZiBuKWwmJnUucHVzaChsKG51bGwpKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkobikpZm9yKHZhciB0PTA7dDxuLmxlbmd0aDt0KyspYihuW3RdLGwsdSk7ZWxzZSB1LnB1c2gobD9sKFwic3RyaW5nXCI9PXR5cGVvZiBufHxcIm51bWJlclwiPT10eXBlb2Ygbj92KG51bGwsbixudWxsLG51bGwpOm51bGwhPW4uX19lfHxudWxsIT1uLl9fYz92KG4udHlwZSxuLnByb3BzLG4ua2V5LG51bGwpOm4pOm4pO3JldHVybiB1fWZ1bmN0aW9uIHgobixsLHUsdCxpKXt2YXIgbztmb3IobyBpbiB1KW8gaW4gbHx8UChuLG8sbnVsbCx1W29dLHQpO2ZvcihvIGluIGwpaSYmXCJmdW5jdGlvblwiIT10eXBlb2YgbFtvXXx8XCJ2YWx1ZVwiPT09b3x8XCJjaGVja2VkXCI9PT1vfHx1W29dPT09bFtvXXx8UChuLG8sbFtvXSx1W29dLHQpfWZ1bmN0aW9uIEMobixsLHUpe1wiLVwiPT09bFswXT9uLnNldFByb3BlcnR5KGwsdSk6bltsXT1cIm51bWJlclwiPT10eXBlb2YgdSYmITE9PT1jLnRlc3QobCk/dStcInB4XCI6bnVsbD09dT9cIlwiOnV9ZnVuY3Rpb24gUChuLGwsdSx0LGkpe3ZhciBvLHIsZixlLGM7aWYoaT9cImNsYXNzTmFtZVwiPT09bCYmKGw9XCJjbGFzc1wiKTpcImNsYXNzXCI9PT1sJiYobD1cImNsYXNzTmFtZVwiKSxcImtleVwiPT09bHx8XCJjaGlsZHJlblwiPT09bCk7ZWxzZSBpZihcInN0eWxlXCI9PT1sKWlmKG89bi5zdHlsZSxcInN0cmluZ1wiPT10eXBlb2YgdSlvLmNzc1RleHQ9dTtlbHNle2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYoby5jc3NUZXh0PVwiXCIsdD1udWxsKSx0KWZvcihyIGluIHQpdSYmciBpbiB1fHxDKG8scixcIlwiKTtpZih1KWZvcihmIGluIHUpdCYmdVtmXT09PXRbZl18fEMobyxmLHVbZl0pfWVsc2VcIm9cIj09PWxbMF0mJlwiblwiPT09bFsxXT8oZT1sIT09KGw9bC5yZXBsYWNlKC9DYXB0dXJlJC8sXCJcIikpLGM9bC50b0xvd2VyQ2FzZSgpLGw9KGMgaW4gbj9jOmwpLnNsaWNlKDIpLHU/KHR8fG4uYWRkRXZlbnRMaXN0ZW5lcihsLE4sZSksKG4ubHx8KG4ubD17fSkpW2xdPXUpOm4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihsLE4sZSkpOlwibGlzdFwiIT09bCYmXCJ0YWdOYW1lXCIhPT1sJiZcImZvcm1cIiE9PWwmJiFpJiZsIGluIG4/bltsXT1udWxsPT11P1wiXCI6dTpcImZ1bmN0aW9uXCIhPXR5cGVvZiB1JiZcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1sJiYobCE9PShsPWwucmVwbGFjZSgvXnhsaW5rOj8vLFwiXCIpKT9udWxsPT11fHwhMT09PXU/bi5yZW1vdmVBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixsLnRvTG93ZXJDYXNlKCkpOm4uc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsbC50b0xvd2VyQ2FzZSgpLHUpOm51bGw9PXV8fCExPT09dT9uLnJlbW92ZUF0dHJpYnV0ZShsKTpuLnNldEF0dHJpYnV0ZShsLHUpKX1mdW5jdGlvbiBOKGwpe3RoaXMubFtsLnR5cGVdKG4uZXZlbnQ/bi5ldmVudChsKTpsKX1mdW5jdGlvbiBUKGwsdSx0LGksbyxyLGYsZSxjKXt2YXIgYSxoLHYscCxtLHcsZyxrLHgsQyxQPXUudHlwZTtpZih2b2lkIDAhPT11LmNvbnN0cnVjdG9yKXJldHVybiBudWxsOyhhPW4uX19iKSYmYSh1KTt0cnl7bjppZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQKXtpZihrPXUucHJvcHMseD0oYT1QLmNvbnRleHRUeXBlKSYmaVthLl9fY10sQz1hP3g/eC5wcm9wcy52YWx1ZTphLl9fOmksdC5fX2M/Zz0oaD11Ll9fYz10Ll9fYykuX189aC5fX0U6KFwicHJvdG90eXBlXCJpbiBQJiZQLnByb3RvdHlwZS5yZW5kZXI/dS5fX2M9aD1uZXcgUChrLEMpOih1Ll9fYz1oPW5ldyB5KGssQyksaC5jb25zdHJ1Y3Rvcj1QLGgucmVuZGVyPUQpLHgmJnguc3ViKGgpLGgucHJvcHM9ayxoLnN0YXRlfHwoaC5zdGF0ZT17fSksaC5jb250ZXh0PUMsaC5fX249aSx2PWguX19kPSEwLGguX19oPVtdKSxudWxsPT1oLl9fcyYmKGguX19zPWguc3RhdGUpLG51bGwhPVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiYoaC5fX3M9PWguc3RhdGUmJihoLl9fcz1zKHt9LGguX19zKSkscyhoLl9fcyxQLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhrLGguX19zKSkpLHA9aC5wcm9wcyxtPWguc3RhdGUsdiludWxsPT1QLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmbnVsbCE9aC5jb21wb25lbnRXaWxsTW91bnQmJmguY29tcG9uZW50V2lsbE1vdW50KCksbnVsbCE9aC5jb21wb25lbnREaWRNb3VudCYmaC5fX2gucHVzaChoLmNvbXBvbmVudERpZE1vdW50KTtlbHNle2lmKG51bGw9PVAuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiZudWxsPT1oLl9fZSYmbnVsbCE9aC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZoLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoayxDKSwhaC5fX2UmJm51bGwhPWguc2hvdWxkQ29tcG9uZW50VXBkYXRlJiYhMT09PWguc2hvdWxkQ29tcG9uZW50VXBkYXRlKGssaC5fX3MsQykpe2ZvcihoLnByb3BzPWssaC5zdGF0ZT1oLl9fcyxoLl9fZD0hMSxoLl9fdj11LHUuX19lPXQuX19lLHUuX19rPXQuX19rLGguX19oLmxlbmd0aCYmZi5wdXNoKGgpLGE9MDthPHUuX19rLmxlbmd0aDthKyspdS5fX2tbYV0mJih1Ll9fa1thXS5fXz11KTticmVhayBufW51bGwhPWguY29tcG9uZW50V2lsbFVwZGF0ZSYmaC5jb21wb25lbnRXaWxsVXBkYXRlKGssaC5fX3MsQyksbnVsbCE9aC5jb21wb25lbnREaWRVcGRhdGUmJmguX19oLnB1c2goZnVuY3Rpb24oKXtoLmNvbXBvbmVudERpZFVwZGF0ZShwLG0sdyl9KX1oLmNvbnRleHQ9QyxoLnByb3BzPWssaC5zdGF0ZT1oLl9fcywoYT1uLl9fcikmJmEodSksaC5fX2Q9ITEsaC5fX3Y9dSxoLl9fUD1sLGE9aC5yZW5kZXIoaC5wcm9wcyxoLnN0YXRlLGguY29udGV4dCksdS5fX2s9YihudWxsIT1hJiZhLnR5cGU9PWQmJm51bGw9PWEua2V5P2EucHJvcHMuY2hpbGRyZW46YSksbnVsbCE9aC5nZXRDaGlsZENvbnRleHQmJihpPXMocyh7fSxpKSxoLmdldENoaWxkQ29udGV4dCgpKSksdnx8bnVsbD09aC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8KHc9aC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwLG0pKSxfKGwsdSx0LGksbyxyLGYsZSxjKSxoLmJhc2U9dS5fX2UsaC5fX2gubGVuZ3RoJiZmLnB1c2goaCksZyYmKGguX19FPWguX189bnVsbCksaC5fX2U9bnVsbH1lbHNlIHUuX19lPWoodC5fX2UsdSx0LGksbyxyLGYsYyk7KGE9bi5kaWZmZWQpJiZhKHUpfWNhdGNoKGwpe24uX19lKGwsdSx0KX1yZXR1cm4gdS5fX2V9ZnVuY3Rpb24gJChsLHUpe24uX19jJiZuLl9fYyh1LGwpLGwuc29tZShmdW5jdGlvbih1KXt0cnl7bD11Ll9faCx1Ll9faD1bXSxsLnNvbWUoZnVuY3Rpb24obil7bi5jYWxsKHUpfSl9Y2F0Y2gobCl7bi5fX2UobCx1Ll9fdil9fSl9ZnVuY3Rpb24gaihuLGwsdSx0LGksbyxyLGMpe3ZhciBzLGEsaCx2LHAsZD11LnByb3BzLHk9bC5wcm9wcztpZihpPVwic3ZnXCI9PT1sLnR5cGV8fGksbnVsbD09biYmbnVsbCE9bylmb3Iocz0wO3M8by5sZW5ndGg7cysrKWlmKG51bGwhPShhPW9bc10pJiYobnVsbD09PWwudHlwZT8zPT09YS5ub2RlVHlwZTphLmxvY2FsTmFtZT09PWwudHlwZSkpe249YSxvW3NdPW51bGw7YnJlYWt9aWYobnVsbD09bil7aWYobnVsbD09PWwudHlwZSlyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoeSk7bj1pP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsbC50eXBlKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KGwudHlwZSksbz1udWxsfWlmKG51bGw9PT1sLnR5cGUpbnVsbCE9byYmKG9bby5pbmRleE9mKG4pXT1udWxsKSxkIT09eSYmKG4uZGF0YT15KTtlbHNlIGlmKGwhPT11KXtpZihudWxsIT1vJiYobz1lLnNsaWNlLmNhbGwobi5jaGlsZE5vZGVzKSksaD0oZD11LnByb3BzfHxmKS5kYW5nZXJvdXNseVNldElubmVySFRNTCx2PXkuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIWMpe2lmKGQ9PT1mKWZvcihkPXt9LHA9MDtwPG4uYXR0cmlidXRlcy5sZW5ndGg7cCsrKWRbbi5hdHRyaWJ1dGVzW3BdLm5hbWVdPW4uYXR0cmlidXRlc1twXS52YWx1ZTsodnx8aCkmJih2JiZoJiZ2Ll9faHRtbD09aC5fX2h0bWx8fChuLmlubmVySFRNTD12JiZ2Ll9faHRtbHx8XCJcIikpfXgobix5LGQsaSxjKSxsLl9faz1sLnByb3BzLmNoaWxkcmVuLHZ8fF8obixsLHUsdCxcImZvcmVpZ25PYmplY3RcIiE9PWwudHlwZSYmaSxvLHIsZixjKSxjfHwoXCJ2YWx1ZVwiaW4geSYmdm9pZCAwIT09eS52YWx1ZSYmeS52YWx1ZSE9PW4udmFsdWUmJihuLnZhbHVlPW51bGw9PXkudmFsdWU/XCJcIjp5LnZhbHVlKSxcImNoZWNrZWRcImluIHkmJnZvaWQgMCE9PXkuY2hlY2tlZCYmeS5jaGVja2VkIT09bi5jaGVja2VkJiYobi5jaGVja2VkPXkuY2hlY2tlZCkpfXJldHVybiBufWZ1bmN0aW9uIHoobCx1LHQpe3RyeXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBsP2wodSk6bC5jdXJyZW50PXV9Y2F0Y2gobCl7bi5fX2UobCx0KX19ZnVuY3Rpb24gQShsLHUsdCl7dmFyIGksbyxyO2lmKG4udW5tb3VudCYmbi51bm1vdW50KGwpLChpPWwucmVmKSYmeihpLG51bGwsdSksdHx8XCJmdW5jdGlvblwiPT10eXBlb2YgbC50eXBlfHwodD1udWxsIT0obz1sLl9fZSkpLGwuX19lPWwuX19kPW51bGwsbnVsbCE9KGk9bC5fX2MpKXtpZihpLmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXtpLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2gobCl7bi5fX2UobCx1KX1pLmJhc2U9aS5fX1A9bnVsbH1pZihpPWwuX19rKWZvcihyPTA7cjxpLmxlbmd0aDtyKyspaVtyXSYmQShpW3JdLHUsdCk7bnVsbCE9byYmYShvKX1mdW5jdGlvbiBEKG4sbCx1KXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcihuLHUpfWZ1bmN0aW9uIEUobCx1LHQpe3ZhciBpLHIsYztuLl9fJiZuLl9fKGwsdSkscj0oaT10PT09byk/bnVsbDp0JiZ0Ll9fa3x8dS5fX2ssbD1oKGQsbnVsbCxbbF0pLGM9W10sVCh1LChpP3U6dHx8dSkuX19rPWwscnx8ZixmLHZvaWQgMCE9PXUub3duZXJTVkdFbGVtZW50LHQmJiFpP1t0XTpyP251bGw6ZS5zbGljZS5jYWxsKHUuY2hpbGROb2RlcyksYyx0fHxmLGkpLCQoYyxsKX1mdW5jdGlvbiBIKG4sbCl7RShuLGwsbyl9ZnVuY3Rpb24gSShuLGwpe3JldHVybiBsPXMocyh7fSxuLnByb3BzKSxsKSxhcmd1bWVudHMubGVuZ3RoPjImJihsLmNoaWxkcmVuPWUuc2xpY2UuY2FsbChhcmd1bWVudHMsMikpLHYobi50eXBlLGwsbC5rZXl8fG4ua2V5LGwucmVmfHxuLnJlZil9ZnVuY3Rpb24gTChuKXt2YXIgbD17fSx1PXtfX2M6XCJfX2NDXCIrcisrLF9fOm4sQ29uc3VtZXI6ZnVuY3Rpb24obixsKXtyZXR1cm4gbi5jaGlsZHJlbihsKX0sUHJvdmlkZXI6ZnVuY3Rpb24obil7dmFyIHQsaT10aGlzO3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dHx8KHQ9W10sdGhpcy5nZXRDaGlsZENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gbFt1Ll9fY109aSxsfSx0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mdW5jdGlvbihsKXtuLnZhbHVlIT09bC52YWx1ZSYmdC5zb21lKGZ1bmN0aW9uKG4pe24uY29udGV4dD1sLnZhbHVlLGcobil9KX0sdGhpcy5zdWI9ZnVuY3Rpb24obil7dC5wdXNoKG4pO3ZhciBsPW4uY29tcG9uZW50V2lsbFVubW91bnQ7bi5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3Quc3BsaWNlKHQuaW5kZXhPZihuKSwxKSxsJiZsLmNhbGwobil9fSksbi5jaGlsZHJlbn19O3JldHVybiB1LkNvbnN1bWVyLmNvbnRleHRUeXBlPXUsdX1uPXtfX2U6ZnVuY3Rpb24obixsKXtmb3IodmFyIHU7bD1sLl9fOylpZigodT1sLl9fYykmJiF1Ll9fKXRyeXtpZih1LmNvbnN0cnVjdG9yJiZudWxsIT11LmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcil1LnNldFN0YXRlKHUuY29uc3RydWN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKG4pKTtlbHNle2lmKG51bGw9PXUuY29tcG9uZW50RGlkQ2F0Y2gpY29udGludWU7dS5jb21wb25lbnREaWRDYXRjaChuKX1yZXR1cm4gZyh1Ll9fRT11KX1jYXRjaChsKXtuPWx9dGhyb3cgbn19LGw9ZnVuY3Rpb24obil7cmV0dXJuIG51bGwhPW4mJnZvaWQgMD09PW4uY29uc3RydWN0b3J9LHkucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKG4sbCl7dmFyIHU7dT10aGlzLl9fcyE9PXRoaXMuc3RhdGU/dGhpcy5fX3M6dGhpcy5fX3M9cyh7fSx0aGlzLnN0YXRlKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiYobj1uKHUsdGhpcy5wcm9wcykpLG4mJnModSxuKSxudWxsIT1uJiZ0aGlzLl9fdiYmKHRoaXMuX19lPSExLGwmJnRoaXMuX19oLnB1c2gobCksZyh0aGlzKSl9LHkucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKG4pe3RoaXMuX192JiYodGhpcy5fX2U9ITAsbiYmdGhpcy5fX2gucHVzaChuKSxnKHRoaXMpKX0seS5wcm90b3R5cGUucmVuZGVyPWQsdT1bXSx0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFByb21pc2U/UHJvbWlzZS5wcm90b3R5cGUudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKTpzZXRUaW1lb3V0LG89ZixyPTA7ZXhwb3J0e0UgYXMgcmVuZGVyLEggYXMgaHlkcmF0ZSxoIGFzIGNyZWF0ZUVsZW1lbnQsaCxkIGFzIEZyYWdtZW50LHAgYXMgY3JlYXRlUmVmLGwgYXMgaXNWYWxpZEVsZW1lbnQseSBhcyBDb21wb25lbnQsSSBhcyBjbG9uZUVsZW1lbnQsTCBhcyBjcmVhdGVDb250ZXh0LGIgYXMgdG9DaGlsZEFycmF5LEEgYXMgX3VubW91bnQsbiBhcyBvcHRpb25zfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC5tb2R1bGUuanMubWFwXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJpbXBvcnQgeyBoLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJy4uL2NvbnRyb2xsZXInO1xuaW1wb3J0IEN5dG9zY2FwZSBmcm9tICdjeXRvc2NhcGUnO1xuaW1wb3J0IHsgZWxlbWVudHMsIHN0eWxlIH0gZnJvbSAnLi4vY3ktY29uZic7XG5pbXBvcnQgQ3l0b3NjYXBlQ29tcG9uZW50IGZyb20gJy4vY3l0b3NjYXBlJztcbmltcG9ydCB7IGlzRGV2IH0gZnJvbSAnLi4vZW52JztcbmltcG9ydCB7IE5vZGVJbmZvIH0gZnJvbSAnLi9ub2RlLWluZm8nO1xuaW1wb3J0IHsgTWVudSB9IGZyb20gJy4vbWVudSc7XG5cbmNsYXNzIEFwcENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICBjb25zdCBjeSA9IG5ldyBDeXRvc2NhcGUoe1xuICAgICAgZWxlbWVudHMsXG4gICAgICBzdHlsZSxcbiAgICAgIGxheW91dDogeyBcbiAgICAgICAgbmFtZTogJ3ByZXNldCcsXG4gICAgICB9LFxuICAgICAgc2VsZWN0aW9uVHlwZTogJ3NpbmdsZScsXG4gICAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgY3kubm9kZXMoKS5wYW5pZnkoKS51bmdyYWJpZnkoKTtcblxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcih7IGN5IH0pO1xuICAgIGNvbnN0IGJ1cyA9IGNvbnRyb2xsZXIuYnVzO1xuXG4gICAgaWYoIGlzRGV2ICl7XG4gICAgICB3aW5kb3cuY3kgPSBjeTtcbiAgICAgIHdpbmRvdy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0geyBjb250cm9sbGVyLCBjeSB9O1xuXG4gICAgYnVzLm9uKCdzaG93SW5mbycsIHRoaXMub25TaG93SW5mbyA9IChub2RlID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBpbmZvTm9kZTogbm9kZSB9KTtcbiAgICB9KSk7XG5cbiAgICBidXMub24oJ2hpZGVJbmZvJywgdGhpcy5vbkhpZGVJbmZvID0gKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBpbmZvTm9kZTogbnVsbCB9KTtcbiAgICB9KSk7ICAgIFxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKXtcbiAgICBjb25zdCBidXMgPSB0aGlzLnN0YXRlLmNvbnRyb2xsZXIuYnVzO1xuXG4gICAgYnVzLnJlbW92ZUxpc3RlbmVyKCdzaG93SW5mbycsIHRoaXMub25TaG93SW5mbyk7XG4gICAgYnVzLnJlbW92ZUxpc3RlbmVyKCdoaWRlSW5mbycsIHRoaXMub25IaWRlSW5mbyk7XG4gIH1cblxuICByZW5kZXIoKXtcbiAgICBjb25zdCB7IGN5LCBjb250cm9sbGVyLCBpbmZvTm9kZSB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIHJldHVybiBoKCdkaXYnLCB7IGNsYXNzOiAnYXBwJyB9LCBbXG4gICAgICBoKEN5dG9zY2FwZUNvbXBvbmVudCwgeyBjeSwgY29udHJvbGxlciB9KSxcblxuICAgICAgaW5mb05vZGUgPyAoXG4gICAgICAgIGgoJ2RpdicsIHsgY2xhc3M6ICdhcHAtbm9kZS1pbmZvJyB9LCBbXG4gICAgICAgICAgaChOb2RlSW5mbywgeyBub2RlOiBpbmZvTm9kZSB9KVxuICAgICAgICBdKVxuICAgICAgKSA6IG51bGwsXG5cbiAgICAgIGgoTWVudSwgeyBjb250cm9sbGVyIH0pXG4gICAgXSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXBwQ29tcG9uZW50O1xuZXhwb3J0IHsgQXBwQ29tcG9uZW50IH07IiwiaW1wb3J0IHsgaCwgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcblxuY2xhc3MgQ3l0b3NjYXBlQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgIHN1cGVyKHByb3BzKTtcbiAgfVxuXG4gIHJlbmRlcigpe1xuICAgIHJldHVybiBoKCdkaXYnLCB7IGlkOiAnY3knIH0pOyAgICBcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCl7XG4gICAgY29uc3QgeyBjeSwgY29udHJvbGxlciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3knKTtcblxuICAgIGN5Lm1vdW50KGNvbnRhaW5lcik7XG4gICAgY3kuZml0KDEwKTtcblxuICAgIGN5Lm9uKCd0YXAnLCB0aGlzLm9uVGFwID0gZSA9PiB7XG4gICAgICBpZiggZS50YXJnZXQgPT09IGN5ICl7XG4gICAgICAgIGNvbnRyb2xsZXIudW5oaWdobGlnaHQoKTtcbiAgICAgICAgY29udHJvbGxlci5oaWRlSW5mbygpO1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlTWVudSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5oaWdobGlnaHQoZS50YXJnZXQpO1xuICAgICAgICBjb250cm9sbGVyLnNob3dJbmZvKGUudGFyZ2V0KTtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZU1lbnUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCl7XG4gICAgY29uc3QgeyBjeSB9ID0gdGhpcy5wcm9wcztcblxuICAgIGN5LnJlbW92ZUxpc3RlbmVyKCd0YXAnLCB0aGlzLm9uVGFwKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDeXRvc2NhcGVDb21wb25lbnQ7XG5leHBvcnQgeyBDeXRvc2NhcGVDb21wb25lbnQgfTsiLCJpbXBvcnQgeyBoLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJztcbmltcG9ydCB7IE5vZGVJbmZvIH0gZnJvbSAnLi9ub2RlLWluZm8nO1xuXG5jbGFzcyBNZW51IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIGNvbnN0IHsgY29udHJvbGxlciB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyBidXMgfSA9IGNvbnRyb2xsZXI7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgb3BlbjogY29udHJvbGxlci5pc01lbnVPcGVuKClcbiAgICB9O1xuXG4gICAgYnVzLm9uKCdvcGVuTWVudScsIHRoaXMub25PcGVuTWVudSA9ICgoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgb3BlbjogdHJ1ZSB9KTtcblxuICAgICAgdGhpcy5mb2N1c1RleHRCb3goKTtcbiAgICB9KSk7XG5cbiAgICBidXMub24oJ2Nsb3NlTWVudScsIHRoaXMub25PcGVuTWVudSA9ICgoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgb3BlbjogZmFsc2UgfSk7XG4gICAgfSkpO1xuXG4gICAgYnVzLm9uKCd1cGRhdGVTZWFyY2gnLCB0aGlzLm9uVXBkYXRlU2VhcmNoID0gKHNlYXJjaE1hdGNoTm9kZXMgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNlYXJjaE1hdGNoTm9kZXMgfSk7XG4gICAgfSkpO1xuXG4gICAgdGhpcy5kZWJvdW5jZWRVcGRhdGVTZWFyY2ggPSBkZWJvdW5jZSgoKSA9PiB0aGlzLnVwZGF0ZVNlYXJjaCgpLCAyNTApO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKXtcbiAgICBjb25zdCB7IGJ1cyB9ID0gdGhpcy5wcm9wcy5jb250cm9sbGVyO1xuXG4gICAgYnVzLnJlbW92ZUxpc3RlbmVyKCdvcGVuTWVudScsIHRoaXMub25PcGVuTWVudSk7XG4gICAgYnVzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZU1lbnUnLCB0aGlzLm9uQ2xvc2VNZW51KTtcbiAgICBidXMucmVtb3ZlTGlzdGVuZXIoJ3VwZGF0ZVNlYXJjaCcsIHRoaXMub25VcGRhdGVTZWFyY2gpO1xuICB9XG5cbiAgb3Blbigpe1xuICAgIGNvbnN0IHsgY29udHJvbGxlciB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnRyb2xsZXIub3Blbk1lbnUoKTtcbiAgfVxuXG4gIHVwZGF0ZVNlYXJjaCgpe1xuICAgIGNvbnN0IHsgY29udHJvbGxlciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZW51LXNlYXJjaCcpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVudS1zZWFyY2gtcmVzdWx0cycpO1xuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gaW5wdXQudmFsdWU7XG5cbiAgICByZXN1bHRzLnNjcm9sbFRvKDAsIDApO1xuXG4gICAgY29udHJvbGxlci51cGRhdGVTZWFyY2gocXVlcnlTdHJpbmcpO1xuICB9XG5cbiAgZm9jdXNUZXh0Qm94KCl7XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVudS1zZWFyY2gnKTtcblxuICAgIGlmKCBpbnB1dCApe1xuICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICBzZWxlY3ROb2RlKG5vZGUpe1xuICAgIGNvbnN0IHsgY29udHJvbGxlciB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnRyb2xsZXIuY2xvc2VNZW51KCk7XG4gICAgY29udHJvbGxlci5oaWdobGlnaHQobm9kZSk7XG4gICAgY29udHJvbGxlci5zaG93SW5mbyhub2RlKTtcbiAgfVxuXG4gIHJlbmRlcigpe1xuICAgIGNvbnN0IHsgY29udHJvbGxlciB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IG9wZW4sIHNlYXJjaE1hdGNoTm9kZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY2xvc2VkID0gIW9wZW47XG5cbiAgICBsZXQgc2VhcmNoUmVzdWx0cyA9IFtdO1xuXG4gICAgaWYoIHNlYXJjaE1hdGNoTm9kZXMgKXtcbiAgICAgIHNlYXJjaFJlc3VsdHMgPSBzZWFyY2hNYXRjaE5vZGVzLm1hcChub2RlID0+IGgoJ2Rpdi5tZW51LW5vZGUtaW5mbycsIHtcbiAgICAgICAgb25DbGljazogKCkgPT4gdGhpcy5zZWxlY3ROb2RlKG5vZGUpXG4gICAgICB9LCBbXG4gICAgICAgIGgoTm9kZUluZm8sIHsgbm9kZSB9KVxuICAgICAgXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBoKCdkaXYnLCB7IGNsYXNzOiAnbWVudS1wYXJlbnQnIH0sIFtcbiAgICAgIGgoJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6IGNsYXNzTmFtZXMoeyAnbWVudS10b2dnbGUnOiB0cnVlLCAnbWVudS1vcGVuJzogb3BlbiB9KSxcbiAgICAgICAgb25DbGljazogKCkgPT4gY29udHJvbGxlci50b2dnbGVNZW51KClcbiAgICAgIH0pLFxuICAgICAgaCgnZGl2JywgeyBjbGFzczogY2xhc3NOYW1lcyh7ICdtZW51JzogdHJ1ZSwgJ21lbnUtY2xvc2VkJzogY2xvc2VkIH0pIH0sIFtcbiAgICAgICAgaCgnaW5wdXQnLCB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIGNsYXNzOiAnbWVudS1zZWFyY2gnLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiAnU2VhcmNoJyxcbiAgICAgICAgICBpZDogJ21lbnUtc2VhcmNoJyxcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB0aGlzLm9wZW4oKSxcbiAgICAgICAgICBvbktleURvd246ICgpID0+IHRoaXMuZGVib3VuY2VkVXBkYXRlU2VhcmNoKClcbiAgICAgICAgfSksXG4gICAgICAgIGgoJ2RpdicsIHsgY2xhc3M6ICdtZW51LXNlYXJjaC1yZXN1bHRzJywgaWQ6ICdtZW51LXNlYXJjaC1yZXN1bHRzJyB9LCBzZWFyY2hSZXN1bHRzKVxuICAgICAgXSlcbiAgICBdKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZW51O1xuZXhwb3J0IHsgTWVudSB9OyIsImltcG9ydCB7IGgsIENvbXBvbmVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbmNsYXNzIE5vZGVJbmZvIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgIHN1cGVyKHByb3BzKTtcbiAgfVxuXG4gIHJlbmRlcigpe1xuICAgIGNvbnN0IHsgbm9kZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBkYXRhID0gbm9kZS5kYXRhKCk7XG4gICAgY29uc3QgeyBuYW1lIH0gPSBkYXRhO1xuICAgIGNvbnN0IHR5cGUgPSBkYXRhLk5vZGVUeXBlRm9ybWF0dGVkICsgKGRhdGEuVHlwZSA/IGAgKCR7ZGF0YS5UeXBlfSlgIDogJycpO1xuICAgIGNvbnN0IG1pbGsgPSBkYXRhLk1pbGs7XG4gICAgY29uc3QgaXNNaWxrID0gbWlsayAhPSBudWxsO1xuICAgIGNvbnN0IGNvdW50cnkgPSBkYXRhLkNvdW50cnk7XG4gICAgY29uc3QgaGFzQ291bnRyeSA9IGNvdW50cnkgIT0gbnVsbDtcbiAgICBjb25zdCBxID0gZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEuTm9kZVR5cGUgPT09ICdDaGVlc2UnID8gYCR7bmFtZX0gY2hlZXNlYCA6IG5hbWUpO1xuXG4gICAgY29uc3QgZWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCkubWFwKGVkZ2UgPT4gaCgnbGknLCB7IGNsYXNzOiAnbm9kZS1pbmZvLW1vcmUtZGV0YWlsJyB9LCBlZGdlLmRhdGEoKS5vcmlnX3NlbnQpKTtcbiAgICAvLyBjb25zb2xlLmxvZyhub2RlLmRhdGEoKSk7XG5cbiAgICByZXR1cm4gaCgnZGl2JywgeyBjbGFzczogJ25vZGUtaW5mbycgfSwgW1xuICAgICAgaCgnZGl2JywgeyBjbGFzczogJ25vZGUtaW5mby1uYW1lJyB9LCBuYW1lKSxcbiAgICAgIGgoJ2RpdicsIHsgY2xhc3M6ICdub2RlLWluZm8tdHlwZScgfSwgdHlwZSksXG4gICAgICBpc01pbGsgPyBoKCdkaXYnLCB7IGNsYXNzOiAnbm9kZS1pbmZvLW1pbGsnIH0sIG1pbGspIDogbnVsbCxcbiAgICAgIGhhc0NvdW50cnkgPyBoKCdkaXYnLCB7IGNsYXNzOiAnbm9kZS1pbmZvLWNvdW50cnknIH0sIGNvdW50cnkpIDogbnVsbCxcbiAgICAgIGgoJ2RpdicsIHsgY2xhc3M6ICdub2RlLWluZm8tbW9yZScgfSwgaCgndWwnLCB7fSwgZWRnZXMpKVxuICAgIF0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE5vZGVJbmZvO1xuZXhwb3J0IHsgTm9kZUluZm8gfTsiLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IG1lbW9pemUgZnJvbSAnbG9kYXNoLm1lbW9pemUnO1xuXG5jb25zdCBsYXlvdXRQYWRkaW5nID0gMTA7XG5jb25zdCBhbmltYXRpb25EdXJhdGlvbiA9IDUwMDtcbmNvbnN0IGVhc2luZyA9ICdlYXNlJztcblxuLy8gc2VhcmNoIHBhcmFtZXRlcnNcbmNvbnN0IG1pbk1ldHJpY1ZhbHVlID0gMC4yNTsgLy8gZmlsdGVyIG91dCBub2RlcyBmcm9tIHNlYXJjaCByZXN1bHRzIGlmIHRoZXkgaGF2ZSB0b3RhbCBzY29yZXMgbG93ZXIgdGhhbiB0aGlzXG5jb25zdCBtaW5TaW1pbGFyaXR5VmFsdWUgPSAwOyAvLyBvbmx5IGluY2x1ZGUgaW4gdG90YWwgbWV0cmljIGlmIHRoZSBpbmRpdmlkdWFsIHNpbSB2YWwgaXMgb24gWzAuNSwgMV1cblxuY29uc3QgZGVsYXlQcm9taXNlID0gZHVyYXRpb24gPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XG5cbmNvbnN0IGdldE9yZ1BvcyA9IG4gPT4gT2JqZWN0LmFzc2lnbih7fSwgbi5kYXRhKCdvcmdQb3MnKSk7XG5cbmNsYXNzIENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcih7IGN5IH0pe1xuICAgIHRoaXMuY3kgPSBjeTtcbiAgICB0aGlzLmJ1cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLm1lbnUgPSBmYWxzZTtcbiAgICB0aGlzLm5vZGVzID0gY3kubm9kZXMoKTtcbiAgICB0aGlzLnNlYXJjaE1hdGNoTm9kZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gIH1cblxuICBpc01lbnVPcGVuKCl7XG4gICAgcmV0dXJuIHRoaXMubWVudTtcbiAgfVxuXG4gIG9wZW5NZW51KCl7XG4gICAgdGhpcy5tZW51ID0gdHJ1ZTtcblxuICAgIHRoaXMuYnVzLmVtaXQoJ29wZW5NZW51Jyk7XG4gICAgdGhpcy5idXMuZW1pdCgndG9nZ2xlTWVudScsIHRydWUpO1xuICB9XG5cbiAgY2xvc2VNZW51KCl7XG4gICAgdGhpcy5tZW51ID0gZmFsc2U7XG5cbiAgICB0aGlzLmJ1cy5lbWl0KCdjbG9zZU1lbnUnKTtcbiAgICB0aGlzLmJ1cy5lbWl0KCd0b2dnbGVNZW51JywgZmFsc2UpO1xuICB9XG5cbiAgdG9nZ2xlTWVudSgpe1xuICAgIGlmKCB0aGlzLmlzTWVudU9wZW4oKSApe1xuICAgICAgdGhpcy5jbG9zZU1lbnUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGVuTWVudSgpO1xuICAgIH1cbiAgfVxuXG4gIGlzSW5mb1Nob3duKCl7XG4gICAgcmV0dXJuIHRoaXMuaW5mb05vZGUgIT0gbnVsbDtcbiAgfVxuXG4gIHNob3dJbmZvKG5vZGUpe1xuICAgIHRoaXMuaW5mb05vZGUgPSBub2RlO1xuXG4gICAgdGhpcy5idXMuZW1pdCgnc2hvd0luZm8nLCBub2RlKTtcbiAgfVxuXG4gIGhpZGVJbmZvKCl7XG4gICAgdGhpcy5idXMuZW1pdCgnaGlkZUluZm8nLCB0aGlzLmluZm9Ob2RlKTtcblxuICAgIHRoaXMuaW5mb05vZGUgPSBudWxsO1xuICB9XG5cbiAgaGFzSGlnaGxpZ2h0KCl7XG4gICAgcmV0dXJuIHRoaXMubGFzdEhpZ2hsaWdodGVkICE9IG51bGw7XG4gIH1cblxuICBoaWdobGlnaHQobm9kZSl7XG4gICAgY29uc3QgeyBjeSB9ID0gdGhpcztcblxuICAgIGlmKCB0aGlzLmhpZ2hsaWdodEluUHJvZ3Jlc3MgKXsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyB9XG5cbiAgICB0aGlzLmhpZ2hsaWdodEluUHJvZ3Jlc3MgPSB0cnVlO1xuXG4gICAgY29uc3QgYWxsRWxlcyA9IGN5LmVsZW1lbnRzKCk7XG4gICAgY29uc3Qgbmhvb2QgPSB0aGlzLmxhc3RIaWdobGlnaHRlZCA9IG5vZGUuY2xvc2VkTmVpZ2hib3Job29kKCk7XG4gICAgY29uc3Qgb3RoZXJzID0gdGhpcy5sYXN0VW5oaWdobGlnaHRlZCA9IGFsbEVsZXMubm90KCBuaG9vZCApO1xuXG4gICAgY29uc3Qgc2hvd092ZXJ2aWV3ID0gKCkgPT4ge1xuICAgICAgY3kuYmF0Y2goKCkgPT4ge1xuICAgICAgICBhbGxFbGVzLnJlbW92ZUNsYXNzKCdmYWRlZCBoaWdobGlnaHRlZCBoaWRkZW4nKTtcblxuICAgICAgICBuaG9vZC5hZGRDbGFzcygnaGlnaGxpZ2h0ZWQnKTtcbiAgICAgICAgb3RoZXJzLmFkZENsYXNzKCdoaWRkZW4nKTtcblxuICAgICAgICBvdGhlcnMucG9zaXRpb25zKGdldE9yZ1Bvcyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbGF5b3V0ID0gbmhvb2QubGF5b3V0KHtcbiAgICAgICAgbmFtZTogJ3ByZXNldCcsXG4gICAgICAgIHBvc2l0aW9uczogZ2V0T3JnUG9zLFxuICAgICAgICBmaXQ6IHRydWUsXG4gICAgICAgIGFuaW1hdGU6IHRydWUsXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nOiBlYXNpbmcsXG4gICAgICAgIHBhZGRpbmc6IGxheW91dFBhZGRpbmdcbiAgICAgIH0pO1xuXG4gICAgICBsYXlvdXQucnVuKCk7XG5cbiAgICAgIHJldHVybiBsYXlvdXQucHJvbWlzZU9uKCdsYXlvdXRzdG9wJyk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJ1bkxheW91dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHAgPSBnZXRPcmdQb3Mobm9kZSk7XG5cbiAgICAgIGNvbnN0IGxheW91dCA9IG5ob29kLmxheW91dCh7XG4gICAgICAgIG5hbWU6ICdjb25jZW50cmljJyxcbiAgICAgICAgZml0OiB0cnVlLFxuICAgICAgICBhbmltYXRlOiB0cnVlLFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZzogZWFzaW5nLFxuICAgICAgICBtaW5Ob2RlU3BhY2luZzogNTAsXG4gICAgICAgIGJvdW5kaW5nQm94OiB7XG4gICAgICAgICAgeDE6IHAueCAtIDEsXG4gICAgICAgICAgeDI6IHAueCArIDEsXG4gICAgICAgICAgeTE6IHAueSAtIDEsXG4gICAgICAgICAgeTI6IHAueSArIDFcbiAgICAgICAgfSxcbiAgICAgICAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAgICAgICBjb25jZW50cmljOiBmdW5jdGlvbiggZWxlICl7XG4gICAgICAgICAgaWYoIGVsZS5zYW1lKCBub2RlICkgKXtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxldmVsV2lkdGg6ICgpID0+IHsgcmV0dXJuIDE7IH0sXG4gICAgICAgIHBhZGRpbmc6IGxheW91dFBhZGRpbmdcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwcm9taXNlID0gbGF5b3V0LnByb21pc2VPbignbGF5b3V0c3RvcCcpO1xuXG4gICAgICBsYXlvdXQucnVuKCk7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICBjb25zdCBzaG93T3RoZXJzRmFkZWQgPSAoKSA9PiB7XG4gICAgICBjeS5iYXRjaCgoKSA9PiB7XG4gICAgICAgIG90aGVycy5yZW1vdmVDbGFzcygnaGlkZGVuJykuYWRkQ2xhc3MoJ2ZhZGVkJyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5idXMuZW1pdCgnaGlnaGxpZ2h0Jywgbm9kZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIC50aGVuKCBzaG93T3ZlcnZpZXcgKVxuICAgICAgLnRoZW4oICgpID0+IGRlbGF5UHJvbWlzZShhbmltYXRpb25EdXJhdGlvbikgKVxuICAgICAgLnRoZW4oIHJ1bkxheW91dCApXG4gICAgICAudGhlbiggc2hvd090aGVyc0ZhZGVkIClcbiAgICAgIC50aGVuKCAoKSA9PiB7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0SW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1cy5lbWl0KCdoaWdobGlnaHRlbmQnLCBub2RlKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHVuaGlnaGxpZ2h0KCl7XG4gICAgaWYoICF0aGlzLmhhc0hpZ2hsaWdodCgpICl7IHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsgfVxuXG4gICAgY29uc3QgeyBjeSB9ID0gdGhpcztcbiAgICBjb25zdCBhbGxFbGVzID0gY3kuZWxlbWVudHMoKTtcbiAgICBjb25zdCBhbGxOb2RlcyA9IGN5Lm5vZGVzKCk7XG5cbiAgICBjeS5zdG9wKCk7XG4gICAgYWxsTm9kZXMuc3RvcCgpO1xuXG4gICAgY29uc3Qgbmhvb2QgPSB0aGlzLmxhc3RIaWdobGlnaHRlZDtcbiAgICBjb25zdCBvdGhlcnMgPSB0aGlzLmxhc3RVbmhpZ2hsaWdodGVkO1xuXG4gICAgdGhpcy5sYXN0SGlnaGxpZ2h0ZWQgPSB0aGlzLmxhc3RVbmhpZ2hsaWdodGVkID0gbnVsbDtcblxuICAgIGNvbnN0IGhpZGVPdGhlcnMgPSBmdW5jdGlvbigpe1xuICAgICAgb3RoZXJzLmFkZENsYXNzKCdoaWRkZW4nKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCByZXNldENsYXNzZXMgPSBmdW5jdGlvbigpe1xuICAgICAgY3kuYmF0Y2goZnVuY3Rpb24oKXtcbiAgICAgICAgYWxsRWxlcy5yZW1vdmVDbGFzcygnaGlkZGVuJykucmVtb3ZlQ2xhc3MoJ2ZhZGVkJykucmVtb3ZlQ2xhc3MoJ2hpZ2hsaWdodGVkJyk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBhbmltYXRlVG9PcmdQb3MgPSBmdW5jdGlvbiggbmhvb2QgKXtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCggbmhvb2Qubm9kZXMoKS5tYXAobiA9PiB7XG4gICAgICAgIHJldHVybiBuLmFuaW1hdGlvbih7XG4gICAgICAgICAgcG9zaXRpb246IGdldE9yZ1BvcyhuKSxcbiAgICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBlYXNpbmdcbiAgICAgICAgfSkucGxheSgpLnByb21pc2UoKTtcbiAgICAgIH0pICk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3RvcmVQb3NpdGlvbnMgPSAoKSA9PiB7XG4gICAgICBjeS5iYXRjaCgoKSA9PiB7XG4gICAgICAgIG90aGVycy5ub2RlcygpLnBvc2l0aW9ucyhnZXRPcmdQb3MpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBhbmltYXRlVG9PcmdQb3MoIG5ob29kLm5vZGVzKCkgKTtcbiAgICB9O1xuXG4gICAgdGhpcy5idXMuZW1pdCgndW5oaWdobGlnaHQnKTtcblxuICAgIHJldHVybiAoXG4gICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oIGhpZGVPdGhlcnMgKVxuICAgICAgLnRoZW4oIHJlc3RvcmVQb3NpdGlvbnMgKVxuICAgICAgLnRoZW4oIHJlc2V0Q2xhc3NlcyApXG4gICAgKTtcbiAgfVxuXG4gIHVwZGF0ZVNlYXJjaChxdWVyeVN0cmluZyl7XG4gICAgY29uc3Qgbm9ybWFsaXplID0gc3RyID0+IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGdldFdvcmRzID0gc3RyID0+IHN0ci5zcGxpdCgvXFxzKy8pO1xuICAgIGNvbnN0IHF1ZXJ5V29yZHMgPSBnZXRXb3Jkcyhub3JtYWxpemUocXVlcnlTdHJpbmcpKTtcblxuICAgIGNvbnN0IGFkZFdvcmRzID0gKHdvcmRMaXN0LCB3b3Jkc1N0cikgPT4ge1xuICAgICAgaWYoIHdvcmRzU3RyICl7XG4gICAgICAgIHdvcmRMaXN0LnB1c2goLi4uZ2V0V29yZHMobm9ybWFsaXplKHdvcmRzU3RyKSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBjYWNoZU5vZGVXb3JkcyA9IG5vZGUgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IG5vZGUuZGF0YSgpO1xuICAgICAgY29uc3Qgd29yZExpc3QgPSBbXTtcbiAgICAgIFxuICAgICAgYWRkV29yZHMod29yZExpc3QsIGRhdGEubmFtZSk7XG4gICAgICBhZGRXb3Jkcyh3b3JkTGlzdCwgZGF0YS5TeW5vbnltKTtcbiAgICAgIGFkZFdvcmRzKHdvcmRMaXN0LCBkYXRhLk5vZGVUeXBlRm9ybWF0dGVkKTtcbiAgICAgIGFkZFdvcmRzKHdvcmRMaXN0LCBkYXRhLk1pbGspO1xuICAgICAgYWRkV29yZHMod29yZExpc3QsIGRhdGEuVHlwZSk7XG4gICAgICBhZGRXb3Jkcyh3b3JkTGlzdCwgZGF0YS5Db3VudHJ5KTtcbiAgICAgICAgXG4gICAgICBub2RlLmRhdGEoJ3dvcmRzJywgd29yZExpc3QpO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRTdHJpbmdTaW1pbGFyaXR5ID0gKHF1ZXJ5V29yZCwgbm9kZVdvcmQpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbm9kZVdvcmQuaW5kZXhPZihxdWVyeVdvcmQpO1xuXG4gICAgICBpZiggaW5kZXggPT09IDAgKXtcbiAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKG5vZGVXb3JkLmxlbmd0aCAtIHF1ZXJ5V29yZC5sZW5ndGgpO1xuICAgICAgICBjb25zdCBtYXhMZW5ndGggPSBNYXRoLm1heChub2RlV29yZC5sZW5ndGgsIHF1ZXJ5V29yZC5sZW5ndGgpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIDEgLSAoZGlmZiAvIG1heExlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0TWV0cmljID0gKG5vZGUsIHF1ZXJ5V29yZHMpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVXb3JkcyA9IG5vZGUuZGF0YSgnd29yZHMnKTtcbiAgICAgIGxldCBzY29yZSA9IDA7XG5cbiAgICAgIGZvciggbGV0IGkgPSAwOyBpIDwgbm9kZVdvcmRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGxldCBub2RlV29yZCA9IG5vZGVXb3Jkc1tpXTtcblxuICAgICAgICBmb3IoIGxldCBqID0gMDsgaiA8IHF1ZXJ5V29yZHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICBsZXQgcXVlcnlXb3JkID0gcXVlcnlXb3Jkc1tqXTtcbiAgICAgICAgICBsZXQgc2ltaWxhcml0eSA9IGdldFN0cmluZ1NpbWlsYXJpdHkocXVlcnlXb3JkLCBub2RlV29yZCk7XG5cbiAgICAgICAgICBpZiggc2ltaWxhcml0eSA+IG1pblNpbWlsYXJpdHlWYWx1ZSApe1xuICAgICAgICAgICAgc2NvcmUgKz0gc2ltaWxhcml0eTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzY29yZTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0Tm9kZU1ldHJpYyA9IG1lbW9pemUobm9kZSA9PiBnZXRNZXRyaWMobm9kZSwgcXVlcnlXb3JkcyksIG5vZGUgPT4gbm9kZS5pZCgpKTtcblxuICAgIGlmKCAhdGhpcy5jYWNoZWROb2RlV29yZHMgKXtcbiAgICAgIHRoaXMuY3kuYmF0Y2goKCkgPT4ge1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2FjaGVOb2RlV29yZHMpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuY2FjaGVkTm9kZVdvcmRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnNlYXJjaE1hdGNoTm9kZXMgPSB0aGlzLm5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIHJldHVybiBnZXROb2RlTWV0cmljKG5vZGUpID4gbWluTWV0cmljVmFsdWU7XG4gICAgfSkuc29ydCgobm9kZUEsIG5vZGVCKSA9PiB7XG4gICAgICByZXR1cm4gZ2V0Tm9kZU1ldHJpYyhub2RlQikgLSBnZXROb2RlTWV0cmljKG5vZGVBKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYnVzLmVtaXQoJ3VwZGF0ZVNlYXJjaCcsIHRoaXMuc2VhcmNoTWF0Y2hOb2Rlcyk7XG5cbiAgICByZXR1cm4gdGhpcy5zZWFyY2hNYXRjaE5vZGVzO1xuICB9XG5cbiAgZ2V0U2VhcmNoTWF0Y2hOb2Rlcygpe1xuICAgIHJldHVybiB0aGlzLnNlYXJjaE1hdGNoTm9kZXM7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udHJvbGxlcjtcbmV4cG9ydCB7IENvbnRyb2xsZXIgfTsiLCJjb25zdCBlbGVtZW50cyA9IHtcbiAgICBcIm5vZGVzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiODg5NTEwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkc4MDVSXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjk3MTYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lbGFub21hXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjgzMTAwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlIxMjBRXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjIwODQwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkg3MjNSXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjk3MDcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImF1cmFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTI4NzM2MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLlE1NDhYXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwMjQxMTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5QMTUyUlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MzY2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJzcG9yYWRpYyBjb2xvcmVjdGFsIGNhbmNlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMjY5NzQwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMjU4NDE1XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NzA0NTUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRlbXllbGluYXRpb25cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTYxNTU4MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczExNTQzMTk4XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjc2MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJHbHU4Mkx5c1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI5NjI0NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRzE0MThEXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjc4NjE2MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJONDQwS1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjY3MDQxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhdXRvc29tYWwgZG9taW5hbnQgRkRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjM2MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUjE0ZGVsXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2NzM3ODIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInNrZWxldGFsIG15b3BhdGh5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjMyODgxMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJFNDIxS1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNzIwOTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUjIxMkNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3Mjg0NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZmFtaWxpYWwgaHlwZXJ0cm9waGljIGNhcmRpb215b3BhdGh5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEzNzcyNzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5HbHU0MTBHbHlmc1g0M1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTcxNTQ2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJzeXN0ZW1pYyBpbmZsYW1tYXRpb25cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTg5NzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTURcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTM1MDgyMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczEwOTI5MTNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3MjcxODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ1RYXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjM0NzkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzOTI3NzUzNVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc0MjM2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBcGVydCBzeW5kcm9tZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5Nzg2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhbXlsb2lkb3Npc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxOTMyNjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGlhc3Ryb3BoaWMgZHlzcGxhc2lhXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE5MTkwMjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnMyMjk0NjkzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE5MzE5ODA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnMxMjk3MDI5MVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTQ2MzE1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJIeXBvbXllbGluYXRpb25cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNDQyODUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlAzOTRMXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjExMTU5ODA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQTU3R1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMTk1MDUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMzg0OTk0MlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc1NTA2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJUU0RcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiOTQ2NDgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMTA0OTgzNDVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTIwNDI2MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibGltYi1naXJkbGUgdHlwZSAyQlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MTgyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJtaWxkIGh5cGVycGhlbnlsYWxhbmluZW1pYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMjQ5ODUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMTA3NTQ4MzNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjAwMjgwMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczc1NDQ0OTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjY1NzMwMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJRMjkyS1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTgyNTk2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjaG9yZWFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMzg1NDUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInAuTjI5SVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMjM3MzkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzNTA1OTIyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjYyNTc4MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLlIyNDBYXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE0NjQ5MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJUeXI4MkN5c1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTg2ODI1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwdWxtb25hcnkgZGlzZWFzZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc1MDcxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJEQ01cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTE4MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTUhQXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NjY0MjUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImh5cG9rZXRvdGljIGh5cG9nbHljYWVtaWFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU3MTY1ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibXlvcGF0aHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NDMwNjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTUxEXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjU1MTA3MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSNTYzUVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDczODY0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ1cmluYXJ5IHRyYWN0IGNhbmNlcnNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNDIzMzIwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkxldTg0OUhpc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjM0MDE5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJESEZSIGRlZmljaWVuY3lcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU1NDQ1OTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwib2JzdGV0cmljXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjkyMTAwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkx5czIwNkdsblwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTkyNjg5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwYW5jcmVhdGl0aXNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNDk1MjMwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlY2Mk1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNTEwNjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUjE2N1dcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYzMDA3NDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUFRTLWRlZmljaWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjUwMTAwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJnYWl0IGRpc3R1cmJhbmNlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjYwNzc5MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLiBQMzYxTFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNjA1ODAwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInAuQzE3MzNGXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE1MTM4NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5XNzQ2KlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5ODcyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBTFNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU2OTE1MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29tcGxleCBJIGRlZmljaWVuY3lcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU4NzY1MDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXRyaWFsIGZpYnJpbGxhdGlvblwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc1NDA0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwYWNoeW9ueWNoaWEgY29uZ2VuaXRhIHR5cGUgSVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI0MDM0NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5FMTM5RFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMzA3MzUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzNzA0ODUzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzU0NzQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk1FTiAyQVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTYzNDM3MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJseW1waG9pZCBoeXBlcnBsYXNpYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MDQxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJGTUZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNDg2NjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUjExN0hcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTU4MTY0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczQ4NDU2MjVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3MjkzNjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTHluY2ggc3luZHJvbWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTE2MDcwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFyZzIzN0dsblwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTQyMDAwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJPQ0FcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3MjkyMDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQW1zdGVyZGFtIElJXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjM2MjUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInAuUjI0MUNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NTA3MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGlsYXRlZCBjYXJkaW9teW9wYXRoeVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjMwMDc0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJQVFMgZGVmaWNpZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjUzMjQxMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSMTIyQ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzMDEyMjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVDY3TVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDczNjgxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJlbmQtc3RhZ2UgcmVuYWwgZGlzZWFzZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMjgyNjAwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMjkxNjczM1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMzE0NTIwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIksxMDhFXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjUwOTIwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFyZzE3MFRycFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNzg2NjIwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMTc1MzAwNjhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTMyNzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwib3JhbCB1bGNlcnNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3MjkyMDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZ2x5Y29nZW4gc3RvcmFnZSBkaXNlYXNlIHR5cGUgMWJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNjIwODgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlR5cjY5SGlzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzQ1MjUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkZMXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjkxMzcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInRoeW1vbWFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTY3Mjg3MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjLjU0OV81NTBkZWxHVFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MDYxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJUMkRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTA5MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGlhYmV0ZXMgY29tcGxpY2F0aW9uc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTk0OTM5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkeXNraW5lc2lhXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjMxOTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiMTEwMGRlbENcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiODA5OTUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkExNzJHXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjkyMDAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm15ZWxvaWQgbWFsaWduYW5jaWVzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjU2MTYwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkUxMDFLXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI4NDAwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlIyMjJRXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEzNTIyMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJFMTYxS1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxOTE4OTkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlJzOTgyOTg5NlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNDY1NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTjM0U1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjY2MzM1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhdXRvc29tYWwgZG9taW5hbnQgbGF0ZXJhbCB0ZW1wb3JhbCBsb2JlIGVwaWxlcHN5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1ODcxOTUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImhlbW9seXNpc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzODExNjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiR2x5ODBBcmdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYwNDE4MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQmlwb2xhciBkaXNvcmRlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5NzE0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJraWRuZXkgZGlzZWFzZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5NzE3MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwZWRpYXRyaWMgYXN0aG1hXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjkyNTIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImhhZW1vY2hyb21hdG9zaXNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU3NDI5MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibWFjcm9jZXBoYWx5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzM3NjUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm1pZ3JhaW5lXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjIwMjU1NjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnM5MjYwMTUxXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2MDk1NTQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImF0YXhpYyBlcGlzb2Rlc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI3ODc5MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRDQ1OFZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjg3NDQwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFyZzE1MUN5c1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDIzMjgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInAuTDQyNFZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTM3MzcwMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSczczODQwOVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5ODM4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBSVBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjk0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkZWx0YSBGNTA4XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE5NjY2MTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5NMTAyOUtcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYwNTY2NDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUEsgZGVmaWNpZW5jeVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzNzcxNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQTU1OVRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU5NTI4NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVXNoZXIgc3luZHJvbWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTgwODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTkFGTERcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjAyNTU3MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczMxMzUwMDJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3MzY4MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZW5kIHN0YWdlIHJlbmFsIGRpc2Vhc2VcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiODA4MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiSFBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjY3MzcwNDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZ2VuZXRpYyBsZXNpb25cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMzIwMjEwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlM4OTFBXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjQ3NTI5MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJLMjU3VFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjQ0NDQxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJzdWRkZW4gZGVhdGhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTQwMzI3MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczkyNzU1MTdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU1NDcyMjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQnllbG9ydXNzaWFuIGJyZWFzdCBjYW5jZXJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NDUwMjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ2FuYXZhbiBkaXNlYXNlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1OTI2ODkwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImp1dmVuaWxlIHBhbmNyZWF0aXRpc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMzU3NzEwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlI4MjBXXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NDQ3MjcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInZlbnRyaWN1bGFyIGVjdG9weVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMzgyMDQwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInAuQXJnMTgyR2x5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEzMjI5MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLkEzMDdTXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjk2NjUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInN0cm9rZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MTgyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJQS1VcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYwMzIxMTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibWljcm9jeXRpYyBoeXBvY2hyb21pYyBhbmVtaWFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTI5ODMyMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLkFyZzIwMWRlbFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc0ODE1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJtaXRvY2hvbmRyaWFsIGVuY2VwaGFsb215b3BhdGh5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzQyNTQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkZWSUkgZGVmaWNpZW5jeVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI4MzkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkUyNTVLXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE1ODQ1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJHU0QgdHlwZSAxYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTcyMjc0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJoZWFyaW5nIGltcGFpcm1lbnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTY4NzkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlI2N0NcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTYwNTg0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLkMxNzMzWVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNzQzNTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5SODcwSFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjAxMDEzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhdXRvc29tYWxcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiODQ2NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5SOTZIXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzQ4NjUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkJTXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI3OTkyMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJTZXIyNTJQaGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTM3NzI3MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjLjEyMjdfMTIyOGR1cFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNjcyODYwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImMuMTExNGRlbEdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NDY1NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ2VEXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjg1Mzk0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJWNDU2QVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MjIxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNTVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI0OTc3NzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTDI2NlZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMzMwNTYwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlQ4MEFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNjUzMDUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlcyNThYXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzUwMzgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImJsYWRkZXIgY2FuY2VyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjk3MDAwMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJUMzIyTVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjQ3MzkyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJJU3NcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3MzU0NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZHlzdG9uaWFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNzY4MTQwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInAuTGV1MTQ5ZGVsXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjMyMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLlY2MDBFXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEyMDk0MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnMxNzU4MFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MzY2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjb2xvcmVjdGFsIHR1bW9yc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI0MjYyNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRDUxM0dcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMzI4NDcwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInAuUDg2TFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc0OTU2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ0eXBlIDEgZGlhYmV0ZXNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjUyNjkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkcxODhSXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjY3ODYwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkM3M1JcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTMwMzY3MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjLjQwMzRkZWxBXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzM2MjMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk1BRERcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTA3NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibmFyY29sZXBzeVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI0OTQ0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLlI0MDhRXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjk4NjAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkNEXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2NzI4MjAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhcmRpYWMgaW52b2x2ZW1lbnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NTAwNzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaHlwZXJ0cm9waGljIGNhcmRpb215b3BhdGh5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NDQ0MzEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkZIXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1ODU0MjAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInBvbHlwb3Npc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMjA2MzcyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJQRURcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NDM4MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibXlvY2xvbnVzIGVwaWxlcHN5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjMxOTgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkczODBSXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2MjQyNjgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkNBVkRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NDY3ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiSHlwb1BQXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjk5MjAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImxldWtvcGVuaWFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYyOTkzNDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZHlzZmVybGlub3BhdGh5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjIyNzM5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJsb25nIFFUIHN5bmRyb21lIHR5cGUgMVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI3NTMwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlI3MDJXXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjExNTMzMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSMzlDXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2MzM1NjIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlRhdVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI2MTU5NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVjU5R1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyMTg3NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5HbHkyMDdBcmdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNjYxMTAwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlI4NjNYXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjk3MTAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlBhcmtpbnNvbidzIGRpc2Vhc2VcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjUwNDcwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIjMyIGRlbHRhVFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTY1ODgwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhcGljYWwgaHlwZXJ0cm9waGljIGNhcmRpb215b3BhdGh5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEyMDAyNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiWTY1OENcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYwNjE3MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaWRpb3BhdGhpYyBicm9uY2hpZWN0YXNpc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI0ODY5MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUjM3N0hcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NDAyMTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTlNDTENcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3MzkzNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwic2lhbGlkb3Npc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI0NzIzMzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiSTE1N1RcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMzAzODEwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkQxMTUySFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI5MDMzMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJQODFMXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjQ3ODk5MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBcmc3MjNHbHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTEwNTAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImdvdXRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjY1NzEzMjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwidWxjZXJhdGl2ZSBjb2xpdGlzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjcwNjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnM3MDI1NDg2XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2NDU5MjIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkhCViBpbmZlY3Rpb25cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU2MjI1MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVHVtb3JcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYyNTU4NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXV0b3NvbWFsIHJlY2Vzc2l2ZSBwZXJzaXN0ZW50IGh5cGVycGxhc3RpYyBwcmltYXJ5IHZpdHJlb3VzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2NzM4NTMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInR5cGUgSUkgY29sbGFnZW5vcGF0aHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYxMTQ2MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRUNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjY3MzgwNjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUGVuZHJlZCBzeW5kcm9tZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzNTg3ODA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRTEzMTdRXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzQyODAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlNEXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjY1MzY5MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSNzY5UVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDczODYwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDcm91em9uIGFuZCBQZmVpZmZlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI2MDc3MDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUTE2M1hcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTQzMzgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkcxMzA2QVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTgxNzQwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhdXRpc3RpY1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMjE0MDUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMTMzMzMyMjZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTI4ODkyMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSODY1R1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMzY2ODYwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk40NkhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTI1MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiSGVyZWRpdGFyeSBoZW1vY2hyb21hdG9zaXNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU0MzgzOTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVudGFsIHJldGFyZGF0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzUzMjcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlRBc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MTYyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJtaWdyYWluZSB3aXRob3V0IGF1cmFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjY0ODE4ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGVzbWluXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzU1MDYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlRheS1TYWNocyBkaXNlYXNlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjc4NTgzMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLkcxOTJSXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjMyODIyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYWxwYWlub3BhdGh5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE3ODg0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJUNzA0TVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc1NTA1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBRFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzMzQwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIjM1ZGVsR1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc0NTEzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJJQ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjczNDMzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXJkaWFjIG1hbGZvcm1hdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYxMDkzMjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiWC1saW5rZWQgZG9taW5hbnQgUGFya2luc29uJ3MgZGlzZWFzZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjgzMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLkFyZzE5Mkhpc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjA5OTYzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJteW9reW1pYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxODgzNDAwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzOTgxNTY2M1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjA3Mzc3MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwcmltYXJ5IGludHJhY3RhYmxlIGVwaWxlcHN5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwMjQxMDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5QMTUyQVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI2MTYwMzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5Bc3AxNTNWYWxcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYyNzU4NzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibXlvdG9uaWFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NTAwNzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiSHlwZXJ0cm9waGljIGNhcmRpb215b3BhdGh5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEyNjc5NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5HbHk2MDNBcmdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiODQ5OTUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlQyOTVNXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjMwMTkzMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSMTMzQ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI5ODkyMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJQMzBMXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE4NTYwNTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnM3NTMzNTY0XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjc2ODYwMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSMTkwNVhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU5NzY2MDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZXBpbGVwc3lcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTY2NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaHlwZXJ0ZW5zaW9uXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2MTA5OTgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhcmRpb215b3BhdGh5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2MTczMzEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkVQU1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI4Njg0MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVzExOTFYXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjU5MDgyMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLkFzbjEwN1NlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxODI4OTEwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImMuMzU5ZGVsXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE4OTM0MTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnMxNDIyNjczXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE4NDcyMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBcmcxNDVHbHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTU0NjE5MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLkxldTQ3NFByb1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMTg4NzgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMTgwNTAwN1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNzc0MDgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMjA0MjMyOVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjczNjc5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJoeXBvdG9uaWFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNDUzNjMwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkMxMzZSXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjgwNjY3MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLkQxNjlHXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1ODQ1MjEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNlcmVicmFsIFgtQUxEXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2ODUyMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBMjQ0VlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNzk3MDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiT1NcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3MjU2OTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRVItbmVnYXRpdmUgYnJlYXN0IGNhbmNlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDczOTM3MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJXRFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTYyMjUxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ0dW1vclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNTM0NDkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMTE2NTUwODFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiODExMjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRDE4TlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI0ODE0MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUjM4WFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI3MTUwMTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUjQyMFdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTIwNTk3NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiSmFja3Nvbi1XZWlzcyBzeW5kcm9tZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjM5Mzg1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNQ01cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYxNjAyNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiSkxOU1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTcxMDgxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJQR0xcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTIyODI0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczI1Njk1MTJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NDgzODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXJyaHl0aG1vZ2VuaWMgcmlnaHQgdmVudHJpY3VsYXIgY2FyZGlvbXlvcGF0aHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMzYwNTgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkMyNDBGXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjMyNzQwMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJUMTA2TVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzMTQ5MDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiR2x5MzY0IHRvIEFzcFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc1MzkyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNUlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTg1MzA1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJuZXVyb25hbCBsb3NzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEyODc0MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnM5ODc4NzBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNDI0NDgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkczODlSXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NjM3MjQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInVuaXBhcmVudGFsIGRpc29teVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjA5OTgzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJsZWZ0IHZlbnRyaWN1bGFyIG5vbi1jb21wYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwMTEyOTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnM1NzcwOTE3XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1OTQ5OTAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInBhbmNyZWF0aWMgc3VmZmljaWVuY3lcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNTc1NDAwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkM0NlJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTQwNDQyMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLlMyNDhBZnMqNjVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjY3MzEyNjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQU8tR0xEXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjU3Mzk0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJTNDY1UlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI1Nzg3MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBcmczNTAwR2xuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2Mzg1MjUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk1DT1BDQlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNzI3MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5Bc3AyMTVBc25cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTIyODIzMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczY5Mjk4NDZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTk4MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJUNzkwTVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTg4ODY2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJteW9jeXRlIGVubGFyZ2VtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjYzNjQ0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJQMTk5UFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI1ODExMTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUTc5UlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MzY2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDUkNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3Mzg1MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwidHlwZSBJSUlhXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2MjM4MTQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInBhaW5mdWwgbXVzY2xlIGNyYW1wc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjI3NzgwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ1cHBlciBsaW1iIG1hbGZvcm1hdGlvbnNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3Mjc2MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ0pEXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjY4NDczMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJJNDYyU1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc1MDMzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJEU1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyMDI5OTAwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMjI4NDM3OFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MjYyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDaGFyY290LU1hcmllLVRvb3RoXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2MDkxNDIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImlzY2hlbWljIHN0cm9rZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNzg1OTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRjMxMExcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTg2MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY3lzdGljIGZpYnJvc2lzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjkwODAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImdpbmdpdml0aXNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMzQ1NTgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkQ0NDRIXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjkyNDkwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImR1b2RlbmFsIHVsY2VyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjU5MTc3MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLkFyZzEzN0dsblwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNzkzMzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiSTE3OVNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3Mzg3NzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZ2FzdHJpYyBub24tY2FyZGlhIGNhbmNlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI1MTM2MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJnbHljaW5lMjUwLS0+IGFzcGFydGF0ZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNDk0OTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTDIwNldcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NTE5NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ0FIXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE2MTIwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkg2M0RcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTczOTM1MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJGODJWXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE4MTAyMTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnMxNjMxNzdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NDM1MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZmFtaWxpYWwgaHlwZXJjaG9sZXN0ZXJvbGVtaWFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNDE3NTMwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkwzNDVQXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2NzEzOTIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkNGRU9NXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEyMDA0MDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5DMTE4WVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMTc3NzQwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlA3OTlMXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjM1MTEwMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSNzYxSFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTkzNzg4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJza2VsZXRhbCBhYm5vcm1hbGl0aWVzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NjM2NjYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZpYnJvc2lzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjM4MTE3MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBcmcyMzdUcnBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYwOTkyMzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibWljcm9jZXBoYWx5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI3NTc5MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSMjc5V1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzNDA3NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUDg2UlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTg2ODI1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJsdW5nIGRpc2Vhc2VcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNTQ0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJHMjAxOVNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3MjU0NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwidmVudHJpY3VsYXIgc2VwdGFsIGRlZmVjdHNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTc2NjI1MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczc1NTI0OVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNjMxNTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUDI1M1JcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3MDAxMjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ1JEXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzQ4MzgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInNlcHRhbCBoeXBlcnRyb3BoeVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTk5NjQxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJvY3Vsb2xlcHRvbWVuaW5nZWFsIGFteWxvaWRvc2lzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE2MDU4MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5DMTc0OEZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMzA3MjgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkk2Nk1cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTA2MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiR0RcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTQ4NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVkhMXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NjAxODYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm90aXRpcyBtZWRpYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxODEwMjAwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMTA3NjE3NDVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjY3OTcwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk4xODhTXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2Njk2MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJQcm8yNTJBcmdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NTA1ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQURBTVRTMTMgZGVmaWNpZW5jaWVzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzQ3NzIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkdTXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwMjM0MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnMxMDQ5Mjk3MlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5ODYzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDRlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTQzMDg2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjb25kdWN0aW9uIGRlZmVjdFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MTgyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwaGVueWxrZXRvbnVyaWFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU5Mjg1NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZ2lhbnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYxMzgyNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibmV1cm9wYXRoeVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjAzOTk4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJQZW5kcmVkJ3Mgc3luZHJvbWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTg3MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwidmFzY3VsaXRpc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNDMwNDMwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMjY0NTQyNFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNDg4MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJJMTcyTlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI2MjUwOTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5EMjQ5TlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDczNjgxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJFU1JEXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjYwNTk0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJFMTAzRFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc0ODM4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBUlZDXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE1NDU2MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSODNDXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE2MzE0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJTMjUyV1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI2NzMyNzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYy4xOTMyZGVsQ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI2NzE0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJQNjY0TFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzODYxODA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUjE3NlhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTUzNDQwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlI5OENcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTMyNDYxMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczI3Mjc5NDNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMzA0OTYwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlY4MDRMXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1ODAwNDMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm1hbGlnbmFuY3lcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU4OTY2ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaGVtYXRvbG9naWMgZGlzb3JkZXJzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjgyODA5MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJFMjkyVlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5NzA0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNU1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MTM1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ0YXVvcGF0aHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTI5MTUxMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLkczMDRLXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjk3MTgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk1JXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE2OTM2MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnM5ODk2MDUyXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1OTM3MTYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInNpZ2h0LXRocmVhdGVuaW5nIGRpYWJldGljIHJldGlub3BhdGh5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1Nzk2NzAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhcmRpYWNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU3NzI5MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaHlwZXJ0cm9waHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNTEwODA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUDUzM1JcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NDUxNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQmVybmFyZC1Tb3VsaWVyIHN5bmRyb21lXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2NTQwNDEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm5ldXJhbCBkZWZlY3RzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjU4Nzc0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwLkFyZzEyMTBDeXNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNjMwNjIwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInAuUjI4N1FcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3MzYyNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicGFydGlhbCBlcGlsZXBzeVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNzA3NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVjE4MElcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNjk5MjEwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlI5MEhcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYyMDEyMDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGVmaWNpZW5jeSBvZiBtaXRvY2hvbmRyaWFsIDMtaHlkcm94eS0zLW1ldGh5bGdsdXRhcnlsLUNvQSBzeW50aGFzZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc1MDA3MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJIQ01cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTIwOTQxMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczI4OTI5NDc0XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzU0OTQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImJpb3RpbmlkYXNlIGRlZmljaWVuY3lcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMzIwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlY2MDBFXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NTA0ODcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlBBRFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxOTI0OTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVzI4M1hcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU2OTYwMzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYm9uZSBsZXNpb25zXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NjE0NjIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImh5cGVyZ2x5Y2VtaWFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTMzODIxMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczExOTg2NDE0XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NTUyMTAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbmdlbml0YWwgbXVzY3VsYXIgZHlzdHJvcGh5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzQ2NTUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFMUFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI1Mjg3MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSMjMxQ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyMjI0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJDMjgyWVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDcyNzE4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjZXJlYnJvdGVuZGlub3VzIHhhbnRob21hdG9zaXNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTE3NjcwMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczQ3ODQyMjdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMzUyODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRk1UQ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI0MDQ4OTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRjIyOUxcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNjU1NzQwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlkyODggQ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTY4NDk4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJtZWR1bGxhcnkgdGh5cm9pZCBjYW5jZXJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjY3MjkyOTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicHVwYWwgbGV0aGFsaXR5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzQyMjgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkNNTFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MDYzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJHRDFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NTQ3NDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibXVsdGlwbGUgZW5kb2NyaW5lIG5lb3BsYXNpYSB0eXBlIDIgc3luZHJvbWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNDcyMzIwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlIxNDVXXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1ODc2NTAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFGXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjMzMjA1MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBcmc1OEdsblwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc0MjM2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBcGVydFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzNDc3ODA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiU2VyNzhMZXVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYzODcyNDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTXVlbmtlIHN5bmRyb21lXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzI5MzYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbG9yZWN0YWwgYWRlbm9tYXNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNjg5MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZmFtaWxpYWwgYXRyaWFsIGZpYnJpbGxhdGlvblwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyMDQzOTAwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzMjA0MTU3MFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI4Njg1MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiRTE5NzhYXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjkzNjkwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIk5vb25hbiBzeW5kcm9tZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNDM1NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicC5BcmcyNThHbHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NDY1MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiSFRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NDM1MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTERMIHJlY2VwdG9yIGRlZmljaWVudFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyOTQ1MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicGhlbnlsYWxhbmluZS01NSB0byBzZXJpbmVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYxMDA0NDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwidW5pbGF0ZXJhbCBwb3N0YXhpYWwgcG9seWRhY3R5bHlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTM4NjQzMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczM4NTAzNzBcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNTQ2NzUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlAzMTZTXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE2MzA5MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnM3NTM3NjA1XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjQyMDU5MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJWNTdkZWxcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNTc1MTkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlMxNDBUXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjYyMDUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkc0ODBDXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzQ1NzUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkdTRElJXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE4MjEzMDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicnM1MTUwNzFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNzUwMDEwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlE1MTBFXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjQ3NjIwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkdsdTIyTHlzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjkyNjMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFQQ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI2MTE2NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQXJnODIwR2xuXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjMxMTEwMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJHMTM1MTNBXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzM1NDUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZvY2FsIG9yIHNlZ21lbnRhbCBkeXN0b25pYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxOTIzOTcwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJzOTAzNjAzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjY1MTMwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkcxM1ZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNDAxOTcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFsYW5kIGlzbGFuZCBleWUgZGlzZWFzZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI2NzE0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwcm9saW5lNjY0LWxldWNpbmVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYzNjQ4OTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiR2x1dDEtZGVmaWNpZW5jeVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5OTkwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmcm9udG90ZW1wb3JhbCBkZW1lbnRpYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDczOTM1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ0eXBlIDJcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA2OTcxODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibXlvY2FyZGlhbCBpbmZhcmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjkxNzgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRlbWVudGluZyBjb25kaXRpb25cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjExMzMwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFyZzUxMCB0byBHbG5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYxMDc5NDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29uZ2VuaXRhbCBzdGF0aW9uYXJ5IG5pZ2h0IGJsaW5kbmVzcyBwaGVub3R5cGVzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzQyMzYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlBmZWlmZmVyIHN5bmRyb21lXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjUyNjA0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSNzAyQ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNjg5OTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibmV1cm92aXNjZXJhbCBwaGVub3R5cGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NTIzNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTGVpZ2ggc3luZHJvbWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNDk0NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiUjQwOFFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTYxNTU5MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyczgwNDEzNTdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiODYwNjMwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInAuIFAyNjZTXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjUyNjA2MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJSNzAySFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI4NDc2NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQzIyOVlcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNTAzMDcwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlYxMzhGXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NjE5MjUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImh5cGVyY2hvbGVzdGVyb2xlbWlhXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzM3NjgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkNPUERcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTY0NTgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlI1MjhIXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1OTgxNDEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImF4b25hbCBsb3NzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NTc5MjcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImxvdy1yZW5pbiwgbG93LWFsZG9zdGVyb25lIGh5cGVydGVuc2lvblwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNjc0MTUxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ0aHlyb2lkIHR1bW9yc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTYyMjUxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ0dW1vcnNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYwOTU1NDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2VyZWJlbGxhciBhdGF4aWFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiOTYwMzIwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlNlcjM1OExldVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyMDYwMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJNNjk0VlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzOTg1NzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZEhNTlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzNTAyNzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQTMzN1BcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NDgwOTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYnJlYXN0IGNhbmNlclwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI3OTU1MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiVGhyNTc0QWxhXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNjk3MTcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzdGhtYVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyNTk4MTEzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkZXZlbG9wbWVudGFsIGRlbGF5XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI2NzMwOTcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlVQRFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCI1MzgxMzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiSTEyNVRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjU0NzY4MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29uZHVjdGlvbiBibG9ja1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNDA1NTYwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIlIzMjc3Q1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInZhcmlhbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc0ODA2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjb3JvbmFyeSBzcGFzbVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIzOTc4MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJBcmcxMDRHbG5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiNDY4MzgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkc3MjRDXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidmFyaWFudFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzQ5MDMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIkFjaG9uZHJvcGxhc2lhXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEwNzUyNzEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIm15b3RvbmljIGRpc2NoYXJnZXNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTY4MTk1MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJUaHIyOThBbGFcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ2YXJpYW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTA3NTQ5OTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY3Jhbmlvc3lub3N0b3RpYyBzeW5kcm9tZXNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjY3MjU2MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2FyZGlhYyBhYm5vcm1hbGl0aWVzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiBcIjI1NTIxMDgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRydWcgYWJ1c2VcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjY3Mzk0NDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaW1tdW5vZGVmaWNpZW5jeVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDY5MDYxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ0eXBlIDIgZGlhYmV0ZXNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJkaXNlYXNlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IFwiMjYwMzQyMDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ0ZUUi1yZWxhdGVkIGRpc29yZGVyc1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImRpc2Vhc2VcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMDc1NDk5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJzeW5kcm9taWMgZm9ybSBvZiBjcmFuaW9zeW5vc3Rvc2lzXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZGlzZWFzZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLFxuICAgIFwiZWRnZXNcIjogW1xuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTE3Nzc0MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjk4OTcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImlkZW50aWZpZWQgSW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIE1ELCBhIHJlY3VycmVudCBQNzk5TCBtdXRhdGlvbiB3YXMgaWRlbnRpZmllZCBpbiBuaW5lIHN1YmplY3RzLCBhcyB3ZWxsIGFzIDEwIG5vdmVsIG11dGF0aW9ucyBpbmNsdWRpbmcgRjQ3MWRlbCwgdGhlIGZpcnN0IGRlbGV0aW9uIG11dGF0aW9uIG9mIFRSUFY0LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxODEwMjAwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTA2MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBbW9uZyB0aGVtLCByczEwNzYxNzQ1IChKTUpEMUMpIGFuZCByczE2MzE3NyAoS0NOUTEpIHdlcmUgcHJvc3BlY3RpdmVseSBhc3NvY2lhdGVkIHdpdGggVDJELlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNjkzNjIwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU5MzcxNjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJPbmx5IHJzOTg5NjA1MiAocCA9IDYuNTUgeCAxMCAoLTUpKSB3YXMgYXNzb2NpYXRlZCB3aXRoIHNpZ2h0LXRocmVhdGVuaW5nIGRpYWJldGljIHJldGlub3BhdGh5IGluIGJvdGggdGhlIHR5cGUgMiAocCA9IDAuMDM1KSBhbmQgdGhlIHR5cGUgMSAocCA9IDAuMDQxKSByZXBsaWNhdGlvbiBjb2hvcnRzLCBhcyB3ZWxsIGFzIGluIHRoZSBJbmRpYW4gY29ob3J0IChwID0gMC4wMTYpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNjQ4MTg4MDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NzE2NTgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiV2UgY29uY2x1ZGUgdGhhdCB0aGUgTDM0NVAgZGVzbWluIG1pc3NlbnNlIG11dGF0aW9uIGNhdXNlcyBteW9wYXRoeSBieSBpbnRlcmZlcmluZyBpbiBhIGRvbWluYW50LW5lZ2F0aXZlIG1hbm5lciB3aXRoIHRoZSBkaW1lcml6YXRpb24tcG9seW1lcml6YXRpb24gcHJvY2VzcyBvZiBpbnRlcm1lZGlhdGUgZmlsYW1lbnQgYXNzZW1ibHkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjM4MTE3MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2NzI1NjIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlZFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSW4gY29udHJhc3QsIG1pc3NlbnNlIG11dGF0aW9ucyBwcm9kdWNlZCBkaXN0aW5jdCBwaGVub3R5cGVzOiBHbHk4MEFyZyBjYXVzZWQgc2lnbmlmaWNhbnQgY2FyZGlhYyBtYWxmb3JtYXRpb25zIGJ1dCBvbmx5IG1pbm9yIHNrZWxldGFsIGFibm9ybWFsaXRpZXM7IGFuZCBBcmcyMzdHbG4gYW5kIEFyZzIzN1RycCBjYXVzZWQgZXh0ZW5zaXZlIHVwcGVyIGxpbWIgbWFsZm9ybWF0aW9ucyBidXQgbGVzcyBzaWduaWZpY2FudCBjYXJkaWFjIGFibm9ybWFsaXRpZXMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE2NzI4NjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTQyMDAwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkl0IGlzIHRoZSBmaXJzdCB0aW1lLCB0byB0aGUgYmVzdCBvZiBvdXIga25vd2xlZGdlLCB0byByZXBvcnQgdGhhdCBjLjU0OV81NTBkZWxHVCBhbmQgYy4xMTE0ZGVsRyBtdXRhdGlvbnMgaW4gdGhlIFRZUiBnZW5lIHdlcmUgYXNzb2NpYXRlZCB3aXRoIE9DQS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNzUzMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2NTcxMzIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiUjcwMlcsIEc5MDhSLCBhbmQgMzAyMGluc0Mgd2VyZSBzdHJvbmdseSBhc3NvY2lhdGVkIHdpdGggQ0QgYnV0IG5vdCB3aXRoIHVsY2VyYXRpdmUgY29saXRpcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzQ3NzgwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTQ2NDkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZvdW5kIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIHRoZSBQMCBnZW5lIGEgU2VyNzhMZXUgbXV0YXRpb24gd2FzIGZvdW5kIGluIG9uZSBmYW1pbHkgd2l0aCBzZXZlcmUgQ01UMSBhbmQgYSBkZSBub3ZvIFR5cjgyQ3lzIG11dGF0aW9uIHdhcyBmb3VuZCBpbiBvbmUgRFNTIHBhdGllbnQuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE3MzkzNTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5MjAwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBbGwgZml2ZSBtdXRhdGlvbnMgYXJlIGFzc29jaWF0ZWQgd2l0aCBOUywgd2hlcmVhcyB0d28gKEE1N0cgYW5kIEY4MlYpIGhhdmUgYWxzbyBiZWVuIGlkZW50aWZpZWQgaW4gdXJpbmFyeSB0cmFjdCBjYW5jZXJzIGFuZCBteWVsb2lkIG1hbGlnbmFuY2llcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTA3MjcxODAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCI1OTE3NzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VkIGJ5XCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJXaG9sZS1leG9tZSBzZXF1ZW5jaW5nIGFzc3VtaW5nIHJlY2Vzc2l2ZSBpbmhlcml0YW5jZSBkZXRlcm1pbmVkIGhpcyBnZW5ldGljIGRpYWdub3NpcyB0byBiZSBjZXJlYnJvdGVuZGlub3VzIHhhbnRob21hdG9zaXMgY2F1c2VkIGJ5IGhvbW96eWdvdXMgbXV0YXRpb25zIChjLjQxMEc+IEEgb3IgcC5BcmcxMzdHbG4pIGluIHRoZSBjeXRvY2hyb21lIFA0NTAgc3ViZmFtaWx5IDI3IEExIChDWVAyN0ExKSBnZW5lLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMjM3MzkwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjYwOTE0MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJTTlAgcnM1MDU5MjIgd2FzIG5vbWluYWxseSBhc3NvY2lhdGVkIHdpdGggaXNjaGVtaWMgc3Ryb2tlIChvZGRzIHJhdGlvID0gMC45NCwgOTUlIGNvbmZpZGVuY2UgaW50ZXJ2YWwgPSAwLjg4LTAuOTksIHAgPSAwLjAyMykuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjI1OTgxMTMwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTMyMjkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhcnJ5XCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJDbGluaWNhbCBmZWF0dXJlcyBhcmUgc2V2ZXJlIGRldmVsb3BtZW50YWwgZGVsYXksIG1pY3JvY2VwaGFseSBhbmQgZHlza2luZXNpYS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiODY4NTMwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NDgwOTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwib2JzZXJ2ZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIGEgdGhpcmQgY2FzZS1jb250cm9sIHN0dWR5IGZyb20gUG9sYW5kLCBFMTk3OFggd2FzIG9ic2VydmVkIGluIDcvMyw5MTAgUG9saXNoIGJyZWFzdCBjYW5jZXIgY2FzZXMgKDAuMiUpIGNvbXBhcmVkIHdpdGggMS8yLDAxMCBjYW5jZXItZnJlZSBwb3B1bGF0aW9uIGNvbnRyb2xzIChPUjogMy42OyA5NSUgQ0k6IDAuNC0yOS4zLCBQID0gMC40KS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTc3NDA4MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzUwMzgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSG93ZXZlciwgcnMyMDQyMzI5IHdhcyBub3QgYXNzb2NpYXRlZCB3aXRoIGJsYWRkZXIgY2FuY2VyIHJpc2sgaW4gcGF0aWVudHMgb2YgRXVyb3BlYW4gZGVzY2VudC5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjU0NjMxNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCI2MjUwOTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJIeXBvbXllbGluYXRpb24gd2l0aCBhdHJvcGh5IG9mIHRoZSBiYXNhbCBnYW5nbGlhIGFuZCBjZXJlYmVsbHVtIChILUFCQykgaGFzIHJlY2VudGx5IGJlZW4gYXNzb2NpYXRlZCB3aXRoIGEgc2luZ2xlIGhldGVyb3p5Z291cyBwLkQyNDlOIG11dGF0aW9uIGluIFRVQkI0QS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjU5Mjg1NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxNDMzODA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZm91bmQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIk5vIGdpYW50IG15b3RvbmljIGRpc2NoYXJnZXMgb3IgcGFpbmZ1bCBtdXNjbGUgY3JhbXBzIHdlcmUgZm91bmQgaW4gdGhlIG90aGVyIEcxMzA2QSBmYW1pbGllcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNjU1NzQwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU5ODExMzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGVzY3JpYmVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBZMjg4IEMgdmFyaWFudCB3YXMgcHJldmlvdXNseSBkZXNjcmliZWQgaW4gYSBjaGlsZCB3aXRoIG1hY3JvY2VwaGFseSwgbWlsZCBkZXZlbG9wbWVudGFsIGRlbGF5LCBpbmNyZWFzZWQgc2lnbmFsIGludGVuc2l0eSBpbiB0aGUgYmFzYWwgZ2FuZ2xpYSwgcGFydGlhbCBjb3J0aWNhbCBibGluZG5lc3MgYW5kIHJldGluaXRpcyBwaWdtZW50b3NhLCBhbmQgc2xpZ2h0bHkgZWxldmF0ZWQgTi1hY2V0eWxhc3BhcnRhdGUgaW4gdGhlIHVyaW5lLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxODQ3MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc1MDA3MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJsaW5rZWQgdG9cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkZhbWlseSBzdHVkaWVzIHNob3dlZCB0aGF0IGFuIEFyZzE0NUdseSBtdXRhdGlvbiB3YXMgbGlua2VkIHRvIEhDTSBhbmQgYSBMeXMyMDZHbG4gbXV0YXRpb24gaGFkIG9jY3VycmVkIGRlIG5vdm8sIHRodXMgc3Ryb25nbHkgc3VnZ2VzdGluZyB0aGF0IGNUbkkgaXMgdGhlIHNldmVudGggSENNIGdlbmUuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjMxMTEwMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzUyMzUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZvdW5kIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlNpbmNlIHRoZSBHMTM1MTNBIG11dGF0aW9uIHdhcyBmb3VuZCBpbiAyMSUgb2Ygb3VyIHBhdGllbnRzIHdpdGggTGVpZ2ggc3luZHJvbWUgYW5kIGNvbXBsZXggSSBkZWZpY2llbmN5ICgzLzE0KSwgaXQgYXBwZWFycyB0aGF0IHRoaXMgbXV0YXRpb24gcmVwcmVzZW50cyBhIGZyZXF1ZW50IGNhdXNlIG9mIExlaWdoLWxpa2Ugc3luZHJvbWUsIHdoaWNoIHNob3VsZCBiZSBzeXN0ZW1hdGljYWxseSB0ZXN0ZWQgZm9yIG1vbGVjdWxhciBkaWFnbm9zaXMgaW4gYWZmZWN0ZWQgY2hpbGRyZW4gYW5kIGZvciBnZW5ldGljIGNvdW5zZWxsaW5nIGluIHRoZWlyIG1hdGVybmFsIHJlbGF0aXZlcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiOTYyNDQwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTIwNDI2MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJEeXNmZXJsaW4gaG9tb3p5Z291cyBtdXRhdGlvbiBHMTQxOEQgY2F1c2VzIGxpbWItZ2lyZGxlIHR5cGUgMkIgaW4gYSBNZXhpY2FuIGZhbWlseS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNDAzNDUwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjY3MzA5NzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZm91bmQgZHVlXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJNb2xlY3VsYXIgZ2VuZXRpYyBhbmFseXNpcyBvZiBseW1waG9ibGFzdGljIGJsYXN0cyBhdCB0aGUgdGltZSBvZiB0aGUgQUxMIGRpYWdub3NpcyByZXZlYWxlZCB0aGUgZ2VybWxpbmUgbXV0YXRpb24gaW4gYSBoZXRlcm96eWdvdXMgc3RhdGUsIHdoaWxlIGluIHRoZSBteWVsb21vbm9jeXRpYyBibGFzdHMgb2NjdXJyaW5nIHdpdGggSk1NTCBkaWFnbm9zaXMsIHRoZSBtdXRhdGlvbiBwLkUxMzlEIHdhcyBmb3VuZCBpbiBhIGhvbW96eWdvdXMgc3RhdGUgZHVlIHRvIGEgdW5pcGFyZW50YWwgZGlzb215IChVUEQpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNjI0MjY4MDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjQ4NjYwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbXBvdW5kIGZvclwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVHdlbnR5LW9uZSBHZXJtYW4gQ0FWRCBwYXRpZW50cyB3ZXJlIGNvbXBvdW5kIGhldGVyb3p5Z291cyBmb3IgZGVsdGEgRjUwOCBhbmQgUjExN0gsIHdoaWNoIHdhcyB0aGUgbW9zdCBmcmVxdWVudCBDQVZEIGdlbm90eXBlIGluIG91ciBzdHVkeSBncm91cC5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTA3NTQ3NDAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIzNTI4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJzdWJjbGFzc2lmaWVkIGludG9cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZXJlZm9yZSwgd2Ugc3VnZ2VzdCB0aGF0IE1FTiAyQSBmYW1pbGllcyBzaG91bGQgbm90IGJlIHN1YmNsYXNzaWZpZWQgaW50byBNRU4gMkEgYW5kIEZNVEMsIGJ1dCByYXRoZXIgYWNjb3JkaW5nIHRvIHRoZWlyIHNwZWNpZmljIG11dGF0aW9uIGluIHRoZSBSRVQgcHJvdGVpbiAoaS5lLiwgZm9yIHRoaXMgZmFtaWx5IE1FTiAyQSBSRVQgQzYxOFMpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI4NjA2MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0NTc1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkhvd2V2ZXIsIHAuIFAyNjZTLCBwLiBQMzYxTCBhbmQgcC5SNDM3QyBtaWdodCBiZSBhc3NvY2lhdGVkIHdpdGggbGF0ZS1vbnNldCBHU0RJSS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTkyNDkwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTgzODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZm91bmQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBXMjgzWCBsZXNpb24gd2FzIGZvdW5kIGluIGFub3RoZXIgdW5yZWxhdGVkIEFJUCBmYW1pbHkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjI2MDQxODEwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTMyNDYxMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkJpcG9sYXIgZGlzb3JkZXIgd2l0aCBhbGNvaG9sIGRlcGVuZGVuY2UgYW5kIG90aGVyIGNvLW1vcmJpZGl0aWVzIHdhcyBhc3NvY2lhdGVkIHdpdGggU05QIHJzMjcyNzk0MyAocCA9IDMuM3gxMC0pIG9uIGNocm9tb3NvbWUgM3AyNi4zIGxvY2F0ZWQgYmV0d2VlbiB0aGUgZ2VuZXMgY29udGFjdGluLTQgcHJlY3Vyc29yIChCSUctMikgYW5kIGNvbnRhY3RpbiA2IChDTlRONikuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEyMDYzNzIwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU5ODExMzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29tYmluZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiV2Ugc2NyZWVuZWQgNCBhZGRpdGlvbmFsIGZhbWlsaWVzLCBpbiB3aGljaCBQRUQgaXMgY29tYmluZWQgd2l0aCBlcGlsZXBzeSwgZGV2ZWxvcG1lbnRhbCBkZWxheSwgb3IgbWlncmFpbmUsIGJ1dCBub3Qgd2l0aCBoZW1vbHlzaXMgb3IgZWNoaW5vY3l0b3NpcywgYW5kIGlkZW50aWZpZWQgMiBhZGRpdGlvbmFsIEdMVVQxIG11dGF0aW9ucyAoQTI3NVQsIEczMTRTKSB0aGF0IGRlY3JlYXNlZCBnbHVjb3NlIHRyYW5zcG9ydCBidXQgZGlkIG5vdCBhZmZlY3QgY2F0aW9uIHBlcm1lYWJpbGl0eS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTc4NjYyMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzQ4MDkwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiU2ltaWxhcmx5LCByczE3NTMwMDY4IGF0IDZxMTQgd2FzIGFzc29jaWF0ZWQgd2l0aCBicmVhc3QgY2FuY2VyIChPUiA9IDEuMTI7IFAgPSAxLjEgeCAxMCAoLTkpKSwgYW5kIHdpdGggYm90aCBFUi1wb3NpdGl2ZSAoT1IgPSAxLjA5OyBQID0gMS41IHggMTAgKC01KSkgYW5kIEVSLW5lZ2F0aXZlIChPUiA9IDEuMTYsIFAgPSAyLjUgeCAxMCAoLTcpKSBkaXNlYXNlLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNzA3NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDcyNzYxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIk91ciByZXN1bHRzIGluZGljYXRlIHRoYXQgdGhlIFYxODBJIG11dGF0aW9uIGNhdXNlZCBDSkQgYXQgYW4gb2xkZXIgYWdlLCB3aXRoIGEgc2xvd2VyIHByb2dyZXNzaW9uIGFuZCBhIGxvd2VyIHBvc3NpYmlsaXR5IG9mIGRldmVsb3BpbmcgbXlvY2xvbnVzLCBjZXJlYmVsbGFyLCBweXJhbWlkYWwgc2lnbnMgYW5kIHZpc3VhbCBkaXN0dXJiYW5jZSBjb21wYXJlZCB3aXRoIGNsYXNzaWNhbCBzcG9yYWRpYyBDSkQgd2l0aCBtZXRoaW9uaW5lIGhvbW96eWdvc2l0eSBhdCBjb2RvbiAxMjkgb2YgUFJOUC5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiODM5MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzQyMjgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRldGVjdGVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJQb2x5ZnVuY3Rpb25hbCBFMjU1Sy1zcGVjaWZpYyBDRDgrIFQgY2VsbHMgd2VyZSBkZXRlY3RlZCBpbiB0d28gaW1hdGluaWItcmVzaXN0YW50IEhMQS1BMysgQ01MIHBhdGllbnRzIGNvbmN1cnJlbnQgd2l0aCBhbiBlZmZlY3RpdmUgYW50aS1DTUwgcmVzcG9uc2UgdG8gZnVydGhlciB0aGVyYXB5LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMDc0MjU0MDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2ODUyMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZWQgYnlcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkZWSUkgZGVmaWNpZW5jeSBpbiBib3RoIHBvcHVsYXRpb25zIGlzIGNhdXNlZCBieSBhIGZvdW5kZXIgQTI0NFYgbXV0YXRpb24gaW4gdGhlIEY3IGdlbmUgYW5kIERKUyBpcyBjYXVzZWQgYnkgdHdvIGZvdW5kZXIgbXV0YXRpb25zLCBJMTE3M0YgYW5kIFIxMTUwSCBpbiB0aGUgTVJQMiBnZW5lIHRoYXQgYXJlIHNwZWNpZmljIGZvciBJcmFuaWFuIGFuZCBNb3JvY2NhbiBKZXdpc2ggcGF0aWVudHMsIHJlc3BlY3RpdmVseS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTI0OTg1MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjk3MTYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiV2UgZnVydGhlciBkZXRlcm1pbmVkIHRoYXQgdGhlIHJzMTA3NTQ4MzMgW1RdIHdhcyBhc3NvY2lhdGVkIHdpdGggYSBkZWNyZWFzZWQgbWVsYW5vbWEgcmlzayBpbiAyMzY4IG1lbGFub21hIGNhc2VzIGFuZCA3NDMyIGNvbnRyb2xzIFtmb3IgQ1QgZ2Vub3R5cGU6IG9kZHMgcmF0aW8gKE9SKVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI4MDk5NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5MzY5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjb252ZXlcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkRvZXMgdGhlIHJhcmUgQTE3MkcgbXV0YXRpb24gb2YgUFRQTjExIGdlbmUgY29udmV5IGEgbWlsZCBOb29uYW4gc3luZHJvbWUgcGhlbm90eXBlP1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNTY2NDI1MDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2MjAxMjAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlZCBieVwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiV2UgcmVwb3J0IHR3byBhZGRpdGlvbmFsIHBhdGllbnRzIGluIHdob20gaHlwb2tldG90aWMgaHlwb2dseWNhZW1pYSB3YXMgY2F1c2VkIGJ5IGEgZGVmaWNpZW5jeSBvZiBtaXRvY2hvbmRyaWFsIDMtaHlkcm94eS0zLW1ldGh5bGdsdXRhcnlsLUNvQSBzeW50aGFzZSAoSE1DTSk7IHR3byBub3ZlbCBtdXRhdGlvbnMgd2VyZSBpZGVudGlmaWVkIChWNTRNIGFuZCBZMTY3QyksIG9uZSBvZiB3aGljaCBkaXJlY3RseSBpbnZvbHZlcyB0aGUgY2F0YWx5dGljIHNpdGUgb2YgdGhlIGVuenltZS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTM1NzcxMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzUwMDcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFI4MjBXIG11dGF0aW9uIGluIHRoZSBNWUJQQzMgZ2VuZSwgYXNzb2NpYXRlZCB3aXRoIGh5cGVydHJvcGhpYyBjYXJkaW9teW9wYXRoeSBpbiBjYXRzLCBjYXVzZXMgaHlwZXJ0cm9waGljIGNhcmRpb215b3BhdGh5IGFuZCBsZWZ0IHZlbnRyaWN1bGFyIG5vbi1jb21wYWN0aW9uIGluIGh1bWFucy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjU4NDUyMTAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjUwMTAwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkaWFnbm9zZWQgdXBvblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSW4gYSA1MCB5ZWFyLW9sZCBDYXVjYXNpYW4gbWFsZSwgY2VyZWJyYWwgWC1BTEQgd2FzIGRpYWdub3NlZCB1cG9uIHByb2dyZXNzaXZlIGdhaXQgZGlzdHVyYmFuY2UsIGludGVsbGVjdHVhbCBkZWNsaW5lLCBlbGV2YXRlZCB2ZXJ5LWxvbmcgY2hhaW4gZmF0dHkgYWNpZHMgaW4gdGhlIHNlcnVtIG9yIGxldWNvY3l0ZXMsIGNlcmVicmFsIE1SSSwgc2hvd2luZyBleHRlbnNpdmUsIHN5bW1ldHJpYywgaG9tb2dlbm91cyBkZW15ZWxpbmF0aW9uIGluIHRoZSBwYXJpZXRvLW9jY2lwaXRhbCBhcmVhcywgdGhlIHNwbGVuaXVtIGNvcnBvcmlzIGNhbGxvc3VtLCB0aGUgdGhhbGFtdXMsIHRoZSBjcnVyYSBjZXJlYnJpLCB0aGUgYnJhaW4gc3RlbSwgYW5kIHRoZSBwZWR1bmN1bGkgY2VyZWJlbGxpLCBhbmQgdGhlIGRlbGV0aW9uIGMuMTQxNS0xNDE2ZGVsQUcgaW4gdGhlIEFCQ0QxLWdlbmUuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjIxODc1MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2NzM4NTMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiV2Ugc3VnZ2VzdCB0aGF0IHRoZSBwLkdseTIwN0FyZyB2YXJpYW50IGNhdXNlcyBhIGRpc3RpbmN0IHR5cGUgSUkgY29sbGFnZW5vcGF0aHkgd2l0aCBmZWF0dXJlcyBvZiBQUFJEIGFuZCBTRUQsIFN0YW5lc2N1IHR5cGUuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEwNjk4MDgwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTQzMDQzMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIG11bHRpdmFyaWF0ZSBtb2RlbHMgYWRqdXN0ZWQgZm9yIGFnZSwgYm9keSBtYXNzIGluZGV4LCBkaWFiZXRlcywgd2Fpc3QvaGlwIHJhdGlvcywgYW5kIGxldmVscyBvZiBnbHljYXRlZCBoZW1vZ2xvYmluLCB0aGUgTkFGTEQgYWN0aXZpdHkgc2NvcmUgd2FzIGFzc29jaWF0ZWQgd2l0aCB0aGUgU05QIHJzMjY0NTQyNCBvbiBjaHJvbW9zb21lIDggaW4gZmFybmVzeWwgZGlwaG9zcGhhdGUgZmFybmVzeWwgdHJhbnNmZXJhc2UgMSAoRkRGVDEpIChQID0gNi44IHggMTAgKC03KSkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjM1MDI3MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2NzI4MjAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImlkZW50aWZpZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQSBoZXRlcm96eWdvdXMgQTMzN1AgbXV0YXRpb24gd2FzIGlkZW50aWZpZWQgaW4gYSBmYW1pbHkgd2l0aCBhbiBhZHVsdC1vbnNldCBza2VsZXRhbCBteW9wYXRoeSBhbmQgbWlsZCBjYXJkaWFjIGludm9sdmVtZW50LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI0NzUyOTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5MTc4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZVwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGFrZW4gdG9nZXRoZXIsIHRoZSBwcmVzZW50IGZpbmRpbmdzIGluZGljYXRlIHRoYXQgdGhlIEsyNTdUIG11dGF0aW9uIGluIFRhdSBjYW4gY2F1c2UgYSBkZW1lbnRpbmcgY29uZGl0aW9uIHNpbWlsYXIgdG8gUGljaydzIGRpc2Vhc2UuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEwMjMyODA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTg1NDIwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJQT0xFIHAuTDQyNFYgd2FzIGlkZW50aWZpZWQgaW4gYSAyOC15ZWFyLW9sZCBwb2x5cG9zaXMgYW5kIENSQyBwYXRpZW50LCBhcyBhIGRlIG5vdm8gbXV0YXRpb24uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjQ3ODk5MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1ODAwNDMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImxpbmtlZCB0b1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIHJlc3VsdHMgc2hvd2VkIHRoYXQ6IFZhbDYwNk1ldCBpcyBhbiBpbnRlcm1lZGlhdGUgbWFsaWduYW5jeSBtdXRhdGlvbjsgQXJnNjk0TGV1IGlzIGEgbm92ZWwgbXV0YXRpb24gd2l0aCBhIGJlbmlnbiBwaGVub3R5cGU7IGFuZCB0aGUgQXJnNzIzR2x5IG11dGF0aW9uIGlzIGxpbmtlZCB0byBtYWxpZ25hbmN5IC0gaXQgY2FuIGxlYWQgbm90IG9ubHkgdG8gSENNIGJ1dCBhbHNvIHRvIGRpbGF0ZWQgY2FyZGlvbXlvcGF0aHkgYXQgdmFyaW91cyBhZ2VzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNjMzNTYyMDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjkxMzUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGF1IGdlbmUgbXV0YXRpb24gRzM4OVIgY2F1c2VzIGEgdGF1b3BhdGh5IHdpdGggYWJ1bmRhbnQgcGljayBib2R5LWxpa2UgaW5jbHVzaW9ucyBhbmQgYXhvbmFsIGRlcG9zaXRzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMDc0OTAzMDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjMxOTgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRlZmluZWQgYnlcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkFjaG9uZHJvcGxhc2lhIGlzIGRlZmluZWQgYnkgcmVjdXJyZW50IEczODBSIG11dGF0aW9ucyBvZiBGR0ZSMy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTA3NTAwNzAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTc5NjcwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkh5cGVydHJvcGhpYyBjYXJkaW9teW9wYXRoeSBjYXVzZWQgYnkgYSBub3ZlbCBhbHBoYS10cm9wb215b3NpbiBtdXRhdGlvbiAoVjk1QSkgaXMgYXNzb2NpYXRlZCB3aXRoIG1pbGQgY2FyZGlhYyBwaGVub3R5cGUsIGFibm9ybWFsIGNhbGNpdW0gYmluZGluZyB0byB0cm9wb25pbiwgYWJub3JtYWwgbXlvc2luIGN5Y2xpbmcsIGFuZCBwb29yIHByb2dub3Npcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNDY4MzgwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjYwOTU1NDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZXhoaWJpdFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiKEtDTkExIEc3MjRDKVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMDY5MjUyMDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjIyMjQwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSGVyZWRpdGFyeSBoZW1vY2hyb21hdG9zaXMgaXMgYXNzb2NpYXRlZCB3aXRoIEMyODJZIGhvbW96eWdvc2l0eS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTAyMzQzMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjk3MDQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQW4gcnMxMDQ5Mjk3MiBbQ10gdmFyaWFudCBsb2NhdGVkIGluIHRoZSBLSUYxQiBnZW5lIHdhcyBhc3NvY2lhdGVkIHdpdGggTVMgd2l0aCBhbiBvZGRzIHJhdGlvIG9mIDEuMzUgKFAgPSAyLjUgeCAxMCAoLTEwKSkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjU3NTE5MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjkyNjIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFMxNDBUIG11dGF0aW9uIGluIG15ZWxpbiBQMCBjYW4gYmUgYXNzb2NpYXRlZCB3aXRoIGNvbmR1Y3Rpb24gYmxvY2sgYW5kIENoYXJjb3QtTWFyaWUtVG9vdGggc2hvdWxkIGJlIHBhcnQgb2YgdGhlIGRpZmZlcmVudGlhbCBkaWFnbm9zaXMgb2YgdGhhdCBwaGVub21lbm9uLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNjg3OTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTkyNjg5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmb3VuZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIE4zNFMgbXV0YXRpb24gd2FzIGZvdW5kIGluIHNpeCBmYW1pbGlhbCBwYW5jcmVhdGl0aXMgcGF0aWVudHMgKHRocmVlIGZhbWlsaWVzKSBhbmQgaW4gb25lIGp1dmVuaWxlIHBhbmNyZWF0aXRpcyBwYXRpZW50LCBhbmQgdGhlIFI2N0MgbXV0YXRpb24gd2FzIGZvdW5kIGluIG9uZSBmYW1pbGlhbCBwYW5jcmVhdGl0aXMgcGF0aWVudCBhbmQgb25lIGp1dmVuaWxlIHBhbmNyZWF0aXRpcyBwYXRpZW50LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI4MzEwMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1OTgxNDEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJCb3RoIHRoZSBRMTYzWCBhbmQgdGhlIFIxMjBRIG11dGF0aW9uIGNhdXNlIGRlbXllbGluYXRpb24gYW5kIGF4b25hbCBsb3NzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI0NDI4NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTY5NjAzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkZXZlbG9wZWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBQMzk0TCBtdXRhbnQgbWljZSBkZXZlbG9wZWQgZm9jYWwgYm9uZSBsZXNpb25zIHdpdGggaW5jcmVhc2luZyBhZ2UgYW5kIGJ5IDEyIG1vbnRocywgMTQvMTggKDc3JSkgaGV0ZXJvenlnb3RlcyBhbmQgMjAvMjEgKDk1JSkgaG9tb3p5Z290ZXMgaGFkIGxlc2lvbnMsIGNvbXBhcmVkIHdpdGggMC8xOCAoMCUpIHdpbGQtdHlwZSBsaXR0ZXJtYXRlcyAoUCA8MC4wMDEpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyMDI1NTYwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NDk1NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJyczkyNjAxNTEgYW5kIHJzMzEzNTAwMiBoYXZlIGJlZW4gYXNzb2NpYXRlZCB3aXRoIHR5cGUgMSBkaWFiZXRlcywgd2hlcmVhcyByczU1OTA0NyBhbmQgcnM2MTIxMTUxNSBoYXZlIG5vdCBiZWVuIGFzc29jaWF0ZWQgd2l0aCBhIHJpc2sgb2YgZGV2ZWxvcGluZyB0eXBlIDEgZGlhYmV0ZXMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEyMDYzNzIwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU4NzE5NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29tYmluZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiV2Ugc2NyZWVuZWQgNCBhZGRpdGlvbmFsIGZhbWlsaWVzLCBpbiB3aGljaCBQRUQgaXMgY29tYmluZWQgd2l0aCBlcGlsZXBzeSwgZGV2ZWxvcG1lbnRhbCBkZWxheSwgb3IgbWlncmFpbmUsIGJ1dCBub3Qgd2l0aCBoZW1vbHlzaXMgb3IgZWNoaW5vY3l0b3NpcywgYW5kIGlkZW50aWZpZWQgMiBhZGRpdGlvbmFsIEdMVVQxIG11dGF0aW9ucyAoQTI3NVQsIEczMTRTKSB0aGF0IGRlY3JlYXNlZCBnbHVjb3NlIHRyYW5zcG9ydCBidXQgZGlkIG5vdCBhZmZlY3QgY2F0aW9uIHBlcm1lYWJpbGl0eS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNjU3MzAwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTY4OTkwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFEyOTJLIG11dGF0aW9uIChob21vYWxsZWxpYywgaGV0ZXJvYWxsZWxpYykgd2FzIHN0cm9uZ2x5IGFzc29jaWF0ZWQgd2l0aCBhIHByb3RyYWN0ZWQgbmV1cm92aXNjZXJhbCBwaGVub3R5cGUgKDEwIG9mIDEyIGNhc2VzKS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTA2NzYwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU0MzA4NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJNdXRhdGlvbiBHbHU4Mkx5cyBpbiBsYW1pbiBBL0MgZ2VuZSBpcyBhc3NvY2lhdGVkIHdpdGggY2FyZGlvbXlvcGF0aHkgYW5kIGNvbmR1Y3Rpb24gZGVmZWN0LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI0ODE0MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCI5MDMzMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyZXBvcnRlZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiUDgxTCBhbmQgUjM4WCBtdXRhdGlvbnMgaGF2ZSBwcmV2aW91c2x5IGJlZW4gcmVwb3J0ZWQgaW4gb3RoZXIgUEdMIGZhbWlsaWVzIGFuZCBQODFMIHdhcyBzdWdnZXN0ZWQgYXMgYSBmb3VuZGVyIG11dGF0aW9uLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI5NDY0ODA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0ODA2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlNOUCByczEwNDk4MzQ1IHdhcyBzdHJvbmdseSBhc3NvY2lhdGVkIHdpdGggY29yb25hcnkgc3Bhc20gaW4gSmFwYW5lc2Ugd29tZW4gdXRpbGl6aW5nIGdlbm9tZS13aWRlIFNOUCBhbmFseXNpcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiODExMjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTcxNTQ2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJleGhpYml0XCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgVFJFWDEgRDE4TiBtaWNlIGV4aGliaXQgc3lzdGVtaWMgaW5mbGFtbWF0aW9uLCBseW1waG9pZCBoeXBlcnBsYXNpYSwgdmFzY3VsaXRpcywgYW5kIGtpZG5leSBkaXNlYXNlLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI4MTEyMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NjM0MzcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImV4aGliaXRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBUUkVYMSBEMThOIG1pY2UgZXhoaWJpdCBzeXN0ZW1pYyBpbmZsYW1tYXRpb24sIGx5bXBob2lkIGh5cGVycGxhc2lhLCB2YXNjdWxpdGlzLCBhbmQga2lkbmV5IGRpc2Vhc2UuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjExMTU5ODA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDczODY0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBbGwgZml2ZSBtdXRhdGlvbnMgYXJlIGFzc29jaWF0ZWQgd2l0aCBOUywgd2hlcmVhcyB0d28gKEE1N0cgYW5kIEY4MlYpIGhhdmUgYWxzbyBiZWVuIGlkZW50aWZpZWQgaW4gdXJpbmFyeSB0cmFjdCBjYW5jZXJzIGFuZCBteWVsb2lkIG1hbGlnbmFuY2llcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzQ3OTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjQ1OTIyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIldlIGZvdW5kIHRoYXQgcnM5Mjc3NTM1IChITEEtRFBCMSwgUCA9IDQuODd4MTAgKC0xNCkpLFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNjE1NTgwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NTAzODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJTTlAgcnMxMTU0MzE5OCB3YXMgYXNzb2NpYXRlZCB3aXRoIGJsYWRkZXIgY2FuY2VyIHJpc2sgd2l0aCBvZGRzIHJhdGlvIChPUikgb2YgMS40MSBhbmQgUC12YWx1ZSBvZiA0LjAzIHggMTAgKC05KS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzgxMTYwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU5Mzc4ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VkXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJJbiBjb250cmFzdCwgbWlzc2Vuc2UgbXV0YXRpb25zIHByb2R1Y2VkIGRpc3RpbmN0IHBoZW5vdHlwZXM6IEdseTgwQXJnIGNhdXNlZCBzaWduaWZpY2FudCBjYXJkaWFjIG1hbGZvcm1hdGlvbnMgYnV0IG9ubHkgbWlub3Igc2tlbGV0YWwgYWJub3JtYWxpdGllczsgYW5kIEFyZzIzN0dsbiBhbmQgQXJnMjM3VHJwIGNhdXNlZCBleHRlbnNpdmUgdXBwZXIgbGltYiBtYWxmb3JtYXRpb25zIGJ1dCBsZXNzIHNpZ25pZmljYW50IGNhcmRpYWMgYWJub3JtYWxpdGllcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTY3Mjg3MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NDIwMDAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSXQgaXMgdGhlIGZpcnN0IHRpbWUsIHRvIHRoZSBiZXN0IG9mIG91ciBrbm93bGVkZ2UsIHRvIHJlcG9ydCB0aGF0IGMuNTQ5XzU1MGRlbEdUIGFuZCBjLjExMTRkZWxHIG11dGF0aW9ucyBpbiB0aGUgVFlSIGdlbmUgd2VyZSBhc3NvY2lhdGVkIHdpdGggT0NBLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI4NTM5NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTg2ODI1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZVwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIG9iamVjdGl2ZSBvZiB0aGlzIHN0dWR5IGlzIHRvIHByb3ZpZGUgY2xpbmljYWwgZXZpZGVuY2UgdGhhdCBWNDU2QSwgYSBub3ZlbCBtdXRhdGlvbiBpbiBTb3V0aCBBc2lhbiBDeXN0aWMgRmlicm9zaXMgcGF0aWVudHMsIGNhbiBjYXVzZSBzaWduaWZpY2FudCBsdW5nIGRpc2Vhc2UuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEwNjkwODAwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU2MDE4NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJJbiB0aGUgaW5kaWdlbm91cyBwb3B1bGF0aW9uLCBib3RoIGdpbmdpdml0aXMgYW5kIEEyTUwxIHZhcmlhbnRzIGluY2x1ZGluZyB0aGUga25vd24gZHVwbGljYXRpb24gdmFyaWFudCBhbmQgdGhlIG5vdmVsIHNwbGljZSB2YXJpYW50IGMuNDA2MSsxRz4gQyB3ZXJlIGluZGVwZW5kZW50bHkgYXNzb2NpYXRlZCB3aXRoIG90aXRpcyBtZWRpYS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNTI2MDYwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjYxNzMzMTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJSNzAyQyBhbmQgUjcwMkggbXV0YXRpb25zIHdlcmUgb25seSBhc3NvY2lhdGVkIHdpdGggRlROUywgRVBTLCBvciBBUFNNLCB0aHVzIGRlZmluaW5nIGEgcmVnaW9uIG9mIE1ZSElJQSBjcml0aWNhbCBpbiB0aGUgY29tYmluZWQgcGF0aG9nZW5lc2lzIG9mIG1hY3JvdGhyb21ib2N5dG9wZW5pYSwgbmVwaHJpdGlzLCBhbmQgZGVhZm5lc3MuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjYyNTc4MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjk3MDcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZvdW5kIHdpdGhvdXRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlByZXZpb3VzbHkgcmVwb3J0ZWQgcC5SMjQwWCB3YXMgZm91bmQgaW4gb25lIHBhdGllbnQgd2l0aCBQS0Qgd2l0aCBtaWdyYWluZSB3aXRob3V0IGF1cmEuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE1MzQ0MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2MTM4MjUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRldmVsb3BcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlI5OEMgbWljZSwgYW4gYXV0aGVudGljIG1vZGVsIG9mIGVhcmx5IG9uc2V0IENoYXJjb3QtTWFyaWUtVG9vdGggZGlzZWFzZSB0eXBlIDFCLCBkZXZlbG9wIG5ldXJvcGF0aHkgaW4gcGFydCBiZWNhdXNlIHRoZSBtaXNmb2xkZWQgbXV0YW50IG15ZWxpbiBwcm90ZWluIHplcm8gaXMgcmV0YWluZWQgaW4gdGhlIGVuZG9wbGFzbWljIHJldGljdWx1bSB3aGVyZSBpdCBhY3RpdmF0ZXMgdGhlIHVuZm9sZGVkIHByb3RlaW4gcmVzcG9uc2UuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjExNzY3MDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0ODA5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlNOUCByczQ3ODQyMjcgd2FzIGNvbnNpc3RlbnRseSBhc3NvY2lhdGVkIHdpdGggYnJlYXN0IGNhbmNlciByaXNrIGFjcm9zcyBhbGwgc3R1ZGllcyB3aXRoIGFkanVzdGVkIG9kZHMgcmF0aW9zICg5NSUgY29uZmlkZW5jZSBpbnRlcnZhbHMpIG9mIDEuMjUgKDEuMjAtMS4zMSkgcGVyIGFsbGVsZSAoUCA9IDMuMiB4IDEwICgtMjUpKSBpbiB0aGUgcG9vbGVkIGFuYWx5c2lzIG9mIHNhbXBsZXMgZnJvbSBhbGwgQXNpYW4gc2FtcGxlcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTg0NzIwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiOTIxMDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibGlua2VkIHRvXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJGYW1pbHkgc3R1ZGllcyBzaG93ZWQgdGhhdCBhbiBBcmcxNDVHbHkgbXV0YXRpb24gd2FzIGxpbmtlZCB0byBIQ00gYW5kIGEgTHlzMjA2R2xuIG11dGF0aW9uIGhhZCBvY2N1cnJlZCBkZSBub3ZvLCB0aHVzIHN0cm9uZ2x5IHN1Z2dlc3RpbmcgdGhhdCBjVG5JIGlzIHRoZSBzZXZlbnRoIEhDTSBnZW5lLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMDY5MTM3MDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjY1MTMwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImhhZFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiT25lIHRoeW1vbWEgYW5kIG9uZSB0aHltaWMgY2FyY2lub21hIGhhcmJvcmVkIEtSQVMgbXV0YXRpb25zIChHMTJBIGFuZCBHMTJWLCByZXNwZWN0aXZlbHkpLCBhbmQgb25lIHRoeW1vbWEgaGFkIGEgRzEzViBIUkFTIG11dGF0aW9uLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNjU0MDQxMDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzM2MjMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInVuZGVyZGlhZ25vc2VkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIk5ldXJpdGUgc2hvcnRlbmluZyBjYXVzZWQgYnkgdGhlIGMuMjUwRz4gQSBtdXRhdGlvbiBpbiBFVEZESCBzdWdnZXN0cyB0aGF0IG5ldXJhbCBkZWZlY3RzIGNvdWxkIGJlIHVuZGVyZGlhZ25vc2VkIGluIGh1bWFuIHBhdGllbnRzIHdpdGggTUFERC5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNTI4NzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCI2ODkzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZXNcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlIyMzFDIG11dGF0aW9uIGluIEtDTlExIGNhdXNlcyBsb25nIFFUIHN5bmRyb21lIHR5cGUgMSBhbmQgZmFtaWxpYWwgYXRyaWFsIGZpYnJpbGxhdGlvbi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjk0NTIwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NDUxNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBIHBoZW55bGFsYW5pbmUtNTUgdG8gc2VyaW5lIGFtaW5vLWFjaWQgc3Vic3RpdHV0aW9uIGluIHRoZSBodW1hbiBnbHljb3Byb3RlaW4gSVggbGV1Y2luZS1yaWNoIHJlcGVhdCBpcyBhc3NvY2lhdGVkIHdpdGggQmVybmFyZC1Tb3VsaWVyIHN5bmRyb21lLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI0MjA1OTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjMwMDc0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmb3VuZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFQ2N00gYW5kIFY1N2RlbCBtdXRhdGlvbnMgaGF2ZSBiZWVuIGZvdW5kIGluIENhdWNhc2lhbiBQVFMgZGVmaWNpZW50IHBhdGllbnRzLCB3aGlsZSB0aGUgTDc2RiwgSVZTMysxRz4gQSwgYW5kIEszOFggbXV0YXRpb25zIGFyZSBub3ZlbC5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTA2NzYwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjYxMDk5ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJNdXRhdGlvbiBHbHU4Mkx5cyBpbiBsYW1pbiBBL0MgZ2VuZSBpcyBhc3NvY2lhdGVkIHdpdGggY2FyZGlvbXlvcGF0aHkgYW5kIGNvbmR1Y3Rpb24gZGVmZWN0LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIzODYxODA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5MTgyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJwcmVzZW50ZWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluZGl2aWR1YWxzIHdpdGggUjExMVgvQTE2NUQgYW5kIFIxNzZYL0ExNjVEIGdlbm90eXBlcywgb24gdGhlIG90aGVyIGhhbmQsIHJlc3BlY3RpdmVseSBwcmVzZW50ZWQgbW9kZXJhdGUgYW5kIGNsYXNzaWMgUEtVIHBoZW5vdHlwZXMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEyMDU5NzUwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3Mzg2MDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwib2JzZXJ2ZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIGFkZGl0aW9uLCB0aGUgSmFja3Nvbi1XZWlzcyBzeW5kcm9tZSBtdXRhdGlvbiwgQzM0MlIsIGluIGV4b24gSUlJYyB3YXMgb2JzZXJ2ZWQgcHJldmlvdXNseSBpbiBvdGhlciBjcmFuaW9zeW5vc3RvdGljIHN5bmRyb21lcywgQ3JvdXpvbiBhbmQgUGZlaWZmZXIuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjM5NzgwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3MjcxODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaWRlbnRpZmllZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVG8gb3VyIGtub3dsZWRnZSwgdGhpcyBpcyB0aGUgZmlyc3QgcmVwb3J0IGluIHdoaWNoIHRoZSBBcmcxMDRHbG4gbXV0YXRpb24gaXMgaWRlbnRpZmllZCBpbiBDVFggcGF0aWVudHMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE5NjY2MTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDczNTQ1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZXNcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIG9uZSBmYW1pbHksIGEgcC5NMTAyOUsgbXV0YXRpb24gaW4gdGhlIEMyIGRvbWFpbiBjYXVzZXMgc2V2ZXJlIGR5c3RvbmlhLCBoeXBvdG9uaWEsIGFuZCBjaG9yZWEuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjIwNDM5MDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0NjU1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkFmdGVyIHJlcGxpY2F0aW9uLCBTTlAgcnMyMDQxNTcwIG9uIGNocm9tb3NvbWUgNyB3YXMgc2lnbmlmaWNhbnRseSBhc3NvY2lhdGVkIHdpdGggcHJvZ3Jlc3Npb24gdG8gUkNESUkgKFA9Mi4zN3gxMCwgb2RkcyByYXRpbz0yLjM2KSBidXQgbm90IHdpdGggQ2VEIHN1c2NlcHRpYmlsaXR5LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNjA1ODIwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NTUwNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJDbGluaWNhbGx5LCBwLkMxNzMzWSB3YXMgYXNzb2NpYXRlZCB3aXRoIEdELCBhcyByZXBvcnRlZCBwcmV2aW91c2x5LCBhcyB3ZWxsIGFzIHRoZSBub3ZlbCBwLk4xNzMwSSwgd2hlcmVhcyBwLkMxNzMzRlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNzk5MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0MjM2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZXNcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBvYnNlcnZhdGlvbiB0aGF0IHRoZSBTZXIyNTJQaGUgbXV0YXRpb24gY2F1c2VzIEFwZXJ0IHN5bmRyb21lLCB3aGVyZWFzIHRoZSBvdGhlciBzaW5nbGUgb3IgZG91YmxlIHN1YnN0aXR1dGlvbnMgYXJlIGFzc29jaWF0ZWQgd2l0aCBtaWxkZXIgb3Igbm9ybWFsIHBoZW5vdHlwZXMsIGhpZ2hsaWdodHMgdGhlIGV4cXVpc2l0ZWx5IHNwZWNpZmljIG1vbGVjdWxhciBwYXRob2dlbmVzaXMgb2YgdGhlIGxpbWIgYW5kIGNyYW5pb2ZhY2lhbCBhYm5vcm1hbGl0aWVzIGFzc29jaWF0ZWQgd2l0aCBBcGVydCBzeW5kcm9tZS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTAxMTI5MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjkwNzYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwicnM1NzcwOTE3LCBhIFNOUCBsb2NhdGVkIGJldHdlZW4gQ1BUMUIgYW5kIENIS0IsIHdhcyBhc3NvY2lhdGVkIHdpdGggbmFyY29sZXBzeSBpbiBKYXBhbmVzZSAocnM1NzcwOTE3IFtDXSwgb2RkcyByYXRpbyAoT1IpID0gMS43OSwgY29tYmluZWQgUCA9IDQuNCB4IDEwICgtNykpIGFuZCBvdGhlciBhbmNlc3RyeSBncm91cHMgKE9SID0gMS40MCwgUCA9IDAuMDIpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMDc0ODA5MDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjYxNTk0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJoYWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkFub3RoZXIgcGF0aWVudCwgd2l0aCBhIG1lbGFub21hIGRpYWdub3NlZCBhdCA3NyB5ZWFycywgYSBicmVhc3QgY2FuY2VyIGRpYWdub3NlZCBhdCA2NiBhbmQgYSBmYW1pbHkgaGlzdG9yeSBvZiBtZWxhbm9tYSwgaGFkIHRoZSBWNTlHIG11dGF0aW9uLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIzMjc0MDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjMwMDc0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJTZXZlbiBtdXRhdGlvbnMgLSBuYW1lbHkgUjI1RywgTjUyUywgVjU2TSwgVjcwRCwgUDg3UywgRDk2TiwgYW5kIFQxMDZNIC0gaGFkIGJlZW4gaWRlbnRpZmllZCBpbiBDaGluZXNlIFBUUy1kZWZpY2llbnQgcGF0aWVudHMgcHJldmlvdXNseS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTEwNTAwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiNjUzMDUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImdlbm90eXBlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJIZXJlLCAxLDk5MyBwcmltYXJ5IGdvdXQgcGF0aWVudHMgYW5kIDQsOTAyIGhlYWx0aCBleGFtaW5hdGlvbiBwYXJ0aWNpcGFudHMgKDMsMzA1IG1hbGVzIGFuZCAxLDU5NyBmZW1hbGVzKSB3ZXJlIGdlbm90eXBlZCB3aXRoIFI5MEggYW5kIFcyNThYLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI1Nzg3MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NjE5MjUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIEFyZzM1MDBHbG4gbXV0YXRpb24gaW4gdGhlIGFwb2xpcG9wcm90ZWluIEIgZ2VuZSwgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIGZhbWlsaWFsIGRlZmVjdGl2ZSBhcG9saXBvcHJvdGVpbiBCLTEwMCBhbmQgaXMgcHJlc2VudCBpbiBhcHByb3hpbWF0ZWx5IDEgaW4gMTAwMCBwZXJzb25zIGluIERlbm1hcmssIGNhdXNlcyBzZXZlcmUgaHlwZXJjaG9sZXN0ZXJvbGVtaWEgYW5kIGluY3JlYXNlcyB0aGUgcmlzayBvZiBpc2NoZW1pYyBoZWFydCBkaXNlYXNlLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMjg3NDMwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTcxNzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJTTlAgcnM5ODc4NzAsIGxvY2F0ZWQgYmV0d2VlbiBITEEtRFBBMSBhbmQgSExBLURQQjEsIHdhcyBjb25zaXN0ZW50bHkgYXNzb2NpYXRlZCB3aXRoIHBlZGlhdHJpYyBhc3RobWEgaW4gMyBpbmRlcGVuZGVudCBwb3B1bGF0aW9ucyAoUCAoY29tYmluZWQpID1cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNDk0NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5MTgyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjbGFzc2lmaWVkIGFzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJCb3RoIHAuUjI0MUMgYW5kIHAuUjQwOFEgYXJlIGNsYXNzaWZpZWQgYXMgbWlsZCBwaGVueWxrZXRvbnVyaWEgKFBLVSkgb3IgbWlsZCBoeXBlcnBoZW55bGFsYW5pbmVtaWEgKE1IUCkgbXV0YXRpb24sIHdoaWNoIG1heSBleHBsYWluIHRoZSBmYWN0IHRoYXQgY2xhc3NpY2FsIFBLVSBpcyB2ZXJ5IHJhcmUgaW4gVGFpd2FuIChuPTQsIG9yIG9uZSBpbiA0MTMsMDM1KS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTM4MjA0MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzI5MzYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQ2xpbmljYWwsIGhpc3RvbG9naWNhbCwgaW1tdW5vaGlzdG9jaGVtaWNhbCBhbmQgbW9sZWN1bGFyIGV2aWRlbmNlIGZyb20gdGhlc2UgZmFtaWxpZXMgYW5kIG90aGVyIGluZGVwZW5kZW50IGNsaW5pY2FsIGFuZCBzY2llbnRpZmljIGV2aWRlbmNlIGluZGljYXRlcyB0aGF0IHRoZSBNTEgxIHAuQXJnMTgyR2x5IChjLjU0NEE+IEcpIGNoYW5nZSBjYXVzZXMgTHluY2ggc3luZHJvbWUgYW5kIHN1cHBvcnRzIHJlY2xhc3NpZmljYXRpb24gb2YgdGhlIHZhcmlhbnQgYXMgcGF0aG9nZW5pYy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiODExMjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5NzE0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJleGhpYml0XCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgVFJFWDEgRDE4TiBtaWNlIGV4aGliaXQgc3lzdGVtaWMgaW5mbGFtbWF0aW9uLCBseW1waG9pZCBoeXBlcnBsYXNpYSwgdmFzY3VsaXRpcywgYW5kIGtpZG5leSBkaXNlYXNlLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMDc0MjM2MDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjE2MzE0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJoYWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkV4Y2VwdCBmb3Igb25lLCBhbGwgdGhlIEFwZXJ0IHBhdGllbnRzIGhhZCBlaXRoZXIgUzI1MlcgKG4gPSAxNikgb3IgUDI1M1IgKG4gPSAxMCkgbXV0YXRpb25zLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNDM1NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjAzNDIwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBwLkFyZzI1OEdseSBtdXRhdGlvbiBpbiBpbnRyYWNlbGx1bGFyIGxvb3AgMiBvZiBDRlRSIGlzIGFzc29jaWF0ZWQgd2l0aCBDRlRSLXJlbGF0ZWQgZGlzb3JkZXJzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI1NTEwNzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTU3OTI3MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlI1NjNRLCBhIG5ldyB2YXJpYW50IG9mIHRoZSBiZXRhIGVwaXRoZWxpYWwgc29kaXVtIGNoYW5uZWwsIGlzIGFzc29jaWF0ZWQgd2l0aCBsb3ctcmVuaW4sIGxvdy1hbGRvc3Rlcm9uZSBoeXBlcnRlbnNpb24sIGluIFNvdXRoIEFmcmljYW4gYmxhY2sgYW5kIG1peGVkLWFuY2VzdHJ5IHBhdGllbnRzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI5MDMzMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NzEwODEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJlcG9ydGVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJQODFMIGFuZCBSMzhYIG11dGF0aW9ucyBoYXZlIHByZXZpb3VzbHkgYmVlbiByZXBvcnRlZCBpbiBvdGhlciBQR0wgZmFtaWxpZXMgYW5kIFA4MUwgd2FzIHN1Z2dlc3RlZCBhcyBhIGZvdW5kZXIgbXV0YXRpb24uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE1NDU2MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjE1ODQ1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkZW1vbnN0cmF0ZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBSODNDIG11dGF0aW9uIHdhcyBhbHNvIGRlbW9uc3RyYXRlZCBpbiBvbmUgaG9tb3p5Z291cyBhbmQgZml2ZSBoZXRlcm9nZW5vdXMgR1NEIHR5cGUgMWEgcGF0aWVudHMsIGluZGljYXRpbmcgdGhhdCB0eXBlIDFhU1AgaXMgYSBtaXNjbGFzc2lmaWNhdGlvbiBvZiBHU0QgdHlwZSAxYS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzE5MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NjIyNTEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkJvdGggMTEwMGRlbEMgYW5kIFIxNDVXIGdlcm0tbGluZSBtdXRhdGlvbnMgaW4gQ0hLMiBhcmUgYXNzb2NpYXRlZCB3aXRoIGxvc3Mgb2YgdGhlIHdpbGQtdHlwZSBhbGxlbGUgaW4gdGhlIGNvcnJlc3BvbmRpbmcgdHVtb3Igc3BlY2ltZW5zLCBhbmQgbmVpdGhlciB0dW1vciBoYXJib3JzIGEgc29tYXRpYyBUUDUzIG11dGF0aW9uLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI0MjYyNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5ODYzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmb3VuZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIG5vdmVsIEQ1MTNHIG11dGF0aW9uIGhhcyBub3QgYmVlbiBmb3VuZCBpbiBtb3JlIHRoYW4gMjAwIG5vbi1DRiBjaHJvbW9zb21lcyBhbmQgaW4gYSBzYW1wbGUgb2YgMzAwIENGIGNocm9tb3NvbWVzIGZyb20gRnJlbmNoIGNsYXNzaWNhbCBDRiBwYXRpZW50cy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTE2MDcwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjY3MjU2MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VkXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJJbiBjb250cmFzdCwgbWlzc2Vuc2UgbXV0YXRpb25zIHByb2R1Y2VkIGRpc3RpbmN0IHBoZW5vdHlwZXM6IEdseTgwQXJnIGNhdXNlZCBzaWduaWZpY2FudCBjYXJkaWFjIG1hbGZvcm1hdGlvbnMgYnV0IG9ubHkgbWlub3Igc2tlbGV0YWwgYWJub3JtYWxpdGllczsgYW5kIEFyZzIzN0dsbiBhbmQgQXJnMjM3VHJwIGNhdXNlZCBleHRlbnNpdmUgdXBwZXIgbGltYiBtYWxmb3JtYXRpb25zIGJ1dCBsZXNzIHNpZ25pZmljYW50IGNhcmRpYWMgYWJub3JtYWxpdGllcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzM0MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NzIyNzQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImhhdmVcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIldlIGZvdW5kIHRoYXQgMzVkZWxHIGhvbW96eWdvdGVzIGhhdmUgc2lnbmlmaWNhbnRseSBtb3JlIGhlYXJpbmcgaW1wYWlybWVudCwgY29tcGFyZWQgd2l0aCAzNWRlbEcvbm9uLTM1ZGVsRyBjb21wb3VuZCBoZXRlcm96eWdvdGVzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMjgyNjAwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTkyMDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgY29tYmluZWQgYW5hbHlzaXMgaW5kaWNhdGVkIHRoYXQgcnMyOTE2NzMzIGluIG1pY3JvY2VwaGFsaW4gMSBbY29tYmluZWQgUEZpc2hlciBtaW49Mi4yN3gxMCwgb2RkcyByYXRpbyAoT1IpID0yLjc0IHdpdGggOTUlIGNvbmZpZGVuY2UgaW50ZXJ2YWwgKENJKSA9MS45Ni0zLjgzOyB0aGUgbm9ucmlzayBnZW5vdHlwZSBhcyByZWZlcmVuY2VdIHdhcyBzaWduaWZpY2FudGx5IGFzc29jaWF0ZWQgd2l0aCBlcGlydWJpY2luLWluZHVjZWQgbGV1a29wZW5pYS9uZXV0cm9wZW5pYS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTIyODIzMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjk3MTgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIHJzNjkyOTg0NiBTTlAgb2YgQlROMkExLCBidXQgbm90IHJzMjU2OTUxMiBvZiBJTEYzLCB3YXMgYWxzbyBzaWduaWZpY2FudGx5IGFzc29jaWF0ZWQgd2l0aCBNSSBpbiBKYXBhbmVzZSBzdWJqZWN0IHBhbmVsIEMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjc5NTUyMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjk3MTYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImlkZW50aWZpZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkEgbm92ZWwgVGhyNTc0QWxhIChjLjE3MjBBPiBHKSBLSVQgbXV0YXRpb24sIHdoaWNoIGhhcyBub3QgYmVlbiByZXBvcnRlZCBpbiBtZWxhbm9tYSBvciBvdGhlciB0dW1vciB0eXBlcywgd2FzIGlkZW50aWZpZWQgaW4gb25lIGdlbml0YWwgbWVsYW5vbWEgY2FzZS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiODQ5OTUwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjYzNjQ4OTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29uc3RpdHV0ZVwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiRGlzZWFzZS1hc3NvY2lhdGVkIEdsdXQxIHNpbmdsZSBhbWlubyBhY2lkIHN1YnN0aXR1dGUgbXV0YXRpb25zIFM2NkYsIFIxMjZDLCBhbmQgVDI5NU0gY29uc3RpdHV0ZSBHbHV0MS1kZWZpY2llbmN5IHN0YXRlcyBpbiB2aXRyby5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTI4NzM2MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzQ4MDkwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSW4gYSBjb21iaW5lZCBhbmFseXNpcyBvZiBvdXIgZm91ciBjYXNlLWNvbnRyb2wgc2VyaWVzLCB0aGUgcC5RNTQ4WCBtdXRhdGlvbiB3YXMgc2lnbmlmaWNhbnRseSBhc3NvY2lhdGVkIHdpdGggYnJlYXN0IGNhbmNlciAoTWFudGVsLUhhZW5zemVsIE9SIDUuMSwgOTUlIENJIDEuMjsgMjEuOSwgcCA9IDAuMDMpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIzODU0NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCI4MDgzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmb3VuZCBBbW9uZ1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQW1vbmcgSFAgcGF0aWVudHMsIG5vIHAuTjI5SSBtdXRhdGlvbnMgd2VyZSBmb3VuZCBhbmQgdGhlIHAuQTE2ViBtdXRhdGlvbiB3YXMgbW9yZSBmcmVxdWVudCB0aGFuIHByZXZpb3VzbHkgcmVwb3J0ZWQsIDQ1IGFuZCAzMiUgaGFkIGV4b2NyaW5lIGFuZCBlbmRvY3JpbmUgaW5zdWZmaWNpZW5jeSwgcmVzcGVjdGl2ZWx5LCBhbmQgYW1vbmcgdElQIHBhdGllbnRzIDkgYW5kIDEyJSwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNTI2OTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDcyOTIwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjb25mZXJzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJHbHVjb3NlLTYtcGhvc3BoYXRhc2UgbXV0YXRpb24gRzE4OFIgY29uZmVycyBhbiBhdHlwaWNhbCBnbHljb2dlbiBzdG9yYWdlIGRpc2Vhc2UgdHlwZSAxYiBwaGVub3R5cGUuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE0MDQ0MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0NTEzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgbm92ZWwgZnJhbWVzaGlmdCBwLlMyNDhBZnMqNjUgd2FzIGlkZW50aWZpZWQgaW4gYSBQS0QvSUMgZmFtaWx5IG1lbWJlciB3aXRoIElDIGFuZCBtaWdyYWluZSB3aXRoIGF1cmEuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjU3Mzk0MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjkwNjEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZvdW5kIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBTNDY1UiBtdXRhdGlvbiB3YXMgZm91bmQgaW4gMC41JSBvZiBvdXIgcGF0aWVudHMgd2l0aCBjb21tb24gdHlwZSAyIGRpYWJldGVzIGFuZCB0aHVzIG1heSBiZSBhIHJhcmUgZ2VuZXRpYyByaXNrIGZhY3RvciBjb250cmlidXRpbmcgdG8gdGhlIGRldmVsb3BtZW50IG9mIHR5cGUgMiBkaWFiZXRlcyByYXRoZXIgdGhhbiBNT0RZNS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNjExNjUwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NTAwNzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJJbiBjb25jbHVzaW9uLCB0aGUgYy4yMDY3KzFHLS0+IEEgbXV0YXRpb24gaXMgYXNzb2NpYXRlZCB3aXRoIEhDTSB3aXRoIHN1YnN0YW50aWFsIGh5cGVydHJvcGh5IGFuZCBtb2RlcmF0ZSBpbmNpZGVuY2Ugb2Ygc3VkZGVuIGRlYXRoLCB3aGVyZWFzIHRoZSBBcmc4MjBHbG4gbXV0YXRpb24gaXMgYXNzb2NpYXRlZCB3aXRoIGVuZC1zdGFnZSBIQ00uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjg4OTUxMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzQzNTMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiTXV0YXRpb24gRzgwNVIgaW4gdGhlIHRyYW5zbWVtYnJhbmUgZG9tYWluIG9mIHRoZSBMREwgcmVjZXB0b3IgZ2VuZSBjYXVzZXMgZmFtaWxpYWwgaHlwZXJjaG9sZXN0ZXJvbGVtaWEgYnkgaW5kdWNpbmcgZWN0b2RvbWFpbiBjbGVhdmFnZSBvZiB0aGUgTERMIHJlY2VwdG9yIGluIHRoZSBlbmRvcGxhc21pYyByZXRpY3VsdW0uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE3MzkzNTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDczODY0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBbGwgZml2ZSBtdXRhdGlvbnMgYXJlIGFzc29jaWF0ZWQgd2l0aCBOUywgd2hlcmVhcyB0d28gKEE1N0cgYW5kIEY4MlYpIGhhdmUgYWxzbyBiZWVuIGlkZW50aWZpZWQgaW4gdXJpbmFyeSB0cmFjdCBjYW5jZXJzIGFuZCBteWVsb2lkIG1hbGlnbmFuY2llcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTIxNDA1MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjk2NjYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSW4gYSBzdWJzZXQgb2YgMTMsNDQ2IGluZGl2aWR1YWxzIHdpdGggZXN0aW1hdGVkIGdsb21lcnVsYXIgZmlsdHJhdGlvbiByYXRlIChlR0ZSKSBtZWFzdXJlbWVudHMsIHdlIHNob3cgdGhhdCByczEzMzMzMjI2IGlzIGluZGVwZW5kZW50bHkgYXNzb2NpYXRlZCB3aXRoIGh5cGVydGVuc2lvbiAodW5hZGp1c3RlZCBmb3IgZUdGUjogMC44OSBbMC44My0wLjk2XSwgcCA9IDAuMDA0OyBhZnRlciBlR0ZSIGFkanVzdG1lbnQ6IDAuODkgWzAuODMtMC45Nl0sIHAgPSAwLjAwMykuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjQ5NTIzMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NjE0NjIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJXZSBjb25jbHVkZSB0aGF0IFY2Mk0gbWF5IGNhdXNlIGh5cGVyZ2x5Y2VtaWEgYnkgYSBjb21wbGV4IGRlZmVjdCBvZiBHQ0sgcmVndWxhdGlvbiBpbnZvbHZpbmcgaW5zdGFiaWxpdHkgaW4gY29tYmluYXRpb24gd2l0aCBsb3NzIG9mIGNvbnRyb2wgYnkgYSBwdXRhdGl2ZSBlbmRvZ2Vub3VzIGFjdGl2YXRvciBhbmQvb3IgR0tSUC5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTc0MzUwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3Mjg0NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBIHAuUjg3MEggbXV0YXRpb24gaW4gdGhlIGJldGEtY2FyZGlhYyBteW9zaW4gaGVhdnkgY2hhaW4gNyBnZW5lIGNhdXNlcyBmYW1pbGlhbCBoeXBlcnRyb3BoaWMgY2FyZGlvbXlvcGF0aHkgaW4gc2V2ZXJhbCBtZW1iZXJzIG9mIGFuIEluZGlhbiBmYW1pbHkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjc1MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5ODYwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlI3MDJXLCBHOTA4UiwgYW5kIDMwMjBpbnNDIHdlcmUgc3Ryb25nbHkgYXNzb2NpYXRlZCB3aXRoIENEIGJ1dCBub3Qgd2l0aCB1bGNlcmF0aXZlIGNvbGl0aXMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjExODg3ODA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyODc0NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZW5jb2RpbmdcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkEgbm9uLXN5bm9ueW1vdXMgU05QIGluIHRoZSBNQzFSIGdlbmUgKHJzMTgwNTAwNyBlbmNvZGluZyBBcmcxNTFDeXMgc3Vic3RpdHV0aW9uKSwgYSBwcmV2aW91c2x5IHdlbGwtZG9jdW1lbnRlZCBwaWdtZW50YXRpb24gZ2VuZSwgc2hvd2VkIHRoZSBzdHJvbmdlc3QgYXNzb2NpYXRpb24gd2l0aCBCQ0MgcmlzayBpbiB0aGUgZGlzY292ZXJ5IHNldCAocnMxODA1MDA3XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjUzODEzMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2MDYxNzIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiRnVydGhlcm1vcmUsIHRoZSBJMTI1VCBtdXRhdGlvbiB3YXMgc2lnbmlmaWNhbnRseSBhc3NvY2lhdGVkIHdpdGggdGhlIGlkaW9wYXRoaWMgYnJvbmNoaWVjdGFzaXMgc3ViLWdyb3VwIChQIDwwLjA1KS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTMwMzY3MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzQ4MDkwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgYW1vbmdcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIGFkZGl0aW9uLCBhbW9uZyB0aGUgYnJlYXN0IGNhbmNlciBjYXNlcyB0aGUgYy40MDM0ZGVsQSBtdXRhdGlvbiBoYXMgYmVlbiBhc3NvY2lhdGVkIHdpdGggYSBsYXRlciBhZ2Ugb2Ygb25zZXQgYW5kIHdvcnNlIGNsaW5pY2FsIG91dGNvbWVzIGluIGNvbXBhcmlzb24gd2l0aCB0aGUgYy41MjY2ZHVwQyBtdXRhdGlvbi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTU4MTY0MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1ODc2NTAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiU05QIHJzNDg0NTYyNSBpbiB0aGUgSUw2UiBnZW5lIHdhcyBhc3NvY2lhdGVkIHdpdGggQUYgKHJlbGF0aXZlIHJpc2sgW1JSXSBDIGFsbGVsZSwgMC45MDsgOTUlIGNvbmZpZGVuY2UgaW50ZXJ2YWwgW0NJXSwgMC44NS0wLjk1OyBQPTAuMDAwNSkgaW4gd2hpdGVzIGJ1dCBkaWQgbm90IHJlYWNoIHN0YXRpc3RpY2FsIHNpZ25pZmljYW5jZSBpbiBBZnJpY2FuIEFtZXJpY2FucyAoUlIsIDAuODY7IDk1JSBDSSwgMC43Mi0xLjAzOyBQPTAuMDkpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMzUyMjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCI0ODY5MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaWRlbnRpZmllZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBIG5ldyBtaXNzZW5zZSAoRTE2MUspIG11dGF0aW9uIHdhcyBpZGVudGlmaWVkIGluIGEgZmFtaWx5IHdpdGggZWFybHkgYXRyaWFsIGZpYnJpbGxhdGlvbiBhbmQgYSBwcmV2aW91c2x5IGRlc2NyaWJlZCAoUjM3N0gpIG11dGF0aW9uIGluIGFub3RoZXIgZmFtaWx5IHdpdGggYSBxdWFkcmljZXBzIG15b3BhdGh5IGFzc29jaWF0ZWQgd2l0aCBEQ00uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEyMDAyNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc1MDU4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkZXRlY3RlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJIb21venlnb3VzIGFuZCBoZXRlcm96eWdvdXMgWTY1OEMgKGMuMTk3M0E+IEcpIGFsbGVsZXMgd2VyZSBkZXRlY3RlZCBpbiB0aGUgcGF0aWVudCBhbmQgaGVyIGNoaWxkIHdpdGggc2V2ZXJlIGFuZCBtaWxkIEFEQU1UUzEzIGRlZmljaWVuY2llcywgcmVzcGVjdGl2ZWx5LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI2MzA2MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTU1MjEwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIldlIG9ic2VydmUgdGhhdCBjLjc5Rz4gQyAocC5EMjdIKSBpcyBhc3NvY2lhdGVkIHdpdGggYSBtaWxkIGxpbWItZ2lyZGxlIG11c2N1bGFyIGR5c3Ryb3BoeSBwaGVub3R5cGUsIHdoZXJlYXMgYy44NjBHPiBBIChwLlIyODdRKSBpcyBhc3NvY2lhdGVkIHdpdGggYSByZWxhdGl2ZWx5IHNldmVyZSBjb25nZW5pdGFsIG11c2N1bGFyIGR5c3Ryb3BoeSB0eXBpY2FsbHkgaW52b2x2aW5nIGJyYWluIGRldmVsb3BtZW50LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI4MDY2NzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTg1MzA1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyZXNjdWVkXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBbHRob3VnaCBwLkQxNjlHIHJlc2N1ZWQgb3JnYW5pc21hbCBwdXBhbCBsZXRoYWxpdHkgYW5kIG5ldXJvbmFsIGxvc3MgdG8gYSBzaW1pbGFyIGV4dGVudCBhcyB3aWxkLXR5cGUgVEFSREJQLCBwLkE5MFYsIHAuRzI4N1MsIGFuZCBwLkEzMTVUIHdlcmUgbGVzcyBlZmZpY2llbnQuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE5NjY2MTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjczNjc5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZXNcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIG9uZSBmYW1pbHksIGEgcC5NMTAyOUsgbXV0YXRpb24gaW4gdGhlIEMyIGRvbWFpbiBjYXVzZXMgc2V2ZXJlIGR5c3RvbmlhLCBoeXBvdG9uaWEsIGFuZCBjaG9yZWEuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjM1MTEwMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjkwNDEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZvdW5kIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJNNjk0SSBhbmQgQTc0NFMgc2VlbSBzcGVjaWZpYyB0byBBcmFiIHBvcHVsYXRpb25zLCBhbmQgUjc2MUggaXMgZnJlcXVlbnRseSBmb3VuZCBpbiBMZWJhbmVzZSBGTUYgcGF0aWVudHMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE4OTM0MTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5NzE3MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcInJzMTQyMjY3MyB3YXMgYWxzbyBhc3NvY2lhdGVkIHdpdGggYXN0aG1hIGluIHRoZSBwdWJsaXNoZWQgR0FCUklFTCAoUCA9IC4wMTgpIGFuZCBFVkUgKFAgPSAxLjMxIHggMTAgKC01KSkgc3R1ZGllcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTA3NTI3MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxNDMzODA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZm91bmQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIk5vIGdpYW50IG15b3RvbmljIGRpc2NoYXJnZXMgb3IgcGFpbmZ1bCBtdXNjbGUgY3JhbXBzIHdlcmUgZm91bmQgaW4gdGhlIG90aGVyIEcxMzA2QSBmYW1pbGllcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjUwNDcwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NDUwMjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaWRlbnRpZmllZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgaG9tb3p5Z291cyAzMiBkZWx0YVQgZGVsZXRpb24gd2FzIGlkZW50aWZpZWQgaW4gdGhlIG9ubHkga25vd24gcGF0aWVudCBvZiBBZnJpY2FuLUFtZXJpY2FuIG9yaWdpbiB3aXRoIENhbmF2YW4gZGlzZWFzZS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzU4NzgwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3MjkzNjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJFMTMxN1EgaXMgc2lnbmlmaWNhbnRseSBhc3NvY2lhdGVkIHdpdGggbXVsdGlwbGUgY29sb3JlY3RhbCBhZGVub21hcyAoT1IgPSAxMS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjYxNjAyNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCI5NzAwMDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2FycmllZFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIHR3byBKTE5TIHBhdGllbnRzIGluIHRoZSBmYW1pbHkgY2FycmllZCB0aGUgaG9tb3p5Z291cyBUMzIyTSBtdXRhdGlvbi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzE0OTAwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjYwNTY2NDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIHRoaXMgd2F5IHRoZSBHbHkzNjQgdG8gQXNwIGFuZCBBcmc1MTAgdG8gR2xuIHN1YnN0aXR1dGlvbnMgbWF5IGNhdXNlIFBLIGRlZmljaWVuY3kgYnkgaW5mbHVlbmNpbmcgdGhlIGFsbG9zdGVyaWMgcHJvcGVydGllcyBvZiB0aGUgZW56eW1lLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyMDAyODAwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3MzY4MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCBJblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSW4gYW4gYWRkaXRpb25hbCB2YWxpZGF0aW9uLWNvaG9ydCBvZiBFQSAoNDEwIGVuZC1zdGFnZSByZW5hbCBkaXNlYXNlIChFU1JEKSBjYXNlcyBhbmQgMTMwOCBjb250cm9scyksIHJzNzU0NDQ5MDQgd2FzIGFzc29jaWF0ZWQgd2l0aCBFU1JEIChPUiA9IDEuMjIsIFAgPSAwLjAzNikuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE4Mjg5MTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjA5NTU0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkhvbW96eWdvdXMgYy4zNTlkZWwgdmFyaWFudCBpbiBNR01FMSBpcyBhc3NvY2lhdGVkIHdpdGggZWFybHkgb25zZXQgY2VyZWJlbGxhciBhdGF4aWEuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjI2MDk5MjMwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTMyMjkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhcnJ5XCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJDbGluaWNhbCBmZWF0dXJlcyBhcmUgc2V2ZXJlIGRldmVsb3BtZW50YWwgZGVsYXksIG1pY3JvY2VwaGFseSBhbmQgZHlza2luZXNpYS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzI4ODEwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjY3MTM5MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZXNlIG9ic2VydmF0aW9ucyBsZWQgdXMgdG8gYXNrIHdoZXRoZXIgYXhvbiBkeXNpbm5lcnZhdGlvbiBpcyBhIHByaW1hcnkgcGhlbm90eXBlLCBhbmQgd2h5IHRoZSBFNDIxSywgYnV0IG5vdCBvdGhlciwgVFVCQjJCIHN1YnN0aXR1dGlvbnMgY2F1c2UgQ0ZFT00uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE4MTAyMTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5MDYxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkFtb25nIHRoZW0sIHJzMTA3NjE3NDUgKEpNSkQxQykgYW5kIHJzMTYzMTc3IChLQ05RMSkgd2VyZSBwcm9zcGVjdGl2ZWx5IGFzc29jaWF0ZWQgd2l0aCBUMkQuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjc1MDAxMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzUwMDcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFBUUE4xMSBsb3NzLW9mLWZ1bmN0aW9uIG11dGF0aW9uIFE1MTBFLVNocDIgY2F1c2VzIGh5cGVydHJvcGhpYyBjYXJkaW9teW9wYXRoeSBieSBkeXNyZWd1bGF0aW5nIG1UT1Igc2lnbmFsaW5nLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI4MDY2NzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjcyOTI5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyZXNjdWVkXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBbHRob3VnaCBwLkQxNjlHIHJlc2N1ZWQgb3JnYW5pc21hbCBwdXBhbCBsZXRoYWxpdHkgYW5kIG5ldXJvbmFsIGxvc3MgdG8gYSBzaW1pbGFyIGV4dGVudCBhcyB3aWxkLXR5cGUgVEFSREJQLCBwLkE5MFYsIHAuRzI4N1MsIGFuZCBwLkEzMTVUIHdlcmUgbGVzcyBlZmZpY2llbnQuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE1NDYxOTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDcyOTIwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCIoXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjQyNDQ4MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjkxMzUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGF1IGdlbmUgbXV0YXRpb24gRzM4OVIgY2F1c2VzIGEgdGF1b3BhdGh5IHdpdGggYWJ1bmRhbnQgcGljayBib2R5LWxpa2UgaW5jbHVzaW9ucyBhbmQgYXhvbmFsIGRlcG9zaXRzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI4MjgwOTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTg2ODI1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmb3VuZCB3aXRob3V0XCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgRTI5MlYgbXV0YXRpb24gd2FzIG5vdCBmb3VuZCBvbiAyMDAgY29udHJvbCBhbGxlbGVzIGZyb20gYWR1bHRzIHdpdGhvdXQgbHVuZyBkaXNlYXNlLCBidXQgc2V2ZW4gYWRkaXRpb25hbCBwYXRpZW50cyBvZiB0aGUgcmVtYWluaW5nIHN0dWR5IHBhdGllbnRzIGhhZCB0aGUgRTI5MlYgbXV0YXRpb24gb24gb25lIGFsbGVsZS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNDE3NTMwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU3MTY1ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJXZSBjb25jbHVkZSB0aGF0IHRoZSBMMzQ1UCBkZXNtaW4gbWlzc2Vuc2UgbXV0YXRpb24gY2F1c2VzIG15b3BhdGh5IGJ5IGludGVyZmVyaW5nIGluIGEgZG9taW5hbnQtbmVnYXRpdmUgbWFubmVyIHdpdGggdGhlIGRpbWVyaXphdGlvbi1wb2x5bWVyaXphdGlvbiBwcm9jZXNzIG9mIGludGVybWVkaWF0ZSBmaWxhbWVudCBhc3NlbWJseS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNTAzMDcwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjYwMzk5ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZm91bmQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQmVjYXVzZSBWMTM4RiB3YXMgZm91bmQgaW4gdGhlIEdlcm1hbiBwYXRpZW50cyB3aXRoIFBlbmRyZWQncyBzeW5kcm9tZSBvbiBhdCBsZWFzdCBvbmUgYWxsZWxlLCB3ZSBnZW5vdHlwZWQgZml2ZSBtaWNyb3NhdGVsbGl0ZSBtYXJrZXJzIGxvY2F0ZWQgaW4gdGhlIFBEUyByZWdpb24uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjI1NDQ0MzEwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiNjcxNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGl2aWRlZCBpbnRvXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJCYXNlZCBvbiB0aGUgZ2VuZXRpYyBtdXRhdGlvbiwgdGhlIEZIIHN1YmplY3RzIHdlcmUgZGl2aWRlZCBpbnRvIDIgZ3JvdXBzLCBLNzkwWCwgKG49MjApIGFuZCBQNjY0TCwgKG49NSksIGFuZCB0aGVpciBMRExSIGFjdGl2aXRpZXMgd2FzIG1lYXN1cmVkIGJ5IHRoaXMgbWV0aG9kLCB3aGljaCB3YXMgZm91bmQgdG8gYmUgNTUuMysvLTguOSUgYW5kIDYzLjkrLy0xMy44JSwgcmVzcGVjdGl2ZWx5LCBvZiB0aGF0IG9mIHRoZSBjb250cm9sIGdyb3VwIChuPTE1KS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjY3OTcwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NDM4MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgTjE4OFMgbXV0YXRpb24gaW4gR2F1Y2hlciBkaXNlYXNlIGlzIGFzc29jaWF0ZWQgd2l0aCBteW9jbG9udXMgZXBpbGVwc3kuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjQ5Nzc3MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjk5OTAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQSBub3ZlbCBMMjY2ViBtdXRhdGlvbiBvZiB0aGUgdGF1IGdlbmUgY2F1c2VzIGZyb250b3RlbXBvcmFsIGRlbWVudGlhIHdpdGggYSB1bmlxdWUgdGF1IHBhdGhvbG9neS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzIwMjEwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU2ODQ5ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VkXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJTODkxQSBtdXRhdGlvbiBjYXVzZWQgbWVkdWxsYXJ5IHRoeXJvaWQgY2FuY2VyIChNVEMpIGluIDY5LjQlLCBwaGVvY2hyb21vY3l0b21hIGluIDIuOCUsIGFuZCBwYXJhdGh5cm9pZCBoeXBlcnBsYXNpYSBpbiA4LjMlIG9mIHRoZSAzNiBwYXRpZW50cyBvZiB0aGlzIGNhc2Ugc2VyaWVzIGFuZCBpbiA2My41LCA0LjEsIGFuZCA0LjElLCByZXNwZWN0aXZlbHksIGZvciB0aGUgZW50aXJlIGdyb3VwcyBvZiA3NCBwYXRpZW50cy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTIyODI0MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjk3MTgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIHJzNjkyOTg0NiBTTlAgb2YgQlROMkExLCBidXQgbm90IHJzMjU2OTUxMiBvZiBJTEYzLCB3YXMgYWxzbyBzaWduaWZpY2FudGx5IGFzc29jaWF0ZWQgd2l0aCBNSSBpbiBKYXBhbmVzZSBzdWJqZWN0IHBhbmVsIEMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjI4NDAwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NTA3MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJSMjIyUSBTQ041QSBtdXRhdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGggcmV2ZXJzaWJsZSB2ZW50cmljdWxhciBlY3RvcHkgYW5kIGRpbGF0ZWQgY2FyZGlvbXlvcGF0aHkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjM2MDU4MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzQzNTMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImV4cHJlc3NlZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIEMyNDBGIG11dGFudCB3YXMgZXhwcmVzc2VkIGluIExETCByZWNlcHRvciBkZWZpY2llbnQgQ0hPTWxkbEE3IGNlbGxzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI3NTMwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTg2MDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB0b1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiUjcwMlcgaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBzdXNjZXB0aWJpbGl0eSB0byBDRCBpbiBBc2hrZW5hemkgSmV3cy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTM1NzcxMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2MDk5ODMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFI4MjBXIG11dGF0aW9uIGluIHRoZSBNWUJQQzMgZ2VuZSwgYXNzb2NpYXRlZCB3aXRoIGh5cGVydHJvcGhpYyBjYXJkaW9teW9wYXRoeSBpbiBjYXRzLCBjYXVzZXMgaHlwZXJ0cm9waGljIGNhcmRpb215b3BhdGh5IGFuZCBsZWZ0IHZlbnRyaWN1bGFyIG5vbi1jb21wYWN0aW9uIGluIGh1bWFucy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiODQ2NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIzOTg1NzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgcC5SOTZIIG11dGF0aW9uIGlzIGFzc29jaWF0ZWQgd2l0aCBkSE1OLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI1NjE2MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NjU4ODAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIEUxMDFLIG11dGF0aW9uIGluIHRoZSBhbHBoYS1jYXJkaWFjIGFjdGluIGdlbmUgKEFDVEMpIGhhcyBiZWVuIGFzc29jaWF0ZWQgd2l0aCBhcGljYWwgaHlwZXJ0cm9waGljIGNhcmRpb215b3BhdGh5IChIQ00pLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNjQ1ODA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0Njc4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJoYWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBDYSAoVikgMS4xIFI1MjhIIG1pY2UgaGFkIGEgSHlwb1BQIHBoZW5vdHlwZSBmb3Igd2hpY2ggbG93IEsrIGNoYWxsZW5nZSBwcm9kdWNlZCBhIHBhcmFkb3hpY2FsIGRlcG9sYXJpemF0aW9uIG9mIHRoZSByZXN0aW5nIHBvdGVudGlhbCwgbG9zcyBvZiBtdXNjbGUgZXhjaXRhYmlsaXR5LCBhbmQgd2Vha25lc3MuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjU0NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5NzEwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBHMjAxOVMgbXV0YXRpb24gd2FzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2xhc3NpY2FsIFBhcmtpbnNvbidzIGRpc2Vhc2UgcGhlbm90eXBlIGFuZCBhIGJyb2FkIHJhbmdlIG9mIG9uc2V0IGFnZSAoMzQgdG8gNzMgeWVhcnMpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMDc1NDk0MDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjM0NTU4MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhdHRyaWJ1dGVkIHRvXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJQYXJ0aWFsIGJpb3RpbmlkYXNlIGRlZmljaWVuY3kgaXMgYWxtb3N0IHVuaXZlcnNhbGx5IGF0dHJpYnV0ZWQgdG8gdGhlIEQ0NDRIIG11dGF0aW9uLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNzIwOTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDcwMDEyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmb3VuZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSW4gdGhlIFNwYW5pc2ggY29sbGVjdGlvbiwgUjIxMkMgd2FzIGZvdW5kIGluIGEgQ1JEIHBhdGllbnQsIGluZGljYXRpbmcgdGhhdCBpdCBtYXkgYmUgYSByYXRoZXIgc2V2ZXJlIGNoYW5nZS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTAyMzI4MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjkzNjYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImlkZW50aWZpZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlBPTEUgcC5MNDI0ViB3YXMgaWRlbnRpZmllZCBpbiBhIDI4LXllYXItb2xkIHBvbHlwb3NpcyBhbmQgQ1JDIHBhdGllbnQsIGFzIGEgZGUgbm92byBtdXRhdGlvbi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNjA3NzkwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NDU3NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGV0ZWN0ZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcInAuIFAzNjFMXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEwNzUwMDcwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjY4MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaGFkXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJPbmUgSENNIHByb2JhbmQgd2l0aCBhIG1heGltYWwgbGVmdCB2ZW50cmljdWxhciB3YWxsIHRoaWNrbmVzcyBvZiAxNyBtbSBoYWQgcC5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzQwNzQwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTQ4NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYWx0ZXJzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJQMjVMIGFsdGVycyBvbmx5IHRoZSB1cHN0cmVhbSBwcm90ZWluLCB3aGVyZWFzIFA4NlIgYWx0ZXJzIGJvdGggVkhMIHByb3RlaW5zLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIzMzIwNTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0ODM4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJzaG93ZWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBtdXRhdGlvbiBBcmc1OEdsbiBzaG93ZWQgYWxzbyBtb2RlcmF0ZSBzZXB0YWwgaHlwZXJ0cm9waHksIGJ1dCwgaW4gY29udHJhc3QsIGl0IHdhcyBhc3NvY2lhdGVkIHdpdGggYW4gZWFybHkgb25zZXQgb2YgY2xpbmljYWwgbWFuaWZlc3RhdGlvbiBhbmQgcHJlbWF0dXJlIHN1ZGRlbiBjYXJkaWFjIGRlYXRoLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMTA1MDAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCI2OTkyMTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZ2Vub3R5cGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkhlcmUsIDEsOTkzIHByaW1hcnkgZ291dCBwYXRpZW50cyBhbmQgNCw5MDIgaGVhbHRoIGV4YW1pbmF0aW9uIHBhcnRpY2lwYW50cyAoMywzMDUgbWFsZXMgYW5kIDEsNTk3IGZlbWFsZXMpIHdlcmUgZ2Vub3R5cGVkIHdpdGggUjkwSCBhbmQgVzI1OFguXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEzMTQ1MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjAxMDEzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBLMTA4RSB2YXJpYW50IHdhcyBhc3NvY2lhdGVkIHdpdGggYW4gYXV0b3NvbWFsIHJlY2Vzc2l2ZSBzZXZlcmUgaW1tdW5vZGVmaWNpZW5jeSB3aXRoIGEgY29tcGxldGUgbGFjayBvZiBjaXJjdWxhdGluZyBtb25vY3l0ZXMgYW5kIGRlbmRyaXRpYyBjZWxscy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTM4NjQzMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzQwMjEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIG1pbm9yIGFsbGVsZSBvZiB0aHJlZSBTTlBzIChyczc2MjkzODYgYXQgM3AyMi4xLCByczk2OTA4OCBhdCA1cDE0LjEsIGFuZCByczM4NTAzNzAgYXQgMTRxMjQuMykgd2VyZSBhc3NvY2lhdGVkIHdpdGggd29yc2UgTlNDTEMgc3Vydml2YWwgd2hpbGUgMiAocnM0MTk5NyBhdCA3cTMxLjMxIGFuZCByczEyMDAwNDQ1IGF0IDlwMjEuMykgd2VyZSBhc3NvY2lhdGVkIHdpdGggYmV0dGVyIE5TQ0xDIHN1cnZpdmFsLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI1MjYwNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjE3MzMxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlI3MDJDIGFuZCBSNzAySCBtdXRhdGlvbnMgd2VyZSBvbmx5IGFzc29jaWF0ZWQgd2l0aCBGVE5TLCBFUFMsIG9yIEFQU00sIHRodXMgZGVmaW5pbmcgYSByZWdpb24gb2YgTVlISUlBIGNyaXRpY2FsIGluIHRoZSBjb21iaW5lZCBwYXRob2dlbmVzaXMgb2YgbWFjcm90aHJvbWJvY3l0b3BlbmlhLCBuZXBocml0aXMsIGFuZCBkZWFmbmVzcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzc3MTQwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTg2MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZm91bmQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkFuIGludGVyZXN0aW5nIGZhY3QgaXMgdGhhdCBBNTU5VCB3YXMgc28gZmFyIGZvdW5kIG1vc3RseSBpbiBDRiBwYXRpZW50cyBvZiBBZnJpY2FuLUFtZXJpY2FuIG9yaWdpbi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNjIwNTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5ODYzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmb3VuZCBvblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiRzQ4MEMgd2FzIGZvdW5kIG9uIG9uZSBhZGRpdGlvbmFsIENGIGNocm9tb3NvbWUgYW5kIG9uIG5vbmUgb2YgMjIwIG5vcm1hbCBjaHJvbW9zb21lcywgaW5jbHVkaW5nIDE2MCBjaHJvbW9zb21lcyBmcm9tIG5vcm1hbCBBZnJpY2FuLUFtZXJpY2FuIGluZGl2aWR1YWxzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMDc1MDA3MDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NzcyOTIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImhhdmVcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkh5cGVydHJvcGhpYyBjYXJkaW9teW9wYXRoeSBwYXRpZW50cyB3aXRoIHRoZSBtYWxpZ25hbnQgQXJnNzE5VHJwIG11dGF0aW9uIGhhdmUgbW9yZSBleHRlbnNpdmUgaHlwZXJ0cm9waHkgdGhhbiB0aG9zZSB3aXRoIHRoZSBiZW5pZ24gTGV1NjA2VmFsIG11dGF0aW9uLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNzI3MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDczODUxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyZWxhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBjLjY0M0c+IEEsIHAuQXNwMjE1QXNuIG11dGF0aW9uIGlzIHJlbGF0ZWQgd2l0aCB0eXBlIElJSWEsIGFzIHRoaXMgbXV0YXRpb24gd2FzIGZvdW5kIGhvbW96eWdvdXNseSBpbiB0d28gdHlwZSBJSUlhIHBhdGllbnRzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMDcwMDEyMDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2MTAwNDQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInNob3dlZFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIHR3byBDUkQgc2libGluZ3Mgd2l0aCB0aGUgYy4xNTYtMkE+IEcgbXV0YXRpb24gYWxzbyBzaG93ZWQgdW5pbGF0ZXJhbCBwb3N0YXhpYWwgcG9seWRhY3R5bHkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjIwNjAwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTc4NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJPdXIgZmluZGluZ3MgY29uZmlybWVkIHRoYXQgaG9tb3p5Z291cyBNNjk0ViBpcyBhc3NvY2lhdGVkIHdpdGggYW15bG9pZG9zaXMgaW4gdGhlIFR1cmtpc2ggcG9wdWxhdGlvbiBhcyB3ZWxsIHNpbWlsYXIgdG8gQXJtZW5pYSwgSXNyYWVsLCBhbmQgQXJhYmlhbiBjb3VudHJpZXMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjg2ODQyMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzQ4NjUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFcxMTkxWCBtdXRhdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGggQlMgYW5kIHJlc3VsdGVkIGluIHRoZSBsb3NzIG9mIGZ1bmN0aW9uIG9mIHRoZSBjYXJkaWFjIHNvZGl1bSBjaGFubmVsLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIzMDE5MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTgxNzQwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJoYXNcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBSMTMzQyBnZW5vdHlwZSBoYXMgYSBwcmVkb21pbmFudGx5IGF1dGlzdGljIHByZXNlbnRhdGlvbiB3aGlsZSB0aGUgUjMwNkMgZ2Vub3R5cGUgaXMgYXNzb2NpYXRlZCB3aXRoIGEgc2xvd2VyIGRpc2Vhc2UgcHJvZ3Jlc3Npb24uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjY4NDczMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzU0MDQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiW0EgZGUgbm9ubyBJNDYyUyBtdXRhdGlvbiBpbiB0aGUgS1JUNkEgZ2VuZSBpcyBhc3NvY2lhdGVkIHdpdGggcGFjaHlvbnljaGlhIGNvbmdlbml0YSB0eXBlIEldLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMDc0NTEzMDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjkxNjIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImhhdmluZ1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiUFJSVDIgbXV0YXRpb25zIHdlcmUgYWxzbyBmb3VuZCBpbiBQS0QvSUMgd2l0aCBtaWdyYWluZTogcC5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNjczMjcwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NDc3MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVwb3J0ZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkEgKExldTg0OUhpcykgYW5kIGMuMTkzMmRlbENdIGhhdmUgYmVlbiByZXBvcnRlZCBpbiBKYXBhbmVzZSBwYXRpZW50cywgYnV0IG5vdCBpbiBHUyBwYXRpZW50cyBmcm9tIG90aGVyIGV0aG5pYyBncm91cHMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjIwNjAwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTc4NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJNNjk0ViBob21venlnb3NpdHkgaXMgYXNzb2NpYXRlZCB3aXRoIHBoZW5vdHlwZSBJSSBhbmQgYW15bG9pZG9zaXMgY29tcGFyZWQgdG8gb3RoZXIgY29tbW9uIGdlbm90eXBlcyBpbiBwYXRpZW50cyB3aXRoIEZNRi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjM2MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc1MDcxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJQTE4gbXV0YXRpb24gUjE0ZGVsIHdhcyBpZGVudGlmaWVkIGluIDEyICgxMiUpIEFSVkMgcGF0aWVudHMgYW5kIGluIDM5ICgxNSUpIERDTSBwYXRpZW50cy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTUxMzg1MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzQ1NzUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRldGVjdGVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJwLiBQMzYxTFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNjA1ODQwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTA2MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJDbGluaWNhbGx5LCBwLkMxNzMzWSB3YXMgYXNzb2NpYXRlZCB3aXRoIEdELCBhcyByZXBvcnRlZCBwcmV2aW91c2x5LCBhcyB3ZWxsIGFzIHRoZSBub3ZlbCBwLk4xNzMwSSwgd2hlcmVhcyBwLkMxNzMzRlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNjY5NjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0MjM2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZXNcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZXNlIHN0dWRpZXMgcHJvdmlkZSBkaXJlY3QgZ2VuZXRpYyBldmlkZW5jZSB0aGF0IHRoZSBQcm8yNTJBcmcgbXV0YXRpb24gaW4gRkdGUjEgY2F1c2VzIGh1bWFuIFBmZWlmZmVyIHN5bmRyb21lIGFuZCB1bmNvdmVycyBhIG1vbGVjdWxhciBtZWNoYW5pc20gaW4gd2hpY2ggRmdmL0ZnZnIxIHNpZ25hbHMgcmVndWxhdGUgaW50cmFtZW1icmFuZW91cyBib25lIGZvcm1hdGlvbiBieSBtb2R1bGF0aW5nIENiZmExIGV4cHJlc3Npb24uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjgxMTIwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTg3MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZXhoaWJpdFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFRSRVgxIEQxOE4gbWljZSBleGhpYml0IHN5c3RlbWljIGluZmxhbW1hdGlvbiwgbHltcGhvaWQgaHlwZXJwbGFzaWEsIHZhc2N1bGl0aXMsIGFuZCBraWRuZXkgZGlzZWFzZS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTYwNTgwMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzU1MDUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQ2xpbmljYWxseSwgcC5DMTczM1kgd2FzIGFzc29jaWF0ZWQgd2l0aCBHRCwgYXMgcmVwb3J0ZWQgcHJldmlvdXNseSwgYXMgd2VsbCBhcyB0aGUgbm92ZWwgcC5OMTczMEksIHdoZXJlYXMgcC5DMTczM0ZcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNTc1NDAwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjY2NjMzNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgQzQ2UiBtdXRhdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGggYXV0b3NvbWFsIGRvbWluYW50IGxhdGVyYWwgdGVtcG9yYWwgbG9iZSBlcGlsZXBzeSBpbiBhIGxhcmdlIE5vcndlZ2lhbiBmYW1pbHkgc2hvd2luZyB1bnVzdWFsIGNsaW5pY2FsIGZlYXR1cmVzIGxpa2Ugc2hvcnQtbGFzdGluZyBzZW5zb3J5IGFwaGFzaWEgYW5kIGF1ZGl0b3J5IHN5bXB0b21zLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIzNTAyNzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjczNzgyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkEgaGV0ZXJvenlnb3VzIEEzMzdQIG11dGF0aW9uIHdhcyBpZGVudGlmaWVkIGluIGEgZmFtaWx5IHdpdGggYW4gYWR1bHQtb25zZXQgc2tlbGV0YWwgbXlvcGF0aHkgYW5kIG1pbGQgY2FyZGlhYyBpbnZvbHZlbWVudC5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzMwNTYwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjY3Mzk0NDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgVDgwQSB2YXJpYW50IHdhcyBhc3NvY2lhdGVkIHdpdGggYW4gYXV0b3NvbWFsIGRvbWluYW50LCBtaWxkZXIgaW1tdW5vZGVmaWNpZW5jeSBhbmQgYSBzZWxlY3RpdmUgZGVwbGV0aW9uIG9mIENEMTFjK0NEMWMrIGNpcmN1bGF0aW5nIGRlbmRyaXRpYyBjZWxscy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjAwMjgwMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzM2ODEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSW4gYW4gYWRkaXRpb25hbCB2YWxpZGF0aW9uLWNvaG9ydCBvZiBFQSAoNDEwIGVuZC1zdGFnZSByZW5hbCBkaXNlYXNlIChFU1JEKSBjYXNlcyBhbmQgMTMwOCBjb250cm9scyksIHJzNzU0NDQ5MDQgd2FzIGFzc29jaWF0ZWQgd2l0aCBFU1JEIChPUiA9IDEuMjIsIFAgPSAwLjAzNikuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEwNzQyMzYwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTYzMTUwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImhhZFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiRXhjZXB0IGZvciBvbmUsIGFsbCB0aGUgQXBlcnQgcGF0aWVudHMgaGFkIGVpdGhlciBTMjUyVyAobiA9IDE2KSBvciBQMjUzUiAobiA9IDEwKSBtdXRhdGlvbnMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE0NjU1MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1OTI2ODkwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZvdW5kIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgTjM0UyBtdXRhdGlvbiB3YXMgZm91bmQgaW4gc2l4IGZhbWlsaWFsIHBhbmNyZWF0aXRpcyBwYXRpZW50cyAodGhyZWUgZmFtaWxpZXMpIGFuZCBpbiBvbmUganV2ZW5pbGUgcGFuY3JlYXRpdGlzIHBhdGllbnQsIGFuZCB0aGUgUjY3QyBtdXRhdGlvbiB3YXMgZm91bmQgaW4gb25lIGZhbWlsaWFsIHBhbmNyZWF0aXRpcyBwYXRpZW50IGFuZCBvbmUganV2ZW5pbGUgcGFuY3JlYXRpdGlzIHBhdGllbnQuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEzNzM3MDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5ODA4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlJzNzM4NDA5IGluIHRoZSBQTlBMQTMgZ2VuZSB3YXMgbW9zdCBzdHJvbmdseSBhc3NvY2lhdGVkIHdpdGggTkFGTEQgYWZ0ZXIgYWRqdXN0bWVudCAoUCA9IDYuOCB4IDEwICgtMTQpLCBPUiA9IDIuMDUpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI1MDkyMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzU1MDYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRldGVjdGVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgQXJnMTcwVHJwIG11dGF0aW9uIHdhcyBhbHNvIGRldGVjdGVkIGluIGEgdGhpcmQgdW5yZWxhdGVkIFRTRCBwYXRpZW50LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMTYwNzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjI3NzgwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIGNvbnRyYXN0LCBtaXNzZW5zZSBtdXRhdGlvbnMgcHJvZHVjZWQgZGlzdGluY3QgcGhlbm90eXBlczogR2x5ODBBcmcgY2F1c2VkIHNpZ25pZmljYW50IGNhcmRpYWMgbWFsZm9ybWF0aW9ucyBidXQgb25seSBtaW5vciBza2VsZXRhbCBhYm5vcm1hbGl0aWVzOyBhbmQgQXJnMjM3R2xuIGFuZCBBcmcyMzdUcnAgY2F1c2VkIGV4dGVuc2l2ZSB1cHBlciBsaW1iIG1hbGZvcm1hdGlvbnMgYnV0IGxlc3Mgc2lnbmlmaWNhbnQgY2FyZGlhYyBhYm5vcm1hbGl0aWVzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMjM3MzkwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTI0OTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJyczUwNTkyMiBhdCBBQk8gd2FzIGFsc28gYXNzb2NpYXRlZCB3aXRoIGR1b2RlbmFsIHVsY2VyIGluIGEgcmVjZXNzaXZlIG1vZGVsIChPUiA9IDEuMzI7IFAgPSAxLjE1IHggMTAgKC0xMCkpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI2NTU3NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTc0MjkxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkZXNjcmliZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFkyODggQyB2YXJpYW50IHdhcyBwcmV2aW91c2x5IGRlc2NyaWJlZCBpbiBhIGNoaWxkIHdpdGggbWFjcm9jZXBoYWx5LCBtaWxkIGRldmVsb3BtZW50YWwgZGVsYXksIGluY3JlYXNlZCBzaWduYWwgaW50ZW5zaXR5IGluIHRoZSBiYXNhbCBnYW5nbGlhLCBwYXJ0aWFsIGNvcnRpY2FsIGJsaW5kbmVzcyBhbmQgcmV0aW5pdGlzIHBpZ21lbnRvc2EsIGFuZCBzbGlnaHRseSBlbGV2YXRlZCBOLWFjZXR5bGFzcGFydGF0ZSBpbiB0aGUgdXJpbmUuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjI2MjM4MTQwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTQzMzgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZvdW5kIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJObyBnaWFudCBteW90b25pYyBkaXNjaGFyZ2VzIG9yIHBhaW5mdWwgbXVzY2xlIGNyYW1wcyB3ZXJlIGZvdW5kIGluIHRoZSBvdGhlciBHMTMwNkEgZmFtaWxpZXMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEwNzUwMDcwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiNDc4OTkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImhhZFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSW4gdGhpcyBwZWRpZ3JlZSwgMTMgb3V0IG9mIDI1IGZhbWlseSBtZW1iZXJzIHdlcmUgZGlhZ25vc2VkIGFzIEhDTSwgNSBkaWVkIG9mIGhlYXJ0IGZhaWx1cmUsIGFsbCBIQ00gcGF0aWVudHMgaW4gdGhpcyBwZWRpZ3JlZSBoYWQgQXJnNzIzR2x5IG11dGF0aW9uIGFuZCAzIG9mIHRoZW0gaGFkIE5ZSEEgSUlJIGFuZCAyIG9mIHRoZW0gd2VyZSBkaWFnbm9zZWQgYXMgSENNIGJlZm9yZSB0aGUgYWdlIG9mIDIwLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIzMDEyMjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjMwMDc0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmb3VuZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFQ2N00gYW5kIFY1N2RlbCBtdXRhdGlvbnMgaGF2ZSBiZWVuIGZvdW5kIGluIENhdWNhc2lhbiBQVFMgZGVmaWNpZW50IHBhdGllbnRzLCB3aGlsZSB0aGUgTDc2RiwgSVZTMysxRz4gQSwgYW5kIEszOFggbXV0YXRpb25zIGFyZSBub3ZlbC5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiODUzOTQwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU4NjgyNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIldlIHByb3ZpZGUgZXZpZGVuY2UgdGhhdCBWNDU2QSBjYW4gY2F1c2Ugc2lnbmlmaWNhbnQgcHVsbW9uYXJ5IGRpc2Vhc2UgaW4gU291dGggQXNpYW4gQ3lzdGljIEZpYnJvc2lzIHBhdGllbnRzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI0NTM2MzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5ODYwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyZXBvcnRlZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVG8gdGhlIGJlc3Qgb2Ygb3VyIGtub3dsZWRnZSwgdGhlIEMxMzZSIG11dGF0aW9uIGhhcyBub3QgcHJldmlvdXNseSBiZWVuIHJlcG9ydGVkIGluIENEIHBhdGllbnRzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI0NjgzODA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjA5OTYzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJleGhpYml0XCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCIoS0NOQTEgRzcyNEMpXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjM2MjUwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTE4MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2xhc3NpZmllZCBhc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQm90aCBwLlIyNDFDIGFuZCBwLlI0MDhRIGFyZSBjbGFzc2lmaWVkIGFzIG1pbGQgcGhlbnlsa2V0b251cmlhIChQS1UpIG9yIG1pbGQgaHlwZXJwaGVueWxhbGFuaW5lbWlhIChNSFApIG11dGF0aW9uLCB3aGljaCBtYXkgZXhwbGFpbiB0aGUgZmFjdCB0aGF0IGNsYXNzaWNhbCBQS1UgaXMgdmVyeSByYXJlIGluIFRhaXdhbiAobj00LCBvciBvbmUgaW4gNDEzLDAzNSkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjMwMzgxMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1ODY4MjUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiV2hlbiBwcmVzZW50IGluIHRyYW5zIHdpdGggYSBDRi1jYXVzaW5nIG11dGF0aW9uLCBEMTE1MkggY2F1c2VzIHNpZ25pZmljYW50IHB1bG1vbmFyeSBkaXNlYXNlLCBidXQgYWxsIHN1YmplY3RzIGhhZCBwcm9sb25nZWQgc3Vydml2YWwuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEzNTA4MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0ODA5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIihyczEwOTI5MTMpLCA1cTEyL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI1NDY3NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDczOTM1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJhbmQgUDMxNlMpIGluIHRoZSBjb2RpbmcgcmVnaW9uIHdlcmUgaWRlbnRpZmllZCBpbiB0d28gSmFwYW5lc2Ugc2lhbGlkb3NpcyBwYXRpZW50cy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNTEzNjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc1NTA2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZXNcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkEgZ2x5Y2luZTI1MC0tPiBhc3BhcnRhdGUgc3Vic3RpdHV0aW9uIGluIHRoZSBhbHBoYS1zdWJ1bml0IG9mIGhleG9zYW1pbmlkYXNlIEEgY2F1c2VzIGp1dmVuaWxlLW9uc2V0IFRheS1TYWNocyBkaXNlYXNlIGluIGEgTGViYW5lc2UtQ2FuYWRpYW4gZmFtaWx5LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyMDg0MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2NzM4MDYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIEg3MjNSIG11dGF0aW9uIGluIHRoZSBQRFMvU0xDMjZBNCBnZW5lIGlzIGFzc29jaWF0ZWQgd2l0aCB0eXBpY2FsIFBlbmRyZWQgc3luZHJvbWUgaW4gS29yZWFuIHBhdGllbnRzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI0NzIzMzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0ODA5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBJMTU3VCB2YXJpYW50IG1heSBiZSBhc3NvY2lhdGVkIHdpdGggYnJlYXN0IGNhbmNlciByaXNrLCBidXQgdGhlIHJpc2sgaXMgbG93ZXIgdGhhbiBmb3IgMTEwMGRlbEMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjI1NjIyNTEwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMzIwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhcnJpZWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIHRoZSBkb3NlLWVzY2FsYXRpb24gY29ob3J0LCBhbW9uZyB0aGUgMTYgcGF0aWVudHMgd2l0aCBtZWxhbm9tYSB3aG9zZSB0dW1vcnMgY2FycmllZCB0aGUgVjYwMEUgQlJBRiBtdXRhdGlvbiBhbmQgd2hvIHdlcmUgcmVjZWl2aW5nIDI0MCBtZyBvciBtb3JlIG9mIFBMWDQwMzIgdHdpY2UgZGFpbHksIDEwIGhhZCBhIHBhcnRpYWwgcmVzcG9uc2UgYW5kIDEgaGFkIGEgY29tcGxldGUgcmVzcG9uc2UuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjMyMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2NzQxNTEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImRldGVjdGVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBZGRpdGlvbmFsbHksIHNvbWF0aWMgcC5WNjAwRVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNjE1NTkwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NTAzODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJTTlAgcnM4MDQxMzU3LCB3aGljaCBpcyBpbiBjb21wbGV0ZSBsaW5rYWdlIGRpc2VxdWlsaWJyaXVtIChyICgyKSA9IDEpIHdpdGggcnMxMTU0MzE5OCwgd2FzIGFsc28gYXNzb2NpYXRlZCB3aXRoIGJsYWRkZXIgY2FuY2VyIHJpc2sgaW4gRXVyb3BlYW5zIChQID0gMC4wNDUgZm9yIGFuIGFkZGl0aXZlIGFuZCBQID0gMC4wMjUgZm9yIGEgcmVjZXNzaXZlIG1vZGVsKSwgZGVzcGl0ZSBtdWNoIGxvd2VyIG1pbm9yIGFsbGVsZSBmcmVxdWVuY3kgaW4gRXVyb3BlYW5zICgzLjclKSBjb21wYXJlZCB3aXRoIHRoZSBKYXBhbmVzZSAoMjIuMiUpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMTk1MDUwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTg3MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJyczM4NDk5NDIgYW5kIHJzOTAzNjAzIHdlcmUgc3Ryb25nbHkgYXNzb2NpYXRlZCB3aXRoIEFMUyB3aGVuIGFsbCBzYW1wbGVzIHdlcmUgaW5jbHVkZWQgKHJzMzg0OTk0MiwgcCA9XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjU3NTE5MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NDc2ODEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFMxNDBUIG11dGF0aW9uIGluIG15ZWxpbiBQMCBjYW4gYmUgYXNzb2NpYXRlZCB3aXRoIGNvbmR1Y3Rpb24gYmxvY2sgYW5kIENoYXJjb3QtTWFyaWUtVG9vdGggc2hvdWxkIGJlIHBhcnQgb2YgdGhlIGRpZmZlcmVudGlhbCBkaWFnbm9zaXMgb2YgdGhhdCBwaGVub21lbm9uLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI2Nzg2MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2MDMyMTEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImhhZFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQzczUi9DNzNSIG1pY2UgdGhhdCBzdXJ2aXZlZCBmZXRhbCBsaWZlIHRvIHdlYW5pbmcgYWdlICh+MTIlKSBoYWQgYSBzZXZlcmUgbWljcm9jeXRpYyBoeXBvY2hyb21pYyBhbmVtaWEgKGhlbW9nbG9iaW4gNy45IGcvZEwsIG1lYW4gY2VsbHVsYXIgdm9sdW1lIDI2LjYgZkwsIG1lYW4gY2VsbHVsYXIgaGVtb2dsb2JpbiBjb250ZW50IDI3LjQgZy9kTCwgcmVkIGNlbGwgZGlzdHJpYnV0aW9uIHdpZHRoIDM3LjclLCByZXRpY3Vsb2N5dGVzIDE5JSkgYW5kIG1hc3NpdmVseSBhY2N1bXVsYXRlZCBpc29tZXIgSSBwb3JwaHlyaW5zICg5NSwgMTgzIGFuZCA0NFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMTE1OTgwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTIwMDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaWRlbnRpZmllZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQWxsIGZpdmUgbXV0YXRpb25zIGFyZSBhc3NvY2lhdGVkIHdpdGggTlMsIHdoZXJlYXMgdHdvIChBNTdHIGFuZCBGODJWKSBoYXZlIGFsc28gYmVlbiBpZGVudGlmaWVkIGluIHVyaW5hcnkgdHJhY3QgY2FuY2VycyBhbmQgbXllbG9pZCBtYWxpZ25hbmNpZXMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjI4NDAwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU0NDcyNzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJSMjIyUSBTQ041QSBtdXRhdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGggcmV2ZXJzaWJsZSB2ZW50cmljdWxhciBlY3RvcHkgYW5kIGRpbGF0ZWQgY2FyZGlvbXlvcGF0aHkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEyOTgzMjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0ODE1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkFub3RoZXIgQUlGTTEgbXV0YXRpb24gdGhhdCBwcmVkaWN0cyBwLkFyZzIwMWRlbCBoYXMgcmVjZW50bHkgYmVlbiBhc3NvY2lhdGVkIHdpdGggc2V2ZXJlIG1pdG9jaG9uZHJpYWwgZW5jZXBoYWxvbXlvcGF0aHkgaW4gdHdvIGluZmFudHMgYnkgaW1wYWlyaW5nIG94aWRhdGl2ZSBwaG9zcGhvcnlsYXRpb24uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjU2MTYwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NTAwNzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgRTEwMUsgbXV0YXRpb24gaW4gdGhlIGFscGhhLWNhcmRpYWMgYWN0aW4gZ2VuZSAoQUNUQykgaGFzIGJlZW4gYXNzb2NpYXRlZCB3aXRoIGFwaWNhbCBoeXBlcnRyb3BoaWMgY2FyZGlvbXlvcGF0aHkgKEhDTSkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEwNjk2NjYwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTY2NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgMTVxMjEuMyBsb2N1cyBsaW5rZWQgd2l0aCBsaXBpZCBsZXZlbHMgYW5kIGh5cGVydGVuc2lvbiB3YXMgYXNzb2NpYXRlZCB3aXRoIHRvdGFsIHN0cm9rZSAocnM0NDcxNjEzOyBQPTMuOXgxMCAoLTgpKSBpbiBBZnJpY2FuIEFtZXJpY2Fucy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNDc1MjkwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTEzNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUYXUgZ2VuZSBtdXRhdGlvbiBLMjU3VCBjYXVzZXMgYSB0YXVvcGF0aHkgc2ltaWxhciB0byBQaWNrJ3MgZGlzZWFzZS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMzI4NDcwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjYzOTM4NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwieWllbGRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBvYnNlcnZlZCBob21venlnb3VzIHAuUDg2TCBtdXRhdGlvbiBpbiB0aGUgTi10ZXJtaW5hbCBleHRlbmRlZCBzZWdtZW50IG1heSB5aWVsZCByZWR1Y2VkIE1DTSBhY3Rpdml0eSBhbmQgaXMgcmVmcmFjdG9yeSB0byBoeWRyb3hvY29iYWxhbWluIHN1cHBsZW1lbnRhdGlvbiwgd2hpbGUgbm90IGluZHVjaW5nIGEgbWV0YWJvbGljYWxseSB1bnN0YWJsZSBwaGVub3R5cGUuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjI0ODgwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NTE5NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwieWllbGRlZFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSW4gcGFydGljdWxhciwgY29udHJhcnkgdG8gd2hhdCBpcyBnZW5lcmFsbHkgcmVwb3J0ZWQgaW4gdGhlIGxpdGVyYXR1cmUsIHdlIGZvdW5kIHRoYXQgY2VydGFpbiBtdXRhdGlvbnMsIGZvciBleGFtcGxlLCB0aGUgUDMwTCwgSTJHLCBhbmQgSTE3Mk4gbXV0YXRpb25zLCB5aWVsZGVkIGRpZmZlcmVudCBDQUggcGhlbm90eXBlcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNDk0NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5MTgyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJleGhpYml0ZWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBwYXRpZW50IGhvbW96eWdvdXMgZm9yIEYyOTlDIG1hbmlmZXN0ZWQgc2V2ZXJlIFBLVSwgd2hlcmVhcyB0aGUgUjQwOFEgaG9tb3p5Z290ZSBleGhpYml0ZWQgYSBtaWxkIFBLVSB2YXJpYW50LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMjA2MzcyMDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1OTc2NjAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbWJpbmVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIldlIHNjcmVlbmVkIDQgYWRkaXRpb25hbCBmYW1pbGllcywgaW4gd2hpY2ggUEVEIGlzIGNvbWJpbmVkIHdpdGggZXBpbGVwc3ksIGRldmVsb3BtZW50YWwgZGVsYXksIG9yIG1pZ3JhaW5lLCBidXQgbm90IHdpdGggaGVtb2x5c2lzIG9yIGVjaGlub2N5dG9zaXMsIGFuZCBpZGVudGlmaWVkIDIgYWRkaXRpb25hbCBHTFVUMSBtdXRhdGlvbnMgKEEyNzVULCBHMzE0UykgdGhhdCBkZWNyZWFzZWQgZ2x1Y29zZSB0cmFuc3BvcnQgYnV0IGRpZCBub3QgYWZmZWN0IGNhdGlvbiBwZXJtZWFiaWxpdHkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjIxMTMzMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2MDU2NjQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJJbiB0aGlzIHdheSB0aGUgR2x5MzY0IHRvIEFzcCBhbmQgQXJnNTEwIHRvIEdsbiBzdWJzdGl0dXRpb25zIG1heSBjYXVzZSBQSyBkZWZpY2llbmN5IGJ5IGluZmx1ZW5jaW5nIHRoZSBhbGxvc3RlcmljIHByb3BlcnRpZXMgb2YgdGhlIGVuenltZS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjYyNTU4NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMzY2ODYwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlZCBieVwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiT3VyIHJlc3VsdHMgc3Ryb25nbHkgc3VnZ2VzdCB0aGF0IGF1dG9zb21hbCByZWNlc3NpdmUgcGVyc2lzdGVudCBoeXBlcnBsYXN0aWMgcHJpbWFyeSB2aXRyZW91cyBpcyBjYXVzZWQgYnkgTjQ2SCBhbmQgaXMgZXRpb2xvZ2ljYWxseSByZWxhdGVkIHRvIG5vbnN5bmRyb21pYyBjb25nZW5pdGFsIHJldGluYWwgbm9uYXR0YWNobWVudC5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTkyMzk3MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjk4NzIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwicnMzODQ5OTQyIGFuZCByczkwMzYwMyB3ZXJlIHN0cm9uZ2x5IGFzc29jaWF0ZWQgd2l0aCBBTFMgd2hlbiBhbGwgc2FtcGxlcyB3ZXJlIGluY2x1ZGVkIChyczM4NDk5NDIsIHAgPVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNjI0MjY4MDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI5NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29tcG91bmQgZm9yXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUd2VudHktb25lIEdlcm1hbiBDQVZEIHBhdGllbnRzIHdlcmUgY29tcG91bmQgaGV0ZXJvenlnb3VzIGZvciBkZWx0YSBGNTA4IGFuZCBSMTE3SCwgd2hpY2ggd2FzIHRoZSBtb3N0IGZyZXF1ZW50IENBVkQgZ2Vub3R5cGUgaW4gb3VyIHN0dWR5IGdyb3VwLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMjA5NDIwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3Mzc2ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGlzIHN0dWR5IHNvdWdodCB0byBpZGVudGlmeSB3aGV0aGVyIGdlbmV0aWMgcG9seW1vcnBoaXNtcyByczI4OTI5NDc0IGFuZCByczE3NTgwIGFyZSBhc3NvY2lhdGVkIHdpdGggQ09QRCBzdXNjZXB0aWJpbGl0eSBhbmQgbHVuZyBmdW5jdGlvbiB2YWx1ZXMgaW4gYSBNZXhpY2FuIG1lc3Rpem8gcG9wdWxhdGlvbi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNDgxNDMwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU3MTA4MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVwb3J0ZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlA4MUwgYW5kIFIzOFggbXV0YXRpb25zIGhhdmUgcHJldmlvdXNseSBiZWVuIHJlcG9ydGVkIGluIG90aGVyIFBHTCBmYW1pbGllcyBhbmQgUDgxTCB3YXMgc3VnZ2VzdGVkIGFzIGEgZm91bmRlciBtdXRhdGlvbi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNTg3NzQwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTg2MDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaWRlbnRpZmllZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIHAuQXJnMTIxMEN5cyB2YXJpYW50IHdhcyBpZGVudGlmaWVkIGluIHR3byBDRCBjYXNlcyBidXQgd2FzIG5vdCBpZGVudGlmaWVkIGluIG91ciBEdXRjaC1HZXJtYW4gbm9uLUNELXR5cGUgQU1EIGNhc2UtY29udHJvbCBjb2hvcnQuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjc4NjE2MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2Mjc1ODcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQSBub3ZlbCBONDQwSyBzb2RpdW0gY2hhbm5lbCBtdXRhdGlvbiBjYXVzZXMgbXlvdG9uaWEgd2l0aCBleGVyY2lzZS1pbmR1Y2VkIHdlYWtuZXNzLS1leGNsdXNpb24gb2YgQ0xDTjEgZXhvbiBkZWxldGlvbi9kdXBsaWNhdGlvbiBieSBNTFBBLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMTUzMzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0MjgwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmb3VuZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgc2FtZSBSMzlDIG11dGF0aW9uIHdhcyBhbHNvIGZvdW5kIGJvdGggaW4gbW9zdCBvZiB0aGUgU3dlZGlzaCBwYXRpZW50cyB3aXRoIFNEIGFuZCBpbiBhIGhldGVyb3p5Z291cyBmb3JtIGluIGZpdmUgcGF0aWVudHMgZnJvbSBjZW50cmFsIEV1cm9wZSB3aG8gcHJlc2VudGVkIHdpdGggYW4gdW51c3VhbGx5IHNldmVyZSAoaW50ZXJtZWRpYXRlKSBTRCBwaGVub3R5cGUuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjk2MDMyMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzQ4MzgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImltcGxpY2F0ZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBTZXIzNThMZXUgbXV0YXRpb24gaW4gVE1FTTQzLCBlbmNvZGluZyBhbiBpbm5lciBudWNsZWFyIG1lbWJyYW5lIHByb3RlaW4sIGhhcyBiZWVuIGltcGxpY2F0ZWQgaW4gYXJyaHl0aG1vZ2VuaWMgcmlnaHQgdmVudHJpY3VsYXIgY2FyZGlvbXlvcGF0aHkgKEFSVkMpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIzODExNzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjI3NzgwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIGNvbnRyYXN0LCBtaXNzZW5zZSBtdXRhdGlvbnMgcHJvZHVjZWQgZGlzdGluY3QgcGhlbm90eXBlczogR2x5ODBBcmcgY2F1c2VkIHNpZ25pZmljYW50IGNhcmRpYWMgbWFsZm9ybWF0aW9ucyBidXQgb25seSBtaW5vciBza2VsZXRhbCBhYm5vcm1hbGl0aWVzOyBhbmQgQXJnMjM3R2xuIGFuZCBBcmcyMzdUcnAgY2F1c2VkIGV4dGVuc2l2ZSB1cHBlciBsaW1iIG1hbGZvcm1hdGlvbnMgYnV0IGxlc3Mgc2lnbmlmaWNhbnQgY2FyZGlhYyBhYm5vcm1hbGl0aWVzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI0MDQ4OTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjA3Mzc3MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkhldGVyb3p5Z291cyBtdXRhdGlvbnMgaW4gTXlvY2xvbmluMS9FRkhDMSBjYXVzZSBqdXZlbmlsZSBteW9jbG9uaWMgZXBpbGVwc3kgKEpNRSksIHRoZSBtb3N0IGNvbW1vbiBmb3JtIG9mIGdlbmV0aWMgZ2VuZXJhbGl6ZWQgZXBpbGVwc2llcywgd2hpbGUgaG9tb3p5Z291cyBGMjI5TCBtdXRhdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGggcHJpbWFyeSBpbnRyYWN0YWJsZSBlcGlsZXBzeSBpbiBpbmZhbmN5LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMDI0MTAwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTAyNDExMDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjb21wYXJlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJXZSBzaG93IHRoYXQgYSBncmFkaWVudCBvZiBpbXBhaXJtZW50IGlzIHByZXNlbnQgd2hlbiB0aGUgcC5QMTUyQSBtdXRhdGlvbiBpcyBjb21wYXJlZCB3aXRoIGFuIGFsbGVsaWMgcC5QMTUyUiBtdXRhdGlvbiwgd2hpY2ggY2F1c2VzIGNsYXNzaWMgUmV0dCBzeW5kcm9tZSBhbmQgYW5vdGhlciBSZXR0IHN5bmRyb21lLWNhdXNpbmcgbXV0YXRpb24sIHN1Y2ggdGhhdCBwcm90ZWluLWhldGVyb2Nocm9tYXRpbiBiaW5kaW5nIG9ic2VydmVkIGJ5IGltbXVub2ZsdW9yZXNjZW5jZSBhbmQgaW1tdW5vYmxvdHRpbmcgaXMgd2lsZC10eXBlPiBQMTUyQT4gUDE1MlI+IFQxNTggTSwgY29uc2lzdGVudCB3aXRoIHRoZSBzZXZlcml0eSBvZiB0aGUgb2JzZXJ2ZWQgcGhlbm90eXBlLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI4NDc2NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTQyMDAwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhZGRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaHJlZSBtdXRhdGlvbmFsIGFsbGVsZXMsIFIyNzhYIGFuZCBSNTJJIG9mIHRoZSBUWVIgZ2VuZSBhbmQgQzIyOVkgb2YgdGhlIFNMQzQ1QTIgZ2VuZSwgYXJlIGFkZGVkIHRvIHRoZSBtdXRhdGlvbmFsIHNwZWN0cmEgb2YgS29yZWFuIHBhdGllbnRzIHdpdGggT0NBLCBhbmQgd2UgcmVwb3J0IHRoZSBmaXJzdCBLb3JlYW4gY2FzZSBvZiBPQ0EyIHdpdGggdGhlIE9DQTIgZ2VuZSBtdXRhdGlvbnMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjMxMTEwMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NjkxNTMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZvdW5kIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlNpbmNlIHRoZSBHMTM1MTNBIG11dGF0aW9uIHdhcyBmb3VuZCBpbiAyMSUgb2Ygb3VyIHBhdGllbnRzIHdpdGggTGVpZ2ggc3luZHJvbWUgYW5kIGNvbXBsZXggSSBkZWZpY2llbmN5ICgzLzE0KSwgaXQgYXBwZWFycyB0aGF0IHRoaXMgbXV0YXRpb24gcmVwcmVzZW50cyBhIGZyZXF1ZW50IGNhdXNlIG9mIExlaWdoLWxpa2Ugc3luZHJvbWUsIHdoaWNoIHNob3VsZCBiZSBzeXN0ZW1hdGljYWxseSB0ZXN0ZWQgZm9yIG1vbGVjdWxhciBkaWFnbm9zaXMgaW4gYWZmZWN0ZWQgY2hpbGRyZW4gYW5kIGZvciBnZW5ldGljIGNvdW5zZWxsaW5nIGluIHRoZWlyIG1hdGVybmFsIHJlbGF0aXZlcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTYzMDkyMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzQ2NTIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQW4gYXNzb2NpYXRpb24gYW5hbHlzaXMgdXNpbmcgaGVhbHRoeSBjb250cm9scyBzaG93ZWQgdGhhdCByczc1Mzc2MDUgaXMgc2lnbmlmaWNhbnRseSBhc3NvY2lhdGVkIHdpdGggSFQgKFAgPSAxLjI0IHggMTAgKC01KTsgb2RkcyByYXRpbyA9IDEuNjA7IDk1JSBjb25maWRlbmNlIGludGVydmFsID0gMS4zMC0xLjk3KSBidXQgbm90IHdpdGggR0QgKFAgPSAuNTApLCBzdWdnZXN0aW5nIHRoYXQgdGhlIHZhcmlhbnQgc3BlY2lmaWNhbGx5IGFmZmVjdHMgc3VzY2VwdGliaWxpdHkgdG8gSFQuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjUzMjQxMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1OTI2ODkwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJlcHJlc2VudHNcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIGFkZGl0aW9uLCB0aGUgbmV3bHkgZm91bmQgUjEyMkMgdmFyaWFudCByZXByZXNlbnRzIGEgbGlrZWx5IHBhbmNyZWF0aXRpcy1wcmVkaXNwb3NpbmcgbXV0YXRpb24uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEzNzcyNzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5MzY2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJNb3Jlb3ZlciwgaW4gc3BvcmFkaWMgY29sb3JlY3RhbCBjYW5jZXIsIHRoZSBjLjEyMjdfMTIyOGR1cCAocC5HbHU0MTBHbHlmc1g0MykgbXV0YXRpb24gd2FzIGlkZW50aWZpZWQgaW4gMTMlIG9mIHBhdGllbnRzIGNvbXBhcmVkIHRvIHRoZSBwLkczOTZEIGFuZCBwLlkxNzlDIGZvdW5kIGluIDEuMiBhbmQgMi4xMiUgcmVzcGVjdGl2ZWx5LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI2NjExMDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTk3NjYwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpbnZvbHZlZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiUjg2M1ggYWx0ZXJhdGlvbiBpbiBIRVJHIGNoYW5uZWwgbWF5IGJlIGludm9sdmVkIGluIGJvdGggcHJvbG9uZ2VkIFFUYyBpbnRlcnZhbCBhbmQgZXBpbGVwc3kuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjY3MTQwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU0NDQzMTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGV0ZWN0ZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBwcm9saW5lNjY0LWxldWNpbmUgbG93IGRlbnNpdHkgbGlwb3Byb3RlaW4gKExETCkgLXJlY2VwdG9yIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBpbiBmb3VyIGFwcGFyZW50bHkgdW5yZWxhdGVkIEluZGlhbiBGSCBmYW1pbGllcyBpbiBTb3V0aCBBZnJpY2EuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjUyODcwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjI3MzkwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiUjIzMUMgbXV0YXRpb24gaW4gS0NOUTEgY2F1c2VzIGxvbmcgUVQgc3luZHJvbWUgdHlwZSAxIGFuZCBmYW1pbGlhbCBhdHJpYWwgZmlicmlsbGF0aW9uLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMzM4MjEwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTA2MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJTZXZlcmFsIFNOUHMgaW4gbGlua2FnZSBkaXNlcXVpbGlicml1bSB3aXRoaW4gdGhlIENMTjggZ2VuZSBsb2N1cyB3ZXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgR0QxIHNldmVyaXR5OiBTTlAgcnMxMTk4NjQxNCB3YXMgYXNzb2NpYXRlZCB3aXRoIEdEMSBzZXZlcml0eSBhdCBQIHZhbHVlIDEuMjYgeCAxMCAoLTYpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI0NzIzMjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTYyMjUxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJCb3RoIDExMDBkZWxDIGFuZCBSMTQ1VyBnZXJtLWxpbmUgbXV0YXRpb25zIGluIENISzIgYXJlIGFzc29jaWF0ZWQgd2l0aCBsb3NzIG9mIHRoZSB3aWxkLXR5cGUgYWxsZWxlIGluIHRoZSBjb3JyZXNwb25kaW5nIHR1bW9yIHNwZWNpbWVucywgYW5kIG5laXRoZXIgdHVtb3IgaGFyYm9ycyBhIHNvbWF0aWMgVFA1MyBtdXRhdGlvbi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTA2OTA0MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5Nzg2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkZXZlbG9waW5nXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJGb3VyLWh1bmRyZWQgcGF0aWVudHMgaGFkIGFteWxvaWRvc2lzIGFuZCBob21venlnb3VzIE02OTRWIHdhcyBkZXRlY3RlZCBpbiAxODkgKDQ3JSkgb2YgdGhlIDQwMCBhbXlsb2lkb3RpYyBwYXRpZW50cyB3aGljaCB3YXMgc2lnbmlmaWNhbnRseSBoaWdoZXIgdGhhbiB0aGF0IGluIHRoZSBGTUYgcGF0aWVudHMgbm90IGRldmVsb3BpbmcgYW15bG9pZG9zaXMgKHAgPDAuMDAwMSkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEyMDU5NzUwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NTQ5OTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwib2JzZXJ2ZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIGFkZGl0aW9uLCB0aGUgSmFja3Nvbi1XZWlzcyBzeW5kcm9tZSBtdXRhdGlvbiwgQzM0MlIsIGluIGV4b24gSUlJYyB3YXMgb2JzZXJ2ZWQgcHJldmlvdXNseSBpbiBvdGhlciBjcmFuaW9zeW5vc3RvdGljIHN5bmRyb21lcywgQ3JvdXpvbiBhbmQgUGZlaWZmZXIuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjI1Nzk2NzAwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU4ODg2NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaW5jbHVkZVwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQWx0aG91Z2ggdGhlIGNhcmRpYWMgcGF0aG9sb2d5IGNhdXNlZCBieSBQUktBRzIgbXV0YXRpb25zIEFyZzMwMkdsbiwgVGhyNDAwQXNuLCBhbmQgQXNuNDg4SWxlIGluY2x1ZGUgbXlvY3l0ZSBlbmxhcmdlbWVudCBhbmQgbWluaW1hbCBpbnRlcnN0aXRpYWwgZmlicm9zaXMsIHRoZXNlIG11dGF0aW9ucyB3ZXJlIG5vdCBhc3NvY2lhdGVkIHdpdGggbXlvY3l0ZSBhbmQgbXlvZmlicmlsbGFyIGRpc2FycmF5LCB0aGUgcGF0aG9nbm9tb25pYyBmZWF0dXJlcyBvZiBoeXBlcnRyb3BoaWMgY2FyZGlvbXlvcGF0aHkgY2F1c2VkIGJ5IHNhcmNvbWVyZSBwcm90ZWluIG11dGF0aW9ucy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNTEwODA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjczNzA0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjb25zdGl0dXRlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlc2UgcmVzdWx0cyBzdWdnZXN0IHRoYXQgdGhlIFA1MzNSIG11dGF0aW9uIGNvbnN0aXR1dGVzIHRoZSBnZW5ldGljIGxlc2lvbiB3aGljaCByZXN1bHRzIGluIE1QUyBJIGluIHBlb3BsZSBvZiBNb3JvY2NhbiBkZXNjZW50IGFuZCBwcm92aWRlcyB5ZXQgbW9yZSBldmlkZW5jZSBmb3IgdGhlIHVuZXZlbiBnZW9ncmFwaGljYWwgZGlzdHJpYnV0aW9uIG9mIG11dGF0aW9ucyBpbiBNUFMgSS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjYzODcyNDAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc1NDk5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjb25zdGl0dXRlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiTXVlbmtlIHN5bmRyb21lIGNvbnN0aXR1dGVzIHRoZSBtb3N0IGNvbW1vbiBzeW5kcm9taWMgZm9ybSBvZiBjcmFuaW9zeW5vc3Rvc2lzLCB3aXRoIGFuIGluY2lkZW5jZSBvZiAxIGluIDMwLDAwMCBiaXJ0aHMgYW5kIGlzIGRlZmluZWQgYnkgdGhlIHByZXNlbmNlIG9mIHRoZSBwLlBybzI1MEFyZyBtdXRhdGlvbiBpbiBGR0ZSMy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTA2OTI2MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5MzY2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBBUEMgdmFyaWFudHMgSTEzMDdLIGFuZCBFMTMxN1EgYXJlIGFzc29jaWF0ZWQgd2l0aCBjb2xvcmVjdGFsIHR1bW9ycywgYnV0IG5vdCBhbHdheXMgd2l0aCBhIGZhbWlseSBoaXN0b3J5LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyMDI1NTcwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NDk1NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJyczkyNjAxNTEgYW5kIHJzMzEzNTAwMiBoYXZlIGJlZW4gYXNzb2NpYXRlZCB3aXRoIHR5cGUgMSBkaWFiZXRlcywgd2hlcmVhcyByczU1OTA0NyBhbmQgcnM2MTIxMTUxNSBoYXZlIG5vdCBiZWVuIGFzc29jaWF0ZWQgd2l0aCBhIHJpc2sgb2YgZGV2ZWxvcGluZyB0eXBlIDEgZGlhYmV0ZXMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE5MzE5ODA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjExNDYyMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkFub3RoZXIgcG9seW1vcnBoaXNtLCByczEyOTcwMjkxIG5lYXIgZ2VuZSBUU0haMSwgd2FzIGFzc29jaWF0ZWQgd2l0aCBib3RoIENSQyBhbmQgRUMgKE9SID0gMS4yNiwgUCA9IDQuODIgeCAxMCAoLTgpKSwgd2l0aCB0aGUgYWxsZWxlcyBzaG93aW5nIG9wcG9zaXRlIGVmZmVjdHMgb24gdGhlIHJpc2tzIG9mIHRoZSB0d28gY2FuY2Vycy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiOTg5MjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc1MTk2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ5aWVsZGVkXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJJbiBwYXJ0aWN1bGFyLCBjb250cmFyeSB0byB3aGF0IGlzIGdlbmVyYWxseSByZXBvcnRlZCBpbiB0aGUgbGl0ZXJhdHVyZSwgd2UgZm91bmQgdGhhdCBjZXJ0YWluIG11dGF0aW9ucywgZm9yIGV4YW1wbGUsIHRoZSBQMzBMLCBJMkcsIGFuZCBJMTcyTiBtdXRhdGlvbnMsIHlpZWxkZWQgZGlmZmVyZW50IENBSCBwaGVub3R5cGVzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI1ODExMTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDcyNTQ1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJzaG93ZWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlE3OVIgU0hQMiBlbWJyeW9uaWMgaGVhcnRzIHNob3dlZCBhbHRlcmVkIGNhcmRpb215b2N5dGUgY2VsbCBjeWNsaW5nLCB2ZW50cmljdWxhciBub25jb21wYWN0aW9uLCBhbmQgdmVudHJpY3VsYXIgc2VwdGFsIGRlZmVjdHMsIHdoaWxlLCBpbiB0aGUgcG9zdG5hdGFsIGNhcmRpb215b2N5dGUsIFE3OVIgU0hQMiBleHByZXNzaW9uIHdhcyBjb21wbGV0ZWx5IGJlbmlnbi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTI2OTc0MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NTQ0NTkwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImhhZFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiSW4gcHJlZ25hbmN5LWFzc29jaWF0ZWQgY2FyZGlvbXlvcGF0aHkgY2FzZXMsIHJzMjU4NDE1IGhhZCBhIHNpbWlsYXIgZWZmZWN0IHZlcnN1cyBsb2NhbDIgY29udHJvbCBzdWJqZWN0cyAoUD0wLjA2OyBPUiwgMS43OSksIHlvdW5nZXIgY29udHJvbCBzdWJqZWN0cyAoUD0wLjE0OyBPUiwgMS42NSksIGFuZCBvYnN0ZXRyaWMgY29udHJvbCBzdWJqZWN0cyAoUD0wLjAzODsgT1IsIDEuOTkpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMjY3OTUwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjYxMDc5NDAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBIG5vdmVsIHAuR2x5NjAzQXJnIG11dGF0aW9uIGluIENBQ05BMUYgY2F1c2VzIEFsYW5kIGlzbGFuZCBleWUgZGlzZWFzZSBhbmQgaW5jb21wbGV0ZSBjb25nZW5pdGFsIHN0YXRpb25hcnkgbmlnaHQgYmxpbmRuZXNzIHBoZW5vdHlwZXMgaW4gYSBmYW1pbHkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE0OTQ5MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1OTQ5OTAwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiT24gdGhlIGJhc2lzIG9mIHRoZSBjbGluaWNhbCBmZWF0dXJlcyBwcmVzZW50ZWQgYnkgdGhlIGZvdXIgcGF0aWVudHMsIHdlIHBvc3R1bGF0ZSB0aGF0IHRoZSBMMjA2VyBtaWdodCBiZSBhc3NvY2lhdGVkIHdpdGggcGFuY3JlYXRpYyBzdWZmaWNpZW5jeSBhbmQgcmVzaWR1YWwgdHJhbnNtZW1icmFuZSB0cmFuc3BvcnQgb2YgY2hsb3JpZGUgaW4gbHVuZy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNjE2MDMwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjYzNDAxOTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJJbiBjb25jbHVzaW9uLCB0aGUgaG9tb3p5Z291cyBESEZSIG11dGF0aW9uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE3NzQwODA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc1MDM4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJyZWxhdGVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgcnMyMDQyMzI5IHJpc2sgYWxsZWxlIHdhcyBhbHNvIHJlbGF0ZWQgdG8gc2lnbmlmaWNhbnRseSBpbmNyZWFzZWQgZXhwcmVzc2lvbiBsZXZlbHMgb2YgQ1dDMjcgbVJOQSBhbmQgcHJvdGVpbiBpbiBibGFkZGVyIGNhbmNlciB0aXNzdWVzIGZyb20gQ2hpbmVzZSBwYXRpZW50cy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTA3NTMyNzAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxNzg4NDA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGVzZSBvYnNlcnZhdGlvbnMgY29uZmlybWVkIHRoYXQgVEFzIHdlcmUgYXNzb2NpYXRlZCB3aXRoIFQ3MDRNIG11dGF0aW9ucyBvZiBTQ040QSBpbiBwYXJhbHlzaXMgcGVyaW9kaWNhIHBhcmFteW90b25pY2EuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjIwMjk5MDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDcyNTY5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlNOUCByczIyODQzNzggYXQgMjBxMTEgd2FzIGFzc29jaWF0ZWQgd2l0aCBFUi1uZWdhdGl2ZSBicmVhc3QgY2FuY2VyIChjb21iaW5lZCB0d28tc3RhZ2UgT1IgPSAxLjE2OyBQID0gMS4xIHggMTAgKC04KSkgYnV0IHNob3dlZCBhIHdlYWtlciBhc3NvY2lhdGlvbiB3aXRoIG92ZXJhbGwgYnJlYXN0IGNhbmNlciAoT1IgPSAxLjA4LCBQID0gMS4zIHggMTAgKC02KSkgYmFzZWQgb24gMTcgODY5IGNhc2VzIGFuZCA0MyA3NDUgY29udHJvbHMgYW5kIG5vIGFzc29jaWF0aW9uIHdpdGggRVItcG9zaXRpdmUgZGlzZWFzZSAoT1IgPSAxLjAxLCBQID0gMC42NykgYmFzZWQgb24gOTk2NSBjYXNlcyBhbmQgMjIgOTAyIGNvbnRyb2xzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxODgzNDAwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTcxNzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJPZiB0aGVzZSAyIFNOUHMsIHJzOTgxNTY2MyB3YXMgYWxzbyBzaWduaWZpY2FudGx5IGFzc29jaWF0ZWQgd2l0aCBlYXJsaWVyIGFzdGhtYSBvbnNldCBpbiBhbiBhbmFseXNpcyBpbmNsdWRpbmcgb25seSB0aGUgcmVwbGljYXRpb24gY29ob3J0cy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTM1NzcxMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzUwMDcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFI4MjBXIG11dGF0aW9uIGluIHRoZSBNWUJQQzMgZ2VuZSwgcHJldmlvdXNseSBhc3NvY2lhdGVkIHdpdGggSENNIGluIHJhZy1kb2xsIGNhdHMsIGNhdXNlcyBib3RoIEhDTSBhbmQgTFZOQyBpbiBob21venlnb3VzIGh1bWFuIGNhcnJpZXJzLCB3aXRoIG1pbGQgb3IgbnVsbCBjbGluaWNhbCBleHByZXNzaW9uIGluIGhldGVyb3p5Z291cyBjYXJyaWVycy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTM3MzcwMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NjM2NjYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiUnM3Mzg0MDksIHJzMjg5NjAxOSwgcnM3Mzg0OTEsIHJzNjAwNjQ3MywgcnM1NzY0NDU1LCBhbmQgcnM2MDA2NjExIHdlcmUgYXNzb2NpYXRlZCB3aXRoIGZpYnJvc2lzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNzkzMzA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0MzA2MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJvYnNlcnZlZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIHR3byBjb21tb24gYWxsZWxlcywgNDU5KzFHPiBBIGFuZCBQNDI2TCwgdG9nZXRoZXIgYWNjb3VudGVkIGZvciA0MiUgb2YgYWxsIDUwIHVucmVsYXRlZCBNTEQgYWxsZWxlcyBpbnZlc3RpZ2F0ZWQ7IEkxNzlTIHdhcyBvYnNlcnZlZCBpbiA2IG9mIDUwIE1MRCBhbGxlbGVzICgxMiUpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxOTMxOTgwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTM2NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBbm90aGVyIHBvbHltb3JwaGlzbSwgcnMxMjk3MDI5MSBuZWFyIGdlbmUgVFNIWjEsIHdhcyBhc3NvY2lhdGVkIHdpdGggYm90aCBDUkMgYW5kIEVDIChPUiA9IDEuMjYsIFAgPSA0LjgyIHggMTAgKC04KSksIHdpdGggdGhlIGFsbGVsZXMgc2hvd2luZyBvcHBvc2l0ZSBlZmZlY3RzIG9uIHRoZSByaXNrcyBvZiB0aGUgdHdvIGNhbmNlcnMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjYwNTk0MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjYzNjQ0MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmb3VuZCB3aGVyZWFzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBbW9uZyB0aGVtLCBvbmx5IEUxMDNELCBINDg2UiwgVjE0OFYsIGFuZCBJVlMxMysyMUMtLT4gRyB3ZXJlIGZvdW5kIGV4Y2x1c2l2ZWx5IGluIHBhdGllbnRzIHdpdGggUE9BRywgd2hlcmVhcyBQMTk5UCwgVDIwMlQsIGFuZCBJVlM4KzIwRy0tPlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI2MDc3MDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTcwNDU1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZVwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQm90aCB0aGUgUTE2M1ggYW5kIHRoZSBSMTIwUSBtdXRhdGlvbiBjYXVzZSBkZW15ZWxpbmF0aW9uIGFuZCBheG9uYWwgbG9zcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTkxOTAyMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzM4NzcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQXQgNnAyMS4xLCByczIyOTQ2OTMgbmVhciBVTkM1Q0wgd2FzIHNpZ25pZmljYW50bHkgYXNzb2NpYXRlZCB3aXRoIGdhc3RyaWMgbm9uLWNhcmRpYSBjYW5jZXIgcmlzayAocD0yLjUweDEwICgtOCkpLCB3aXRoIE9SICg5NSUgQ0kpIG9mIDEuMTggKDEuMTIgdG8gMS4yNiksIGJ1dCB0aGVyZSB3YXMgb25seSBhIG5vbWluYWwgYXNzb2NpYXRpb24gZm9yIGNhcmRpYSBjYW5jZXIgKHA9MS40N3gxMCAoLTIpKS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjU2MjI1MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxOTgwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbnRhaW5lZFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVHVtb3IgY2VsbHMgZnJvbSBhIHNpeHRoIHBhdGllbnQgd2l0aCBhIGRydWctc2Vuc2l0aXZlIEVHRlIgbXV0YXRpb24gd2hvc2UgdHVtb3IgcHJvZ3Jlc3NlZCBvbiBhZGp1dmFudCBnZWZpdGluaWIgYWZ0ZXIgY29tcGxldGUgcmVzZWN0aW9uIGFsc28gY29udGFpbmVkIHRoZSBUNzkwTSBtdXRhdGlvbi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTMwNzM1MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjkzMjcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImxpbmtlZCB0b1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiUGF0aWVudC1vbmx5IGFuYWx5c2lzIHN1Z2dlc3RlZCB0aGF0IHJzNzA0ODUzIGlzIGFsc28gbGlua2VkIHRvIG9yYWwgdWxjZXJzLCBoZW1hdG9sb2dpYyBkaXNvcmRlcnMgYW5kIGFudGktZG91YmxlLXN0cmFuZGVkIEROQSAoZHNETkEpIGFudGlib2R5IHByb2R1Y3Rpb24uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE2MTIwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTI1MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVjb2duaXNlZCBhc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiRmlyc3QgY29uc2lkZXJlZCBhcyBhIHBvbHltb3JwaGlzbSBvZiB0aGUgSEZFIGdlbmUsIHRoZSBINjNEIG11dGF0aW9uIGlzIG5vdyB3aWRlbHkgcmVjb2duaXNlZCBhcyBhIGhhZW1vY2hyb21hdG9zaXMgYXNzb2NpYXRlZCBhbGxlbGUuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE5MTg5OTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTUyMTA4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlJzOTgyOTg5Ni1DIHdhcyBub3QgYXNzb2NpYXRlZCB3aXRoIGRydWcgYWJ1c2UgYWNyb3NzIHRoZSBFQSBjb2hvcnRzOiBmcmVxdWVuY3kgPSAzNiUgYW5kIG1ldGEtYW5hbHlzaXMgUCA9IDAuMTIuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjYyMDg4MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1OTk2NDEwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIEFUVFIgVHlyNjlIaXMgbXV0YXRpb24gaXMgYXNzb2NpYXRlZCB3aXRoIG9jdWxvbGVwdG9tZW5pbmdlYWwgYW15bG9pZG9zaXMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjc2ODYwMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI2Mjk5MzQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInByb2R1Y2VkXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgbmV3IFIxOTA1WCBEWVNGIGZvdW5kZXIgbXV0YXRpb24gcHJvZHVjZWQgdGhlIDMgcG9zc2libGUgZHlzZmVybGlub3BhdGh5IHBoZW5vdHlwZXMgd2l0aG91dCBpbnRyYWZhbWlsaWFsIGhldGVyb2dlbmVpdHkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjQyMzMyMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzQ3NzIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInJlcG9ydGVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBIChMZXU4NDlIaXMpIGFuZCBjLjE5MzJkZWxDXSBoYXZlIGJlZW4gcmVwb3J0ZWQgaW4gSmFwYW5lc2UgcGF0aWVudHMsIGJ1dCBub3QgaW4gR1MgcGF0aWVudHMgZnJvbSBvdGhlciBldGhuaWMgZ3JvdXBzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIyNzg1OTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc0NjU1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJleGhpYml0ZWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkludGVyZXN0aW5nbHksIHRoZSByZWNvbnN0cnVjdGl2ZSBleHBlcmltZW50cyBkZW1vbnN0cmF0ZWQgdGhhdCB0aGUgRjMxMEwgbXV0YW50IGV4aGliaXRlZCBhbiBBTFAgYWN0aXZpdHkgbGV2ZWwgNjUlIG9mIHRoZSBub3JtYWwgbGV2ZWwsIHdoZXJlYXMgdGhlIG11dGFudCBHNDM5UiBoYWQgbm8gYWN0aXZpdHkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjQ3NjIwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NDgzODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgbXV0YXRpb24gR2x1MjJMeXMgd2FzIGFzc29jaWF0ZWQgd2l0aCBtb2RlcmF0ZSBzZXB0YWwgaHlwZXJ0cm9waHksIGEgbGF0ZSBvbnNldCBvZiBjbGluaWNhbCBtYW5pZmVzdGF0aW9uLCBhbmQgYmVuaWduIGRpc2Vhc2UgY291cnNlIGFuZCBwcm9nbm9zaXMuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjcwNjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5NzE4MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIHRlc3RzIGZvciBhc3NvY2lhdGlvbiB3aXRoIG90aGVyIHZhc2N1bGFyIGRpc2Vhc2VzLCB3ZSBmb3VuZCB0aGF0IHJzNzAyNTQ4NlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxOTY2NjEwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU4MjU5NjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJJbiBvbmUgZmFtaWx5LCBhIHAuTTEwMjlLIG11dGF0aW9uIGluIHRoZSBDMiBkb21haW4gY2F1c2VzIHNldmVyZSBkeXN0b25pYSwgaHlwb3RvbmlhLCBhbmQgY2hvcmVhLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNTM0NDkwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3MzkzNzAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJyczExNjU1MDgxIHdhcyBhbHNvIGFzc29jaWF0ZWQgd2l0aCBXRCAoUCA9IDIuNzggeCAxMCAoLTIpKSBidXQgbm90IHdpdGggYW55IG90aGVyIGZvY2FsIG9yIHNlZ21lbnRhbCBkeXN0b25pYS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNjUzNjkwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMzI4MjIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbmZpcm1lZFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQSBob21venlnb3VzIFI3NjlRIG11dGF0aW9uIGluIHRoZSBjYWxwYWluLTMgZ2VuZSBhbmQgYWJzZW5jZSBvZiBtdXNjbGUgY2FscGFpbi0zIHByb3RlaW4gY29uZmlybWVkIGEgY2FscGFpbm9wYXRoeS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNzg1ODMwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjYxMDkzMjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgUkFCMzlCIHAuRzE5MlIgbXV0YXRpb24gY2F1c2VzIFgtbGlua2VkIGRvbWluYW50IFBhcmtpbnNvbidzIGRpc2Vhc2UuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE4MjEzMDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDY5MDYxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhc3NvY2lhdGVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkNvbWJpbmVkIG1ldGEtYW5hbHlzaXMgdXNpbmcgZGlyZWN0bHkgZ2Vub3R5cGVkIGRhdGEgZm9yIHN0YWdlcyAxIGFuZCAyIHJldmVhbGVkIHRoYXQgcnM1MTUwNzEgaW4gQU5LMSBhbmQgcnM3NjU2NDE2IG5lYXIgTUdDMjE2NzUgd2VyZSBhc3NvY2lhdGVkIHdpdGggdHlwZSAyIGRpYWJldGVzIGluIHRoZSBKYXBhbmVzZSBwb3B1bGF0aW9uIGF0IHRoZSBnZW5vbWUtd2lkZSBzaWduaWZpY2FudCBsZXZlbCAoUCA8NSB4IDEwICgtOCkpLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI0NjgzODA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDczNjI1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJleGhpYml0XCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCIoS0NOQTEgRzcyNEMpXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjE0MDU1NjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDczNjgxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkZXZlbG9wZWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIG9uZSBmYW1pbHksIHR3byBzaWJsaW5ncyBob21venlnb3VzIGZvciBSMzI3N0MgZGV2ZWxvcGVkIGVuZCBzdGFnZSByZW5hbCBkaXNlYXNlIGF0IGFnZXMgNzUgYW5kIDYyIHllYXJzLCB3aGlsZSBzaXggaGV0ZXJvenlnb3RlcyBoYWQgZmV3IGN5c3RzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMDY5MjIxMDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjE2ODE5NTA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiaGFyYm91cnNcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIldlIGZpbmQgdGhhdCB0aGUgTU0gcmlzayBhbGxlbGUgaGFyYm91cnMgYSBUaHIyOThBbGEgbWlzc2Vuc2UgdmFyaWFudCBpbiBhbiBFTEwyIGRvbWFpbiByZXF1aXJlZCBmb3IgdHJhbnNjcmlwdGlvbiBlbG9uZ2F0aW9uLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI2MDc3MDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTk4MTQxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZVwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQm90aCB0aGUgUTE2M1ggYW5kIHRoZSBSMTIwUSBtdXRhdGlvbiBjYXVzZSBkZW15ZWxpbmF0aW9uIGFuZCBheG9uYWwgbG9zcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTc2NjI1MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NTA0ODcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIHJzNzU1MjQ5LXRyYWZmaWMgZXhwb3N1cmUgaW50ZXJhY3Rpb24gd2FzIGFzc29jaWF0ZWQgd2l0aCBQQUQgYXQgYSBnZW5vbWUtd2lkZSBzaWduaWZpY2FudCBsZXZlbCAoUCA9IDIuMjl4MTAtOCkgaW4gRXVyb3BlYW4tQW1lcmljYW5zLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNDAzMjcwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3NDUyNTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJyczkyNzU1MTcsIHdoaWNoIGlzIGluIGhpZ2ggbGlua2FnZSBkaXNlcXVpbGlicml1bSB3aXRoIHJzMjY0NzAxMiAocjIgPSAwLjkpLCB3YXMgbm8gbG9uZ2VyIGFzc29jaWF0ZWQgd2l0aCBGTCBhZnRlciBjb25kaXRpb25pbmcgb24gcnMyNjQ3MDEyLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMjY3OTUwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiNDAxOTcwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlc1wiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQSBub3ZlbCBwLkdseTYwM0FyZyBtdXRhdGlvbiBpbiBDQUNOQTFGIGNhdXNlcyBBbGFuZCBpc2xhbmQgZXllIGRpc2Vhc2UgYW5kIGluY29tcGxldGUgY29uZ2VuaXRhbCBzdGF0aW9uYXJ5IG5pZ2h0IGJsaW5kbmVzcyBwaGVub3R5cGVzIGluIGEgZmFtaWx5LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNzk3MDAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMjAwNDAwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImhhcmJvcmVkXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgT1MgYmFieSBoYXJib3JlZCBhIGhvbW96eWdvdXMgcC5DMTE4WSBtdXRhdGlvbiBpbiBJTDdSLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMzUyMjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTg3NjUwMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkEgbmV3IG1pc3NlbnNlIChFMTYxSykgbXV0YXRpb24gd2FzIGlkZW50aWZpZWQgaW4gYSBmYW1pbHkgd2l0aCBlYXJseSBhdHJpYWwgZmlicmlsbGF0aW9uIGFuZCBhIHByZXZpb3VzbHkgZGVzY3JpYmVkIChSMzc3SCkgbXV0YXRpb24gaW4gYW5vdGhlciBmYW1pbHkgd2l0aCBhIHF1YWRyaWNlcHMgbXlvcGF0aHkgYXNzb2NpYXRlZCB3aXRoIERDTS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTA2OTg2MzAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCI2MjA1MDRcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJleHByZXNzZXNcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkFzIGV4cGVjdGVkLCB0aGUgRzQ4MEMgY3lzdGljIGZpYnJvc2lzIG1vdXNlIG1vZGVsIGV4cHJlc3NlcyB0aGUgRzQ4MEMgbXV0YW50IHRyYW5zY3JpcHQgYXQgYSBsZXZlbCBjb21wYXJhYmxlIHRvIHRoYXQgb2Ygd2lsZC10eXBlIENGVFI6XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjQwMzQ1MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NjM3MjQwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZvdW5kIGR1ZVwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiTW9sZWN1bGFyIGdlbmV0aWMgYW5hbHlzaXMgb2YgbHltcGhvYmxhc3RpYyBibGFzdHMgYXQgdGhlIHRpbWUgb2YgdGhlIEFMTCBkaWFnbm9zaXMgcmV2ZWFsZWQgdGhlIGdlcm1saW5lIG11dGF0aW9uIGluIGEgaGV0ZXJvenlnb3VzIHN0YXRlLCB3aGlsZSBpbiB0aGUgbXllbG9tb25vY3l0aWMgYmxhc3RzIG9jY3VycmluZyB3aXRoIEpNTUwgZGlhZ25vc2lzLCB0aGUgbXV0YXRpb24gcC5FMTM5RCB3YXMgZm91bmQgaW4gYSBob21venlnb3VzIHN0YXRlIGR1ZSB0byBhIHVuaXBhcmVudGFsIGRpc29teSAoVVBEKS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNTEwNjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTQzODM5MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpZGVudGlmaWVkIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGUgZmlyc3QgbXV0YXRpb24sIGFuIEUxMzdHLCB3YXMgaWRlbnRpZmllZCBpbiB0aGUgTVJYMTYgZmFtaWx5LCBhbmQgdGhlIHNlY29uZCwgUjE2N1csIHdhcyBpZGVudGlmaWVkIGluIGEgbmV3IG1lbnRhbCByZXRhcmRhdGlvbiAoTVIpIGZhbWlseSBzaG93biB0byBiZSBsaW5rZWQgdG8gWHEyOC5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjc1NzkwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTkzMjYwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImZvdW5kIGluXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBIGhvbW96eWdvdXMgUjI3OVcgbXV0YXRpb24gd2FzIHJlY2VudGx5IGZvdW5kIGluIHRoZSBkaWFzdHJvcGhpYyBkeXNwbGFzaWEgc3VsZmF0ZSB0cmFuc3BvcnRlciBnZW5lLCBEVERTVCwgaW4gYSBwYXRpZW50IHdpdGggTUVEIHdobyBoYWQgYSBjbHViIGZvb3QgYW5kIGRvdWJsZS1sYXllcmVkIHBhdGVsbGEuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjQyNDQ4MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNjkxNzgwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUYWtlbiB0b2dldGhlciwgdGhlIHByZXNlbnQgZmluZGluZ3MgaW5kaWNhdGUgdGhhdCB0aGUgRzM4OVIgbXV0YXRpb24gaW4gVGF1IGNhbiBjYXVzZSBhIGRlbWVudGluZyBjb25kaXRpb24gdGhhdCBjbG9zZWx5IHJlc2VtYmxlcyBQaWNrJ3MgZGlzZWFzZS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTY5MzYyMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzM5MzUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFzc29jaWF0ZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIk9ubHkgcnM5ODk2MDUyIChwID0gNi41NSB4IDEwICgtNSkpIHdhcyBhc3NvY2lhdGVkIHdpdGggc2lnaHQtdGhyZWF0ZW5pbmcgZGlhYmV0aWMgcmV0aW5vcGF0aHkgaW4gYm90aCB0aGUgdHlwZSAyIChwID0gMC4wMzUpIGFuZCB0aGUgdHlwZSAxIChwID0gMC4wNDEpIHJlcGxpY2F0aW9uIGNvaG9ydHMsIGFzIHdlbGwgYXMgaW4gdGhlIEluZGlhbiBjb2hvcnQgKHAgPSAwLjAxNikuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjEyOTE1MTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjM4NTI1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJkZXRlY3RlZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIFNUUkE2IHAuRzMwNFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI3NjgxNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjY3MDQxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJpbmR1Y2VcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkFQT0UgUjEzNlMgYW5kIHAuTGV1MTQ5ZGVsIGluZHVjZSBhdXRvc29tYWwgZG9taW5hbnQgRkQgYW5kIGEgcGhlbm90eXBlIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gRkNITCwgcmVzcGVjdGl2ZWx5LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMjA2MzcyMDFcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzM3NjUwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbWJpbmVkIHdpdGhcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIldlIHNjcmVlbmVkIDQgYWRkaXRpb25hbCBmYW1pbGllcywgaW4gd2hpY2ggUEVEIGlzIGNvbWJpbmVkIHdpdGggZXBpbGVwc3ksIGRldmVsb3BtZW50YWwgZGVsYXksIG9yIG1pZ3JhaW5lLCBidXQgbm90IHdpdGggaGVtb2x5c2lzIG9yIGVjaGlub2N5dG9zaXMsIGFuZCBpZGVudGlmaWVkIDIgYWRkaXRpb25hbCBHTFVUMSBtdXRhdGlvbnMgKEEyNzVULCBHMzE0UykgdGhhdCBkZWNyZWFzZWQgZ2x1Y29zZSB0cmFuc3BvcnQgYnV0IGRpZCBub3QgYWZmZWN0IGNhdGlvbiBwZXJtZWFiaWxpdHkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjg2ODUzMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjI1NTQ3MjIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImlkZW50aWZpZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIGEgY2FzZS1jb250cm9sIHN0dWR5IGZyb20gQmVsYXJ1cywgdGhlIEUxOTc4WCBtdXRhdGlvbiB3YXMgaWRlbnRpZmllZCBpbiAxMC8xLDg5MSBCeWVsb3J1c3NpYW4gYnJlYXN0IGNhbmNlciBjYXNlcyAoMC41JSkgY29tcGFyZWQgd2l0aCAxLzEsMDE5IHBvcHVsYXRpb24gY29udHJvbHMgW29kZHMgcmF0aW8gKE9SKTogNS40OyA5NSUgY29uZmlkZW5jZSBpbnRlcnZhbCAoOTUlIENJKSwgMC43LTQyLjQsIFAgPSAwLjFdLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxNTM0NDkwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3MzU0NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJyczExNjU1MDgxIHdhcyBhbHNvIGFzc29jaWF0ZWQgd2l0aCBXRCAoUCA9IDIuNzggeCAxMCAoLTIpKSBidXQgbm90IHdpdGggYW55IG90aGVyIGZvY2FsIG9yIHNlZ21lbnRhbCBkeXN0b25pYS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMTI4ODkyMDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzUwMzMwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhdXNlXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJJbnRlcmVzdGluZ2x5LCB3aGlsZSBsb3NzIG9mIE5hICh2KSAxLjEgZnVuY3Rpb24gaXMgY29tbW9uIGluIERTLCB0aGUgUjg2NUcgbXV0YXRpb24gbWF5IGNhdXNlIERTIGJ5IG92ZXJhbGwgZ2Fpbi1vZi1mdW5jdGlvbiBkZWZlY3RzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMjA5NDEwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA3Mzc2ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJUaGlzIHN0dWR5IHNvdWdodCB0byBpZGVudGlmeSB3aGV0aGVyIGdlbmV0aWMgcG9seW1vcnBoaXNtcyByczI4OTI5NDc0IGFuZCByczE3NTgwIGFyZSBhc3NvY2lhdGVkIHdpdGggQ09QRCBzdXNjZXB0aWJpbGl0eSBhbmQgbHVuZyBmdW5jdGlvbiB2YWx1ZXMgaW4gYSBNZXhpY2FuIG1lc3Rpem8gcG9wdWxhdGlvbi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiODMxMDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNTcwNDU1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZVwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQm90aCB0aGUgUTE2M1ggYW5kIHRoZSBSMTIwUSBtdXRhdGlvbiBjYXVzZSBkZW15ZWxpbmF0aW9uIGFuZCBheG9uYWwgbG9zcy5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiMjY3MzEyNjAxXCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIzMDcyODA0XCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibG9jYXRlZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiQU8tR0xEIG11dGF0aW9ucywgaW5jbHVkaW5nIHRob3NlIGZvdW5kIGhlcmUsIGFyZSBsb2NhdGVkIGluIHRoZSBOLXRlcm1pbnVzIChJNjZNLCBHMjcwRCwgNTM1LTU3M2RlbCkgb3IgQy10ZXJtaW51cyAoTDYxOFMpIG9mIHRoZSBHQUxDIGVuenltZSwgd2hlcmVhcyB0aGUgcmVwb3J0ZWQgbXV0YXRpb25zIGluIHRoZSBpbmZhbnRpbGUgZm9ybSAoSUYtR0xEKSBhcmUgaW4gdGhlIGNlbnRyYWwgZG9tYWluLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI1MTA2MDRcIixcbiAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcIjEwNzUzOTIwMVwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImlkZW50aWZpZWQgaW5cIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlRoZSBmaXJzdCBtdXRhdGlvbiwgYW4gRTEzN0csIHdhcyBpZGVudGlmaWVkIGluIHRoZSBNUlgxNiBmYW1pbHksIGFuZCB0aGUgc2Vjb25kLCBSMTY3Vywgd2FzIGlkZW50aWZpZWQgaW4gYSBuZXcgbWVudGFsIHJldGFyZGF0aW9uIChNUikgZmFtaWx5IHNob3duIHRvIGJlIGxpbmtlZCB0byBYcTI4LlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI3MTUwMTA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjQ0NDQxMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmb3VuZCBpblwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIE4tdGVybWluYWwgUjQyMFcgbXV0YXRpb24gaGFzIGFscmVhZHkgYmVlbiBmb3VuZCBpbiBqdXZlbmlsZSBzdWRkZW4gZGVhdGggY2FkYXZlcnMgb2YgdW5yZWxhdGVkIGZhbWlsaWVzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIzODExNjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIyNjczNDMzMDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZWRcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIkluIGNvbnRyYXN0LCBtaXNzZW5zZSBtdXRhdGlvbnMgcHJvZHVjZWQgZGlzdGluY3QgcGhlbm90eXBlczogR2x5ODBBcmcgY2F1c2VkIHNpZ25pZmljYW50IGNhcmRpYWMgbWFsZm9ybWF0aW9ucyBidXQgb25seSBtaW5vciBza2VsZXRhbCBhYm5vcm1hbGl0aWVzOyBhbmQgQXJnMjM3R2xuIGFuZCBBcmcyMzdUcnAgY2F1c2VkIGV4dGVuc2l2ZSB1cHBlciBsaW1iIG1hbGZvcm1hdGlvbnMgYnV0IGxlc3Mgc2lnbmlmaWNhbnQgY2FyZGlhYyBhYm5vcm1hbGl0aWVzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxODU2MDUwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTA2OTA5MTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXNzb2NpYXRlZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJyczc1MzM1NjQgd2FzIG5vdCBhc3NvY2lhdGVkIHdpdGggZGlhYmV0ZXMgY29tcGxpY2F0aW9ucyBpbiBEQ0NUL0VESUMgb3Igd2l0aCBTRiBpbiBzdWJqZWN0cyB3aXRob3V0IGRpYWJldGVzIChub25kaWFiZXRpYyBbTkRdKVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCI2MjU3ODA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDczNzY1MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJmb3VuZCB3aXRoXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJQcmV2aW91c2x5IHJlcG9ydGVkIHAuUjI0MFggd2FzIGZvdW5kIGluIG9uZSBwYXRpZW50IHdpdGggUEtEIHdpdGggbWlncmFpbmUgd2l0aG91dCBhdXJhLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIzMDQ5NjA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCIxMDc1NDc0MDFcIixcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYXVzZXNcIixcbiAgICAgICAgICAgICAgICBcIm9yaWdfc2VudFwiOiBcIlNvbWUgc3R1ZGllcyBoYXZlIHN1Z2dlc3RlZCB0aGF0IHRoZSBWODA0TCBtdXRhdGlvbiBjYXVzZXMgdGhlIGxvdyBwZW5ldHJhbmNlIG11bHRpcGxlIGVuZG9jcmluZSBuZW9wbGFzaWEgdHlwZSAyIHN5bmRyb21lLCB3aXRoIGxhdGUgb25zZXQgYW5kIHJlbGF0aXZlbHkgaW5kb2xlbnQgY291cnNlLCB3aGVyZWFzIG90aGVycyBoYXZlIHJlcG9ydGVkIHRoYXQgVjgwNEwgYW5kIFY4MDRNIGhhdmUgYW4gYWdncmVzc2l2ZSBwb3RlbnRpYWwuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiBcIjI1OTQ5MzkwMVwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMTMyMjkwNFwiLFxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImNhcnJ5XCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJDbGluaWNhbCBmZWF0dXJlcyBhcmUgc2V2ZXJlIGRldmVsb3BtZW50YWwgZGVsYXksIG1pY3JvY2VwaGFseSBhbmQgZHlza2luZXNpYS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNTkwODIwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjY0NzM5MjAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVwb3J0ZWQgd2l0aFwiLFxuICAgICAgICAgICAgICAgIFwib3JpZ19zZW50XCI6IFwiVGhlIHAuQXNuMTA3U2VyIG1pc3NlbnNlIG11dGF0aW9uIG9mIEFMRzEzIGhhZCBiZWVuIHByZXZpb3VzbHkgcmVwb3J0ZWQgaW4gZm91ciBmZW1hbGVzIHdpdGggSVNzLlwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwiZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgXCJzb3VyY2VcIjogXCIxMzA3MzUwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU4OTY2ODAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwibGlua2VkIHRvXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJQYXRpZW50LW9ubHkgYW5hbHlzaXMgc3VnZ2VzdGVkIHRoYXQgcnM3MDQ4NTMgaXMgYWxzbyBsaW5rZWQgdG8gb3JhbCB1bGNlcnMsIGhlbWF0b2xvZ2ljIGRpc29yZGVycyBhbmQgYW50aS1kb3VibGUtc3RyYW5kZWQgRE5BIChkc0ROQSkgYW50aWJvZHkgcHJvZHVjdGlvbi5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBcImRhdGFcIjoge1xuICAgICAgICAgICAgICAgIFwic291cmNlXCI6IFwiNzg3OTMwNFwiLFxuICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiMjU5NTI4NTAxXCIsXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2F1c2VzXCIsXG4gICAgICAgICAgICAgICAgXCJvcmlnX3NlbnRcIjogXCJBIG5vdmVsIEQ0NThWIG11dGF0aW9uIGluIHRoZSBTQU5TIFBEWiBiaW5kaW5nIG1vdGlmIGNhdXNlcyBhdHlwaWNhbCBVc2hlciBzeW5kcm9tZS5cIlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXVxufTtcblxuLy8gcHJvY2VzcyBkYXRhXG5lbGVtZW50cy5ub2Rlcy5mb3JFYWNoKChuKSA9PiB7XG4gIGNvbnN0IGRhdGEgPSBuLmRhdGE7XG5cbiAgZGF0YS5Ob2RlVHlwZUZvcm1hdHRlZCA9IGRhdGEudHlwZTtcblxuICAvLyB0aGUgc291cmNlIGRhdGEgZm9yIHR5cGVzIGlzbid0IGZvcm1hdHRlZCB3ZWxsIGZvciByZWFkaW5nXG4gIGlmKCBkYXRhLk5vZGVUeXBlRm9ybWF0dGVkID09PSAnZGlzZWFzZScgKXtcbiAgICBkYXRhLk5vZGVUeXBlRm9ybWF0dGVkID0gJ0Rpc2Vhc2UnO1xuICAgIGRhdGEuTm9kZVR5cGUgPSAnUmVkV2luZSc7XG4gIH0gZWxzZSBpZiggZGF0YS5Ob2RlVHlwZUZvcm1hdHRlZCA9PT0gJ3ZhcmlhbnQnICl7XG4gICAgZGF0YS5Ob2RlVHlwZUZvcm1hdHRlZCA9ICdWYXJpYW50JztcbiAgICBkYXRhLk5vZGVUeXBlID0gJ1doaXRlV2luZSc7XG4gIH0gZWxzZSBpZiggZGF0YS5Ob2RlVHlwZUZvcm1hdHRlZCA9PT0gJ0NoZWVzZVR5cGUnICl7XG4gICAgZGF0YS5Ob2RlVHlwZUZvcm1hdHRlZCA9ICdDaGVlc2UgVHlwZSc7XG4gIH1cblxuICAvLyBzYXZlIG9yaWdpbmFsIHBvc2l0aW9uIGZvciB1c2UgaW4gYW5pbWF0ZWQgbGF5b3V0c1xuICBuLmRhdGEub3JnUG9zID0ge1xuICAgIHg6IE1hdGgucmFuZG9tKCkgKiAzMDAwLFxuICAgIHk6IE1hdGgucmFuZG9tKCkgKiAyMDAwXG4gIH07XG4gIG4ucG9zaXRpb24gPSB7XG4gICAgeDogTWF0aC5yYW5kb20oKSAqIDMwMDAsXG4gICAgeTogTWF0aC5yYW5kb20oKSAqIDIwMDBcbiAgfVxuXG4gIC8vIHplcm8gd2lkdGggc3BhY2UgYWZ0ZXIgZGFzaGVzIHRvIGFsbG93IGZvciBsaW5lIGJyZWFraW5nXG4gIGRhdGEubmFtZSA9IGRhdGEubmFtZS5yZXBsYWNlKC9bLV0vZywgJy1cXHUyMDBCJyk7XG5cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBlbGVtZW50czsiLCJpbXBvcnQgc3R5bGUgZnJvbSAnLi9zdHlsZSc7XG5pbXBvcnQgZWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cyc7XG5cbmV4cG9ydCB7IHN0eWxlLCBlbGVtZW50cyB9O1xuZXhwb3J0IGRlZmF1bHQgeyBzdHlsZSwgZWxlbWVudHMgfTtcbiIsImV4cG9ydCBkZWZhdWx0IGBcbmNvcmUge1xuXHRhY3RpdmUtYmctY29sb3I6ICNmZmY7XG5cdGFjdGl2ZS1iZy1vcGFjaXR5OiAwLjMzMztcbn1cblxuZWRnZSB7XG5cdGN1cnZlLXN0eWxlOiBiZXppZXI7XG5cdG9wYWNpdHk6IDAuNDtcblx0d2lkdGg6IDI7XG5cdHotaW5kZXg6IDA7XG5cdG92ZXJsYXktb3BhY2l0eTogMDtcbiAgICBldmVudHM6IG5vO1xuICAgIGNvbnRlbnQ6IGRhdGEobmFtZSk7XG4gICAgdGFyZ2V0LWFycm93LXNoYXBlOiB0cmlhbmdsZTtcbiAgICBmb250LXNpemU6IDY7XG59XG5cbm5vZGUge1xuXHR3aWR0aDogNDA7XG5cdGhlaWdodDogNDA7XG5cdGZvbnQtc2l6ZTogOTtcblx0Zm9udC13ZWlnaHQ6IGJvbGQ7XG5cdG1pbi16b29tZWQtZm9udC1zaXplOiA0O1xuXHRsYWJlbDogZGF0YShuYW1lKTtcblx0dGV4dC13cmFwOiB3cmFwO1xuXHR0ZXh0LW1heC13aWR0aDogNTA7XG5cdHRleHQtdmFsaWduOiBjZW50ZXI7XG5cdHRleHQtaGFsaWduOiBjZW50ZXI7XG5cdHRleHQtZXZlbnRzOiB5ZXM7XG5cdGNvbG9yOiAjMDAwO1xuXHR0ZXh0LW91dGxpbmUtd2lkdGg6IDE7XG5cdHRleHQtb3V0bGluZS1jb2xvcjogI2ZmZjtcblx0dGV4dC1vdXRsaW5lLW9wYWNpdHk6IDE7XG5cdG92ZXJsYXktY29sb3I6ICNmZmY7XG59XG5cbmVkZ2VbaW50ZXJhY3Rpb24gPSBcImNjXCJdIHtcblx0bGluZS1jb2xvcjogI0ZBQ0QzNztcblx0b3BhY2l0eTogMC42NjY7XG5cdHotaW5kZXg6IDk7XG5cdHdpZHRoOiA0O1xufVxuXG5ub2RlW05vZGVUeXBlID0gXCJDaGVlc2VcIl0sXG5ub2RlW05vZGVUeXBlID0gXCJDaGVlc2VUeXBlXCJdIHtcblx0YmFja2dyb3VuZC1jb2xvcjogI0ZBQ0QzNztcblx0dGV4dC1vdXRsaW5lLWNvbG9yOiAjRkFDRDM3O1xufVxuXG5ub2RlW05vZGVUeXBlID0gXCJDaGVlc2VcIl1bUXVhbGl0eV0sXG5ub2RlW05vZGVUeXBlID0gXCJDaGVlc2VUeXBlXCJdW1F1YWxpdHldIHtcblx0d2lkdGg6IG1hcERhdGEoUXVhbGl0eSwgNzAsIDEwMCwgMjAsIDUwKTtcblx0aGVpZ2h0OiBtYXBEYXRhKFF1YWxpdHksIDcwLCAxMDAsIDIwLCA1MCk7XG59XG5cbm5vZGVbTm9kZVR5cGUgPSBcIldoaXRlV2luZVwiXSB7XG5cdGJhY2tncm91bmQtY29sb3I6ICNFRUFBQUE7XG59XG5cbmVkZ2VbaW50ZXJhY3Rpb24gPSBcImN3XCJdIHtcblx0bGluZS1jb2xvcjogd2hpdGU7XG59XG5cbm5vZGVbTm9kZVR5cGUgPSBcIlJlZFdpbmVcIl0ge1xuXHRiYWNrZ3JvdW5kLWNvbG9yOiAjQUFFRUFBO1xufVxuXG5lZGdlW2ludGVyYWN0aW9uID0gXCJjclwiXSB7XG5cdGxpbmUtY29sb3I6ICNERTMxMjg7XG59XG5cbm5vZGVbTm9kZVR5cGUgPSBcIkNpZGVyXCJdIHtcblx0YmFja2dyb3VuZC1jb2xvcjogI0E0RUIzNDtcblx0dGV4dC1vdXRsaW5lLWNvbG9yOiAjQTRFQjM0O1xufVxuXG5ub2RlLmhpZ2hsaWdodGVkIHtcblx0bWluLXpvb21lZC1mb250LXNpemU6IDA7XG4gIHotaW5kZXg6IDk5OTk7XG59XG5cbmVkZ2UuaGlnaGxpZ2h0ZWQge1xuXHRvcGFjaXR5OiAwLjg7XG5cdHdpZHRoOiA0O1xuXHR6LWluZGV4OiA5OTk5O1xufVxuXG4uZmFkZWQge1xuICBldmVudHM6IG5vO1xufVxuXG5ub2RlLmZhZGVkIHtcbiAgb3BhY2l0eTogMC4wODtcbn1cblxuZWRnZS5mYWRlZCB7XG4gIG9wYWNpdHk6IDAuMDY7XG59XG5cbi5oaWRkZW4ge1xuXHRkaXNwbGF5OiBub25lO1xufVxuXG5gO1xuIiwiZXhwb3J0IGNvbnN0IE5PREVfRU5WID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlY7XG5leHBvcnQgY29uc3QgaXNQcm9kID0gTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbmV4cG9ydCBjb25zdCBpc0RldiA9ICFpc1Byb2Q7IiwiaW1wb3J0IHsgaXNQcm9kIH0gZnJvbSAnLi9lbnYnO1xuaW1wb3J0IHsgaCwgcmVuZGVyIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9hcHAnO1xuXG5pZiggIWlzUHJvZCApeyAvLyBzZXQgdXAgbGl2ZXJlbG9hZCBmb3IgZGV2XG4gIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIHNjcmlwdC5zcmMgPSAnaHR0cDovLycgKyBsb2NhdGlvbi5ob3N0bmFtZSArICc6MzU3MjkvbGl2ZXJlbG9hZC5qcz9zbmlwdmVyPTEnO1xuXG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApO1xufVxuXG5jb25zdCByb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbnJvb3Quc2V0QXR0cmlidXRlKCdpZCcsICdyb290Jyk7XG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJvb3QpO1xuXG5yZW5kZXIoaChBcHBDb21wb25lbnQpLCByb290KTtcblxuY29uc29sZS5sb2coYFlvdSBjYW4gdmlldyB0aGUgc291cmNlIGNvZGUgb2YgdGhpcyBDeXRvc2NhcGUuanMtcG93ZXJlZCBhcHAgYXQgaHR0cHM6Ly9naXRodWIuY29tL2N5dG9zY2FwZS93aW5lYW5kY2hlZXNlbWFwYCk7Il0sInNvdXJjZVJvb3QiOiIifQ==